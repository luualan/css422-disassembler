00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/9/2020 3:40:44 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler for the Motorola MC68000 Microprocessor
00000000                             3  * Written by :  Avery Mortenson & Alan Luu
00000000                             4  * Date       :  2/12/2020
00000000                             5  * Description:  An inverse assembler (disassembler) that will 
00000000                             6  * convert a memory image of instructions and data back 
00000000                             7  * to the MC68000 assembly code and that will output the 
00000000                             8  * disassembled code to the display.
00000000                             9  *-----------------------------------------------------------
00001000                            10      ORG    $1000
00001000                            11  START:            
00001000                            12  *------------------------------------------------------------*
00001000                            13  * D0: used for the tasks
00001000                            14  * D1: used to hold the size of the input obtained. 
00001000                            15  * D5: used to store the starting and ending address 
00001000                            16  * temporarily before moving them to A4 and A6 correspondingly. 
00001000                            17  * D6: used to check the last digit to see if the input 
00001000                            18  * for the starting and ending address causes a bus error. 
00001000                            19  * A1: a pointer to the message to print out. 
00001000                            20  *------------------------------------------------------------*
00001000                            21  
00001000  103C 000E                 22  DISP_W      MOVE.B  #14,D0                  ; Display Welcome Message. 
00001004  43F9 00002F4A             23              LEA     WELCOME,A1
0000100A  4E4F                      24              TRAP    #15
0000100C                            25  
0000100C                            26  * Put program code here
0000100C                            27  
0000100C  103C 000E                 28  DISP_UI         MOVE.B  #14,D0              ; Display User Instructions. 
00001010  43F9 00002F80             29                  LEA     USER_INST,A1
00001016  4E4F                      30                  TRAP    #15    
00001018                            31  
00001018  4FF9 0000A000             32  PROMPT_START    LEA     stack, SP           ; SP = stack ($A0000)
0000101E  43F9 0000315F             33                  LEA     START_IN,A1         ; Display starting address message
00001024  103C 000E                 34                  MOVE.B  #14,D0
00001028  4E4F                      35                  TRAP    #15       
0000102A                            36       
0000102A  43F9 00003198             37  READ_START      LEA     START_ADDRESS,A1    ; Store user's starting address input
00001030  103C 0002                 38                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001034  4E4F                      39                  TRAP    #15
00001036  1C3C 0000                 40                  MOVE.B  #0,D6               ; Used to indicate we are at start address
0000103A                            41  
0000103A  6000 0022                 42  VALIDATE_START  BRA     ATOI
0000103E                            43  
0000103E  43F9 0000317C             44  PROMPT_END      LEA     END_IN,A1           ; Display starting address message
00001044  103C 000E                 45                  MOVE.B  #14,D0
00001048  4E4F                      46                  TRAP    #15            
0000104A  43F9 000031B8             47  READ_END        LEA     END_ADDRESS,A1      ; Store user's starting address input
00001050  103C 0002                 48                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001054  4E4F                      49                  TRAP    #15
00001056  1C3C 0001                 50                  MOVE.B  #1,D6               ; Used to indicate we are at end address
0000105A                            51  
0000105A  6000 0002                 52  VALIDATE_END    BRA     ATOI
0000105E                            53                 
0000105E                            54  * D0 stores the value to pushed from A1.
0000105E                            55  
0000105E  1019                      56  ATOI            MOVE.B  (A1)+,D0    ; Move to next character in A1 and store in D0          
00001060  B03C 0030                 57                  CMP.B   #$30,D0
00001064  6D00 0040                 58                  BLT     INPUT_INVALID
00001068  B03C 0039                 59                  CMP.B   #$39,D0
0000106C  6E00 0016                 60                  BGT     ASCII_TO_HEX_LETTER
00001070  0400 0030                 61                  SUB.B   #$30,D0     ; Subtract by 30 to get the numbers 0-9
00001074  DA80                      62                  ADD.L   D0,D5
00001076  5341                      63                  SUBI    #1,D1       ; Decrement input's length to move to next character          
00001078  B23C 0000                 64                  CMP.B   #0,D1       ; Compare to see if we're at the last digit
0000107C  6700 0046                 65                  BEQ     LAST_DIGIT_CHECK
00001080  E98D                      66                  LSL.L   #4,D5
00001082  60DA                      67                  BRA     ATOI
00001084                            68  
00001084                            69    
00001084  B03C 0041                 70  ASCII_TO_HEX_LETTER     CMP.B   #$41,D0
00001088  6D00 001C                 71                          BLT     INPUT_INVALID
0000108C  B03C 0046                 72                          CMP.B   #$46, D0
00001090  6E00 0014                 73                          BGT     INPUT_INVALID 
00001094  0400 0031                 74                          SUB.B   #$31,D0     ; Subtract by 31 to get the numbers A-F
00001098  5D00                      75                          SUB.B   #6,D0
0000109A  DA80                      76                          ADD.L   D0,D5
0000109C  5341                      77                          SUBI    #1,D1
0000109E  6700 0024                 78                          BEQ     LAST_DIGIT_CHECK
000010A2  E98D                      79                          LSL.L   #4,D5
000010A4  60B8                      80                          BRA     ATOI     
000010A6                            81  
000010A6                            82                      
000010A6  43F9 00002EEC             83  INPUT_INVALID   LEA     ERROR_MESSAGE, A1   ; Display error message
000010AC  103C 000E                 84                  MOVE.B  #14, D0
000010B0  4E4F                      85                  TRAP    #15
000010B2  4206                      86                  CLR.B   D6
000010B4                            87                  
000010B4  BC3C 0000                 88                  CMP.B   #0,D6           ; When D6 is 0
000010B8  6700 FF5E                 89                  BEQ     PROMPT_START    ; Go back to start prompt
000010BC  BC3C 0001                 90                  CMP.B   #1,D6           ; When D6 is 1
000010C0  6700 FF7C                 91                  BEQ     PROMPT_END      ; Go back to end prompt
000010C4                            92  
000010C4                            93                            
000010C4  2E05                      94  LAST_DIGIT_CHECK    MOVE.L  D5, D7          ; D7 used as temporary storage
000010C6  E20F                      95                      LSR.B   #1, D7          ; Check for carry bit to see if last digit is odd
000010C8  6500 002E                 96                      BCS     LAST_DIGIT_ODD  ; branch when there is a carry; this indicates odd last digit 
000010CC  4287                      97                      CLR.L   D7
000010CE  BC3C 0000                 98                      CMP.B   #0,D6
000010D2  6700 000A                 99                      BEQ     COMPLETE_START  
000010D6  BC3C 0001                100                      CMP.B   #1,D6
000010DA  6700 000A                101                      BEQ     COMPLETE_END
000010DE                           102  
000010DE  2845                     103  COMPLETE_START      MOVEA.L D5, A4  ; A4 holds the starting address
000010E0  4285                     104                      CLR.L   D5 
000010E2  6000 FF5A                105                      BRA PROMPT_END
000010E6                           106  
000010E6  2C45                     107  COMPLETE_END        MOVEA.L D5, A6  ; A6 holds the ending address
000010E8  2A4C                     108                      MOVEA.L A4, A5  ; Store starting address into current address
000010EA                           109                      
000010EA                           110                      *Clear the data and address registers used to obtain the starting and ending address 
000010EA  4280                     111                      CLR.L   D0
000010EC  4285                     112                      CLR.L   D5
000010EE  4286                     113                      CLR.L   D6
000010F0  327C 0000                114                      MOVEA   #0, A1
000010F4  6000 01B0                115                      BRA     START_DECODING  ; All inputs are valid, go to the decode process
000010F8                           116                      
000010F8  43F9 00002F0A            117  LAST_DIGIT_ODD      LEA     ODD_ERROR_MESSAGE, A1 
000010FE  103C 000E                118                      MOVE.B  #14, D0
00001102  4E4F                     119                      TRAP    #15
00001104                           120                      
00001104  BC3C 0000                121                      CMP.B   #0,D6           ; When D6 is 0
00001108  6700 FF0E                122                      BEQ     PROMPT_START    ; Go back to start prompt
0000110C  BC3C 0001                123                      CMP.B   #1,D6           ; When D6 is 1
00001110  6700 FF2C                124                      BEQ     PROMPT_END      ; Go back to end prompt
00001114                           125  *--------------------------------------------------------------------------------------
00001114                           126  * param D2 data size to convert into ASCII
00001114                           127  * param A2 a pointer to decode_buf
00001114                           128  * param A5 the current address
00001114                           129  * itoa (D2, A2, A5) {
00001114                           130  * D0 byte data in ACII
00001114                           131  * D1 #sfhit
00001114                           132  * D7 long data to convert into ASCII
00001114                           133  * }
00001114                           134          
00001114                           135  ITOA                                ; convert integer to ASCII  
00001114  48E7 C000                136          MOVEM.L D0-D1,-(SP) 
00001118  B43C 0000                137          CMP.B   #%00, D2            ; byte
0000111C  6700 007E                138          BEQ     ITOA_BYTE
00001120  B43C 0001                139          CMP.B   #%01, D2            ; word
00001124  6700 0096                140          BEQ     ITOA_WORD
00001128  B43C 0002                141          CMP.B   #%10, D2            ; long
0000112C  6700 00CC                142          BEQ     ITOA_LONG
00001130  4EF9 0000122C            143          JMP     ITOA_LONGADDRESS    ; long address
00001136                           144          
00001136                           145  ITOA_MOVE                           ; convert integer to ASCII
00001136  48E7 C000                146          MOVEM.L D0-D1,-(SP) 
0000113A  B43C 0001                147          CMP.B   #%01, D2            ; byte
0000113E  6700 005C                148          BEQ     ITOA_BYTE
00001142  B43C 0003                149          CMP.B   #%11, D2            ; word
00001146  6700 0074                150          BEQ     ITOA_WORD
0000114A  B43C 0002                151          CMP.B   #%10,D2             ; long
0000114E  6700 00AA                152          BEQ     ITOA_LONG
00001152  4EF9 0000122C            153          JMP     ITOA_LONGADDRESS    ; long address
00001158                           154          
00001158                           155  ITOA_OPMODE                         ; convert integer to ASCII
00001158  48E7 C000                156          MOVEM.L D0-D1,-(SP) 
0000115C  B43C 0000                157          CMP.B   #%000,D2            ; When 0 then byte
00001160  6700 003A                158          BEQ     ITOA_BYTE
00001164  B43C 0004                159          CMP.B   #%100,D2            ; When 4 then byte
00001168  6700 0032                160          BEQ     ITOA_BYTE 
0000116C  B43C 0001                161          CMP.B   #%001,D2            ; When 1 then word
00001170  6700 004A                162          BEQ     ITOA_WORD
00001174  B43C 0003                163          CMP.B   #%011,D2            ; When 3 then word
00001178  6700 0042                164          BEQ     ITOA_WORD
0000117C  B43C 0005                165          CMP.B   #%101,D2            ; When 5 then word
00001180  6700 003A                166          BEQ     ITOA_WORD 
00001184  B43C 0002                167          CMP.B   #%010,D2            ; When 2 then long
00001188  6700 0070                168          BEQ     ITOA_LONG
0000118C  B43C 0006                169          CMP.B   #%110,D2            ; When 6 then long
00001190  6700 0068                170          BEQ     ITOA_LONG
00001194  B43C 0007                171          CMP.B   #%111,D2            ; When 7 then long
00001198  6700 0060                172          BEQ     ITOA_LONG
0000119C                           173          
0000119C                           174  ITOA_BYTE
0000119C  3E1D                     175          MOVE.W  (A5)+,D7
0000119E  4EB9 00001264            176          JSR     ITOA_BYTE_CONVERT
000011A4  4EF9 000012A0            177          JMP     ITOA_DONE
000011AA                           178  
000011AA                           179  ITOA_BYTE_BRANCH
000011AA  48E7 C000                180          MOVEM.L D0-D1,-(SP)
000011AE  3E05                     181          MOVE.W  D5,D7
000011B0  4EB9 00001264            182          JSR     ITOA_BYTE_CONVERT
000011B6  4EF9 000012A0            183          JMP     ITOA_DONE
000011BC                           184          
000011BC                           185  ITOA_WORD
000011BC  3E15                     186          MOVE.W  (A5),D7
000011BE  123C 0008                187          MOVE.B  #right8, D1
000011C2  E26F                     188          LSR.W   D1,D7
000011C4  4EB9 00001264            189          JSR     ITOA_BYTE_CONVERT
000011CA  3E1D                     190          MOVE.W  (A5)+, D7
000011CC  4EB9 00001264            191          JSR     ITOA_BYTE_CONVERT
000011D2  4EF9 000012A0            192          JMP     ITOA_DONE
000011D8                           193          
000011D8                           194  ITOA_WORD_BRANCH
000011D8  48E7 C000                195          MOVEM.L D0-D1,-(SP) 
000011DC  3E05                     196          MOVE.W  D5,D7
000011DE  123C 0008                197          MOVE.B  #right8, D1
000011E2  E26F                     198          LSR.W   D1,D7
000011E4  4EB9 00001264            199          JSR     ITOA_BYTE_CONVERT
000011EA  3E05                     200          MOVE.W  D5, D7
000011EC  361D                     201          MOVE.W  (A5)+, D3
000011EE  4EB9 00001264            202          JSR     ITOA_BYTE_CONVERT
000011F4  4EF9 000012A0            203          JMP     ITOA_DONE
000011FA                           204          
000011FA                           205  ITOA_LONG
000011FA  3E15                     206          MOVE.W  (A5),D7
000011FC  123C 0008                207          MOVE.B  #right8, D1
00001200  E26F                     208          LSR.W   D1, D7
00001202  4EB9 00001264            209          JSR     ITOA_BYTE_CONVERT
00001208  3E1D                     210          MOVE.W  (A5)+, D7
0000120A  4EB9 00001264            211          JSR     ITOA_BYTE_CONVERT
00001210                           212          
00001210  3E15                     213          MOVE.W  (A5),D7
00001212  123C 0008                214          MOVE.B  #right8, D1
00001216  E26F                     215          LSR.W   D1, D7
00001218  4EB9 00001264            216          JSR     ITOA_BYTE_CONVERT
0000121E  3E1D                     217          MOVE.W  (A5)+, D7
00001220  4EB9 00001264            218          JSR     ITOA_BYTE_CONVERT
00001226  4EF9 000012A0            219          JMP     ITOA_DONE
0000122C                           220  
0000122C                           221  ITOA_LONGADDRESS
0000122C  3E0D                     222          MOVE.W  A5,D7
0000122E  123C 0018                223          MOVE.B  #right24,D1
00001232  E26F                     224          LSR.W   D1,D7
00001234  4EB9 00001264            225          JSR     ITOA_BYTE_CONVERT
0000123A  3E0D                     226          MOVE.W  A5,D7
0000123C  123C 0010                227          MOVE.B  #right16,D1
00001240  E26F                     228          LSR.W   D1,D7
00001242  4EB9 00001264            229          JSR     ITOA_BYTE_CONVERT
00001248  3E0D                     230          MOVE.W  A5,D7
0000124A  123C 0008                231          MOVE.B  #right8,D1
0000124E  E26F                     232          LSR.W   D1,D7
00001250  4EB9 00001264            233          JSR     ITOA_BYTE_CONVERT
00001256  3E0D                     234          MOVE.W  A5,D7
00001258  4EB9 00001264            235          JSR     ITOA_BYTE_CONVERT   
0000125E  4EF9 000012A0            236          JMP     ITOA_DONE   
00001264                           237  
00001264                           238  ITOA_BYTE_CONVERT
00001264  3007                     239          MOVE.W  D7, D0 
00001266  0240 00F0                240          ANDI.W  #$F0, D0
0000126A  123C 0004                241          MOVE.B  #right4, D1
0000126E  E268                     242          LSR.W   D1, D0
00001270  4EB9 00001284            243          JSR     ITOA_NIBBLE_CONVERT
00001276                           244          
00001276  3007                     245          MOVE.W  D7, D0
00001278  0240 000F                246          ANDI.W  #$0F, D0
0000127C  4EB9 00001284            247          JSR     ITOA_NIBBLE_CONVERT
00001282  4E75                     248          RTS
00001284                           249          
00001284                           250  ITOA_NIBBLE_CONVERT
00001284  B03C 0009                251          CMP.B   #9, D0
00001288  6E00 000A                252          BGT     ITOA_CONVERT_A_TO_F
0000128C  0600 0030                253          ADD.B   #$30, D0
00001290  14C0                     254          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
00001292  4E75                     255          RTS
00001294                           256          
00001294                           257  ITOA_CONVERT_A_TO_F
00001294  0400 000A                258          SUBI.B  #10, D0
00001298  0600 0041                259          ADDI.B  #$41, D0
0000129C  14C0                     260          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
0000129E  4E75                     261          RTS
000012A0                           262  
000012A0                           263  ITOA_DONE
000012A0  4CDF 0003                264          MOVEM.L (SP)+, D0-D1
000012A4  4E75                     265          RTS
000012A6                           266  *-------------------------------------------------------------------------------*
000012A6                           267  START_DECODING
000012A6  4282                     268          CLR.L   D2
000012A8                           269          
000012A8                           270  DECODING_ITERATION
000012A8                           271          ;decoding the current address
000012A8  4EB9 00001358            272          JSR     DECODE_MEMORY
000012AE  103C 000D                273          MOVE.B  #task13, D0
000012B2  43F9 00005000            274          LEA     decoded_buffer, A1
000012B8  4E4F                     275          TRAP    #15
000012BA                           276          
000012BA                           277          ;check if decoding has finished or if the screen is filled 
000012BA  BDCD                     278          CMP.L   A5, A6
000012BC  6F00 0022                279          BLE     CONTINUE_OR_END     ; If A6-A5 <= 0, go to CONTINUE_OR_END 
000012C0                           280          
000012C0                           281          ;have yet to reach the ending address
000012C0  5202                     282          ADDQ.B  #1, D2              ; D2 (screen_line_counter)++
000012C2  B43C 0014                283          CMP.B   #lines_p_screen, D2
000012C6  6C00 0004                284          BGE     DECODE_PAUSE
000012CA                           285          ;not yet reached the maximum lines per screen. 
000012CA  60DC                     286          BRA     DECODING_ITERATION
000012CC                           287  
000012CC                           288  DECODE_PAUSE
000012CC  103C 000E                289          MOVE.B  #task14, D0
000012D0  43F9 000030FA            290          LEA     ENTER_PROMPT, A1
000012D6  4E4F                     291          TRAP    #15
000012D8  103C 0005                292          MOVE.B  #task5, D0
000012DC  4E4F                     293          TRAP    #15
000012DE  60C6                     294          BRA     START_DECODING
000012E0                           295  
000012E0                           296  CONTINUE_OR_END
000012E0  4280                     297          CLR.L   D0
000012E2  4281                     298          CLR.L   D1
000012E4  4282                     299          CLR.L   D2
000012E6  4283                     300          CLR.L   D3
000012E8  4284                     301          CLR.L   D4
000012EA  4285                     302          CLR.L   D5
000012EC  4286                     303          CLR.L   D6
000012EE  4287                     304          CLR.L   D7
000012F0  327C 0000                305          MOVEA   #0,A1
000012F4  347C 0000                306          MOVEA   #0,A2
000012F8  367C 0000                307          MOVEA   #0,A3
000012FC  387C 0000                308          MOVEA   #0,A4
00001300  3A7C 0000                309          MOVEA   #0,A5
00001304  3C7C 0000                310          MOVEA   #0,A6
00001308                           311  
00001308  103C 000E                312          MOVE.B  #task14, D0
0000130C  43F9 00003117            313          LEA     PROMPT_AGAIN, A1
00001312  4E4F                     314          TRAP    #15
00001314                           315          
00001314  103C 0002                316          MOVE.B  #task2, D0
00001318  43F9 00002DE4            317          LEA     ascii_y_n, A1
0000131E  4E4F                     318          TRAP    #15
00001320                           319          
00001320  1639 00002DE4            320          MOVE.B  ascii_y_n, D3
00001326  0C03 0059                321          CMPI.B  #y_uppercase, D3
0000132A  6700 FCEC                322          BEQ     PROMPT_START
0000132E  0C03 0079                323          CMPI.B  #y_lowercase, D3
00001332  6700 FCE4                324          BEQ     PROMPT_START
00001336  0C03 004E                325          CMPI.B  #n_uppercase, D3
0000133A  6700 000C                326          BEQ     EXIT
0000133E  0C03 006E                327          CMPI.B  #n_lowercase, D3
00001342  6700 0004                328          BEQ     EXIT
00001346  6098                     329          BRA     CONTINUE_OR_END 
00001348                           330          
00001348                           331  EXIT
00001348  103C 000E                332          MOVE.B  #task14, D0
0000134C  43F9 0000313A            333          LEA     EXIT_PROMPT, A1
00001352  4E4F                     334          TRAP    #15  
00001354  6000 1A8A                335          BRA     DONE             
00001358                           336  *---------------------------------------------------------------------------------*
00001358                           337  * D0: the current instruction. 
00001358                           338  * D1: used as temp storage
00001358                           339  * D2: data size 
00001358                           340  * D3: loop counter for the amount of lines per screen. 
00001358                           341  * D4: 
00001358                           342  * D5: #shifts
00001358                           343  * D6: store first nibble
00001358                           344  * D7: 
00001358                           345  * A0: 
00001358                           346  * A1: A pointer to the message to print out. 
00001358                           347  * A2: A pointer to the decode_buffer. 
00001358                           348  * A3: 
00001358                           349  * A4: Store the starting address and increment to the ending address. 
00001358                           350  * A5: The current address. 
00001358                           351  * A6: Store the ending address. 
00001358                           352  * A7: Stack pointer. 
00001358                           353  *---------------------------------------------------------------------------------*                             
00001358                           354  DECODE_MEMORY       
00001358  48E7 2002                355          MOVEM.L D2/A6, -(SP)
0000135C                           356                  
0000135C                           357          ;zero clear the decode_buffer
0000135C  4EB9 00001394            358          JSR     OP_CLEAR_DATA
00001362  45F9 00005000            359          LEA     decoded_buffer, A2  Load decode buffer into A2
00001368                           360                  
00001368                           361          ;print out the current address
00001368  7403                     362          MOVE.L  #$0003, D2
0000136A  4EB8 1114                363          JSR      ITOA
0000136E                           364          
0000136E  14FC 0009                365          MOVE.B  #$9, (A2)+  ; Add space after long address
00001372                           366                  
00001372                           367          ;load the next instruction and jump to the opcode table entry
00001372  41F9 000013AA            368          LEA     OP_TABLE, A0
00001378  4280                     369          CLR.L   D0
0000137A  301D                     370          MOVE.W  (A5)+, D0       ; Store A5's value into D0, then increment A5
0000137C  2200                     371          MOVE.L  D0, D1          ; Store A5's value from D0 into D1
0000137E  1A3C 000C                372          MOVE.B  #right12, D5    ; Store 12 into D5
00001382  EA69                     373          LSR.W   D5, D1          ; Shift first nibble into LSB position
00001384  2C01                     374          MOVE.L  D1, D6          ; Store first nibble into D6
00001386  C2FC 0006                375          MULU    #6, D1          ; Multiply 6 to D1
0000138A  4EF0 1000                376          JMP     0(A0, D1)       ; Go to displacement (A0 + D1 * 6)      
0000138E                           377  OP_FINISH
0000138E  4CDF 4004                378          MOVEM.L (SP)+, D2/A6,
00001392  4E75                     379          RTS
00001394                           380  *------------------------------------------------------------------------------------*
00001394                           381  *Clear the 32 bits within the decoded_buffer       
00001394                           382  OP_CLEAR_DATA
00001394  4283                     383          CLR.L   D3
00001396  163C 0040                384          MOVE.B  #buffer_size, D3
0000139A  45F9 00005000            385          LEA     decoded_buffer, A2
000013A0                           386          
000013A0                           387  OP_CLEAR_DATA_LOOP
000013A0  14FC 0000                388          MOVE.B  #0, (A2)+
000013A4  5343                     389          SUBI    #1, D3
000013A6  6EF8                     390          BGT     OP_CLEAR_DATA_LOOP
000013A8  4E75                     391          RTS
000013AA                           392  
000013AA                           393  *------------------------------------------------------------------------------------*
000013AA                           394  OP_TABLE
000013AA  4EF9 0000140A            395          JMP     code0000    ; ADDI.bwl/ ANDI.bwl / CMPI.bwl / EORI.bwl / ORI.bwl / SUBI.bwl 
000013B0  4EF9 00001424            396          JMP     code0001    ; MOVE.b
000013B6  4EF9 00001428            397          JMP     code0010    ; MOVE.l / MOVEA.l
000013BC  4EF9 00001440            398          JMP     code0011    ; MOVE.w / MOVEA.w
000013C2  4EF9 00001458            399          JMP     code0100    ; CLR.bwl / JMP / JSR / LEA / MOVEM.wl / NOP / NOT.bwl / RTS / STOP / TRAP
000013C8  4EF9 00001472            400          JMP     code0101    ; ADDQ.bwl / SUBQ.bwl / Scc / Dbcc
000013CE  4EF9 00001476            401          JMP     code0110    ; BRA.bw / BSR.bw / Bcc.bw
000013D4  4EF9 00001502            402          JMP     code0111    ; MOVEQ
000013DA  4EF9 00001506            403          JMP     code1000    ; DIVS / DIVU / CR.bwl
000013E0  4EF9 00001526            404          JMP     code1001    ; SUB.bwl / SUBA.wl
000013E6  4EF9 0000152A            405          JMP     code1010    ;   [unassigned]
000013EC  4EF9 0000152E            406          JMP     code1011    ; CMP.bwl / CMPA.wl / EOR.bwl
000013F2  4EF9 00001532            407          JMP     code1100    ; MULS / MULU / AND.bwl
000013F8  4EF9 0000154C            408          JMP     code1101    ; ADD.bwl / ADDA.wl / ADDX.bwl
000013FE  4EF9 00001566            409          JMP     code1110    ; ASL.bwl / ASR.bwl / LSL.bwl / LSR.bwl / ROR.bwl / ROL.bwl
00001404  4EF9 000015E4            410          JMP     code1111    ;   [unassigned]
0000140A                           411          
0000140A                           412  code0000                            ; Opcodes ADDI and SUBI
0000140A  2200                     413          MOVE.L  D0,D1               ; D0 is current instruction word
0000140C  0241 0F00                414          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
00001410  1A3C 0008                415          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001414  EA69                     416          LSR.W   D5,D1               ; Shift nibble into LSB position
00001416  C2FC 0006                417          MULU    #6, D1              ; Set displacement 
0000141A  41F9 000015E8            418          LEA     OP_0000_TABLE,A0    ; Load table into A0
00001420  4EF0 1000                419          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00001424                           420  
00001424                           421  code0001                            ; Opcode MOVE.B
00001424  6000 053A                422          BRA     OP_MOVE             ; Go to opcode MOVE
00001428                           423  
00001428                           424  code0010                            ; Opcodes MOVE.L and MOVEA.L 
00001428  2200                     425          MOVE.L  D0,D1               ; D0 is current instruction word
0000142A  0241 01C0                426          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000142E  1A3C 0006                427          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001432  EA69                     428          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001434  B23C 0001                429          CMP.B   #1, D1              ; When 001 in destination mode
00001438  6700 0502                430          BEQ     OP_MOVEA            ; Go to opcode MOVEA
0000143C  6000 0522                431          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001440                           432  
00001440                           433  code0011                            ; Opcodes MOVE.W and MOVEA.W 
00001440  2200                     434          MOVE.L  D0,D1               ; D0 is current instruction word
00001442  0241 01C0                435          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001446  1A3C 0006                436          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000144A  EA69                     437          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000144C  B23C 0001                438          CMP.B   #1, D1              ; When 001 in destination mode
00001450  6700 04EA                439          BEQ     OP_MOVEA            ; Go to opcode MOVEA
00001454  6000 050A                440          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001458                           441  
00001458                           442  code0100                            ; Opcodes CLR, JSR, LEA, MOVEM, NOP, RTS
00001458  2200                     443          MOVE.L  D0,D1               ; D0 is current instruction word
0000145A  0241 0F00                444          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
0000145E  1A3C 0008                445          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001462  EA69                     446          LSR.W   D5,D1               ; Shift nibble into LSB position
00001464  C2FC 0006                447          MULU    #6, D1              ; Set displacement 
00001468  41F9 00001648            448          LEA     OP_0100_TABLE,A0    ; Load table into A0
0000146E  4EF0 1000                449          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00001472                           450  
00001472                           451  code0101                            ; Opcode ADDQ.B/W/L
00001472  6000 05A4                452          BRA     OP_ADDQ             ; Go to opcode ADDQ
00001476                           453  
00001476                           454  code0110                            ; Opcodes BRA / BSR / BHI
00001476  2200                     455          MOVE.L  D0,D1               ; D0 is current instruction word
00001478  0241 0F00                456          ANDI.W  #second_nibble,D1   ; Extract 2nd 4 bits from instruction word
0000147C  1A3C 0008                457          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001480  EA69                     458          LSR.W   D5,D1               ; Shift nibble into LSB position
00001482  B23C 0000                459          CMP.B   #0, D1              ; When 0000 in second nibble 
00001486  6700 05B0                460          BEQ     OP_BRA              ; Go to opcode BRA
0000148A  B23C 0001                461          CMP.B   #1, D1              ; When 0001 in second nibble 
0000148E  6700 05C4                462          BEQ     OP_BSR              ; Go to opcode BSR
00001492  B23C 0002                463          CMP.B   #2, D1              ; When 0010 in second nibble 
00001496  6700 05D8                464          BEQ     OP_BHI              ; Go to opcode BHI
0000149A  B23C 0003                465          CMP.B   #3, D1              ; When 0011 in second nibble
0000149E  6700 05EC                466          BEQ     OP_BLS              ; Go to opcode BLS
000014A2  B23C 0004                467          CMP.B   #4, D1              ; When 0100 in second nibble
000014A6  6700 0600                468          BEQ     OP_BCC              ; Go to opcode BCC
000014AA  B23C 0005                469          CMP.B   #5, D1              ; When 0101 in second nibble
000014AE  6700 0614                470          BEQ     OP_BCS              ; Go to opcode BCS
000014B2  B23C 0006                471          CMP.B   #6, D1              ; When 0110 in second nibble
000014B6  6700 0628                472          BEQ     OP_BNE              ; Go to opcode BNE
000014BA  B23C 0007                473          CMP.B   #7, D1              ; When 0111 in second nibble
000014BE  6700 063C                474          BEQ     OP_BEQ              ; Go to opcode BEQ
000014C2  B23C 0008                475          CMP.B   #8, D1              ; When 1000 in second nibble
000014C6  6700 0650                476          BEQ     OP_BVC              ; Go to opcode BVC
000014CA  B23C 0009                477          CMP.B   #9, D1              ; When 1001 in second nibble
000014CE  6700 0664                478          BEQ     OP_BVS              ; Go to opcode BVS
000014D2  B23C 000A                479          CMP.B   #10, D1             ; When 1010 in second nibble
000014D6  6700 0678                480          BEQ     OP_BPL              ; Go to opcode BPL
000014DA  B23C 000B                481          CMP.B   #11, D1             ; When 1011 in second nibble
000014DE  6700 068C                482          BEQ     OP_BMI              ; Go to opcode BMI
000014E2  B23C 000C                483          CMP.B   #12, D1             ; When 1100 in second nibble
000014E6  6700 06A0                484          BEQ     OP_BGE              ; Go to opcode BGE
000014EA  B23C 000D                485          CMP.B   #13, D1             ; When 1101 in second nibble
000014EE  6700 06B4                486          BEQ     OP_BLT              ; Go to opcode BLT
000014F2  B23C 000E                487          CMP.B   #14, D1             ; When 1110 in second nibble
000014F6  6700 06C8                488          BEQ     OP_BGT              ; Go to opcode BGT
000014FA  B23C 000F                489          CMP.B   #15, D1             ; When 1111 in second nibble
000014FE  6700 06DC                490          BEQ     OP_BLE              ; Go to opcode BLE
00001502                           491  
00001502                           492  code0111                            ; Opcode MOVEQ
00001502  6000 06F4                493          BRA     OP_MOVEQ            ; Go to opcode MOVEQ
00001506                           494  
00001506                           495  code1000                            ; Opcodes DIVU word and OR.B/W/L
00001506  2200                     496          MOVE.L  D0,D1               ; D0 is current instruction word
00001508  0241 01C0                497          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000150C  1A3C 0006                498          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001510  EA69                     499          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001512  B23C 0003                500          CMP.B   #3,D1               ; When 011 in destination mode
00001516  6700 0704                501          BEQ     OP_DIVU             ; Go to opcode DIVU word
0000151A  B23C 0007                502          CMP.B   #7,D1               ; When 111
0000151E  6700 03CC                503          BEQ     OP_UNSUPPORTED      ; Go to opcode unsupported
00001522  6000 0718                504          BRA     OP_OR               ; Otherwise, go to opcode OR
00001526                           505  
00001526                           506  code1001                            ; Opcode SUB.B/W/L
00001526  6000 072C                507          BRA     OP_SUB              ; Go to opcode SUB   
0000152A                           508  
0000152A                           509  code1010                            ; Opcode not supported 
0000152A  6000 03C0                510          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
0000152E                           511       
0000152E                           512  code1011                            ; Opcode CMP.B/W/L
0000152E  6000 0740                513          BRA     OP_CMP              ; Go to opcode CMP
00001532                           514  
00001532                           515  code1100                            ; Opcodes MULS, MULU, AND.B/W/L
00001532  2200                     516          MOVE.L  D0,D1               ; D0 is current instruction word
00001534  0241 01C0                517          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001538  1A3C 0006                518          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000153C  EA69                     519          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000153E  C2FC 0006                520          MULU    #6, D1              ; Set displacement 
00001542  41F9 000016A8            521          LEA     OP_1100_TABLE,A0    ; Load table into A0
00001548  4EF0 1000                522          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
0000154C                           523  
0000154C                           524  code1101                            ; Opcodes ADD.B/W/L, ADDA.B/W/L
0000154C  2200                     525          MOVE.L  D0,D1               ; D0 is current instruction word
0000154E  0241 01C0                526          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001552  1A3C 0006                527          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001556  EA69                     528          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001558  C2FC 0006                529          MULU    #6, D1              ; Set displacement 
0000155C  41F9 00001708            530          LEA     OP_1101_TABLE,A0    ; Load table into A0
00001562  4EF0 1000                531          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
00001566                           532  
00001566                           533  code1110                            ; Opcodes ASL.B/W/L, ASR.B/W/L, LSL.B/W/L, LSR.B/W/L, ROL.B/W/L, ROR.B/W/L   
00001566  2200                     534          MOVE.L  D0,D1               ; D0 is current instruction word
00001568  0241 01C0                535          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
0000156C  1A3C 0006                536          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001570  EA69                     537          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001572                           538     
00001572                           539          ; Check Memory Shifts
00001572  B23C 0007                540          CMP.B   #7, D1              ; When 111
00001576  6700 0024                541          BEQ     MEMORY_1110_LEFT    ; Go to Memory Shift Left Side
0000157A                           542      
0000157A  B23C 0003                543          CMP.B   #3, D1              ; When 011
0000157E  6700 0040                544          BEQ     MEMORY_1110_RIGHT   ; Go Memory Shift Right Side
00001582                           545      
00001582                           546          ; Check Register Shifts
00001582  2200                     547          MOVE.L  D0,D1                       ; D0 is current instruction word
00001584  0241 0038                548          ANDI.W  #src_mode,D1                ; Extract 5-3 bits from instruction word
00001588  1A3C 0003                549          MOVE.B  #right3,D5                  ; Used to shift 3 times to right
0000158C  EA69                     550          LSR.W   D5,D1                       ; Shift 5-3 bits into LSB position
0000158E  C2FC 0006                551          MULU    #6,D1                       ; Set displacement 
00001592  41F9 00001768            552          LEA     OP_1110_TABLE_REGISTER,A0   ; Load table into A0
00001598  4EF0 1000                553          JMP     0(A0,D1)                    ; go to displacement (A0 + D1 * 6)
0000159C                           554  
0000159C                           555  MEMORY_1110_LEFT    
0000159C  2200                     556          MOVE.L  D0,D1               ; D0 is current instruction word
0000159E  0241 0E00                557          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
000015A2  1A3C 0009                558          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000015A6  EA69                     559          LSR.W   D5,D1               ; Shift dst reg into LSB position
000015A8  B23C 0000                560          CMP.B   #0,D1               ; When D1 is 0
000015AC  6700 0792                561          BEQ     OP_ASL              ; Go to opcode ASL
000015B0  B23C 0001                562          CMP.B   #1, D1              ; when D1 is 1
000015B4  6700 07C2                563          BEQ     OP_LSL              ; Go to opcode LSL
000015B8  B23C 0003                564          CMP.B   #3, D1              ; When D1 is 3
000015BC  6700 07F2                565          BEQ     OP_ROL              ; Go to opcode ROL
000015C0                           566  
000015C0                           567  MEMORY_1110_RIGHT
000015C0  2200                     568          MOVE.L  D0,D1               ; D0 is current instruction word
000015C2  0241 0E00                569          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
000015C6  1A3C 0009                570          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000015CA  EA69                     571          LSR.W   D5,D1               ; Shift dst reg into LSB position
000015CC  B23C 0000                572          CMP.B   #0,D1               ; When D1 is 0
000015D0  6700 0752                573          BEQ     OP_ASR              ; Go to opcode ASR
000015D4  B23C 0001                574          CMP.B   #1, D1              ; when D1 is 1
000015D8  6700 0782                575          BEQ     OP_LSR              ; Go to opcode LSR
000015DC  B23C 0003                576          CMP.B   #3, D1              ; When D1 is 3
000015E0  6700 07B2                577          BEQ     OP_ROR              ; Go to opcode ROR
000015E4                           578  
000015E4                           579  code1111                            ; Opcode not supported 
000015E4  6000 0306                580          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
000015E8                           581           
000015E8                           582  OP_0000_TABLE
000015E8  4EF9 000018EC            583          JMP     OP_UNSUPPORTED  ; 0 Go to opcode unsupported  
000015EE  4EF9 000018EC            584          JMP     OP_UNSUPPORTED  ; 1 Go to opcode unsupported  
000015F4  4EF9 000018EC            585          JMP     OP_UNSUPPORTED  ; 2 Go to opcode unsupported  
000015FA  4EF9 000018EC            586          JMP     OP_UNSUPPORTED  ; 3 Go to opcode unsupported  
00001600  4EF9 000018FC            587          JMP     OP_SUBI         ; 4 Go to opcode SUBI
00001606  4EF9 000018EC            588          JMP     OP_UNSUPPORTED  ; 5 Go to opcode unsupported  
0000160C  4EF9 0000191C            589          JMP     OP_ADDI         ; 6 Go to opcode ADDI
00001612  4EF9 000018EC            590          JMP     OP_UNSUPPORTED  ; 7 Go to opcode unsupported  
00001618  4EF9 000018EC            591          JMP     OP_UNSUPPORTED  ; 8 Go to opcode unsupported  
0000161E  4EF9 000018EC            592          JMP     OP_UNSUPPORTED  ; 9 Go to opcode unsupported  
00001624  4EF9 000018EC            593          JMP     OP_UNSUPPORTED  ; A Go to opcode unsupported  
0000162A  4EF9 000018EC            594          JMP     OP_UNSUPPORTED  ; B Go to opcode unsupported  
00001630  4EF9 000018EC            595          JMP     OP_UNSUPPORTED  ; C Go to opcode unsupported  
00001636  4EF9 000018EC            596          JMP     OP_UNSUPPORTED  ; D Go to opcode unsupported  
0000163C  4EF9 000018EC            597          JMP     OP_UNSUPPORTED  ; E Go to opcode unsupported  
00001642  4EF9 000018EC            598          JMP     OP_UNSUPPORTED  ; F Go to opcode unsupported  
00001648                           599      
00001648                           600  OP_0100_TABLE
00001648  4EF9 000018EC            601          JMP     OP_UNSUPPORTED      ; 0 Go to opcode unsupported  
0000164E  4EF9 000019FC            602          JMP     OP_LEA              ; 1 Go to opcode LEA
00001654  4EF9 00001980            603          JMP     OP_CLR              ; 2 Go to opcode CLR
0000165A  4EF9 000019FC            604          JMP     OP_LEA              ; 3 Go to opcode LEA
00001660  4EF9 000018EC            605          JMP     OP_UNSUPPORTED      ; 4 Go to opcode unsupported  
00001666  4EF9 000019FC            606          JMP     OP_LEA              ; 5 Go to opcode LEA
0000166C  4EF9 0000191C            607          JMP     OP_ADDI             ; 6 Go to opcode ADDI
00001672  4EF9 000019FC            608          JMP     OP_LEA              ; 7 Go to opcode LEA
00001678  4EF9 000019D8            609          JMP     OP_MOVEM            ; 8 Go to opcode MOVEM
0000167E  4EF9 000019FC            610          JMP     OP_LEA              ; 9 Go to opcode LEA
00001684  4EF9 000018EC            611          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
0000168A  4EF9 000019FC            612          JMP     OP_LEA              ; B Go to opcode LEA
00001690  4EF9 000019D8            613          JMP     OP_MOVEM            ; C Go to opcode MOVEM
00001696  4EF9 000019FC            614          JMP     OP_LEA              ; D Go to opcode LEA
0000169C  4EF9 0000182E            615          JMP     JSR_NOP_RTS         ; E Go to opcode JSR, NOP, or RTS
000016A2  4EF9 000018EC            616          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000016A8                           617      
000016A8                           618  OP_1100_TABLE
000016A8  4EF9 00001CCC            619          JMP     OP_AND              ; 0 Go to opcode AND 
000016AE  4EF9 00001CCC            620          JMP     OP_AND              ; 1 Go to opcode AND
000016B4  4EF9 00001CCC            621          JMP     OP_AND              ; 2 Go to opcode AND
000016BA  4EF9 00001C8C            622          JMP     OP_MULU             ; 3 Go to opcode MULU
000016C0  4EF9 00001CCC            623          JMP     OP_AND              ; 4 Go to opcode AND 
000016C6  4EF9 00001CCC            624          JMP     OP_AND              ; 5 Go to opcode AND
000016CC  4EF9 00001CCC            625          JMP     OP_AND              ; 6 Go to opcode AND
000016D2  4EF9 00001CAC            626          JMP     OP_MULS             ; 7 Go to opcode MULS
000016D8  4EF9 000018EC            627          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
000016DE  4EF9 000018EC            628          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
000016E4  4EF9 000018EC            629          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000016EA  4EF9 000018EC            630          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
000016F0  4EF9 000018EC            631          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
000016F6  4EF9 000018EC            632          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
000016FC  4EF9 000018EC            633          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001702  4EF9 000018EC            634          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001708                           635      
00001708                           636  OP_1101_TABLE
00001708  4EF9 00001CE8            637          JMP     OP_ADD              ; 0 Go to opcode ADD 
0000170E  4EF9 00001CE8            638          JMP     OP_ADD              ; 1 Go to opcode ADD
00001714  4EF9 00001CE8            639          JMP     OP_ADD              ; 2 Go to opcode ADD
0000171A  4EF9 00001D04            640          JMP     OP_ADDA             ; 3 Go to opcode ADDA
00001720  4EF9 00001CE8            641          JMP     OP_ADD              ; 4 Go to opcode ADD 
00001726  4EF9 00001CE8            642          JMP     OP_ADD              ; 5 Go to opcode ADD
0000172C  4EF9 00001CE8            643          JMP     OP_ADD              ; 6 Go to opcode ADD
00001732  4EF9 00001D04            644          JMP     OP_ADDA             ; 7 Go to opcode ADDA
00001738  4EF9 000018EC            645          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000173E  4EF9 000018EC            646          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001744  4EF9 000018EC            647          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
0000174A  4EF9 000018EC            648          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
00001750  4EF9 000018EC            649          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001756  4EF9 000018EC            650          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000175C  4EF9 000018EC            651          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001762  4EF9 000018EC            652          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001768                           653      
00001768                           654  OP_1110_TABLE_REGISTER
00001768  4EF9 000017C8            655          JMP     OP_AS_CHECK         ; 0 Check if AS is left or right
0000176E  4EF9 000017EA            656          JMP     OP_LS_CHECK         ; 1 Check if LS is left or right
00001774  4EF9 000018EC            657          JMP     OP_UNSUPPORTED      ; 2 Go to opcode unsupported  
0000177A  4EF9 0000180C            658          JMP     OP_RO_CHECK         ; 3 Check if RO is left or right
00001780  4EF9 000017C8            659          JMP     OP_AS_CHECK         ; 4 Check if AS is left or right
00001786  4EF9 000017EA            660          JMP     OP_LS_CHECK         ; 5 Check if LS is left or right
0000178C  4EF9 000018EC            661          JMP     OP_UNSUPPORTED      ; 6 Go to opcode unsupported 
00001792  4EF9 0000180C            662          JMP     OP_RO_CHECK         ; 7 Check if RO is left or right
00001798  4EF9 000018EC            663          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000179E  4EF9 000018EC            664          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
000017A4  4EF9 000018EC            665          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000017AA  4EF9 000018EC            666          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
000017B0  4EF9 000018EC            667          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
000017B6  4EF9 000018EC            668          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
000017BC  4EF9 000018EC            669          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
000017C2  4EF9 000018EC            670          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000017C8                           671  
000017C8                           672  OP_AS_CHECK
000017C8  2200                     673          MOVE.L  D0,D1               ; D0 is current instruction word
000017CA  0241 01C0                674          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000017CE  1A3C 0006                675          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000017D2  EA69                     676          LSR.W   D5,D1               ; Shift dst mode into LSB position
000017D4  0201 0004                677          ANDI.B  #4,D1               ; Get only bit 8 (dr)
000017D8  E449                     678          LSR.W   #2,D1
000017DA                           679  
000017DA  B23C 0001                680          CMP.B   #1,D1               ; Go left
000017DE  6700 0560                681          BEQ     OP_ASL              ; 1 Go to opcode ASL
000017E2  B23C 0000                682          CMP.B   #0,D1               ; Go right
000017E6  6700 053C                683          BEQ     OP_ASR              ; 0 Go to opcode ASR
000017EA                           684          
000017EA                           685  OP_LS_CHECK
000017EA  2200                     686          MOVE.L  D0,D1               ; D0 is current instruction word
000017EC  0241 01C0                687          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000017F0  1A3C 0006                688          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000017F4  EA69                     689          LSR.W   D5,D1               ; Shift dst mode into LSB position
000017F6  0201 0004                690          ANDI.B  #4,D1               ; Get only bit 8 (dr)
000017FA  E449                     691          LSR.W   #2,D1
000017FC                           692  
000017FC  B23C 0001                693          CMP.B   #1,D1               ; Go left
00001800  6700 0576                694          BEQ     OP_LSL              ; 1 Go to opcode LSL
00001804  B23C 0000                695          CMP.B   #0,D1               ; Go right
00001808  6700 0552                696          BEQ     OP_LSR              ; 0 Go to opcode LSR
0000180C                           697          
0000180C                           698  OP_RO_CHECK
0000180C  2200                     699          MOVE.L  D0,D1               ; D0 is current instruction word
0000180E  0241 01C0                700          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00001812  1A3C 0006                701          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001816  EA69                     702          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001818  0201 0004                703          ANDI.B  #4,D1               ; Get only bit 8 (dr)
0000181C  E449                     704          LSR.W   #2,D1
0000181E                           705  
0000181E  B23C 0001                706          CMP.B   #1,D1               ; Go left
00001822  6700 058C                707          BEQ     OP_ROL              ; 1 Go to opcode ROL
00001826  B23C 0000                708          CMP.B   #0,D1               ; Go right
0000182A  6700 0568                709          BEQ     OP_ROR              ; 0 Go to opcode ROR
0000182E                           710          
0000182E                           711  JSR_NOP_RTS
0000182E  2200                     712          MOVE.L  D0,D1               ; D0 is current instruction word
00001830  0241 01C0                713          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001834  1A3C 0006                714          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001838  EA69                     715          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000183A  B23C 0002                716          CMP.B   #2, D1              ; When 010 in destination mode
0000183E  6700 017C                717          BEQ     OP_JSR              ; Go to opcode JSR
00001842                           718          
00001842  2200                     719          MOVE.L  D0,D1               ; D0 is current instruction word
00001844  0241 000F                720          ANDI.W  #fourth_nibble,D1   ; Extract dst mode position from instruction word
00001848  B23C 0001                721          CMP.B   #1, D1  
0000184C  6700 000E                722          BEQ     NOP_CHECK
00001850  B23C 0005                723          CMP.B   #5, D1  
00001854  6700 004E                724          BEQ     RTS_CHECK
00001858  6000 0092                725          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000185C                           726          
0000185C                           727  NOP_CHECK
0000185C  2200                     728          MOVE.L  D0,D1               ; D0 is current instruction word
0000185E  0241 F000                729          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
00001862  1A3C 000C                730          MOVE.B  #right12,D5         ; Used to shift 6 times to right
00001866  EA69                     731          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001868  B23C 0004                732          CMP.B   #4, D1              
0000186C  6700 0006                733          BEQ     NOP_CHECK_TWO
00001870  6000 007A                734          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
00001874                           735          
00001874                           736  NOP_CHECK_TWO
00001874  2200                     737          MOVE.L  D0,D1               ; D0 is current instruction word
00001876  0241 0F00                738          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
0000187A  1A3C 0008                739          MOVE.B  #right8,D5          ; Used to shift 6 times to right
0000187E  EA69                     740          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001880  B23C 000E                741          CMP.B   #14, D1            
00001884  6700 0006                742          BEQ     NOP_CHECK_THREE
00001888  6000 0062                743          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000188C                           744  
0000188C                           745  NOP_CHECK_THREE
0000188C  2200                     746          MOVE.L  D0,D1               ; D0 is current instruction word
0000188E  0241 00F0                747          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
00001892  1A3C 0004                748          MOVE.B  #right4,D5          ; Used to shift 6 times to right
00001896  EA69                     749          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001898  B23C 0007                750          CMP.B   #7, D1              
0000189C  6700 00FE                751          BEQ     OP_NOP
000018A0  6000 004A                752          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018A4                           753       
000018A4                           754  RTS_CHECK
000018A4  2200                     755          MOVE.L  D0,D1               ; D0 is current instruction word
000018A6  0241 F000                756          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
000018AA  1A3C 000C                757          MOVE.B  #right12,D5         ; Used to shift 6 times to right
000018AE  EA69                     758          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018B0  B23C 0004                759          CMP.B   #4, D1              
000018B4  6700 0006                760          BEQ     RTS_CHECK_TWO
000018B8  6000 0032                761          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018BC                           762          
000018BC                           763  RTS_CHECK_TWO
000018BC  2200                     764          MOVE.L  D0,D1               ; D0 is current instruction word
000018BE  0241 0F00                765          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
000018C2  1A3C 0008                766          MOVE.B  #right8,D5          ; Used to shift 6 times to right
000018C6  EA69                     767          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018C8  B23C 000E                768          CMP.B   #14, D1             
000018CC  6700 0006                769          BEQ     RTS_CHECK_THREE
000018D0  6000 001A                770          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018D4                           771  
000018D4                           772  RTS_CHECK_THREE
000018D4  2200                     773          MOVE.L  D0,D1               ; D0 is current instruction word
000018D6  0241 00F0                774          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
000018DA  1A3C 0004                775          MOVE.B  #right4,D5          ; Used to shift 6 times to right
000018DE  EA69                     776          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018E0  B23C 0007                777          CMP.B   #7, D1             
000018E4  6700 00C6                778          BEQ     OP_RTS
000018E8  6000 0002                779          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018EC                           780  
000018EC                           781  OP_UNSUPPORTED
000018EC  43F9 00002ED1            782          LEA     OPCODE_INVALID,A1 
000018F2  103C 000E                783          MOVE.B  #14,D0
000018F6  4E4F                     784          TRAP    #15
000018F8  4EF8 138E                785          JMP     OP_FINISH
000018FC                           786          
000018FC                           787  *----------------------------------------------------------------------------------------------*
000018FC                           788  * param D0 the current instruction in word
000018FC                           789  * param D1 the EA type
000018FC                           790  * param A2 a pointer to the decode_buffer
000018FC                           791  * param A5 current address
000018FC                           792  * ea_start(D0, D1, A2, A5){
000018FC                           793  * D2: size
000018FC                           794  * D3: src mode, dst mode
000018FC                           795  * D4: src regs, dst regs
000018FC                           796  * D5: #shifts
000018FC                           797  * D7: immediate data
000018FC                           798  * A0: EA_TYPE_TABLE
000018FC                           799  *       0 = ea_immediate
000018FC                           800  * }
000018FC                           801  
000018FC                           802  *----------------------------------------------------------------------------------------------*
000018FC                           803  * First 4 bits: 0000
000018FC                           804  OP_SUBI
000018FC  14FC 0053                805          MOVE.B  #'S',(A2)+
00001900  14FC 0055                806          MOVE.B  #'U',(A2)+
00001904  14FC 0042                807          MOVE.B  #'B',(A2)+
00001908  14FC 0049                808          MOVE.B  #'I',(A2)+
0000190C  223C 00000000            809          MOVE.L  #ea_type_immediate,D1
00001912  4EB9 00001DCC            810          JSR     EA_START
00001918  4EF8 138E                811          JMP     OP_FINISH
0000191C                           812          
0000191C                           813  OP_ADDI
0000191C  14FC 0041                814          MOVE.B  #'A',(A2)+
00001920  14FC 0044                815          MOVE.B  #'D',(A2)+
00001924  14FC 0044                816          MOVE.B  #'D',(A2)+
00001928  14FC 0049                817          MOVE.B  #'I',(A2)+
0000192C  223C 00000000            818          MOVE.L  #ea_type_immediate,D1
00001932  4EB9 00001DCC            819          JSR     EA_START
00001938  4EF8 138E                820          JMP     OP_FINISH
0000193C                           821  
0000193C                           822  *-----------------------------------------------------------------------------------------------*
0000193C                           823  * First 4 bits: 0001
0000193C                           824  OP_MOVEA
0000193C  14FC 004D                825          MOVE.B  #'M',(A2)+
00001940  14FC 004F                826          MOVE.B  #'O',(A2)+
00001944  14FC 0056                827          MOVE.B  #'V',(A2)+
00001948  14FC 0045                828          MOVE.B  #'E',(A2)+
0000194C  14FC 0041                829          MOVE.B  #'A',(A2)+
00001950  223C 00000002            830          MOVE.L  #ea_type_movea,D1
00001956  4EB9 00001DCC            831          JSR     EA_START
0000195C  4EF8 138E                832          JMP     OP_FINISH
00001960                           833  
00001960                           834  *------------------------------------------------------------------------------------------------*
00001960                           835  * First 4 bits: 0011
00001960                           836  OP_MOVE
00001960  14FC 004D                837          MOVE.B  #'M',(A2)+
00001964  14FC 004F                838          MOVE.B  #'O',(A2)+
00001968  14FC 0056                839          MOVE.B  #'V',(A2)+
0000196C  14FC 0045                840          MOVE.B  #'E',(A2)+
00001970  223C 00000001            841          MOVE.L  #ea_type_move,D1
00001976  4EB9 00001DCC            842          JSR     EA_START
0000197C  4EF8 138E                843          JMP     OP_FINISH
00001980                           844  
00001980                           845  *------------------------------------------------------------------------------------------------*
00001980                           846  * First 4 bits: 0100
00001980                           847  OP_CLR
00001980  14FC 0043                848          MOVE.B  #'C',(A2)+
00001984  14FC 004C                849          MOVE.B  #'L',(A2)+
00001988  14FC 0052                850          MOVE.B  #'R',(A2)+
0000198C  223C 00000004            851          MOVE.L  #ea_type_dstonly,D1
00001992  4EB9 00001DCC            852          JSR     EA_START
00001998  4EF8 138E                853          JMP     OP_FINISH
0000199C                           854          
0000199C                           855  OP_NOP
0000199C  14FC 004E                856          MOVE.B  #'N',(A2)+
000019A0  14FC 004F                857          MOVE.B  #'O',(A2)+
000019A4  14FC 0050                858          MOVE.B  #'P',(A2)+
000019A8  4EF8 138E                859          JMP     OP_FINISH
000019AC                           860          
000019AC                           861  OP_RTS
000019AC  14FC 0052                862          MOVE.B  #'R',(A2)+
000019B0  14FC 0054                863          MOVE.B  #'T',(A2)+
000019B4  14FC 0053                864          MOVE.B  #'S',(A2)+
000019B8  4EF8 138E                865          JMP     OP_FINISH
000019BC                           866          
000019BC                           867  OP_JSR
000019BC  14FC 004A                868          MOVE.B  #'J',(A2)+
000019C0  14FC 0053                869          MOVE.B  #'S',(A2)+
000019C4  14FC 0052                870          MOVE.B  #'R',(A2)+
000019C8  223C 00000004            871          MOVE.L  #ea_type_dstonly,D1
000019CE  4EB9 00001DCC            872          JSR     EA_START
000019D4  4EF8 138E                873          JMP     OP_FINISH
000019D8                           874  
000019D8                           875  OP_MOVEM
000019D8  14FC 004D                876          MOVE.B  #'M',(A2)+
000019DC  14FC 004F                877          MOVE.B  #'O',(A2)+
000019E0  14FC 0056                878          MOVE.B  #'V',(A2)+
000019E4  14FC 0045                879          MOVE.B  #'E',(A2)+
000019E8  14FC 004D                880          MOVE.B  #'M',(A2)+
000019EC  223C 00000006            881          MOVE.L  #ea_type_movem,D1
000019F2  4EB9 00001DCC            882          JSR     EA_START
000019F8  4EF8 138E                883          JMP     OP_FINISH
000019FC                           884          
000019FC                           885  OP_LEA
000019FC  14FC 004C                886          MOVE.B  #'L',(A2)+
00001A00  14FC 0045                887          MOVE.B  #'E',(A2)+
00001A04  14FC 0041                888          MOVE.B  #'A',(A2)+
00001A08  223C 00000003            889          MOVE.L  #ea_type_lea,D1
00001A0E  4EB9 00001DCC            890          JSR     EA_START
00001A14  4EF8 138E                891          JMP     OP_FINISH
00001A18                           892  
00001A18                           893  *------------------------------------------------------------------------------------------------*
00001A18                           894  * First 4 bits: 0101
00001A18                           895  OP_ADDQ
00001A18  14FC 0041                896          MOVE.B  #'A',(A2)+
00001A1C  14FC 0044                897          MOVE.B  #'D',(A2)+
00001A20  14FC 0044                898          MOVE.B  #'D',(A2)+
00001A24  14FC 0051                899          MOVE.B  #'Q',(A2)+
00001A28  223C 00000008            900          MOVE.L  #ea_type_quick,D1
00001A2E  4EB9 00001DCC            901          JSR     EA_START
00001A34  4EF8 138E                902          JMP     OP_FINISH
00001A38                           903          
00001A38                           904  *------------------------------------------------------------------------------------------------*
00001A38                           905  * First 4 bits: 0110
00001A38                           906  OP_BRA
00001A38  14FC 0042                907          MOVE.B  #'B',(A2)+
00001A3C  14FC 0052                908          MOVE.B  #'R',(A2)+
00001A40  14FC 0041                909          MOVE.B  #'A',(A2)+
00001A44  223C 00000009            910          MOVE.L  #ea_type_branch,D1
00001A4A  4EB9 00001DCC            911          JSR     EA_START
00001A50  4EF8 138E                912          JMP     OP_FINISH
00001A54                           913  
00001A54                           914  OP_BSR
00001A54  14FC 0042                915          MOVE.B  #'B',(A2)+
00001A58  14FC 0053                916          MOVE.B  #'S',(A2)+
00001A5C  14FC 0052                917          MOVE.B  #'R',(A2)+
00001A60  223C 00000009            918          MOVE.L  #ea_type_branch,D1
00001A66  4EB9 00001DCC            919          JSR     EA_START
00001A6C  4EF8 138E                920          JMP     OP_FINISH
00001A70                           921          
00001A70                           922  OP_BHI
00001A70  14FC 0042                923          MOVE.B  #'B',(A2)+
00001A74  14FC 0048                924          MOVE.B  #'H',(A2)+
00001A78  14FC 0049                925          MOVE.B  #'I',(A2)+
00001A7C  223C 00000009            926          MOVE.L  #ea_type_branch,D1
00001A82  4EB9 00001DCC            927          JSR     EA_START
00001A88  4EF8 138E                928          JMP     OP_FINISH
00001A8C                           929  
00001A8C                           930  OP_BLS
00001A8C  14FC 0042                931          MOVE.B  #'B',(A2)+
00001A90  14FC 004C                932          MOVE.B  #'L',(A2)+
00001A94  14FC 0053                933          MOVE.B  #'S',(A2)+
00001A98  223C 00000009            934          MOVE.L  #ea_type_branch,D1
00001A9E  4EB9 00001DCC            935          JSR     EA_START
00001AA4  4EF8 138E                936          JMP     OP_FINISH
00001AA8                           937  
00001AA8                           938  OP_BCC
00001AA8  14FC 0042                939          MOVE.B  #'B',(A2)+
00001AAC  14FC 0043                940          MOVE.B  #'C',(A2)+
00001AB0  14FC 0043                941          MOVE.B  #'C',(A2)+
00001AB4  223C 00000009            942          MOVE.L  #ea_type_branch,D1
00001ABA  4EB9 00001DCC            943          JSR     EA_START
00001AC0  4EF8 138E                944          JMP     OP_FINISH
00001AC4                           945          
00001AC4                           946  OP_BCS
00001AC4  14FC 0042                947          MOVE.B  #'B',(A2)+
00001AC8  14FC 0043                948          MOVE.B  #'C',(A2)+
00001ACC  14FC 0053                949          MOVE.B  #'S',(A2)+
00001AD0  223C 00000009            950          MOVE.L  #ea_type_branch,D1
00001AD6  4EB9 00001DCC            951          JSR     EA_START
00001ADC  4EF8 138E                952          JMP     OP_FINISH
00001AE0                           953  
00001AE0                           954  OP_BNE
00001AE0  14FC 0042                955          MOVE.B  #'B',(A2)+
00001AE4  14FC 004E                956          MOVE.B  #'N',(A2)+
00001AE8  14FC 0045                957          MOVE.B  #'E',(A2)+
00001AEC  223C 00000009            958          MOVE.L  #ea_type_branch,D1
00001AF2  4EB9 00001DCC            959          JSR     EA_START
00001AF8  4EF8 138E                960          JMP     OP_FINISH
00001AFC                           961  
00001AFC                           962  OP_BEQ
00001AFC  14FC 0042                963          MOVE.B  #'B',(A2)+
00001B00  14FC 0045                964          MOVE.B  #'E',(A2)+
00001B04  14FC 0051                965          MOVE.B  #'Q',(A2)+
00001B08  223C 00000009            966          MOVE.L  #ea_type_branch,D1
00001B0E  4EB9 00001DCC            967          JSR     EA_START
00001B14  4EF8 138E                968          JMP     OP_FINISH
00001B18                           969  
00001B18                           970  OP_BVC
00001B18  14FC 0042                971          MOVE.B  #'B',(A2)+
00001B1C  14FC 0056                972          MOVE.B  #'V',(A2)+
00001B20  14FC 0043                973          MOVE.B  #'C',(A2)+
00001B24  223C 00000009            974          MOVE.L  #ea_type_branch,D1
00001B2A  4EB9 00001DCC            975          JSR     EA_START
00001B30  4EF8 138E                976          JMP     OP_FINISH
00001B34                           977  
00001B34                           978  OP_BVS
00001B34  14FC 0042                979          MOVE.B  #'B',(A2)+
00001B38  14FC 0056                980          MOVE.B  #'V',(A2)+
00001B3C  14FC 0053                981          MOVE.B  #'S',(A2)+
00001B40  223C 00000009            982          MOVE.L  #ea_type_branch,D1
00001B46  4EB9 00001DCC            983          JSR     EA_START
00001B4C  4EF8 138E                984          JMP     OP_FINISH
00001B50                           985  
00001B50                           986  OP_BPL
00001B50  14FC 0042                987          MOVE.B  #'B',(A2)+
00001B54  14FC 0050                988          MOVE.B  #'P',(A2)+
00001B58  14FC 004C                989          MOVE.B  #'L',(A2)+
00001B5C  223C 00000009            990          MOVE.L  #ea_type_branch,D1
00001B62  4EB9 00001DCC            991          JSR     EA_START
00001B68  4EF8 138E                992          JMP     OP_FINISH
00001B6C                           993  
00001B6C                           994  OP_BMI
00001B6C  14FC 0042                995          MOVE.B  #'B',(A2)+
00001B70  14FC 004D                996          MOVE.B  #'M',(A2)+
00001B74  14FC 0049                997          MOVE.B  #'I',(A2)+
00001B78  223C 00000009            998          MOVE.L  #ea_type_branch,D1
00001B7E  4EB9 00001DCC            999          JSR     EA_START
00001B84  4EF8 138E               1000          JMP     OP_FINISH
00001B88                          1001  
00001B88                          1002  OP_BGE
00001B88  14FC 0042               1003          MOVE.B  #'B',(A2)+
00001B8C  14FC 0047               1004          MOVE.B  #'G',(A2)+
00001B90  14FC 0045               1005          MOVE.B  #'E',(A2)+
00001B94  223C 00000009           1006          MOVE.L  #ea_type_branch,D1
00001B9A  4EB9 00001DCC           1007          JSR     EA_START
00001BA0  4EF8 138E               1008          JMP     OP_FINISH
00001BA4                          1009  
00001BA4                          1010  OP_BLT
00001BA4  14FC 0042               1011          MOVE.B  #'B',(A2)+
00001BA8  14FC 004C               1012          MOVE.B  #'L',(A2)+
00001BAC  14FC 0054               1013          MOVE.B  #'T',(A2)+
00001BB0  223C 00000009           1014          MOVE.L  #ea_type_branch,D1
00001BB6  4EB9 00001DCC           1015          JSR     EA_START
00001BBC  4EF8 138E               1016          JMP     OP_FINISH
00001BC0                          1017  
00001BC0                          1018  OP_BGT
00001BC0  14FC 0042               1019          MOVE.B  #'B',(A2)+
00001BC4  14FC 0047               1020          MOVE.B  #'G',(A2)+
00001BC8  14FC 0054               1021          MOVE.B  #'T',(A2)+
00001BCC  223C 00000009           1022          MOVE.L  #ea_type_branch,D1
00001BD2  4EB9 00001DCC           1023          JSR     EA_START
00001BD8  4EF8 138E               1024          JMP     OP_FINISH
00001BDC                          1025  
00001BDC                          1026  OP_BLE
00001BDC  14FC 0042               1027          MOVE.B  #'B',(A2)+
00001BE0  14FC 004C               1028          MOVE.B  #'L',(A2)+
00001BE4  14FC 0045               1029          MOVE.B  #'E',(A2)+
00001BE8  223C 00000009           1030          MOVE.L  #ea_type_branch,D1
00001BEE  4EB9 00001DCC           1031          JSR     EA_START
00001BF4  4EF8 138E               1032          JMP     OP_FINISH
00001BF8                          1033  *------------------------------------------------------------------------------------------------*
00001BF8                          1034  * First 4 bits: 0111
00001BF8                          1035  OP_MOVEQ
00001BF8  14FC 004D               1036          MOVE.B  #'M',(A2)+
00001BFC  14FC 004F               1037          MOVE.B  #'O',(A2)+
00001C00  14FC 0056               1038          MOVE.B  #'V',(A2)+
00001C04  14FC 0045               1039          MOVE.B  #'E',(A2)+
00001C08  14FC 0051               1040          MOVE.B  #'Q',(A2)+
00001C0C  223C 00000008           1041          MOVE.L  #ea_type_quick,D1
00001C12  4EB9 00001DCC           1042          JSR     EA_START
00001C18  4EF8 138E               1043          JMP     OP_FINISH
00001C1C                          1044          
00001C1C                          1045  *------------------------------------------------------------------------------------------------*
00001C1C                          1046  * First 4 bits: 1000
00001C1C                          1047  OP_DIVU
00001C1C  14FC 0044               1048          MOVE.B  #'D',(A2)+
00001C20  14FC 0049               1049          MOVE.B  #'I',(A2)+
00001C24  14FC 0056               1050          MOVE.B  #'V',(A2)+
00001C28  14FC 0055               1051          MOVE.B  #'U',(A2)+
00001C2C  223C 00000005           1052          MOVE.L  #ea_type_ext,D1
00001C32  4EB9 00001DCC           1053          JSR     EA_START
00001C38  4EF8 138E               1054          JMP     OP_FINISH
00001C3C                          1055    
00001C3C                          1056  OP_OR
00001C3C  14FC 004F               1057          MOVE.B  #'O',(A2)+
00001C40  14FC 0052               1058          MOVE.B  #'R',(A2)+
00001C44  223C 00000005           1059          MOVE.L  #ea_type_ext,D1
00001C4A  4EB9 00001DCC           1060          JSR     EA_START
00001C50  4EF8 138E               1061          JMP     OP_FINISH
00001C54                          1062  
00001C54                          1063  *------------------------------------------------------------------------------------------------*
00001C54                          1064  * First 4 bits: 1001
00001C54                          1065  OP_SUB
00001C54  14FC 0053               1066          MOVE.B  #'S',(A2)+
00001C58  14FC 0055               1067          MOVE.B  #'U',(A2)+
00001C5C  14FC 0042               1068          MOVE.B  #'B',(A2)+
00001C60  223C 00000005           1069          MOVE.L  #ea_type_ext,D1
00001C66  4EB9 00001DCC           1070          JSR     EA_START
00001C6C  4EF8 138E               1071          JMP     OP_FINISH
00001C70                          1072          
00001C70                          1073  *------------------------------------------------------------------------------------------------*
00001C70                          1074  * First 4 bits: 1011
00001C70                          1075  OP_CMP
00001C70  14FC 0043               1076          MOVE.B  #'C',(A2)+
00001C74  14FC 004D               1077          MOVE.B  #'M',(A2)+
00001C78  14FC 0050               1078          MOVE.B  #'P',(A2)+
00001C7C  223C 00000005           1079          MOVE.L  #ea_type_ext,D1
00001C82  4EB9 00001DCC           1080          JSR     EA_START
00001C88  4EF8 138E               1081          JMP     OP_FINISH
00001C8C                          1082          
00001C8C                          1083  *------------------------------------------------------------------------------------------------*
00001C8C                          1084  * First 4 bits: 1100
00001C8C                          1085  OP_MULU
00001C8C  14FC 004D               1086          MOVE.B  #'M',(A2)+
00001C90  14FC 0055               1087          MOVE.B  #'U',(A2)+
00001C94  14FC 004C               1088          MOVE.B  #'L',(A2)+
00001C98  14FC 0055               1089          MOVE.B  #'U',(A2)+
00001C9C  223C 00000005           1090          MOVE.L  #ea_type_ext,D1
00001CA2  4EB9 00001DCC           1091          JSR     EA_START
00001CA8  4EF8 138E               1092          JMP     OP_FINISH
00001CAC                          1093          
00001CAC                          1094  OP_MULS
00001CAC  14FC 004D               1095          MOVE.B  #'M',(A2)+
00001CB0  14FC 0055               1096          MOVE.B  #'U',(A2)+
00001CB4  14FC 004C               1097          MOVE.B  #'L',(A2)+
00001CB8  14FC 0053               1098          MOVE.B  #'S',(A2)+
00001CBC  223C 00000005           1099          MOVE.L  #ea_type_ext,D1
00001CC2  4EB9 00001DCC           1100          JSR     EA_START
00001CC8  4EF8 138E               1101          JMP     OP_FINISH
00001CCC                          1102          
00001CCC                          1103  OP_AND
00001CCC  14FC 0041               1104          MOVE.B  #'A',(A2)+
00001CD0  14FC 004E               1105          MOVE.B  #'N',(A2)+
00001CD4  14FC 0044               1106          MOVE.B  #'D',(A2)+
00001CD8  223C 00000005           1107          MOVE.L  #ea_type_ext,D1
00001CDE  4EB9 00001DCC           1108          JSR     EA_START
00001CE4  4EF8 138E               1109          JMP     OP_FINISH
00001CE8                          1110          
00001CE8                          1111  *------------------------------------------------------------------------------------------------*
00001CE8                          1112  * First 4 bits: 1101
00001CE8                          1113  OP_ADD
00001CE8  14FC 0041               1114          MOVE.B  #'A',(A2)+
00001CEC  14FC 0044               1115          MOVE.B  #'D',(A2)+
00001CF0  14FC 0044               1116          MOVE.B  #'D',(A2)+
00001CF4  223C 00000005           1117          MOVE.L  #ea_type_ext,D1
00001CFA  4EB9 00001DCC           1118          JSR     EA_START
00001D00  4EF8 138E               1119          JMP     OP_FINISH
00001D04                          1120  
00001D04                          1121  OP_ADDA
00001D04  14FC 0041               1122          MOVE.B  #'A',(A2)+
00001D08  14FC 0044               1123          MOVE.B  #'D',(A2)+
00001D0C  14FC 0044               1124          MOVE.B  #'D',(A2)+
00001D10  14FC 0041               1125          MOVE.B  #'A',(A2)+
00001D14  223C 00000005           1126          MOVE.L  #ea_type_ext,D1
00001D1A  4EB9 00001DCC           1127          JSR     EA_START
00001D20  4EF8 138E               1128          JMP     OP_FINISH
00001D24                          1129          
00001D24                          1130  *------------------------------------------------------------------------------------------------*
00001D24                          1131  * First 4 bits: 1110
00001D24                          1132  OP_ASR
00001D24  14FC 0041               1133          MOVE.B  #'A',(A2)+
00001D28  14FC 0053               1134          MOVE.B  #'S',(A2)+
00001D2C  14FC 0052               1135          MOVE.B  #'R',(A2)+
00001D30  223C 00000007           1136          MOVE.L  #ea_type_shifts,D1
00001D36  4EB9 00001DCC           1137          JSR     EA_START
00001D3C  4EF8 138E               1138          JMP     OP_FINISH
00001D40                          1139  OP_ASL
00001D40  14FC 0041               1140          MOVE.B  #'A',(A2)+
00001D44  14FC 0053               1141          MOVE.B  #'S',(A2)+
00001D48  14FC 004C               1142          MOVE.B  #'L',(A2)+
00001D4C  223C 00000007           1143          MOVE.L  #ea_type_shifts,D1
00001D52  4EB9 00001DCC           1144          JSR     EA_START
00001D58  4EF8 138E               1145          JMP     OP_FINISH
00001D5C                          1146          
00001D5C                          1147  OP_LSR
00001D5C  14FC 004C               1148          MOVE.B  #'L',(A2)+
00001D60  14FC 0053               1149          MOVE.B  #'S',(A2)+
00001D64  14FC 0052               1150          MOVE.B  #'R',(A2)+
00001D68  223C 00000007           1151          MOVE.L  #ea_type_shifts,D1
00001D6E  4EB9 00001DCC           1152          JSR     EA_START
00001D74  4EF8 138E               1153          JMP     OP_FINISH
00001D78                          1154         
00001D78                          1155  OP_LSL
00001D78  14FC 004C               1156          MOVE.B  #'L',(A2)+
00001D7C  14FC 0053               1157          MOVE.B  #'S',(A2)+
00001D80  14FC 004C               1158          MOVE.B  #'L',(A2)+
00001D84  223C 00000007           1159          MOVE.L  #ea_type_shifts,D1
00001D8A  4EB9 00001DCC           1160          JSR     EA_START
00001D90  4EF8 138E               1161          JMP     OP_FINISH
00001D94                          1162          
00001D94                          1163  OP_ROR
00001D94  14FC 0052               1164          MOVE.B  #'R',(A2)+
00001D98  14FC 004F               1165          MOVE.B  #'O',(A2)+
00001D9C  14FC 0052               1166          MOVE.B  #'R',(A2)+
00001DA0  223C 00000007           1167          MOVE.L  #ea_type_shifts,D1
00001DA6  4EB9 00001DCC           1168          JSR     EA_START
00001DAC  4EF8 138E               1169          JMP     OP_FINISH
00001DB0                          1170          
00001DB0                          1171  OP_ROL
00001DB0  14FC 0052               1172          MOVE.B  #'R',(A2)+
00001DB4  14FC 004F               1173          MOVE.B  #'O',(A2)+
00001DB8  14FC 004C               1174          MOVE.B  #'L',(A2)+
00001DBC  223C 00000007           1175          MOVE.L  #ea_type_shifts,D1
00001DC2  4EB9 00001DCC           1176          JSR     EA_START
00001DC8  4EF8 138E               1177          JMP     OP_FINISH
00001DCC                          1178          
00001DCC                          1179  *------------------------------------------------------------------------------------------------*
00001DCC                          1180  EA_START
00001DCC  48E7 38C0               1181          MOVEM.L D2-D4/A0-A1, -(SP)
00001DD0                          1182          
00001DD0  41F9 00001DE4           1183          LEA     EA_TYPE_TABLE, A0
00001DD6  C2FC 0006               1184          MULU    #6, D1
00001DDA  4EF0 1000               1185          JMP     0(A0, D1)
00001DDE                          1186          
00001DDE                          1187  EA_FINISH
00001DDE  4CDF 031C               1188          MOVEM.L (SP)+, D2-D4/A0-A1
00001DE2  4E75                    1189          RTS
00001DE4                          1190          
00001DE4                          1191  EA_TYPE_TABLE
00001DE4  4EF9 00001F02           1192          JMP     EA_IMMEDIATE        ; 0: ea_immediate
00001DEA  4EF9 00001F5A           1193          JMP     EA_MOVE             ; 1: ea_move
00001DF0  4EF9 00001FC6           1194          JMP     EA_MOVEA            ; 2: ea_movea
00001DF6  4EF9 00002032           1195          JMP     EA_LEA              ; 3: ea_lea
00001DFC  4EF9 000020B0           1196          JMP     EA_DSTONLY          ; 4: ea_dstonly
00001E02  4EF9 00002162           1197          JMP     EA_EXT              ; 5: ea_ext
00001E08  4EF9 00002352           1198          JMP     EA_MOVEM            ; 6: ea_movem
00001E0E  4EF9 000029B6           1199          JMP     EA_SHIFTS           ; 7: ea_shifts
00001E14  4EF9 00002B38           1200          JMP     EA_QUICK            ; 8: ea_quick
00001E1A  4EF9 00002BFA           1201          JMP     EA_branch           ; 9: ea_branch
00001E20  4EF8 1DDE               1202          JMP     EA_FINISH
00001E24                          1203          
00001E24                          1204  EA_SIZE_GENERAL
00001E24  B43C 0000               1205          CMP.B   #%00,D2             ; .b
00001E28  6700 00B6               1206          BEQ     EA_SIZE_B       
00001E2C  B43C 0001               1207          CMP.B   #%01,D2             ; .w
00001E30  6700 00B8               1208          BEQ     EA_SIZE_W       
00001E34  B43C 0002               1209          CMP.B   #%10,D2             ; .l
00001E38  6700 00BC               1210          BEQ     EA_SIZE_L
00001E3C  6000 0F52               1211          BRA     EA_WRONG_SIZE       ; wrong size
00001E40                          1212  
00001E40                          1213  EA_SIZE_MOVE
00001E40  B43C 0001               1214          CMP.B   #%01,D2             ; .b
00001E44  6700 009A               1215          BEQ     EA_SIZE_B       
00001E48  B43C 0003               1216          CMP.B   #%11,D2             ; .w
00001E4C  6700 009C               1217          BEQ     EA_SIZE_W       
00001E50  B43C 0002               1218          CMP.B   #%10,D2             ; .l
00001E54  6700 00A0               1219          BEQ     EA_SIZE_L
00001E58  6000 0F36               1220          BRA     EA_WRONG_SIZE       ; wrong size
00001E5C                          1221  
00001E5C                          1222  EA_SIZE_MOVEA     
00001E5C  B43C 0003               1223          CMP.B   #%11,D2             ; .w
00001E60  6700 0088               1224          BEQ     EA_SIZE_W       
00001E64  B43C 0002               1225          CMP.B   #%10,D2             ; .l
00001E68  6700 008C               1226          BEQ     EA_SIZE_L
00001E6C  6000 0F22               1227          BRA     EA_WRONG_SIZE       ; wrong size
00001E70                          1228          
00001E70                          1229  EA_SIZE_MOVEM     
00001E70  B43C 0000               1230          CMP.B   #%0000,D2              ; .w
00001E74  6700 0074               1231          BEQ     EA_SIZE_W       
00001E78  B43C 0004               1232          CMP.B   #%0100,D2              ; .l
00001E7C  6700 0078               1233          BEQ     EA_SIZE_L
00001E80  6000 0F0E               1234          BRA     EA_WRONG_SIZE       ; wrong size
00001E84                          1235  
00001E84                          1236  EA_SIZE_OPMODE_012456               ; Check opmode field for size
00001E84  B43C 0000               1237          CMP.B   #%000,D2            ; When 0 then .b
00001E88  6700 0056               1238          BEQ     EA_SIZE_B
00001E8C  B43C 0004               1239          CMP.B   #%100,D2            ; When 4 then .b
00001E90  6700 004E               1240          BEQ     EA_SIZE_B  
00001E94  B43C 0001               1241          CMP.B   #%001,D2            ; When 1 then .w
00001E98  6700 0050               1242          BEQ     EA_SIZE_W
00001E9C  B43C 0005               1243          CMP.B   #%101,D2            ; When 5 then .w
00001EA0  6700 0048               1244          BEQ     EA_SIZE_W 
00001EA4  B43C 0002               1245          CMP.B   #%010,D2            ; When 2 then .l
00001EA8  6700 004C               1246          BEQ     EA_SIZE_L
00001EAC  B43C 0006               1247          CMP.B   #%110,D2            ; When 6 then .l
00001EB0  6700 0044               1248          BEQ     EA_SIZE_L
00001EB4  6000 0EDA               1249          BRA     EA_WRONG_SIZE       ; wrong size
00001EB8                          1250  
00001EB8                          1251  EA_SIZE_ADDA                        ; Check opmode field for size
00001EB8  B43C 0003               1252          CMP.B   #%011,D2            ; When 3 then .w
00001EBC  6700 002C               1253          BEQ     EA_SIZE_W       
00001EC0  B43C 0007               1254          CMP.B   #%111,D2            ; When 7 then .l
00001EC4  6700 0030               1255          BEQ     EA_SIZE_L
00001EC8  6000 0EC6               1256          BRA     EA_WRONG_SIZE       ; wrong size
00001ECC                          1257                  
00001ECC                          1258  EA_SIZE_MEMORY_SHIFTS
00001ECC  B43C 0000               1259          CMP.B   #%00,D2             ; .w
00001ED0  6700 0022               1260          BEQ     EA_SIZE_W_MEMORY      
00001ED4  B43C 0001               1261          CMP.B   #%01,D2             ; .l
00001ED8  6700 001C               1262          BEQ     EA_SIZE_L      
00001EDC  6000 0EB2               1263          BRA     EA_WRONG_SIZE       ; wrong size
00001EE0                          1264  
00001EE0                          1265  EA_SIZE_B
00001EE0  14FC 002E               1266          MOVE.B  #'.',(A2)+
00001EE4  14FC 0042               1267          MOVE.B  #'B',(A2)+
00001EE8  4E75                    1268          RTS
00001EEA                          1269  EA_SIZE_W
00001EEA  14FC 002E               1270          MOVE.B  #'.',(A2)+
00001EEE  14FC 0057               1271          MOVE.B  #'W',(A2)+
00001EF2  4E75                    1272          RTS     
00001EF4                          1273  EA_SIZE_W_MEMORY
00001EF4  4E75                    1274          RTS        
00001EF6                          1275  EA_SIZE_L
00001EF6  14FC 002E               1276          MOVE.B  #'.',(A2)+
00001EFA  14FC 004C               1277          MOVE.B  #'L',(A2)+
00001EFE  4E75                    1278          RTS
00001F00                          1279  EA_SIZE_DONE
00001F00  4E75                    1280          RTS
00001F02                          1281  *------------------------------------------------------------------------------------------------*     
00001F02                          1282  EA_IMMEDIATE                        ; 0 ea_immediate
00001F02  2200                    1283          MOVE.L  D0,D1
00001F04  0241 01C0               1284          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00001F08  1A3C 0006               1285          MOVE.B  #right6,D5          ; Store 6 into D5
00001F0C  EA69                    1286          LSR.W   D5,D1               ; Shift D1 six times to LSB position
00001F0E  0201 0003               1287          ANDI.B  #3,D1               ; Remove the front bit from D1
00001F12  1401                    1288          MOVE.B  D1,D2               ; Store D1 into D2 (used to check size)
00001F14  4EB8 1E24               1289          JSR     EA_SIZE_GENERAL     ; Get size 
00001F18                          1290          
00001F18  14FC 0020               1291          MOVE.B  #$20,(A2)+          ; Add space after size
00001F1C  14FC 0020               1292          MOVE.B  #$20,(A2)+          ; Add space 
00001F20  14FC 0020               1293          MOVE.B  #$20,(A2)+          ; Add space
00001F24                          1294  
00001F24                          1295          ; Get source and store into decode buffer
00001F24  7804                    1296          MOVE.L  #4,D4               ; Store 100 into D4 (jump to immed)
00001F26  7607                    1297          MOVE.L  #7,D3               ; Store 111 into D3 (Go abs and immed)
00001F28  4EB9 00002C52           1298          JSR     EA_GEN_SRC          ; Get EA src print 
00001F2E                          1299  
00001F2E  14FC 002C               1300          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001F32  14FC 0020               1301          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F36                          1302  
00001F36                          1303          ; Get desination and store into decode buffer
00001F36  2800                    1304          MOVE.L  D0,D4               ; Store the current address into D4 
00001F38  0244 0007               1305          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00001F3C                          1306          
00001F3C  2600                    1307          MOVE.L  D0,D3               ; Store the current address into D3 
00001F3E  0243 0038               1308          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00001F42  1A3C 0003               1309          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00001F46  EA6B                    1310          LSR.W   D5,D3               ; do the actual shift 
00001F48  B63C 0001               1311          CMP.B   #1,D3               ; If dest mode is 001: An
00001F4C  6700 0E62               1312          BEQ     DST_INVALID         ; Go to invalid message 
00001F50  4EB9 00002C52           1313          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00001F56                          1314  
00001F56  4EF8 1DDE               1315          JMP     EA_FINISH           ; Opcode is finish
00001F5A                          1316  *------------------------------------------------------------------------------------------------*
00001F5A                          1317  EA_MOVE                             ; 1: ea_move
00001F5A  2200                    1318          MOVE.L  D0,D1
00001F5C  0241 F000               1319          ANDI.W  #first_nibble,D1
00001F60  1A3C 000C               1320          MOVE.B  #right12,D5 
00001F64  EA69                    1321          LSR.W   D5,D1
00001F66  0201 0003               1322          ANDI.B  #3,D1
00001F6A  1401                    1323          MOVE.B  D1,D2
00001F6C  4EB8 1E40               1324          JSR     EA_SIZE_MOVE
00001F70                          1325          
00001F70  14FC 0020               1326          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001F74  14FC 0020               1327          MOVE.B  #$20,(A2)+          ; Print out a space
00001F78  14FC 0020               1328          MOVE.B  #$20,(A2)+          ; Print out a space
00001F7C                          1329          
00001F7C                          1330          ; Get source and store into decode buffer
00001F7C  2800                    1331          MOVE.L  D0,D4               ; Store the src reg in D4
00001F7E  0244 0007               1332          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001F82                          1333          
00001F82  2600                    1334          MOVE.L  D0,D3               ; Store the src mode in D3
00001F84  0243 0038               1335          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001F88  1A3C 0003               1336          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001F8C  EA6B                    1337          LSR.W   D5,D3               ; Do the actual shift 
00001F8E  4EB9 00002C52           1338          JSR     EA_GEN_SRC
00001F94                          1339          
00001F94  14FC 002C               1340          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001F98  14FC 0020               1341          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F9C                          1342          
00001F9C                          1343          ; Get desination and store into decode buffer
00001F9C  2800                    1344          MOVE.L  D0,D4               ; Store the dest reg in D4
00001F9E  0244 0E00               1345          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001FA2  1A3C 0009               1346          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001FA6  EA6C                    1347          LSR.W   D5,D4               ; Do the actual shift
00001FA8                          1348          
00001FA8  2600                    1349          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001FAA  0243 01C0               1350          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001FAE  1A3C 0006               1351          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001FB2  EA6B                    1352          LSR.W   D5,D3               ; Do the actual shift 
00001FB4  B63C 0001               1353          CMP.B   #1,D3               ; If dest mode is 001: An
00001FB8  6700 0DF6               1354          BEQ     DST_INVALID         ; Go to invalid message 
00001FBC  4EB9 00002C52           1355          JSR     EA_GEN_SRC          ; Get EA print
00001FC2                          1356          
00001FC2  4EF8 1DDE               1357          JMP     EA_FINISH           ; Opcode is finish
00001FC6                          1358  *------------------------------------------------------------------------------------------------*          
00001FC6                          1359  EA_MOVEA                            ; 2: ea_movea
00001FC6  2200                    1360          MOVE.L  D0,D1
00001FC8  0241 F000               1361          ANDI.W  #first_nibble,D1
00001FCC  1A3C 000C               1362          MOVE.B  #right12,D5 
00001FD0  EA69                    1363          LSR.W   D5,D1
00001FD2  0201 0003               1364          ANDI.B  #3,D1
00001FD6  1401                    1365          MOVE.B  D1,D2
00001FD8  4EB8 1E5C               1366          JSR     EA_SIZE_MOVEA 
00001FDC                          1367          
00001FDC  14FC 0020               1368          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001FE0  14FC 0020               1369          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001FE4                          1370          
00001FE4                          1371          ; Get source and store into decode buffer
00001FE4  2800                    1372          MOVE.L  D0,D4               ; Store the src reg in D4
00001FE6  0244 0007               1373          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001FEA                          1374          
00001FEA  2600                    1375          MOVE.L  D0,D3               ; Store the src mode in D3
00001FEC  0243 0038               1376          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001FF0  1A3C 0003               1377          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001FF4  EA6B                    1378          LSR.W   D5,D3               ; Do the actual shift 
00001FF6  4EB9 00002C52           1379          JSR     EA_GEN_SRC
00001FFC                          1380          
00001FFC  14FC 002C               1381          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002000  14FC 0020               1382          MOVE.B  #$20,(A2)+          ; Add space after comma
00002004                          1383          
00002004                          1384          ; Get desination and store into decode buffer
00002004  2800                    1385          MOVE.L  D0,D4               ; Store the dest reg in D4
00002006  0244 0E00               1386          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000200A  1A3C 0009               1387          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000200E  EA6C                    1388          LSR.W   D5,D4               ; Do the actual shift
00002010                          1389          
00002010  2600                    1390          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00002012  0243 01C0               1391          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00002016  1A3C 0006               1392          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
0000201A  EA6B                    1393          LSR.W   D5,D3               ; Do the actual shift 
0000201C  B63C 0001               1394          CMP.B   #1,D3               ; If dst mode is 001: An 
00002020  6700 0006               1395          BEQ     MOVEA_DST_VALID     ; dst is valid, so branch 
00002024  6000 0D8A               1396          BRA     DST_INVALID         ; Otherwise, go to invalid message 
00002028                          1397          
00002028                          1398  MOVEA_DST_VALID
00002028  4EB9 00002C52           1399          JSR     EA_GEN_SRC          ; Get EA print
0000202E  4EF8 1DDE               1400          JMP     EA_FINISH           ; Opcode is finish
00002032                          1401  *------------------------------------------------------------------------------------------------*
00002032                          1402  EA_LEA                              ; 3: ea_lea
00002032  14FC 0020               1403          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002036  14FC 0020               1404          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000203A  14FC 0020               1405          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000203E  14FC 0020               1406          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002042  14FC 0020               1407          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002046  14FC 0020               1408          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000204A                          1409  
0000204A  2800                    1410          MOVE.L  D0,D4               ; Store the src reg in D4
0000204C  0244 0007               1411          ANDI.W  #src_reg,D4         ; get the bits at 2-0
00002050                          1412          
00002050  2600                    1413          MOVE.L  D0,D3               ; Store the src mode in D3
00002052  0243 0038               1414          ANDI.W  #src_mode,D3        ; get bits 5-3
00002056  1A3C 0003               1415          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB
0000205A  EA6B                    1416          LSR.W   D5,D3               ; do the actual shift 
0000205C  B67C 0002               1417          CMP     #2,D3               ; If D3 (src mode) is 010 (An)
00002060  6700 000E               1418          BEQ     LEA_SRC_VALID
00002064  B67C 0007               1419          CMP     #7,D3               ; If D3 (src mode) is 111 (W or L)
00002068  6700 0006               1420          BEQ     LEA_SRC_VALID
0000206C  6000 0D52               1421          BRA     SRC_INVALID         ; when src mode is not 010 or 111, branch to error message
00002070                          1422          
00002070                          1423  LEA_SRC_VALID        
00002070  4EB9 00002C52           1424          JSR     EA_GEN_SRC          ; Go to function 
00002076                          1425   
00002076  14FC 002C               1426          MOVE.B  #$2C,(A2)+          ; Add comma after size print
0000207A  14FC 0020               1427          MOVE.B  #$20,(A2)+          ; Add space after comma
0000207E                          1428  
0000207E  2600                    1429          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00002080  0243 01C0               1430          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00002084  1A3C 0006               1431          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00002088  EA6B                    1432          LSR.W   D5,D3               ; Do the actual shift
0000208A  B63C 0007               1433          CMP.B   #7,D3               ; Check if D3 is 111
0000208E  6700 0006               1434          BEQ     CHANGE_TO_001       ; change the D3 bits to 001 
00002092  6000 0D1C               1435          BRA     DST_INVALID         ; Print out an error message if bits 8-6 (dst mode) are not 111
00002096                          1436    
00002096                          1437  CHANGE_TO_001
00002096  163C 0001               1438          MOVE.B  #%001,D3            ; set D3 to 001 to ensure the print out A 
0000209A                          1439          
0000209A  2800                    1440          MOVE.L  D0,D4               ; Store the dest reg in D4 to get the Address register number
0000209C  0244 0E00               1441          ANDI.W  #dst_reg,D4         ; get the bits at 11-9
000020A0  1A3C 0009               1442          MOVE.B  #right9,D5          ; shift the bits 11-9 to the LSB
000020A4  EA6C                    1443          LSR.W   D5,D4               ; do the actual shift
000020A6  4EB9 00002C52           1444          JSR     EA_GEN_SRC          ; Print out the address register
000020AC  4EF8 1DDE               1445          JMP     EA_FINISH           ; Opcode is finish
000020B0                          1446  *------------------------------------------------------------------------------------------------*
000020B0                          1447  EA_DSTONLY                          ; 4: ea_dstonly
000020B0  2200                    1448          MOVE.L  D0,D1
000020B2  0241 0F00               1449          ANDI.W  #second_nibble,D1   ; get second nibble from D1
000020B6  1A3C 0008               1450          MOVE.B  #right8,D5 
000020BA  EA69                    1451          LSR.W   D5,D1     
000020BC  B23C 0002               1452          CMP.B   #2, D1              ; When 0010 for second nibble
000020C0  6700 000E               1453          BEQ     EA_CLEAR            ; Then do EA_CLEAR
000020C4  B23C 000E               1454          CMP.B   #$E, D1             ; When 1110 for second nibble
000020C8  6700 0050               1455          BEQ     EA_JSR              ; Then do EA_JSR
000020CC  6000 0CE2               1456          BRA     DST_INVALID     
000020D0                          1457          
000020D0                          1458  EA_CLEAR
000020D0  2200                    1459          MOVE.L  D0,D1
000020D2  0241 01C0               1460          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
000020D6  1A3C 0006               1461          MOVE.B  #right6,D5          ; Store 6 into D5
000020DA  EA69                    1462          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
000020DC  0201 0003               1463          ANDI.B  #3,D1               ; Remove the front bit from D1
000020E0  1401                    1464          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
000020E2  4EB8 1E24               1465          JSR     EA_SIZE_GENERAL     ; Get size 
000020E6                          1466          
000020E6  14FC 0020               1467          MOVE.B  #$20,(A2)+          ; Add space after size
000020EA  14FC 0020               1468          MOVE.B  #$20,(A2)+          ; Add space 
000020EE  14FC 0020               1469          MOVE.B  #$20,(A2)+          ; Add space 
000020F2  14FC 0020               1470          MOVE.B  #$20,(A2)+          ; Add space
000020F6                          1471          
000020F6                          1472          ; Get desination and store into decode buffer
000020F6  2800                    1473          MOVE.L  D0,D4               ; Store the current address into D4 
000020F8  0244 0007               1474          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
000020FC                          1475          
000020FC  2600                    1476          MOVE.L  D0,D3               ; Store the current address into D3 
000020FE  0243 0038               1477          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002102  1A3C 0003               1478          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002106  EA6B                    1479          LSR.W   D5,D3               ; do the actual shift 
00002108  B63C 0001               1480          CMP.B   #1,D3               ; If dest mode is 001: An
0000210C  6700 0CA2               1481          BEQ     DST_INVALID         ; Go to invalid message 
00002110  4EB9 00002C52           1482          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00002116  4EF8 1DDE               1483          JMP     EA_FINISH           ; Opcode is finish
0000211A                          1484          
0000211A  14FC 0020               1485  EA_JSR  MOVE.B  #$20,(A2)+          ; Add space 
0000211E  14FC 0020               1486          MOVE.B  #$20,(A2)+          ; Add space 
00002122  14FC 0020               1487          MOVE.B  #$20,(A2)+          ; Add space 
00002126  14FC 0020               1488          MOVE.B  #$20,(A2)+          ; Add space 
0000212A  14FC 0020               1489          MOVE.B  #$20,(A2)+          ; Add space 
0000212E  14FC 0020               1490          MOVE.B  #$20,(A2)+          ; Add space
00002132                          1491  
00002132                          1492          ; Get EA and store into decode buffer   
00002132  2800                    1493          MOVE.L  D0,D4               ; Store the current address into D4 
00002134  0244 0007               1494          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00002138                          1495          
00002138  2600                    1496          MOVE.L  D0,D3               ; Store the current address into D3 
0000213A  0243 0038               1497          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
0000213E  1A3C 0003               1498          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002142  EA6B                    1499          LSR.W   D5,D3               ; do the actual shift 
00002144  B67C 0002               1500          CMP     #2,D3               ; If D3 (src mode) is 010: (An)
00002148  6700 000E               1501          BEQ     JSR_EA_VALID
0000214C  B67C 0007               1502          CMP     #7,D3               ; If D3 (src mode) is 111: (W or L)
00002150  6700 0006               1503          BEQ     JSR_EA_VALID
00002154  6000 0C7A               1504          BRA     EA_INVALID          ; Otherwise, branch to invalid message
00002158                          1505          
00002158                          1506  JSR_EA_VALID
00002158  4EB9 00002C52           1507          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
0000215E  4EF8 1DDE               1508          JMP     EA_FINISH           ; Opcode is finish
00002162                          1509  *------------------------------------------------------------------------------------------------*
00002162                          1510  EA_EXT                              ; 5: ea_ext
00002162  2200                    1511          MOVE.L  D0,D1
00002164  0241 01C0               1512          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1 (get opmode)
00002168  1A3C 0006               1513          MOVE.B  #right6,D5          ; Store 6 into D5
0000216C  EA69                    1514          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
0000216E  1401                    1515          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002170  C2FC 0006               1516          MULU    #6, D1              ; Multiply 6 to D1 
00002174  41F9 0000217E           1517          LEA     EA_EXT_TABLE,A0     ; Load table into A0
0000217A  4EF0 1000               1518          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
0000217E                          1519  
0000217E                          1520  EA_EXT_TABLE
0000217E  4EF9 000021AE           1521          JMP     EA_OPMODE_012456    ; 000: ADD/SUB/CMP/OR/AND
00002184  4EF9 000021AE           1522          JMP     EA_OPMODE_012456    ; 001: ADD/SUB/CMP/OR/AND
0000218A  4EF9 000021AE           1523          JMP     EA_OPMODE_012456    ; 010: ADD/SUB/CMP/OR/AND
00002190  4EF9 0000229C           1524          JMP     EA_OPMODE_37        ; 011: ADDA/MULS/MULU/DIVU
00002196  4EF9 000021AE           1525          JMP     EA_OPMODE_012456    ; 100: ADD/SUB/CMP/OR/AND
0000219C  4EF9 000021AE           1526          JMP     EA_OPMODE_012456    ; 101: ADD/SUB/CMP/OR/AND
000021A2  4EF9 000021AE           1527          JMP     EA_OPMODE_012456    ; 110: ADD/SUB/CMP/OR/AND
000021A8  4EF9 0000229C           1528          JMP     EA_OPMODE_37        ; 111: ADDA/MULS/MULU/DIVU
000021AE                          1529  
000021AE                          1530  EA_OPMODE_012456
000021AE  4EB8 1E84               1531          JSR     EA_SIZE_OPMODE_012456    
000021B2                          1532          
000021B2  14FC 0020               1533          MOVE.B  #$20,(A2)+          ; Print out a space after the size
000021B6  14FC 0020               1534          MOVE.B  #$20,(A2)+          ; Print out a space 
000021BA  14FC 0020               1535          MOVE.B  #$20,(A2)+          ; Print out a space
000021BE  14FC 0020               1536          MOVE.B  #$20,(A2)+          ; Add space
000021C2                          1537          
000021C2                          1538          ; Operation: <ea> + Dn -> Dn
000021C2  B43C 0000               1539          CMP.B   #%000,D2            ; When 0 then Dn is destination
000021C6  6700 002E               1540          BEQ     Dn_DST
000021CA  B43C 0001               1541          CMP.B   #%001,D2            ; When 1 then Dn is destination
000021CE  6700 0026               1542          BEQ     Dn_DST
000021D2  B43C 0002               1543          CMP.B   #%010,D2            ; When 2 then Dn is destination
000021D6  6700 001E               1544          BEQ     Dn_DST
000021DA                          1545          
000021DA                          1546          ; Operation: Dn + <ea> -> <ea>
000021DA  B43C 0004               1547          CMP.B   #%100,D2            ; When 4 then Dn is source
000021DE  6700 0054               1548          BEQ     Dn_SRC  
000021E2  B43C 0005               1549          CMP.B   #%101,D2            ; When 5 then Dn is source
000021E6  6700 004C               1550          BEQ     Dn_SRC 
000021EA  B43C 0006               1551          CMP.B   #%110,D2            ; When 6 then Dn is source
000021EE  6700 0044               1552          BEQ     Dn_SRC 
000021F2                          1553          
000021F2  6000 0BDC               1554          BRA     EA_INVALID
000021F6                          1555  
000021F6                          1556  Dn_DST
000021F6                          1557          ; Get source and store into decode buffer
000021F6  2800                    1558          MOVE.L  D0,D4               ; Store the src reg in D4
000021F8  0244 0007               1559          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000021FC                          1560          
000021FC  2600                    1561          MOVE.L  D0,D3               ; Store the src mode in D3
000021FE  0243 0038               1562          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002202  1A3C 0003               1563          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002206  EA6B                    1564          LSR.W   D5,D3               ; Do the actual shift 
00002208  4EB9 0000227A           1565          JSR     AND_OR_CHECK 
0000220E  4EB9 00002C52           1566          JSR     EA_GEN_SRC          ; Get EA print
00002214                          1567          
00002214  14FC 002C               1568          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002218  14FC 0020               1569          MOVE.B  #$20,(A2)+          ; Add space after comma
0000221C                          1570          
0000221C                          1571          ; Get desination and store into decode buffer
0000221C  2800                    1572          MOVE.L  D0,D4               ; Store the dest reg in D4
0000221E  0244 0E00               1573          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002222  1A3C 0009               1574          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002226  EA6C                    1575          LSR.W   D5,D4               ; Do the actual shift
00002228                          1576          
00002228  7600                    1577          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000222A  4EB9 00002C52           1578          JSR     EA_GEN_SRC          ; Get the Dn print
00002230  4EF8 1DDE               1579          JMP     EA_FINISH           ; Opcode is finish
00002234                          1580            
00002234                          1581  Dn_SRC  
00002234  BC3C 000B               1582          CMP.B   #11,D6              ; If first nibble is 1011 (indicates CMP opcode)
00002238  6700 0B96               1583          BEQ     EA_INVALID          ; Then branch to error message
0000223C                          1584       
0000223C                          1585          ; Get source and store into decode buffer
0000223C  2800                    1586          MOVE.L  D0,D4               ; Store the src reg in D4
0000223E  0244 0E00               1587          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002242  1A3C 0009               1588          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002246  EA6C                    1589          LSR.W   D5,D4               ; Do the actual shift
00002248                          1590          
00002248  7600                    1591          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000224A  4EB9 00002C52           1592          JSR     EA_GEN_SRC          ; Get the Dn print
00002250                          1593          
00002250  14FC 002C               1594          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002254  14FC 0020               1595          MOVE.B  #$20,(A2)+          ; Add space after comma
00002258                          1596  
00002258                          1597          ; Get destination and store into decode buffer
00002258  2800                    1598          MOVE.L  D0,D4               ; Store the dst reg in D4
0000225A  0244 0007               1599          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000225E                          1600          
0000225E  2600                    1601          MOVE.L  D0,D3               ; Store the dest mode in D3
00002260  0243 0038               1602          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002264  1A3C 0003               1603          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002268  EA6B                    1604          LSR.W   D5,D3               ; Do the actual shift
0000226A  4EB9 00002D68           1605          JSR     An_CHECK            ; Check if mode is An
00002270                          1606         
00002270  4EB9 00002C52           1607          JSR     EA_GEN_SRC          ; Get EA print
00002276  4EF8 1DDE               1608          JMP     EA_FINISH           ; Opcode is finish
0000227A                          1609  
0000227A                          1610  AND_OR_CHECK
0000227A  BC3C 000C               1611          CMP.B   #12,D6              ; If first nibble is 1100 (indicates AND opcode)
0000227E  6700 000C               1612          BEQ     EA_AND              
00002282  BC3C 0008               1613          CMP.B   #8,D6               ; If first nibble is 1000 (indicates OR opcode)
00002286  6700 000A               1614          BEQ     EA_OR 
0000228A  4E75                    1615          RTS
0000228C                          1616  EA_AND
0000228C  4EF9 00002D68           1617          JMP     An_CHECK            ; Go check if mode is An 
00002292                          1618      
00002292                          1619  EA_OR
00002292  14FC 0020               1620          MOVE.B  #$20,(A2)+          ; Add space
00002296  4EF9 00002D68           1621          JMP     An_CHECK            ; Check if mode is An
0000229C                          1622          
0000229C                          1623  EA_OPMODE_37
0000229C  BC3C 0008               1624          CMP.B   #8,D6               ; If first nibble 1000: DIVU
000022A0  6700 0012               1625          BEQ     EA_MULS_MULU_DIV
000022A4  BC3C 000C               1626          CMP.B   #12,D6              ; If first nibble 1100: MULS/MULU
000022A8  6700 000A               1627          BEQ     EA_MULS_MULU_DIV
000022AC  BC3C 000D               1628          CMP.B   #13,D6              ; If first nibble 1101: ADDA
000022B0  6700 0058               1629          BEQ     EA_ADDA                
000022B4                          1630  
000022B4                          1631  EA_MULS_MULU_DIV
000022B4  143C 0001               1632          MOVE.B  #1,D2               ; Set D2 to 1, since we know size is word   
000022B8                          1633  
000022B8  14FC 0020               1634          MOVE.B  #$20,(A2)+          ; Print out a space
000022BC  14FC 0020               1635          MOVE.B  #$20,(A2)+          ; Print out a space
000022C0  14FC 0020               1636          MOVE.B  #$20,(A2)+          ; Print out a space
000022C4  14FC 0020               1637          MOVE.B  #$20,(A2)+          ; Add space
000022C8  14FC 0020               1638          MOVE.B  #$20,(A2)+          ; Add space
000022CC                          1639  
000022CC                          1640          ; Get source and store into decode buffer
000022CC  2800                    1641          MOVE.L  D0,D4               ; Store the src reg in D4
000022CE  0244 0007               1642          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000022D2                          1643          
000022D2  2600                    1644          MOVE.L  D0,D3               ; Store the src mode in D3
000022D4  0243 0038               1645          ANDI.W  #src_mode,D3        ; Get bits 5-3
000022D8  1A3C 0003               1646          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000022DC  EA6B                    1647          LSR.W   D5,D3               ; Do the actual shift
000022DE  4EB9 00002D68           1648          JSR     An_CHECK            ; Check if mode is An 
000022E4  4EB9 00002C52           1649          JSR     EA_GEN_SRC          ; Go get EA print
000022EA                          1650          
000022EA  14FC 002C               1651          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000022EE  14FC 0020               1652          MOVE.B  #$20,(A2)+          ; Add space after comma
000022F2                          1653          
000022F2                          1654          ; Get desination and store into decode buffer
000022F2  2800                    1655          MOVE.L  D0,D4               ; Store the dest reg in D4
000022F4  0244 0E00               1656          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
000022F8  1A3C 0009               1657          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
000022FC  EA6C                    1658          LSR.W   D5,D4               ; Do the actual shift
000022FE                          1659          
000022FE  7600                    1660          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
00002300  4EB9 00002C52           1661          JSR     EA_GEN_SRC          ; Go get EA print
00002306  4EF8 1DDE               1662          JMP     EA_FINISH           ; Opcode is finish
0000230A                          1663  
0000230A                          1664  EA_ADDA
0000230A  4EB8 1EB8               1665          JSR     EA_SIZE_ADDA        ; Get size    
0000230E                          1666  
0000230E  14FC 0020               1667          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002312  14FC 0020               1668          MOVE.B  #$20,(A2)+          ; Print out a space
00002316  14FC 0020               1669          MOVE.B  #$20,(A2)+          ; Add space        
0000231A                          1670          
0000231A                          1671          
0000231A                          1672          ; Get source and store into decode buffer
0000231A  2800                    1673          MOVE.L  D0,D4               ; Store the src reg in D4
0000231C  0244 0007               1674          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002320                          1675          
00002320  2600                    1676          MOVE.L  D0,D3               ; Store the src mode in D3
00002322  0243 0038               1677          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002326  1A3C 0003               1678          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000232A  EA6B                    1679          LSR.W   D5,D3               ; Do the actual shift 
0000232C  4EB9 00002C52           1680          JSR     EA_GEN_SRC
00002332                          1681          
00002332  14FC 002C               1682          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002336  14FC 0020               1683          MOVE.B  #$20,(A2)+          ; Add space after comma
0000233A                          1684          
0000233A                          1685          ; Get desination and store into decode buffer
0000233A  2800                    1686          MOVE.L  D0,D4               ; Store the dest reg in D4
0000233C  0244 0E00               1687          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002340  1A3C 0009               1688          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002344  EA6C                    1689          LSR.W   D5,D4               ; Do the actual shift
00002346                          1690          
00002346  7601                    1691          MOVE.L  #1,D3               ; Store 001 into D3, so it can jump to An 
00002348  4EB9 00002C52           1692          JSR     EA_GEN_SRC          ; Go get EA print
0000234E  4EF8 1DDE               1693          JMP     EA_FINISH           ; Opcode is finish
00002352                          1694  *------------------------------------------------------------------------------------------------*
00002352                          1695  EA_MOVEM        ; 6: ea_movem
00002352  2200                    1696          MOVE.L  D0, D1
00002354  0241 00F0               1697          ANDI.W  #third_nibble,D1
00002358  1A3C 0004               1698          MOVE.B  #right4,D5 
0000235C  EA69                    1699          LSR.W   D5,D1
0000235E  0201 0004               1700          ANDI.B  #4,D1
00002362  1401                    1701          MOVE.B  D1,D2
00002364  4EB8 1E70               1702          JSR     EA_SIZE_MOVEM       ; get the size of the MOVEM as .W or .L 
00002368                          1703  
00002368  14FC 0020               1704          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000236C  14FC 0020               1705          MOVE.B  #$20,(A2)+          ; Print out a space
00002370                          1706          
00002370                          1707  *-----------------------------------------------------------------------------------*
00002370                          1708  * HANDLE the case where src mode is 010. 
00002370  2600                    1709          MOVE.L  D0,D3               ; Store the src mode in D3
00002372  0243 0038               1710          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002376  1A3C 0003               1711          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000237A  EA6B                    1712          LSR.W   D5,D3 
0000237C                          1713  
0000237C  B63C 0002               1714          CMP.B   #2, D3
00002380  6700 0312               1715          BEQ     MEM_TO_REG        
00002384                          1716  
00002384                          1717  *-----------------------------------------------------------------------------------*
00002384                          1718  
00002384  2200                    1719          MOVE.L  D0, D1
00002386  0241 0F00               1720          ANDI.W  #second_nibble,D1
0000238A  1A3C 0008               1721          MOVE.B  #right8,D5 
0000238E  EA69                    1722          LSR.W   D5,D1
00002390  0201 0006               1723          ANDI.B  #6, D1              ; Get the Dr field
00002394                          1724          
00002394  B23C 0000               1725          CMP.B   #0, D1              ; check if Dr field is 0. 
00002398  6700 000A               1726          BEQ     REG_TO_MEM
0000239C                          1727  
0000239C  B23C 0004               1728          CMP.B   #4, D1              ; check if Dr field is 1. 
000023A0  6700 02F2               1729          BEQ     MEM_TO_REG
000023A4                          1730  
000023A4                          1731  REG_TO_MEM                          ; pre-decrement - D7-D0,A7-A0
000023A4  3C15                    1732          MOVE.W  (A5), D6            ; store the register list mask field for REG to MEM
000023A6                          1733          
000023A6                          1734  * Print out the proper data and address registers. 
000023A6                          1735  * FIRST NIBBLE CHECK D0 - D3
000023A6                          1736  *-----------------------------------------------------------------------------------*
000023A6                          1737  * Print out D0 if mask field states to. 
000023A6                          1738  
000023A6  3606                    1739          MOVE.W  D6, D3
000023A8  0243 F000               1740          ANDI.W  #first_nibble,D3
000023AC  1A3C 000C               1741          MOVE.B  #right12,D5 
000023B0  EA6B                    1742          LSR.W   D5,D3
000023B2  0203 0008               1743          ANDI.B  #8,D3
000023B6  B63C 0008               1744          CMP.B   #8,D3
000023BA  6700 0006               1745          BEQ     D4_Dn_SETONE_0      ; SETONE refers to the set for reg to mem branch. 
000023BE  6000 0014               1746          BRA     CHECK1_BIT_14
000023C2                          1747  D4_Dn_SETONE_0
000023C2  183C 0000               1748          MOVE.B  #$0, D4
000023C6                          1749          
000023C6  6000 0002               1750          BRA     PRINT1_D0
000023CA                          1751          
000023CA                          1752  PRINT1_D0
000023CA  4EB9 00002C90           1753          JSR     EA_Dn
000023D0  14FC 002F               1754          MOVE.B  #$2F,(A2)+
000023D4                          1755          
000023D4                          1756  *-----------------------------------------------------------------------------------*
000023D4                          1757  * Print out D1 if mask field states to. 
000023D4                          1758  
000023D4                          1759  CHECK1_BIT_14
000023D4  3606                    1760          MOVE.W  D6, D3
000023D6  0243 F000               1761          ANDI.W  #first_nibble,D3
000023DA  1A3C 000C               1762          MOVE.B  #right12,D5 
000023DE  EA6B                    1763          LSR.W   D5,D3
000023E0  0203 0004               1764          ANDI.B  #4,D3
000023E4  B63C 0004               1765          CMP.B   #4,D3
000023E8  6700 0006               1766          BEQ     D4_Dn_SETONE_1      ; SETONE refers to the set for reg to mem branch. 
000023EC  6000 0014               1767          BRA     CHECK1_BIT_13
000023F0                          1768  D4_Dn_SETONE_1
000023F0  183C 0001               1769          MOVE.B  #$1, D4
000023F4                          1770          
000023F4  6000 0002               1771          BRA     PRINT1_D1
000023F8                          1772          
000023F8                          1773  PRINT1_D1
000023F8  4EB9 00002C90           1774          JSR     EA_Dn
000023FE  14FC 002F               1775          MOVE.B  #$2F,(A2)+
00002402                          1776  
00002402                          1777  *-----------------------------------------------------------------------------------*
00002402                          1778  * Print out D2 if mask field states to. 
00002402                          1779  
00002402                          1780  CHECK1_BIT_13
00002402  3606                    1781          MOVE.W  D6, D3
00002404  0243 F000               1782          ANDI.W  #first_nibble,D3
00002408  1A3C 000C               1783          MOVE.B  #right12,D5 
0000240C  EA6B                    1784          LSR.W   D5,D3
0000240E  0203 0002               1785          ANDI.B  #2,D3
00002412  B63C 0002               1786          CMP.B   #2,D3
00002416  6700 0006               1787          BEQ     D4_Dn_SETONE_2      ; SETONE refers to the set for reg to mem branch. 
0000241A  6000 0014               1788          BRA     CHECK1_BIT_12
0000241E                          1789  D4_Dn_SETONE_2
0000241E  183C 0002               1790          MOVE.B  #$2, D4
00002422                          1791          
00002422  6000 0002               1792          BRA     PRINT1_D2
00002426                          1793          
00002426                          1794  PRINT1_D2
00002426  4EB9 00002C90           1795          JSR     EA_Dn
0000242C  14FC 002F               1796          MOVE.B  #$2F,(A2)+       
00002430                          1797  
00002430                          1798  *-----------------------------------------------------------------------------------*
00002430                          1799  * Print out D3 if mask field states to. 
00002430                          1800  
00002430                          1801  CHECK1_BIT_12
00002430  3606                    1802          MOVE.W  D6, D3
00002432  0243 F000               1803          ANDI.W  #first_nibble,D3
00002436  1A3C 000C               1804          MOVE.B  #right12,D5 
0000243A  EA6B                    1805          LSR.W   D5,D3
0000243C  0203 0001               1806          ANDI.B  #1,D3
00002440  B63C 0001               1807          CMP.B   #1,D3
00002444  6700 0006               1808          BEQ     D4_Dn_SETONE_3      ; SETONE refers to the set for reg to mem branch. 
00002448  6000 0014               1809          BRA     CHECK1_BIT_11
0000244C                          1810  D4_Dn_SETONE_3
0000244C  183C 0003               1811          MOVE.B  #$3, D4
00002450                          1812          
00002450  6000 0002               1813          BRA     PRINT1_D3
00002454                          1814          
00002454                          1815  PRINT1_D3
00002454  4EB9 00002C90           1816          JSR     EA_Dn
0000245A  14FC 002F               1817          MOVE.B  #$2F,(A2)+ 
0000245E                          1818          
0000245E                          1819  * SECOND NIBBLE CHECK D4 - D7
0000245E                          1820  *-----------------------------------------------------------------------------------*
0000245E                          1821  * Print out D4 if mask field states to. 
0000245E                          1822  
0000245E                          1823  
0000245E                          1824  CHECK1_BIT_11
0000245E  3606                    1825          MOVE.W  D6, D3
00002460  0243 0F00               1826          ANDI.W  #second_nibble,D3
00002464  1A3C 0008               1827          MOVE.B  #right8,D5 
00002468  EA6B                    1828          LSR.W   D5,D3
0000246A  0203 0008               1829          ANDI.B  #8,D3
0000246E  B63C 0008               1830          CMP.B   #8,D3
00002472  6700 0006               1831          BEQ     D4_Dn_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
00002476  6000 0014               1832          BRA     CHECK1_BIT_10
0000247A                          1833  D4_Dn_SETONE_4
0000247A  183C 0004               1834          MOVE.B  #$4, D4
0000247E                          1835          
0000247E  6000 0002               1836          BRA     PRINT1_D4
00002482                          1837          
00002482                          1838  PRINT1_D4
00002482  4EB9 00002C90           1839          JSR     EA_Dn
00002488  14FC 002F               1840          MOVE.B  #$2F,(A2)+ 
0000248C                          1841  
0000248C                          1842  *-----------------------------------------------------------------------------------*
0000248C                          1843  * Print out D5 if mask field states to. 
0000248C                          1844  
0000248C                          1845  CHECK1_BIT_10
0000248C  3606                    1846          MOVE.W  D6, D3
0000248E  0243 0F00               1847          ANDI.W  #second_nibble,D3
00002492  1A3C 0008               1848          MOVE.B  #right8,D5 
00002496  EA6B                    1849          LSR.W   D5,D3
00002498  0203 0004               1850          ANDI.B  #4,D3
0000249C  B63C 0004               1851          CMP.B   #4,D3
000024A0  6700 0006               1852          BEQ     D4_Dn_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
000024A4  6000 0014               1853          BRA     CHECK1_BIT_9
000024A8                          1854  D4_Dn_SETONE_5
000024A8  183C 0005               1855          MOVE.B  #$5, D4
000024AC                          1856          
000024AC  6000 0002               1857          BRA     PRINT1_D5
000024B0                          1858          
000024B0                          1859  PRINT1_D5
000024B0  4EB9 00002C90           1860          JSR     EA_Dn
000024B6  14FC 002F               1861          MOVE.B  #$2F,(A2)+ 
000024BA                          1862  
000024BA                          1863  *-----------------------------------------------------------------------------------*
000024BA                          1864  * Print out D6 if mask field states to. 
000024BA                          1865  
000024BA                          1866  CHECK1_BIT_9
000024BA  3606                    1867          MOVE.W  D6, D3
000024BC  0243 0F00               1868          ANDI.W  #second_nibble,D3
000024C0  1A3C 0008               1869          MOVE.B  #right8,D5 
000024C4  EA6B                    1870          LSR.W   D5,D3
000024C6  0203 0002               1871          ANDI.B  #2,D3
000024CA  B63C 0002               1872          CMP.B   #2,D3
000024CE  6700 0006               1873          BEQ     D4_Dn_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
000024D2  6000 0014               1874          BRA     CHECK1_BIT_8
000024D6                          1875  D4_Dn_SETONE_6
000024D6  183C 0006               1876          MOVE.B  #$6, D4
000024DA                          1877          
000024DA  6000 0002               1878          BRA     PRINT1_D6
000024DE                          1879          
000024DE                          1880  PRINT1_D6
000024DE  4EB9 00002C90           1881          JSR     EA_Dn
000024E4  14FC 002F               1882          MOVE.B  #$2F,(A2)+ 
000024E8                          1883          
000024E8                          1884  *-----------------------------------------------------------------------------------*
000024E8                          1885  * Print out D7 if mask field states to. 
000024E8                          1886  
000024E8                          1887  CHECK1_BIT_8
000024E8  3606                    1888          MOVE.W  D6, D3
000024EA  0243 0F00               1889          ANDI.W  #second_nibble,D3
000024EE  1A3C 0008               1890          MOVE.B  #right8,D5 
000024F2  EA6B                    1891          LSR.W   D5,D3
000024F4  0203 0001               1892          ANDI.B  #1,D3
000024F8  B63C 0001               1893          CMP.B   #1,D3
000024FC  6700 0006               1894          BEQ     D4_Dn_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
00002500  6000 0014               1895          BRA     CHECK1_BIT_7
00002504                          1896  D4_Dn_SETONE_7
00002504  183C 0007               1897          MOVE.B  #$7, D4
00002508                          1898          
00002508  6000 0002               1899          BRA     PRINT1_D7
0000250C                          1900          
0000250C                          1901  PRINT1_D7
0000250C  4EB9 00002C90           1902          JSR     EA_Dn
00002512  14FC 002F               1903          MOVE.B  #$2F,(A2)+ 
00002516                          1904  
00002516                          1905  * THIRD NIBBLE CHECK - A0 / A3
00002516                          1906  *-----------------------------------------------------------------------------------*
00002516                          1907  * Print out A0 if mask field states to. 
00002516                          1908  
00002516                          1909  CHECK1_BIT_7
00002516  3606                    1910          MOVE.W  D6, D3
00002518  0243 00F0               1911          ANDI.W  #third_nibble,D3
0000251C  1A3C 0004               1912          MOVE.B  #right4,D5 
00002520  EA6B                    1913          LSR.W   D5,D3
00002522  0203 0008               1914          ANDI.B  #8,D3
00002526  B63C 0008               1915          CMP.B   #8,D3
0000252A  6700 0006               1916          BEQ     D4_An_SETONE_0       ; SETONE refers to the set for reg to mem branch. 
0000252E  6000 0014               1917          BRA     CHECK1_BIT_6
00002532                          1918  D4_An_SETONE_0
00002532  183C 0000               1919          MOVE.B  #$0, D4
00002536                          1920          
00002536  6000 0002               1921          BRA     PRINT1_A0
0000253A                          1922          
0000253A                          1923  PRINT1_A0
0000253A  4EB9 00002C9C           1924          JSR     EA_An
00002540  14FC 002F               1925          MOVE.B  #$2F,(A2)+ 
00002544                          1926          
00002544                          1927  *-----------------------------------------------------------------------------------*
00002544                          1928  * Print out A1 if mask field states to. 
00002544                          1929  
00002544                          1930  CHECK1_BIT_6
00002544  3606                    1931          MOVE.W  D6, D3
00002546  0243 00F0               1932          ANDI.W  #third_nibble,D3
0000254A  1A3C 0004               1933          MOVE.B  #right4,D5 
0000254E  EA6B                    1934          LSR.W   D5,D3
00002550  0203 0004               1935          ANDI.B  #4,D3
00002554  B63C 0004               1936          CMP.B   #4,D3
00002558  6700 0006               1937          BEQ     D4_An_SETONE_1       ; SETONE refers to the set for reg to mem branch. 
0000255C  6000 0014               1938          BRA     CHECK1_BIT_5
00002560                          1939  D4_An_SETONE_1
00002560  183C 0001               1940          MOVE.B  #$1, D4
00002564                          1941          
00002564  6000 0002               1942          BRA     PRINT1_A1
00002568                          1943          
00002568                          1944  PRINT1_A1
00002568  4EB9 00002C9C           1945          JSR     EA_An
0000256E  14FC 002F               1946          MOVE.B  #$2F,(A2)+ 
00002572                          1947  
00002572                          1948  *-----------------------------------------------------------------------------------*
00002572                          1949  * Print out A2 if mask field states to. 
00002572                          1950  
00002572                          1951  CHECK1_BIT_5
00002572  3606                    1952          MOVE.W  D6, D3
00002574  0243 00F0               1953          ANDI.W  #third_nibble,D3
00002578  1A3C 0004               1954          MOVE.B  #right4,D5 
0000257C  EA6B                    1955          LSR.W   D5,D3
0000257E  0203 0002               1956          ANDI.B  #2,D3
00002582  B63C 0002               1957          CMP.B   #2,D3
00002586  6700 0006               1958          BEQ     D4_An_SETONE_2       ; SETONE refers to the set for reg to mem branch. 
0000258A  6000 0014               1959          BRA     CHECK1_BIT_4
0000258E                          1960  D4_An_SETONE_2
0000258E  183C 0002               1961          MOVE.B  #$2, D4
00002592                          1962          
00002592  6000 0002               1963          BRA     PRINT1_A2
00002596                          1964          
00002596                          1965  PRINT1_A2
00002596  4EB9 00002C9C           1966          JSR     EA_An
0000259C  14FC 002F               1967          MOVE.B  #$2F,(A2)+ 
000025A0                          1968  
000025A0                          1969  *-----------------------------------------------------------------------------------*
000025A0                          1970  * Print out A3 if mask field states to. 
000025A0                          1971  
000025A0                          1972  CHECK1_BIT_4
000025A0  3606                    1973          MOVE.W  D6, D3
000025A2  0243 00F0               1974          ANDI.W  #third_nibble,D3
000025A6  1A3C 0004               1975          MOVE.B  #right4,D5 
000025AA  EA6B                    1976          LSR.W   D5,D3
000025AC  0203 0001               1977          ANDI.B  #1,D3
000025B0  B63C 0001               1978          CMP.B   #1,D3
000025B4  6700 0006               1979          BEQ     D4_An_SETONE_3       ; SETONE refers to the set for reg to mem branch. 
000025B8  6000 0014               1980          BRA     CHECK1_BIT_3
000025BC                          1981  D4_An_SETONE_3
000025BC  183C 0003               1982          MOVE.B  #$3, D4
000025C0                          1983          
000025C0  6000 0002               1984          BRA     PRINT1_A3
000025C4                          1985          
000025C4                          1986  PRINT1_A3
000025C4  4EB9 00002C9C           1987          JSR     EA_An
000025CA  14FC 002F               1988          MOVE.B  #$2F,(A2)+ 
000025CE                          1989  
000025CE                          1990  * FOURTH NIBBLE CHECK A4 - A7 
000025CE                          1991  *-----------------------------------------------------------------------------------*
000025CE                          1992  * Print out A4 if mask field states to. 
000025CE                          1993  
000025CE                          1994  CHECK1_BIT_3
000025CE  3606                    1995          MOVE.W  D6, D3
000025D0  0243 000F               1996          ANDI.W  #fourth_nibble,D3
000025D4  0203 0008               1997          ANDI.B  #8,D3
000025D8  B63C 0008               1998          CMP.B   #8,D3
000025DC  6700 0006               1999          BEQ     D4_An_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
000025E0  6000 0014               2000          BRA     CHECK1_BIT_2
000025E4                          2001  D4_An_SETONE_4
000025E4  183C 0004               2002          MOVE.B  #$4, D4
000025E8                          2003          
000025E8  6000 0002               2004          BRA     PRINT1_A4
000025EC                          2005          
000025EC                          2006  PRINT1_A4
000025EC  4EB9 00002C9C           2007          JSR     EA_An
000025F2  14FC 002F               2008          MOVE.B  #$2F,(A2)+ 
000025F6                          2009  
000025F6                          2010  *-----------------------------------------------------------------------------------*
000025F6                          2011  * Print out A5 if mask field states to. 
000025F6                          2012  
000025F6                          2013  CHECK1_BIT_2
000025F6  3606                    2014          MOVE.W  D6, D3
000025F8  0243 000F               2015          ANDI.W  #fourth_nibble,D3
000025FC  0203 0004               2016          ANDI.B  #4,D3
00002600  B63C 0004               2017          CMP.B   #4,D3
00002604  6700 0006               2018          BEQ     D4_An_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
00002608  6000 0014               2019          BRA     CHECK1_BIT_1
0000260C                          2020  D4_An_SETONE_5
0000260C  183C 0005               2021          MOVE.B  #$5, D4
00002610                          2022          
00002610  6000 0002               2023          BRA     PRINT1_A5
00002614                          2024          
00002614                          2025  PRINT1_A5
00002614  4EB9 00002C9C           2026          JSR     EA_An
0000261A  14FC 002F               2027          MOVE.B  #$2F,(A2)+ 
0000261E                          2028  
0000261E                          2029  *-----------------------------------------------------------------------------------*
0000261E                          2030  * Print out A6 if mask field states to. 
0000261E                          2031  
0000261E                          2032  CHECK1_BIT_1
0000261E  3606                    2033          MOVE.W  D6, D3
00002620  0243 000F               2034          ANDI.W  #fourth_nibble,D3
00002624  0203 0002               2035          ANDI.B  #2,D3
00002628  B63C 0002               2036          CMP.B   #2,D3
0000262C  6700 0006               2037          BEQ     D4_An_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
00002630  6000 0014               2038          BRA     CHECK1_BIT_0
00002634                          2039  D4_An_SETONE_6
00002634  183C 0006               2040          MOVE.B  #$6, D4
00002638                          2041          
00002638  6000 0002               2042          BRA     PRINT1_A6
0000263C                          2043          
0000263C                          2044  PRINT1_A6
0000263C  4EB9 00002C9C           2045          JSR     EA_An
00002642  14FC 002F               2046          MOVE.B  #$2F,(A2)+ 
00002646                          2047  
00002646                          2048  *-----------------------------------------------------------------------------------*
00002646                          2049  * Print out A7 if mask field states to. 
00002646                          2050  
00002646                          2051  CHECK1_BIT_0
00002646  3606                    2052          MOVE.W  D6, D3
00002648  0243 000F               2053          ANDI.W  #fourth_nibble,D3
0000264C  0203 0001               2054          ANDI.B  #1,D3
00002650  B63C 0001               2055          CMP.B   #1,D3
00002654  6700 0006               2056          BEQ     D4_An_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
00002658  6000 0014               2057          BRA     FINISH_REG_TO_MEM
0000265C                          2058  D4_An_SETONE_7
0000265C  183C 0007               2059          MOVE.B  #$7, D4
00002660                          2060          
00002660  6000 0002               2061          BRA     PRINT1_A7
00002664                          2062          
00002664                          2063  PRINT1_A7
00002664  4EB9 00002C9C           2064          JSR     EA_An
0000266A  14FC 002F               2065          MOVE.B  #$2F,(A2)+ 
0000266E                          2066  
0000266E                          2067  FINISH_REG_TO_MEM
0000266E  14FC 002C               2068          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002672  14FC 0020               2069          MOVE.B  #$20,(A2)+          ; Add space after comma
00002676                          2070  
00002676  2800                    2071          MOVE.L  D0,D4               ; Store the src reg in D4
00002678  0244 0007               2072          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000267C                          2073          
0000267C  2600                    2074          MOVE.L  D0,D3               ; Store the src mode in D3
0000267E  0243 0038               2075          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002682  1A3C 0003               2076          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002686  EA6B                    2077          LSR.W   D5,D3               ; Do the actual shift 
00002688  4EB9 00002C52           2078          JSR     EA_GEN_SRC
0000268E                          2079          
0000268E  301D                    2080          MOVE.W  (A5)+, D0 
00002690                          2081  
00002690  4EF8 1DDE               2082          JMP     EA_FINISH
00002694                          2083  
00002694                          2084  MEM_TO_REG                          ; post-increment + A7-A0,D7-D0
00002694                          2085  
00002694  B63C 0002               2086          CMP.B   #2, D3              ; check if the destination is (An)
00002698  6700 0022               2087          BEQ     MEM_TO_REG_CONTINUE ; branch to print out the address and data registers. 
0000269C                          2088          
0000269C  2800                    2089          MOVE.L  D0,D4               ; Store the src reg in D4
0000269E  0244 0007               2090          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000026A2                          2091          
000026A2  2600                    2092          MOVE.L  D0,D3               ; Store the src mode in D3
000026A4  0243 0038               2093          ANDI.W  #src_mode,D3        ; Get bits 5-3
000026A8  1A3C 0003               2094          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000026AC  EA6B                    2095          LSR.W   D5,D3               ; Do the actual shift 
000026AE  4EB9 00002C52           2096          JSR     EA_GEN_SRC
000026B4                          2097          
000026B4  14FC 002C               2098          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000026B8  14FC 0020               2099          MOVE.B  #$20,(A2)+          ; Add space after comma
000026BC                          2100  
000026BC                          2101          
000026BC                          2102  * Print out the proper data and address registers. 
000026BC                          2103  * FIRST NIBBLE CHECK A7 - A4
000026BC                          2104  *-----------------------------------------------------------------------------------*
000026BC                          2105  * Print out A7 if mask field states to. 
000026BC                          2106  MEM_TO_REG_CONTINUE
000026BC  3C15                    2107          MOVE.W  (A5), D6            ; store the register list mask field for MEM to REG
000026BE                          2108          
000026BE  3606                    2109          MOVE.W  D6, D3
000026C0  0243 F000               2110          ANDI.W  #first_nibble,D3
000026C4  1A3C 000C               2111          MOVE.B  #right12,D5 
000026C8  EA6B                    2112          LSR.W   D5,D3
000026CA  0203 0008               2113          ANDI.B  #8,D3
000026CE  B63C 0008               2114          CMP.B   #8,D3
000026D2  6700 0006               2115          BEQ     D4_An_SET_7
000026D6  6000 0014               2116          BRA     CHECK_BIT_14
000026DA                          2117  D4_An_SET_7
000026DA  183C 0007               2118          MOVE.B  #$7, D4
000026DE                          2119          
000026DE  6000 0002               2120          BRA     PRINT_A7
000026E2                          2121          
000026E2                          2122  PRINT_A7
000026E2  4EB9 00002C9C           2123          JSR     EA_An
000026E8  14FC 002F               2124          MOVE.B  #$2F,(A2)+
000026EC                          2125          
000026EC                          2126  *-----------------------------------------------------------------------------------*
000026EC                          2127  * Print out A6 if mask field states to. 
000026EC                          2128  
000026EC                          2129  CHECK_BIT_14
000026EC  3606                    2130          MOVE.W  D6, D3
000026EE  0243 F000               2131          ANDI.W  #first_nibble,D3
000026F2  1A3C 000C               2132          MOVE.B  #right12,D5 
000026F6  EA6B                    2133          LSR.W   D5,D3
000026F8  0203 0004               2134          ANDI.B  #4,D3
000026FC  B63C 0004               2135          CMP.B   #4,D3
00002700  6700 0006               2136          BEQ     D4_An_SET_6
00002704  6000 0014               2137          BRA     CHECK_BIT_13
00002708                          2138  D4_An_SET_6
00002708  183C 0006               2139          MOVE.B  #$6, D4
0000270C                          2140          
0000270C  6000 0002               2141          BRA     PRINT_A6
00002710                          2142          
00002710                          2143  PRINT_A6
00002710  4EB9 00002C9C           2144          JSR     EA_An
00002716  14FC 002F               2145          MOVE.B  #$2F,(A2)+
0000271A                          2146  
0000271A                          2147  *-----------------------------------------------------------------------------------*
0000271A                          2148  * Print out A5 if mask field states to. 
0000271A                          2149  
0000271A                          2150  CHECK_BIT_13
0000271A  3606                    2151          MOVE.W  D6, D3
0000271C  0243 F000               2152          ANDI.W  #first_nibble,D3
00002720  1A3C 000C               2153          MOVE.B  #right12,D5 
00002724  EA6B                    2154          LSR.W   D5,D3
00002726  0203 0002               2155          ANDI.B  #2,D3
0000272A  B63C 0002               2156          CMP.B   #2,D3
0000272E  6700 0006               2157          BEQ     D4_An_SET_5
00002732  6000 0014               2158          BRA     CHECK_BIT_12
00002736                          2159  D4_An_SET_5
00002736  183C 0005               2160          MOVE.B  #$5, D4
0000273A                          2161          
0000273A  6000 0002               2162          BRA     PRINT_A5
0000273E                          2163          
0000273E                          2164  PRINT_A5
0000273E  4EB9 00002C9C           2165          JSR     EA_An
00002744  14FC 002F               2166          MOVE.B  #$2F,(A2)+
00002748                          2167  
00002748                          2168  *-----------------------------------------------------------------------------------*
00002748                          2169  * Print out A4 if mask field states to. 
00002748                          2170          
00002748                          2171  CHECK_BIT_12
00002748  3606                    2172          MOVE.W  D6, D3
0000274A  0243 F000               2173          ANDI.W  #first_nibble,D3
0000274E  1A3C 000C               2174          MOVE.B  #right12,D5 
00002752  EA6B                    2175          LSR.W   D5,D3
00002754  0203 0001               2176          ANDI.B  #1,D3
00002758  B63C 0001               2177          CMP.B   #1,D3
0000275C  6700 0006               2178          BEQ     D4_An_SET_4
00002760  6000 0014               2179          BRA     CHECK_BIT_11
00002764                          2180  D4_An_SET_4
00002764  183C 0004               2181          MOVE.B  #$4, D4
00002768                          2182          
00002768  6000 0002               2183          BRA     PRINT_A4
0000276C                          2184          
0000276C                          2185  PRINT_A4
0000276C  4EB9 00002C9C           2186          JSR     EA_An
00002772  14FC 002F               2187          MOVE.B  #$2F,(A2)+
00002776                          2188  
00002776                          2189  *-----------------------------------------------------------------------------------*
00002776                          2190  * Print out A3 if mask field states to. 
00002776                          2191  * SECOND NIBBLE CHECK A7 - A4
00002776                          2192    
00002776                          2193  CHECK_BIT_11
00002776  3606                    2194          MOVE.W  D6, D3
00002778  0243 0F00               2195          ANDI.W  #second_nibble,D3
0000277C  1A3C 0008               2196          MOVE.B  #right8,D5 
00002780  EA6B                    2197          LSR.W   D5,D3
00002782  0203 0008               2198          ANDI.B  #8,D3
00002786  B63C 0008               2199          CMP.B   #8,D3
0000278A  6700 0006               2200          BEQ     D4_An_SET_3
0000278E  6000 0014               2201          BRA     CHECK_BIT_10
00002792                          2202  D4_An_SET_3
00002792  183C 0003               2203          MOVE.B  #$3, D4
00002796                          2204          
00002796  6000 0002               2205          BRA     PRINT_A3
0000279A                          2206          
0000279A                          2207  PRINT_A3
0000279A  4EB9 00002C9C           2208          JSR     EA_An
000027A0  14FC 002F               2209          MOVE.B  #$2F,(A2)+     
000027A4                          2210  
000027A4                          2211  *-----------------------------------------------------------------------------------*
000027A4                          2212  * Print out A2 if mask field states to. 
000027A4                          2213    
000027A4                          2214  CHECK_BIT_10
000027A4  3606                    2215          MOVE.W  D6, D3
000027A6  0243 0F00               2216          ANDI.W  #second_nibble,D3
000027AA  1A3C 0008               2217          MOVE.B  #right8,D5 
000027AE  EA6B                    2218          LSR.W   D5,D3
000027B0  0203 0004               2219          ANDI.B  #4,D3
000027B4  B63C 0004               2220          CMP.B   #4,D3
000027B8  6700 0006               2221          BEQ     D4_An_SET_2
000027BC  6000 0014               2222          BRA     CHECK_BIT_9
000027C0                          2223  D4_An_SET_2
000027C0  183C 0002               2224          MOVE.B  #$2, D4
000027C4                          2225          
000027C4  6000 0002               2226          BRA     PRINT_A2
000027C8                          2227          
000027C8                          2228  PRINT_A2
000027C8  4EB9 00002C9C           2229          JSR     EA_An
000027CE  14FC 002F               2230          MOVE.B  #$2F,(A2)+  
000027D2                          2231  
000027D2                          2232  *-----------------------------------------------------------------------------------*
000027D2                          2233  * Print out A1 if mask field states to. 
000027D2                          2234    
000027D2                          2235  CHECK_BIT_9
000027D2  3606                    2236          MOVE.W  D6, D3
000027D4  0243 0F00               2237          ANDI.W  #second_nibble,D3
000027D8  1A3C 0008               2238          MOVE.B  #right8,D5 
000027DC  EA6B                    2239          LSR.W   D5,D3
000027DE  0203 0002               2240          ANDI.B  #2,D3
000027E2  B63C 0002               2241          CMP.B   #2,D3
000027E6  6700 0006               2242          BEQ     D4_An_SET_1
000027EA  6000 0012               2243          BRA     CHECK_BIT_8
000027EE                          2244  D4_An_SET_1
000027EE  183C 0001               2245          MOVE.B  #$1, D4
000027F2                          2246          
000027F2  60D4                    2247          BRA     PRINT_A2
000027F4                          2248          
000027F4                          2249  PRINT_A1
000027F4  4EB9 00002C9C           2250          JSR     EA_An
000027FA  14FC 002F               2251          MOVE.B  #$2F,(A2)+ 
000027FE                          2252  
000027FE                          2253  *-----------------------------------------------------------------------------------*
000027FE                          2254  * Print out A0 if mask field states to. 
000027FE                          2255    
000027FE                          2256  CHECK_BIT_8
000027FE  3606                    2257          MOVE.W  D6, D3
00002800  0243 0F00               2258          ANDI.W  #second_nibble,D3
00002804  1A3C 0008               2259          MOVE.B  #right8,D5 
00002808  EA6B                    2260          LSR.W   D5,D3
0000280A  0203 0001               2261          ANDI.B  #1,D3
0000280E  B63C 0001               2262          CMP.B   #1,D3
00002812  6700 0006               2263          BEQ     D4_An_SET_0
00002816  6000 0014               2264          BRA     CHECK_BIT_7
0000281A                          2265  D4_An_SET_0
0000281A  183C 0000               2266          MOVE.B  #$0, D4
0000281E                          2267          
0000281E  6000 0002               2268          BRA     PRINT_A0
00002822                          2269          
00002822                          2270  PRINT_A0
00002822  4EB9 00002C9C           2271          JSR     EA_An
00002828  14FC 002F               2272          MOVE.B  #$2F,(A2)+        
0000282C                          2273  
0000282C                          2274  *-----------------------------------------------------------------------------------*
0000282C                          2275  * Print out D7 if mask field states to. 
0000282C                          2276  * THIRD NIBBLE CHECK D7-D0
0000282C                          2277  
0000282C                          2278  CHECK_BIT_7
0000282C  3606                    2279          MOVE.W  D6, D3
0000282E  0243 00F0               2280          ANDI.W  #third_nibble,D3
00002832  1A3C 0004               2281          MOVE.B  #right4,D5 
00002836  EA6B                    2282          LSR.W   D5,D3
00002838  0203 0008               2283          ANDI.B  #8,D3
0000283C  B63C 0008               2284          CMP.B   #8,D3
00002840  6700 0006               2285          BEQ     D4_Dn_SET_7
00002844  6000 0014               2286          BRA     CHECK_BIT_6
00002848                          2287  D4_Dn_SET_7
00002848  183C 0007               2288          MOVE.B  #$7, D4
0000284C                          2289          
0000284C  6000 0002               2290          BRA     PRINT_D7
00002850                          2291          
00002850                          2292  PRINT_D7
00002850  4EB9 00002C90           2293          JSR     EA_Dn
00002856  14FC 002F               2294          MOVE.B  #$2F,(A2)+
0000285A                          2295  
0000285A                          2296  *-----------------------------------------------------------------------------------*
0000285A                          2297  * Print out D6 if mask field states to. 
0000285A                          2298  
0000285A                          2299  CHECK_BIT_6
0000285A  3606                    2300          MOVE.W  D6, D3
0000285C  0243 00F0               2301          ANDI.W  #third_nibble,D3
00002860  1A3C 0004               2302          MOVE.B  #right4,D5 
00002864  EA6B                    2303          LSR.W   D5,D3
00002866  0203 0004               2304          ANDI.B  #4,D3
0000286A  B63C 0004               2305          CMP.B   #4,D3
0000286E  6700 0006               2306          BEQ     D4_Dn_SET_6
00002872  6000 0014               2307          BRA     CHECK_BIT_5
00002876                          2308  D4_Dn_SET_6
00002876  183C 0006               2309          MOVE.B  #$6, D4
0000287A                          2310          
0000287A  6000 0002               2311          BRA     PRINT_D6
0000287E                          2312          
0000287E                          2313  PRINT_D6
0000287E  4EB9 00002C90           2314          JSR     EA_Dn
00002884  14FC 002F               2315          MOVE.B  #$2F,(A2)+
00002888                          2316  
00002888                          2317  *-----------------------------------------------------------------------------------*
00002888                          2318  * Print out D5 if mask field states to. 
00002888                          2319  
00002888                          2320  CHECK_BIT_5
00002888  3606                    2321          MOVE.W  D6, D3
0000288A  0243 00F0               2322          ANDI.W  #third_nibble,D3
0000288E  1A3C 0004               2323          MOVE.B  #right4,D5 
00002892  EA6B                    2324          LSR.W   D5,D3
00002894  0203 0002               2325          ANDI.B  #2,D3
00002898  B63C 0002               2326          CMP.B   #2,D3
0000289C  6700 0006               2327          BEQ     D4_Dn_SET_5
000028A0  6000 0014               2328          BRA     CHECK_BIT_4
000028A4                          2329  D4_Dn_SET_5
000028A4  183C 0005               2330          MOVE.B  #$5, D4
000028A8                          2331          
000028A8  6000 0002               2332          BRA     PRINT_D5
000028AC                          2333          
000028AC                          2334  PRINT_D5
000028AC  4EB9 00002C90           2335          JSR     EA_Dn
000028B2  14FC 002F               2336          MOVE.B  #$2F,(A2)+
000028B6                          2337  
000028B6                          2338  *-----------------------------------------------------------------------------------*
000028B6                          2339  * Print out D4 if mask field states to. 
000028B6                          2340  
000028B6                          2341  CHECK_BIT_4
000028B6  3606                    2342          MOVE.W  D6, D3
000028B8  0243 00F0               2343          ANDI.W  #third_nibble,D3
000028BC  1A3C 0004               2344          MOVE.B  #right4,D5 
000028C0  EA6B                    2345          LSR.W   D5,D3
000028C2  0203 0001               2346          ANDI.B  #1,D3
000028C6  B63C 0001               2347          CMP.B   #1,D3
000028CA  6700 0006               2348          BEQ     D4_Dn_SET_4
000028CE  6000 0014               2349          BRA     CHECK_BIT_3
000028D2                          2350  D4_Dn_SET_4
000028D2  183C 0004               2351          MOVE.B  #$4, D4
000028D6                          2352          
000028D6  6000 0002               2353          BRA     PRINT_D4
000028DA                          2354          
000028DA                          2355  PRINT_D4
000028DA  4EB9 00002C90           2356          JSR     EA_Dn
000028E0  14FC 002F               2357          MOVE.B  #$2F,(A2)+
000028E4                          2358  
000028E4                          2359  *-----------------------------------------------------------------------------------*
000028E4                          2360  * Print out D3 if mask field states to. 
000028E4                          2361  * FOURTH NIBBLE CHECK / D3 - D0
000028E4                          2362  
000028E4                          2363  CHECK_BIT_3
000028E4  3606                    2364          MOVE.W  D6, D3
000028E6  0243 000F               2365          ANDI.W  #fourth_nibble,D3
000028EA  0203 0008               2366          ANDI.B  #8,D3
000028EE  B63C 0008               2367          CMP.B   #8,D3
000028F2  6700 0006               2368          BEQ     D4_Dn_SET_3
000028F6  6000 0014               2369          BRA     CHECK_BIT_2
000028FA                          2370  D4_Dn_SET_3
000028FA  183C 0003               2371          MOVE.B  #$3, D4
000028FE                          2372          
000028FE  6000 0002               2373          BRA     PRINT_D3
00002902                          2374          
00002902                          2375  PRINT_D3
00002902  4EB9 00002C90           2376          JSR     EA_Dn
00002908  14FC 002F               2377          MOVE.B  #$2F,(A2)+
0000290C                          2378  
0000290C                          2379  *-----------------------------------------------------------------------------------*
0000290C                          2380  * Print out D2 if mask field states to. 
0000290C                          2381  
0000290C                          2382  CHECK_BIT_2
0000290C  3606                    2383          MOVE.W  D6, D3
0000290E  0243 000F               2384          ANDI.W  #fourth_nibble,D3
00002912  0203 0004               2385          ANDI.B  #4,D3
00002916  B63C 0004               2386          CMP.B   #4,D3
0000291A  6700 0006               2387          BEQ     D4_Dn_SET_2
0000291E  6000 0014               2388          BRA     CHECK_BIT_1
00002922                          2389  D4_Dn_SET_2
00002922  183C 0002               2390          MOVE.B  #$2, D4
00002926                          2391          
00002926  6000 0002               2392          BRA     PRINT_D2
0000292A                          2393          
0000292A                          2394  PRINT_D2
0000292A  4EB9 00002C90           2395          JSR     EA_Dn
00002930  14FC 002F               2396          MOVE.B  #$2F,(A2)+
00002934                          2397  
00002934                          2398  *-----------------------------------------------------------------------------------*
00002934                          2399  * Print out D1 if mask field states to. 
00002934                          2400  
00002934                          2401  CHECK_BIT_1
00002934  3606                    2402          MOVE.W  D6, D3
00002936  0243 000F               2403          ANDI.W  #fourth_nibble,D3
0000293A  0203 0002               2404          ANDI.B  #2,D3
0000293E  B63C 0002               2405          CMP.B   #2,D3
00002942  6700 0006               2406          BEQ     D4_Dn_SET_1
00002946  6000 0014               2407          BRA     CHECK_BIT_0
0000294A                          2408  D4_Dn_SET_1
0000294A  183C 0001               2409          MOVE.B  #$1, D4
0000294E                          2410          
0000294E  6000 0002               2411          BRA     PRINT_D1
00002952                          2412          
00002952                          2413  PRINT_D1
00002952  4EB9 00002C90           2414          JSR     EA_Dn
00002958  14FC 002F               2415          MOVE.B  #$2F,(A2)+
0000295C                          2416  
0000295C                          2417  *-----------------------------------------------------------------------------------*
0000295C                          2418  * Print out D0 if mask field states to. 
0000295C                          2419  
0000295C                          2420  CHECK_BIT_0
0000295C  3606                    2421          MOVE.W  D6, D3
0000295E  0243 000F               2422          ANDI.W  #fourth_nibble,D3
00002962  0203 0001               2423          ANDI.B  #1,D3
00002966  B63C 0001               2424          CMP.B   #1,D3
0000296A  6700 0006               2425          BEQ     D4_Dn_SET_0
0000296E  6000 0014               2426          BRA     FINISH_MOVEM_MEM_TO_REG
00002972                          2427  D4_Dn_SET_0
00002972  183C 0000               2428          MOVE.B  #$0, D4
00002976                          2429          
00002976  6000 0002               2430          BRA     PRINT_D0
0000297A                          2431          
0000297A                          2432  PRINT_D0
0000297A  4EB9 00002C90           2433          JSR     EA_Dn
00002980  14FC 002F               2434          MOVE.B  #$2F,(A2)+
00002984                          2435  
00002984                          2436  FINISH_MOVEM_MEM_TO_REG
00002984                          2437          
00002984  2600                    2438          MOVE.L  D0,D3               ; Store the src mode in D3
00002986  0243 0038               2439          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000298A  1A3C 0003               2440          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000298E  EA6B                    2441          LSR.W   D5,D3               ; Do the actual shift
00002990                          2442  
00002990  2800                    2443          MOVE.L  D0,D4               ; Store the dst reg in D4
00002992  0244 0007               2444          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002996                          2445   
00002996  B63C 0002               2446          CMP.B   #2, D3
0000299A  6700 0006               2447          BEQ     An_FINISH           ; branch to print out (An) 
0000299E  6000 0010               2448          BRA     NORMAL_FINISH       ; branch to the normal finish
000029A2                          2449  
000029A2                          2450  An_FINISH
000029A2  14FC 002C               2451          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000029A6  14FC 0020               2452          MOVE.B  #$20,(A2)+          ; Add space after comma
000029AA                          2453          
000029AA                          2454                      
000029AA  4EB9 00002C52           2455          JSR     EA_GEN_SRC
000029B0                          2456  
000029B0                          2457  NORMAL_FINISH
000029B0  301D                    2458          MOVE.W  (A5)+, D0
000029B2                          2459          
000029B2  4EF8 1DDE               2460          JMP     EA_FINISH
000029B6                          2461  *------------------------------------------------------------------------------------------------*
000029B6                          2462  EA_SHIFTS       ; 7: ea_shifts
000029B6  2200                    2463          MOVE.L  D0,D1               ; D0 is current instruction word
000029B8  0241 01C0               2464          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000029BC  1A3C 0006               2465          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000029C0  EA69                    2466          LSR.W   D5,D1               ; Shift dst mode into LSB position
000029C2  C2FC 0006               2467          MULU    #6, D1              ; Set displacement 
000029C6  41F9 000029D0           2468          LEA     EA_SHIFTS_TABLE,A0  ; Load table into A0
000029CC  4EF0 1000               2469          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000029D0                          2470  
000029D0                          2471  EA_SHIFTS_TABLE
000029D0  4EF9 00002A76           2472          JMP     EA_REGISTER_SHIFTS  ; 000 Register
000029D6  4EF9 00002A76           2473          JMP     EA_REGISTER_SHIFTS  ; 001 Register
000029DC  4EF9 00002A76           2474          JMP     EA_REGISTER_SHIFTS  ; 010 Register
000029E2  4EF9 00002A00           2475          JMP     EA_MEMORY_SHIFTS    ; 011 Memory
000029E8  4EF9 00002A76           2476          JMP     EA_REGISTER_SHIFTS  ; 100 Register
000029EE  4EF9 00002A76           2477          JMP     EA_REGISTER_SHIFTS  ; 101 Register
000029F4  4EF9 00002A76           2478          JMP     EA_REGISTER_SHIFTS  ; 110 Register
000029FA  4EF9 00002A00           2479          JMP     EA_MEMORY_SHIFTS    ; 111 Memory
00002A00                          2480          
00002A00                          2481  EA_MEMORY_SHIFTS
00002A00                          2482          ; Get EA and store into decode buffer
00002A00  2800                    2483          MOVE.L  D0,D4               ; Store the EA reg in D4
00002A02  0244 0007               2484          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002A06                          2485          
00002A06  2600                    2486          MOVE.L  D0,D3               ; Store the EA mode in D3
00002A08  0243 0038               2487          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002A0C  1A3C 0003               2488          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002A10  EA6B                    2489          LSR.W   D5,D3               ; Do the actual shift
00002A12  4EB9 00002D68           2490          JSR     An_CHECK            ; Check if mode is An 
00002A18  4EB9 00002D72           2491          JSR     Dn_CHECK            ; Check if mode is Dn
00002A1E  4EB9 00002D7C           2492          JSR     IMMEDIATE_CHECK     ; Check if mode is immediate
00002A24                          2493          
00002A24  14FC 0020               2494          MOVE.B  #$20,(A2)+          ; Print out a space 
00002A28  14FC 0020               2495          MOVE.B  #$20,(A2)+          ; Print out a space
00002A2C  14FC 0020               2496          MOVE.B  #$20,(A2)+          ; Print out a space
00002A30  14FC 0020               2497          MOVE.B  #$20,(A2)+          ; Print out a space
00002A34  14FC 0020               2498          MOVE.B  #$20,(A2)+          ; Add space
00002A38                          2499          
00002A38  4EB9 00002A50           2500          JSR     FRONT_FORMAT
00002A3E  4EB9 00002C52           2501          JSR     EA_GEN_SRC          ; Go get EA print
00002A44  B63C 002A               2502          CMP.B   #$2A,D3             ; When mode is 111 * 6 (2A)
00002A48  6700 001E               2503          BEQ     BACK_PARENTHESIS  
00002A4C  4EF8 1DDE               2504          JMP     EA_FINISH           ; Opcode is finish
00002A50                          2505  
00002A50                          2506  FRONT_FORMAT
00002A50  B63C 0007               2507          CMP.B   #7,D3               ; When mode is 111
00002A54  6700 0008               2508          BEQ     ADD_PARENTHESIS
00002A58  14FC 0020               2509          MOVE.B  #$20,(A2)+          ; Print out a space
00002A5C  4E75                    2510          RTS
00002A5E                          2511          
00002A5E                          2512  ADD_PARENTHESIS
00002A5E  14FC 0020               2513          MOVE.B  #$20,(A2)+          ; Print out a space
00002A62  14FC 0028               2514          MOVE.B  #'(',(A2)+
00002A66  4E75                    2515          RTS
00002A68                          2516          
00002A68                          2517  BACK_PARENTHESIS            
00002A68  14FC 0029               2518          MOVE.B  #')',(A2)+
00002A6C  1404                    2519          MOVE.B  D4,D2
00002A6E  4EB8 1ECC               2520          JSR     EA_SIZE_MEMORY_SHIFTS
00002A72  4EF8 1DDE               2521          JMP     EA_FINISH           ; Opcode is finish
00002A76                          2522      
00002A76                          2523  EA_REGISTER_SHIFTS
00002A76  2200                    2524          MOVE.L  D0,D1
00002A78  0241 01C0               2525          ANDI.W  #dst_mode,D1
00002A7C  1A3C 0006               2526          MOVE.B  #right6,D5 
00002A80  EA69                    2527          LSR.W   D5,D1
00002A82  0201 0003               2528          ANDI.B  #3,D1               ; Remove bit 8 and get bits 7-6
00002A86  1401                    2529          MOVE.B  D1,D2
00002A88  4EB8 1E24               2530          JSR     EA_SIZE_GENERAL
00002A8C                          2531          
00002A8C  2600                    2532          MOVE.L  D0,D3               ; Store the instruction in D3
00002A8E  0243 0038               2533          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002A92  1A3C 0003               2534          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002A96  EA6B                    2535          LSR.W   D5,D3               ; Do the actual shift 
00002A98  0203 0004               2536          ANDI.B  #4,D3               ; Get bit 5(ir) from bits 5-3
00002A9C  E44B                    2537          LSR.W   #2,D3
00002A9E                          2538  
00002A9E  B63C 0000               2539          CMP.B   #0,D3               ; When D1 is 0 (immediate)
00002AA2  6700 0006               2540          BEQ     IMMEDIATE_SRC
00002AA6  6000 0056               2541          BRA     REGISTER_SRC        ; When D1 is 1 (register)
00002AAA                          2542          
00002AAA                          2543  IMMEDIATE_SRC
00002AAA  14FC 0020               2544          MOVE.B  #$20,(A2)+          ; Add space
00002AAE  14FC 0020               2545          MOVE.B  #$20,(A2)+          ; Add space
00002AB2  14FC 0020               2546          MOVE.B  #$20,(A2)+          ; Add space
00002AB6  14FC 0020               2547          MOVE.B  #$20,(A2)+          ; Add space
00002ABA                          2548          
00002ABA                          2549          ; Get source and store into decode buffer
00002ABA  2800                    2550          MOVE.L  D0,D4               ; Store the src reg in D4
00002ABC  0244 0E00               2551          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002AC0  1A3C 0009               2552          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002AC4  EA6C                    2553          LSR.W   D5,D4               ; Do the actual shift
00002AC6  4EB9 00002AEE           2554          JSR     CHECK_IF_ZERO       ; Check if register is 0
00002ACC                          2555          
00002ACC  14FC 0023               2556          MOVE.B  #$23,(A2)+          ; Add # symbol
00002AD0  0604 0030               2557          ADDI.B  #$30,D4             ; Convert hex to ASCII
00002AD4  14C4                    2558          MOVE.B  D4,(A2)+            ; Store into buffer
00002AD6                          2559          
00002AD6  14FC 002C               2560          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002ADA  14FC 0020               2561          MOVE.B  #$20,(A2)+          ; Add space after comma
00002ADE                          2562  
00002ADE                          2563          ; Get destination and store into decode buffer
00002ADE  2800                    2564          MOVE.L  D0,D4               ; Store the src reg in D4
00002AE0  0244 0007               2565          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002AE4  4EB9 00002C90           2566          JSR     EA_Dn               ; store Dn into decode buffer
00002AEA  4EF8 1DDE               2567          JMP     EA_FINISH           ; Opcode is finish
00002AEE                          2568                
00002AEE                          2569  CHECK_IF_ZERO
00002AEE  B83C 0000               2570          CMP.B   #0,D4               ; When D4 is 0 
00002AF2  6700 0004               2571          BEQ     IMMEDIATE_EIGHT     ; Branch
00002AF6  4E75                    2572          RTS
00002AF8                          2573  
00002AF8                          2574  IMMEDIATE_EIGHT
00002AF8  183C 0008               2575          MOVE.B  #8,D4               ; Store 8 into D4 
00002AFC  4E75                    2576          RTS
00002AFE                          2577  
00002AFE                          2578  REGISTER_SRC        
00002AFE  14FC 0020               2579          MOVE.B  #$20,(A2)+          ; Add space
00002B02  14FC 0020               2580          MOVE.B  #$20,(A2)+          ; Add space
00002B06  14FC 0020               2581          MOVE.B  #$20,(A2)+          ; Add space
00002B0A  14FC 0020               2582          MOVE.B  #$20,(A2)+          ; Add space
00002B0E                          2583  
00002B0E                          2584          ; Get source and store into decode buffer
00002B0E  2800                    2585          MOVE.L  D0,D4               ; Store the src reg in D4
00002B10  0244 0E00               2586          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B14  1A3C 0009               2587          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B18  EA6C                    2588          LSR.W   D5,D4               ; Do the actual shift
00002B1A  4EB9 00002C90           2589          JSR     EA_Dn               ; store Dn into decode buffer
00002B20                          2590          
00002B20  14FC 002C               2591          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B24  14FC 0020               2592          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B28                          2593  
00002B28                          2594          ; Get destination and store into decode buffer
00002B28  2800                    2595          MOVE.L  D0,D4               ; Store the src reg in D4
00002B2A  0244 0007               2596          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002B2E  4EB9 00002C90           2597          JSR     EA_Dn               ; store Dn into decode buffer
00002B34  4EF8 1DDE               2598          JMP     EA_FINISH           ; Opcode is finish
00002B38                          2599  *------------------------------------------------------------------------------------------------*
00002B38                          2600  EA_QUICK        ; 8: ea_quick
00002B38  BC3C 0005               2601          CMP.B   #5, D6              ; check if the first nibble is 5 for ADDQ
00002B3C  6700 000A               2602          BEQ     ADDQ_EA_CALC
00002B40                          2603          
00002B40  BC3C 0007               2604          CMP.B   #7, D6              ; check if the first nibble is 7 for MOVEQ
00002B44  6700 0072               2605          BEQ     MOVEQ_EA_CALC
00002B48                          2606          
00002B48                          2607  ADDQ_EA_CALC
00002B48  2200                    2608          MOVE.L  D0,D1
00002B4A  0241 01C0               2609          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00002B4E  1A3C 0006               2610          MOVE.B  #right6,D5          ; Store 6 into D5
00002B52  EA69                    2611          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002B54  0201 0003               2612          ANDI.B  #3,D1               ; Remove the front bit from D1
00002B58  1401                    2613          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002B5A  4EB8 1E24               2614          JSR     EA_SIZE_GENERAL     ; Get size and print size.
00002B5E                          2615          
00002B5E  14FC 0020               2616          MOVE.B  #$20,(A2)+          ; Add space after size
00002B62  14FC 0020               2617          MOVE.B  #$20,(A2)+          ; Add space
00002B66  14FC 0020               2618          MOVE.B  #$20,(A2)+          ; Add space
00002B6A                          2619          
00002B6A  14FC 0023               2620          MOVE.B  #$23,(A2)+          ; Add # symbol
00002B6E  14FC 0024               2621          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002B72                          2622          
00002B72  2800                    2623          MOVE.L  D0,D4               ; Store the data in D4
00002B74  0244 0E00               2624          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B78  1A3C 0009               2625          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B7C  EA6C                    2626          LSR.W   D5,D4               ; Do the actual shift
00002B7E                          2627          
00002B7E  B83C 0000               2628          CMP.B   #0, D4
00002B82  6700 0006               2629          BEQ     CHANGE_TO_EIGHT
00002B86                          2630          
00002B86  6000 0006               2631          BRA     DONT_CHANGE
00002B8A                          2632  
00002B8A                          2633  CHANGE_TO_EIGHT
00002B8A  183C 0008               2634          MOVE.B  #8, D4
00002B8E                          2635  
00002B8E                          2636  DONT_CHANGE        
00002B8E  0604 0030               2637          ADDI.B  #$30, D4
00002B92  14C4                    2638          MOVE.B  D4, (A2)+      
00002B94                          2639          
00002B94  14FC 002C               2640          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B98  14FC 0020               2641          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B9C                          2642          
00002B9C  2800                    2643          MOVE.L  D0,D4               ; Store the src reg in D4
00002B9E  0244 0007               2644          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002BA2                          2645          
00002BA2  2600                    2646          MOVE.L  D0,D3               ; Store the src mode in D3
00002BA4  0243 0038               2647          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002BA8  1A3C 0003               2648          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002BAC  EA6B                    2649          LSR.W   D5,D3               ; Do the actual shift 
00002BAE  4EB9 00002C52           2650          JSR     EA_GEN_SRC
00002BB4                          2651          
00002BB4  4EF8 1DDE               2652          JMP     EA_FINISH
00002BB8                          2653  
00002BB8                          2654  MOVEQ_EA_CALC
00002BB8  14FC 0020               2655          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002BBC  14FC 0020               2656          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002BC0  14FC 0020               2657          MOVE.B  #$20,(A2)+          ; Add space
00002BC4  14FC 0020               2658          MOVE.B  #$20,(A2)+          ; Add space
00002BC8                          2659  
00002BC8  14FC 0023               2660          MOVE.B  #$23,(A2)+          ; Add # symbol
00002BCC  14FC 0024               2661          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002BD0                          2662          
00002BD0  2200                    2663          MOVE.L  D0, D1              ; move D0 to D1
00002BD2  0241 00FF               2664          ANDI.W  #second_half, D1    ; get the second 8 bits of D1
00002BD6  1A01                    2665          MOVE.B  D1, D5              ; move D1 to D5 to convert it to ASCII
00002BD8                          2666          
00002BD8  4EB8 11AA               2667          JSR     ITOA_BYTE_BRANCH    ; print out the bit of data
00002BDC                          2668          
00002BDC  14FC 002C               2669          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002BE0  14FC 0020               2670          MOVE.B  #$20,(A2)+          ; Add space after comma
00002BE4                          2671          
00002BE4  2800                    2672          MOVE.L  D0,D4               ; Store the data in D4
00002BE6  0244 0E00               2673          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002BEA  1A3C 0009               2674          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002BEE  EA6C                    2675          LSR.W   D5,D4               ; Do the actual shift
00002BF0  4EB9 00002C52           2676          JSR     EA_GEN_SRC
00002BF6                          2677          
00002BF6  4EF8 1DDE               2678          JMP     EA_FINISH
00002BFA                          2679  *------------------------------------------------------------------------------------------------*
00002BFA                          2680  EA_BRANCH       ; 9: ea_branch
00002BFA  14FC 0020               2681          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002BFE  14FC 0020               2682          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C02  14FC 0020               2683          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C06  14FC 0020               2684          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C0A  14FC 0020               2685          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C0E  14FC 0020               2686          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C12                          2687  
00002C12  2600                    2688          MOVE.L  D0,D3               ; D0 is current instruction word
00002C14  0243 00F0               2689          ANDI.W  #third_nibble,D3   ; Extract 3rd nibble from instruction word
00002C18  1A3C 0004               2690          MOVE.B  #right4,D5
00002C1C                          2691          
00002C1C  2800                    2692          MOVE.L  D0,D4               ; D0 is current instruction word
00002C1E  0244 000F               2693          ANDI.W  #fourth_nibble,D4   ; Extract 4th nibble from instruction word
00002C22                          2694           
00002C22  B63C 0000               2695          CMP.B   #0,D3               ; check if 3rd nibble is 0. 
00002C26  6700 0006               2696          BEQ     FOURTH_NIBBLE_CHECK
00002C2A                          2697          
00002C2A  6000 0018               2698          BRA     BRANCH_WORD_CHECK
00002C2E                          2699          
00002C2E                          2700  FOURTH_NIBBLE_CHECK                 
00002C2E  B83C 0000               2701          CMP.B   #0,D4               ; check if the 4th nibble is 0. 
00002C32                          2702          
00002C32  3A15                    2703          MOVE.W  (A5), D5            ; store the 16-bit displacement into D5
00002C34                          2704          
00002C34  260D                    2705          MOVE.L  A5, D3              ; Store A5 address into D3
00002C36                          2706          
00002C36  DA43                    2707          ADD.W   D3, D5              ; Add the address to D5 to get the displacement. 
00002C38                          2708          
00002C38  14FC 0024               2709          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C3C                          2710          
00002C3C  4EB8 11D8               2711          JSR     ITOA_WORD_BRANCH    ; Print. 
00002C40                          2712  
00002C40  4EF8 1DDE               2713          JMP     EA_FINISH
00002C44                          2714  
00002C44                          2715  BRANCH_WORD_CHECK
00002C44  4245                    2716          CLR     D5                  ; handles 8-bit displacement. 
00002C46  DA03                    2717          ADD.B   D3,D5               ; add d3 and d4 to d5
00002C48  DA04                    2718          ADD.B   D4,D5
00002C4A                          2719          
00002C4A  4EB8 11AA               2720          JSR     ITOA_BYTE_BRANCH    ; Print. 
00002C4E                          2721  
00002C4E  4EF8 1DDE               2722          JMP     EA_FINISH
00002C52                          2723  
00002C52                          2724  EA_GEN_SRC
00002C52  41F9 00002C60           2725          LEA     EA_GEN_TABLE_SRC, A0
00002C58  C6FC 0006               2726          MULU    #6, D3              ; use D3 to jump to the proper src mode and dst mode. 
00002C5C  4EF0 3000               2727          JMP     0(A0,D3)            ; jump to each ea src generation table entry 
00002C60                          2728  
00002C60                          2729  EA_GEN_TABLE_SRC
00002C60  4EF9 00002C90           2730          JMP     EA_Dn                       ; 000: Dn
00002C66  4EF9 00002C9C           2731          JMP     EA_An                       ; 001: An
00002C6C  4EF9 00002CA8           2732          JMP     EA_An_Indirect              ; 010: (An)
00002C72  4EF9 00002CBC           2733          JMP     EA_An_Indirect_Inc          ; 011: (An)+
00002C78  4EF9 00002CD4           2734          JMP     EA_An_Indirect_Dec          ; 100: -(An)
00002C7E  4EF9 00002CEC           2735          JMP     EA_UNSUPPORTED              ; 101: Unsupported EA
00002C84  4EF9 00002CEC           2736          JMP     EA_UNSUPPORTED              ; 110: Unsupported EA
00002C8A  4EF9 00002CFA           2737          JMP     EA_Absolute_And_Immediate   ; 111: (xxx).W,(xxx).L, or #<data>
00002C90                          2738  
00002C90                          2739  EA_Dn               ; 000: Dn
00002C90  14FC 0044               2740          MOVE.B  #'D',(A2)+
00002C94  0604 0030               2741          ADDI.B  #$30,D4
00002C98  14C4                    2742          MOVE.B  D4,(A2)+
00002C9A  4E75                    2743          RTS
00002C9C                          2744  
00002C9C                          2745  EA_An               ; 001: An
00002C9C  14FC 0041               2746          MOVE.B  #'A',(A2)+
00002CA0  0604 0030               2747          ADDI.B  #$30,D4
00002CA4  14C4                    2748          MOVE.B  D4,(A2)+
00002CA6  4E75                    2749          RTS
00002CA8                          2750  
00002CA8                          2751  EA_An_Indirect      ; 010: (An)
00002CA8  14FC 0028               2752          MOVE.B  #'(',(A2)+
00002CAC  14FC 0041               2753          MOVE.B  #'A',(A2)+
00002CB0  0604 0030               2754          ADDI.B  #$30,D4
00002CB4  14C4                    2755          MOVE.B  D4,(A2)+
00002CB6  14FC 0029               2756          MOVE.B  #')',(A2)+
00002CBA  4E75                    2757          RTS
00002CBC                          2758          
00002CBC                          2759  EA_An_Indirect_Inc  ; 011: (An)+
00002CBC  14FC 0028               2760          MOVE.B  #'(',(A2)+
00002CC0  14FC 0041               2761          MOVE.B  #'A',(A2)+
00002CC4  0604 0030               2762          ADDI.B  #$30, D4
00002CC8  14C4                    2763          MOVE.B  D4,(A2)+
00002CCA  14FC 0029               2764          MOVE.B  #')',(A2)+
00002CCE  14FC 002B               2765          MOVE.B  #'+',(A2)+
00002CD2  4E75                    2766          RTS
00002CD4                          2767          
00002CD4                          2768  EA_An_Indirect_Dec  ; 100: -(An)
00002CD4  14FC 002D               2769          MOVE.B  #'-',(A2)+
00002CD8  14FC 0028               2770          MOVE.B  #'(',(A2)+
00002CDC  14FC 0041               2771          MOVE.B  #'A',(A2)+
00002CE0  0604 0030               2772          ADDI.B  #$30,D4
00002CE4  14C4                    2773          MOVE.B  D4,(A2)+
00002CE6  14FC 0029               2774          MOVE.B  #')',(A2)+
00002CEA  4E75                    2775          RTS
00002CEC                          2776  
00002CEC                          2777  EA_UNSUPPORTED
00002CEC  43F9 00002E2F           2778          LEA     EA_TYPE_ERROR,A1
00002CF2  103C 000E               2779          MOVE.B  #14,D0
00002CF6  4E4F                    2780          TRAP    #15  
00002CF8  4E75                    2781          RTS 
00002CFA                          2782          
00002CFA                          2783  EA_Absolute_And_Immediate           ; 111: (xxx).W,(xxx).L, or #<data>
00002CFA  B83C 0000               2784          CMP.B   #0,D4               ; If D4 is (xxx).W
00002CFE  6700 0016               2785          BEQ     ABSOLUTE_WORD
00002D02                          2786          
00002D02  B83C 0001               2787          CMP.B   #1,D4               ; If D4 is (xxx).L
00002D06  6700 001A               2788          BEQ     ABSOLUTE_LONG
00002D0A                          2789          
00002D0A  B83C 0004               2790          CMP.B   #4,D4               ; If D4 is #<data>  
00002D0E  6700 001E               2791          BEQ     IMMEDIATE
00002D12                          2792          
00002D12  6000 008C               2793          BRA     ABSOLUTE_IMMEDIATE_ERROR    
00002D16                          2794  
00002D16                          2795  ABSOLUTE_WORD
00002D16  14FC 0024               2796          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D1A  7401                    2797          MOVE.L  #1,D2               ; Insert 1 to D2 
00002D1C  4EB8 1114               2798          JSR     ITOA                ; Convert word hex values to ITOA
00002D20  4E75                    2799          RTS
00002D22                          2800          
00002D22                          2801  ABSOLUTE_LONG
00002D22  14FC 0024               2802          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D26  7402                    2803          MOVE.L  #2,D2               ; Insert 2 to D2
00002D28  4EB8 1114               2804          JSR     ITOA                ; Convert long hex values to ITOA
00002D2C  4E75                    2805          RTS
00002D2E                          2806     
00002D2E                          2807  IMMEDIATE
00002D2E  14FC 0023               2808          MOVE.B  #$23,(A2)+          ; Add # symbol
00002D32  14FC 0024               2809          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D36                          2810  
00002D36  BC3C 0001               2811          CMP.B   #1,D6               ; If MOVE.b (code0001)
00002D3A  6700 0020               2812          BEQ     DO_ITOA_MOVE
00002D3E  BC3C 0002               2813          CMP.B   #2, D6              ; If MOVE.l / MOVEA.l (code0010)
00002D42  6700 0018               2814          BEQ     DO_ITOA_MOVE
00002D46  BC3C 0003               2815          CMP.B   #3, D6              ; If MOVE.w / MOVEA.w (code0011)
00002D4A  6700 0010               2816          BEQ     DO_ITOA_MOVE        
00002D4E  BC3C 000D               2817          CMP.B   #13, D6             ; If ADD / ADDA (code1101)
00002D52  6700 000E               2818          BEQ     DO_ITOA_OPMODE
00002D56                          2819          
00002D56  4EB8 1114               2820          JSR     ITOA                ; Go to ITOA when not a move instruction
00002D5A  4E75                    2821          RTS
00002D5C                          2822          
00002D5C                          2823  DO_ITOA_MOVE
00002D5C  4EB8 1136               2824          JSR ITOA_MOVE
00002D60  4E75                    2825          RTS
00002D62                          2826                
00002D62                          2827  DO_ITOA_OPMODE
00002D62  4EB8 1158               2828          JSR ITOA_OPMODE
00002D66  4E75                    2829          RTS
00002D68                          2830  
00002D68                          2831  An_CHECK 
00002D68  B63C 0001               2832          CMP.B   #1,D3               ; If mode is An     
00002D6C  6700 0062               2833          BEQ     EA_INVALID          ; Then branch to error message
00002D70  4E75                    2834          RTS   
00002D72                          2835        
00002D72                          2836  Dn_CHECK 
00002D72  B63C 0000               2837          CMP.B   #0,D3               ; If mode is An     
00002D76  6700 0058               2838          BEQ     EA_INVALID          ; Then branch to error message
00002D7A  4E75                    2839          RTS    
00002D7C                          2840       
00002D7C                          2841  IMMEDIATE_CHECK
00002D7C  B63C 0007               2842          CMP.B   #7,D3
00002D80  6700 0004               2843          BEQ     REGISTER_CHECK
00002D84  4E75                    2844          RTS
00002D86                          2845          
00002D86                          2846  REGISTER_CHECK
00002D86  B63C 0004               2847          CMP.B   #4,D3               ; If 100 in register
00002D8A  6700 0044               2848          BEQ     EA_INVALID          ; Branch to invalid
00002D8E  4E75                    2849          RTS   
00002D90                          2850                
00002D90                          2851  EA_WRONG_SIZE 
00002D90  43F9 00002DE5           2852          LEA     WRONG_SIZE_MESSAGE, A1 
00002D96  103C 000E               2853          MOVE.B  #14, D0
00002D9A  4E4F                    2854          TRAP    #15
00002D9C  4EF8 138E               2855          JMP     OP_FINISH
00002DA0                          2856          
00002DA0                          2857  ABSOLUTE_IMMEDIATE_ERROR  
00002DA0  43F9 00002DF3           2858          LEA     ABSOLUTE_WRONGREG, A1 
00002DA6  103C 000E               2859          MOVE.B  #14, D0
00002DAA  4E4F                    2860          TRAP    #15
00002DAC  4EF8 138E               2861          JMP     OP_FINISH
00002DB0                          2862          
00002DB0                          2863  DST_INVALID
00002DB0  43F9 00002E51           2864          LEA     DST_INVALID_MSG, A1 
00002DB6  103C 000E               2865          MOVE.B  #14, D0
00002DBA  4E4F                    2866          TRAP    #15
00002DBC  4EF8 138E               2867          JMP     OP_FINISH
00002DC0                          2868          
00002DC0                          2869  SRC_INVALID 
00002DC0  43F9 00002E83           2870          LEA     SRC_INVALID_MSG, A1 
00002DC6  103C 000E               2871          MOVE.B  #14, D0
00002DCA  4E4F                    2872          TRAP    #15
00002DCC  4EF8 138E               2873          JMP     OP_FINISH
00002DD0                          2874          
00002DD0                          2875  EA_INVALID  
00002DD0  43F9 00002EB0           2876          LEA     EA_INVALID_MSG, A1 
00002DD6  103C 000E               2877          MOVE.B  #14, D0
00002DDA  4E4F                    2878          TRAP    #15
00002DDC  4EF8 138E               2879          JMP     OP_FINISH
00002DE0                          2880           
00002DE0  FFFF FFFF               2881  DONE    SIMHALT             ; halt simulator
00002DE4                          2882  
00002DE4                          2883  * Put variables and constants here
00002DE4                          2884     
00002DE4                          2885         
00002DE4  =00000040               2886  buffer_size         EQU         64 
00002DE4  =00005000               2887  decoded_buffer      EQU         $5000
00002DE4                          2888     
00002DE4  =0000000D               2889  CR                  EQU         $0D
00002DE4  =0000000A               2890  LF                  EQU         $0A
00002DE4  =0000A000               2891  stack               EQU         $0000A000
00002DE4  =00000014               2892  lines_p_screen      EQU         20
00002DE4  =00000003               2893  right3              EQU         3
00002DE4  =00000004               2894  right4              EQU         4
00002DE4  =00000006               2895  right6              EQU         6
00002DE4  =00000008               2896  right8              EQU         8
00002DE4  =00000009               2897  right9              EQU         9
00002DE4  =0000000C               2898  right12             EQU         12
00002DE4  =00000010               2899  right16             EQU         16
00002DE4  =00000018               2900  right24             EQU         24
00002DE4= 20                      2901  ascii_y_n           DC.B        32
00002DE5  =00000059               2902  y_uppercase         EQU         $59         
00002DE5  =00000079               2903  y_lowercase         EQU         $79
00002DE5  =0000004E               2904  n_uppercase         EQU         $4E
00002DE5  =0000006E               2905  n_lowercase         EQU         $6E
00002DE5  =00000002               2906  task2               EQU         $02
00002DE5  =00000005               2907  task5               EQU         $05
00002DE5  =00000009               2908  task9               EQU         $09
00002DE5  =0000000D               2909  task13              EQU         $0D
00002DE5  =0000000E               2910  task14              EQU         $0E
00002DE5  =0000F000               2911  first_nibble        EQU         $F000
00002DE5  =00000F00               2912  second_nibble       EQU         $0F00   
00002DE5  =000000F0               2913  third_nibble        EQU         $00F0
00002DE5  =0000000F               2914  fourth_nibble       EQU         $000F
00002DE5  =000000FF               2915  second_half         EQU         $00FF
00002DE5  =000001C0               2916  dst_mode            EQU         $01C0
00002DE5  =00000E00               2917  dst_reg             EQU         $0E00
00002DE5  =00000038               2918  src_mode            EQU         $0038
00002DE5  =00000007               2919  src_reg             EQU         $0007
00002DE5  =00000100               2920  bit8                EQU         $0100
00002DE5                          2921  
00002DE5  =00000000               2922  ea_type_immediate   EQU     0       ; EA Type = immediate
00002DE5  =00000001               2923  ea_type_move        EQU     1       ; EA Type = move
00002DE5  =00000002               2924  ea_type_movea       EQU     2       ; EA Type = movea
00002DE5  =0000000C               2925  ea_type_movea6      EQU     12      ; EA Type = movea * 6
00002DE5  =00000003               2926  ea_type_lea         EQU     3       ; EA Type = lea
00002DE5  =00000004               2927  ea_type_dstonly     EQU     4       ; EA Type = clr, neg, not, jsr, jmp
00002DE5  =00000005               2928  ea_type_ext         EQU     5       ; EA Type = ext, add, adda
00002DE5  =00000006               2929  ea_type_movem       EQU     6       ; EA Type = movem
00002DE5  =00000007               2930  ea_type_shifts      EQU     7       ; EA Type = ASL/ASR/LSL/LSR/ROL/ROR
00002DE5                          2931  ; ea_type_trap        EQU     7       ; EA Type = trap
00002DE5  =00000008               2932  ea_type_quick       EQU     8       ; EA Type = addq, subq
00002DE5  =00000009               2933  ea_type_branch      EQU     9       ; EA Type = bra, bsr, bcc
00002DE5  =00000000               2934  ea_bcc_flag         EQU     0       ; EA Type = branch, flag = bcc
00002DE5  =00000001               2935  ea_dbcc_flag        EQU     1       ; EA Type = branch, flag = dbcc
00002DE5  =00000002               2936  ea_scc_flag         EQU     2       ; EA Type = branch, flag = scc
00002DE5  =00000007               2937  ea_type_shifts      EQU     7
00002DE5                          2938  
00002DE5= 57 72 6F 6E 67 20 ...   2939  WRONG_SIZE_MESSAGE  DC.B    'Wrong size.',CR,LF,0
00002DF3= 45 52 52 4F 52 3A ...   2940  ABSOLUTE_WRONGREG   DC.B    'ERROR: Register does not exist for Absolute and immediate',CR,LF,0
00002E2F= 45 52 52 4F 52 3A ...   2941  EA_TYPE_ERROR       DC.B    'ERROR: EA type is not supported',CR,LF,0
00002E51= 45 52 52 4F 52 3A ...   2942  DST_INVALID_MSG     DC.B    'ERROR: Destination effective address is invalid',CR,LF,0
00002E83= 45 52 52 4F 52 3A ...   2943  SRC_INVALID_MSG     DC.B    'ERROR: Source effective address is invalid',CR,LF,0
00002EB0= 45 52 52 4F 52 3A ...   2944  EA_INVALID_MSG      DC.B    'ERROR: Invalid addressing mode',CR,LF,0
00002ED1= 45 52 52 4F 52 3A ...   2945  OPCODE_INVALID      DC.B    'ERROR: Opcode is invalid',CR,LF,0
00002EEC= 45 52 52 4F 52 3A ...   2946  ERROR_MESSAGE       DC.B    'ERROR: The input is invalid',CR,LF,0  
00002F0A= 45 52 52 4F 52 3A ...   2947  ODD_ERROR_MESSAGE   DC.B    'ERROR: The last digit of the address is odd, which is invalid',CR,LF,0  
00002F4A                          2948               
00002F4A= 57 65 6C 63 6F 6D ...   2949  WELCOME             DC.B        'Welcome to the 68k Disassembler of Avery and Alan',CR,LF,CR,LF,0
00002F80                          2950  
00002F80= 50 6C 65 61 73 65 ...   2951  USER_INST           DC.B        'Please follow the proper input instructions below: ',CR,LF
00002FB5= 2D 20 53 74 61 72 ...   2952                      DC.B        '- Starting address must be lower than ending address.',CR,LF
00002FEC= 2D 20 54 68 65 20 ...   2953                      DC.B        '- The values for the starting and ending address must be an even value.',CR,LF
00003035= 2D 20 53 74 61 72 ...   2954                      DC.B        '- Starting and ending address must be inputted as hexadecimal value.',CR,LF
0000307B= 2D 20 44 6F 20 6E ...   2955                      DC.B        '- Do not put spaces in between input characters.',CR,LF
000030AD= 2D 20 56 61 6C 69 ...   2956                      DC.B        '- Valid characters include: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F',CR,LF,0
000030FA                          2957                  
000030FA= 50 72 65 73 73 20 ...   2958  ENTER_PROMPT        DC.B        'Press enter to continue...',CR,LF,0
00003117= 50 72 65 73 73 20 ...   2959  PROMPT_AGAIN        DC.B        'Press Y to continue / N to exit.',CR,LF,0
0000313A= 50 72 6F 67 72 61 ...   2960  EXIT_PROMPT         DC.B        'Program has execution has stopped.',CR,LF,0
0000315F                          2961        
0000315F= 45 6E 74 65 72 20 ...   2962  START_IN            DC.B        'Enter a starting address: ',CR,LF,0 
0000317C= 45 6E 74 65 72 20 ...   2963  END_IN              DC.B        'Enter an ending address: ',CR,LF,0 
00003198                          2964  START_ADDRESS       DS.B        32     
000031B8                          2965  END_ADDRESS         DS.B        32 
000031D8                          2966       
000031D8                          2967  
000031D8                          2968      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_IMMEDIATE_ERROR  2DA0
ABSOLUTE_LONG       2D22
ABSOLUTE_WORD       2D16
ABSOLUTE_WRONGREG   2DF3
ADDQ_EA_CALC        2B48
ADD_PARENTHESIS     2A5E
AND_OR_CHECK        227A
AN_CHECK            2D68
AN_FINISH           29A2
ASCII_TO_HEX_LETTER  1084
ASCII_Y_N           2DE4
ATOI                105E
BACK_PARENTHESIS    2A68
BIT8                100
BRANCH_WORD_CHECK   2C44
BUFFER_SIZE         40
CHANGE_TO_001       2096
CHANGE_TO_EIGHT     2B8A
CHECK1_BIT_0        2646
CHECK1_BIT_1        261E
CHECK1_BIT_10       248C
CHECK1_BIT_11       245E
CHECK1_BIT_12       2430
CHECK1_BIT_13       2402
CHECK1_BIT_14       23D4
CHECK1_BIT_2        25F6
CHECK1_BIT_3        25CE
CHECK1_BIT_4        25A0
CHECK1_BIT_5        2572
CHECK1_BIT_6        2544
CHECK1_BIT_7        2516
CHECK1_BIT_8        24E8
CHECK1_BIT_9        24BA
CHECK_BIT_0         295C
CHECK_BIT_1         2934
CHECK_BIT_10        27A4
CHECK_BIT_11        2776
CHECK_BIT_12        2748
CHECK_BIT_13        271A
CHECK_BIT_14        26EC
CHECK_BIT_2         290C
CHECK_BIT_3         28E4
CHECK_BIT_4         28B6
CHECK_BIT_5         2888
CHECK_BIT_6         285A
CHECK_BIT_7         282C
CHECK_BIT_8         27FE
CHECK_BIT_9         27D2
CHECK_IF_ZERO       2AEE
CODE0000            140A
CODE0001            1424
CODE0010            1428
CODE0011            1440
CODE0100            1458
CODE0101            1472
CODE0110            1476
CODE0111            1502
CODE1000            1506
CODE1001            1526
CODE1010            152A
CODE1011            152E
CODE1100            1532
CODE1101            154C
CODE1110            1566
CODE1111            15E4
COMPLETE_END        10E6
COMPLETE_START      10DE
CONTINUE_OR_END     12E0
CR                  D
D4_AN_SETONE_0      2532
D4_AN_SETONE_1      2560
D4_AN_SETONE_2      258E
D4_AN_SETONE_3      25BC
D4_AN_SETONE_4      25E4
D4_AN_SETONE_5      260C
D4_AN_SETONE_6      2634
D4_AN_SETONE_7      265C
D4_AN_SET_0         281A
D4_AN_SET_1         27EE
D4_AN_SET_2         27C0
D4_AN_SET_3         2792
D4_AN_SET_4         2764
D4_AN_SET_5         2736
D4_AN_SET_6         2708
D4_AN_SET_7         26DA
D4_DN_SETONE_0      23C2
D4_DN_SETONE_1      23F0
D4_DN_SETONE_2      241E
D4_DN_SETONE_3      244C
D4_DN_SETONE_4      247A
D4_DN_SETONE_5      24A8
D4_DN_SETONE_6      24D6
D4_DN_SETONE_7      2504
D4_DN_SET_0         2972
D4_DN_SET_1         294A
D4_DN_SET_2         2922
D4_DN_SET_3         28FA
D4_DN_SET_4         28D2
D4_DN_SET_5         28A4
D4_DN_SET_6         2876
D4_DN_SET_7         2848
DECODED_BUFFER      5000
DECODE_MEMORY       1358
DECODE_PAUSE        12CC
DECODING_ITERATION  12A8
DISP_UI             100C
DISP_W              1000
DN_CHECK            2D72
DN_DST              21F6
DN_SRC              2234
DONE                2DE0
DONT_CHANGE         2B8E
DO_ITOA_MOVE        2D5C
DO_ITOA_OPMODE      2D62
DST_INVALID         2DB0
DST_INVALID_MSG     2E51
DST_MODE            1C0
DST_REG             E00
EA_ABSOLUTE_AND_IMMEDIATE  2CFA
EA_ADDA             230A
EA_AN               2C9C
EA_AND              228C
EA_AN_INDIRECT      2CA8
EA_AN_INDIRECT_DEC  2CD4
EA_AN_INDIRECT_INC  2CBC
EA_BCC_FLAG         0
EA_BRANCH           2BFA
EA_CLEAR            20D0
EA_DBCC_FLAG        1
EA_DN               2C90
EA_DSTONLY          20B0
EA_EXT              2162
EA_EXT_TABLE        217E
EA_FINISH           1DDE
EA_GEN_SRC          2C52
EA_GEN_TABLE_SRC    2C60
EA_IMMEDIATE        1F02
EA_INVALID          2DD0
EA_INVALID_MSG      2EB0
EA_JSR              211A
EA_LEA              2032
EA_MEMORY_SHIFTS    2A00
EA_MOVE             1F5A
EA_MOVEA            1FC6
EA_MOVEM            2352
EA_MULS_MULU_DIV    22B4
EA_OPMODE_012456    21AE
EA_OPMODE_37        229C
EA_OR               2292
EA_QUICK            2B38
EA_REGISTER_SHIFTS  2A76
EA_SCC_FLAG         2
EA_SHIFTS           29B6
EA_SHIFTS_TABLE     29D0
EA_SIZE_ADDA        1EB8
EA_SIZE_B           1EE0
EA_SIZE_DONE        1F00
EA_SIZE_GENERAL     1E24
EA_SIZE_L           1EF6
EA_SIZE_MEMORY_SHIFTS  1ECC
EA_SIZE_MOVE        1E40
EA_SIZE_MOVEA       1E5C
EA_SIZE_MOVEM       1E70
EA_SIZE_OPMODE_012456  1E84
EA_SIZE_W           1EEA
EA_SIZE_W_MEMORY    1EF4
EA_START            1DCC
EA_TYPE_BRANCH      9
EA_TYPE_DSTONLY     4
EA_TYPE_ERROR       2E2F
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_SHIFTS      7
EA_TYPE_TABLE       1DE4
EA_UNSUPPORTED      2CEC
EA_WRONG_SIZE       2D90
END_ADDRESS         31B8
END_IN              317C
ENTER_PROMPT        30FA
ERROR_MESSAGE       2EEC
EXIT                1348
EXIT_PROMPT         313A
FINISH_MOVEM_MEM_TO_REG  2984
FINISH_REG_TO_MEM   266E
FIRST_NIBBLE        F000
FOURTH_NIBBLE       F
FOURTH_NIBBLE_CHECK  2C2E
FRONT_FORMAT        2A50
IMMEDIATE           2D2E
IMMEDIATE_CHECK     2D7C
IMMEDIATE_EIGHT     2AF8
IMMEDIATE_SRC       2AAA
INPUT_INVALID       10A6
ITOA                1114
ITOA_BYTE           119C
ITOA_BYTE_BRANCH    11AA
ITOA_BYTE_CONVERT   1264
ITOA_CONVERT_A_TO_F  1294
ITOA_DONE           12A0
ITOA_LONG           11FA
ITOA_LONGADDRESS    122C
ITOA_MOVE           1136
ITOA_NIBBLE_CONVERT  1284
ITOA_OPMODE         1158
ITOA_WORD           11BC
ITOA_WORD_BRANCH    11D8
JSR_EA_VALID        2158
JSR_NOP_RTS         182E
LAST_DIGIT_CHECK    10C4
LAST_DIGIT_ODD      10F8
LEA_SRC_VALID       2070
LF                  A
LINES_P_SCREEN      14
MEMORY_1110_LEFT    159C
MEMORY_1110_RIGHT   15C0
MEM_TO_REG          2694
MEM_TO_REG_CONTINUE  26BC
MOVEA_DST_VALID     2028
MOVEQ_EA_CALC       2BB8
NOP_CHECK           185C
NOP_CHECK_THREE     188C
NOP_CHECK_TWO       1874
NORMAL_FINISH       29B0
N_LOWERCASE         6E
N_UPPERCASE         4E
ODD_ERROR_MESSAGE   2F0A
OPCODE_INVALID      2ED1
OP_0000_TABLE       15E8
OP_0100_TABLE       1648
OP_1100_TABLE       16A8
OP_1101_TABLE       1708
OP_1110_TABLE_REGISTER  1768
OP_ADD              1CE8
OP_ADDA             1D04
OP_ADDI             191C
OP_ADDQ             1A18
OP_AND              1CCC
OP_ASL              1D40
OP_ASR              1D24
OP_AS_CHECK         17C8
OP_BCC              1AA8
OP_BCS              1AC4
OP_BEQ              1AFC
OP_BGE              1B88
OP_BGT              1BC0
OP_BHI              1A70
OP_BLE              1BDC
OP_BLS              1A8C
OP_BLT              1BA4
OP_BMI              1B6C
OP_BNE              1AE0
OP_BPL              1B50
OP_BRA              1A38
OP_BSR              1A54
OP_BVC              1B18
OP_BVS              1B34
OP_CLEAR_DATA       1394
OP_CLEAR_DATA_LOOP  13A0
OP_CLR              1980
OP_CMP              1C70
OP_DIVU             1C1C
OP_FINISH           138E
OP_JSR              19BC
OP_LEA              19FC
OP_LSL              1D78
OP_LSR              1D5C
OP_LS_CHECK         17EA
OP_MOVE             1960
OP_MOVEA            193C
OP_MOVEM            19D8
OP_MOVEQ            1BF8
OP_MULS             1CAC
OP_MULU             1C8C
OP_NOP              199C
OP_OR               1C3C
OP_ROL              1DB0
OP_ROR              1D94
OP_RO_CHECK         180C
OP_RTS              19AC
OP_SUB              1C54
OP_SUBI             18FC
OP_TABLE            13AA
OP_UNSUPPORTED      18EC
PRINT1_A0           253A
PRINT1_A1           2568
PRINT1_A2           2596
PRINT1_A3           25C4
PRINT1_A4           25EC
PRINT1_A5           2614
PRINT1_A6           263C
PRINT1_A7           2664
PRINT1_D0           23CA
PRINT1_D1           23F8
PRINT1_D2           2426
PRINT1_D3           2454
PRINT1_D4           2482
PRINT1_D5           24B0
PRINT1_D6           24DE
PRINT1_D7           250C
PRINT_A0            2822
PRINT_A1            27F4
PRINT_A2            27C8
PRINT_A3            279A
PRINT_A4            276C
PRINT_A5            273E
PRINT_A6            2710
PRINT_A7            26E2
PRINT_D0            297A
PRINT_D1            2952
PRINT_D2            292A
PRINT_D3            2902
PRINT_D4            28DA
PRINT_D5            28AC
PRINT_D6            287E
PRINT_D7            2850
PROMPT_AGAIN        3117
PROMPT_END          103E
PROMPT_START        1018
READ_END            104A
READ_START          102A
REGISTER_CHECK      2D86
REGISTER_SRC        2AFE
REG_TO_MEM          23A4
RIGHT12             C
RIGHT16             10
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT6              6
RIGHT8              8
RIGHT9              9
RTS_CHECK           18A4
RTS_CHECK_THREE     18D4
RTS_CHECK_TWO       18BC
SECOND_HALF         FF
SECOND_NIBBLE       F00
SRC_INVALID         2DC0
SRC_INVALID_MSG     2E83
SRC_MODE            38
SRC_REG             7
STACK               A000
START               1000
START_ADDRESS       3198
START_DECODING      12A6
START_IN            315F
TASK13              D
TASK14              E
TASK2               2
TASK5               5
TASK9               9
THIRD_NIBBLE        F0
USER_INST           2F80
VALIDATE_END        105A
VALIDATE_START      103A
WELCOME             2F4A
WRONG_SIZE_MESSAGE  2DE5
Y_LOWERCASE         79
Y_UPPERCASE         59
