00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/8/2020 11:25:31 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler for the Motorola MC68000 Microprocessor
00000000                             3  * Written by :  Avery Mortenson & Alan Luu
00000000                             4  * Date       :  2/12/2020
00000000                             5  * Description:  An inverse assembler (disassembler) that will 
00000000                             6  * convert a memory image of instructions and data back 
00000000                             7  * to the MC68000 assembly code and that will output the 
00000000                             8  * disassembled code to the display.
00000000                             9  *-----------------------------------------------------------
00001000                            10      ORG    $1000
00001000                            11  START:            
00001000                            12  *------------------------------------------------------------*
00001000                            13  * D0: used for the tasks
00001000                            14  * D1: used to hold the size of the input obtained. 
00001000                            15  * D5: used to store the starting and ending address 
00001000                            16  * temporarily before moving them to A4 and A6 correspondingly. 
00001000                            17  * D6: used to check the last digit to see if the input 
00001000                            18  * for the starting and ending address causes a bus error. 
00001000                            19  * A1: a pointer to the message to print out. 
00001000                            20  *------------------------------------------------------------*
00001000                            21  
00001000  103C 000E                 22  DISP_W      MOVE.B  #14,D0                  ; Display Welcome Message. 
00001004  43F9 00002E72             23              LEA     WELCOME,A1
0000100A  4E4F                      24              TRAP    #15
0000100C                            25  
0000100C                            26  * Put program code here
0000100C                            27  
0000100C  103C 000E                 28  DISP_UI         MOVE.B  #14,D0              ; Display User Instructions. 
00001010  43F9 00002EA8             29                  LEA     USER_INST,A1
00001016  4E4F                      30                  TRAP    #15    
00001018                            31  
00001018  4FF9 0000A000             32  PROMPT_START    LEA     stack, SP           ; SP = stack ($A0000)
0000101E  43F9 00003087             33                  LEA     START_IN,A1         ; Display starting address message
00001024  103C 000E                 34                  MOVE.B  #14,D0
00001028  4E4F                      35                  TRAP    #15       
0000102A                            36       
0000102A  43F9 000030C0             37  READ_START      LEA     START_ADDRESS,A1    ; Store user's starting address input
00001030  103C 0002                 38                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001034  4E4F                      39                  TRAP    #15
00001036  1C3C 0000                 40                  MOVE.B  #0,D6               ; Used to indicate we are at start address
0000103A                            41  
0000103A  6000 0022                 42  VALIDATE_START  BRA     ATOI
0000103E                            43  
0000103E  43F9 000030A4             44  PROMPT_END      LEA     END_IN,A1           ; Display starting address message
00001044  103C 000E                 45                  MOVE.B  #14,D0
00001048  4E4F                      46                  TRAP    #15            
0000104A  43F9 000030E0             47  READ_END        LEA     END_ADDRESS,A1      ; Store user's starting address input
00001050  103C 0002                 48                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001054  4E4F                      49                  TRAP    #15
00001056  1C3C 0001                 50                  MOVE.B  #1,D6               ; Used to indicate we are at end address
0000105A                            51  
0000105A  6000 0002                 52  VALIDATE_END    BRA     ATOI
0000105E                            53                 
0000105E                            54  * D0 stores the value to pushed from A1.
0000105E                            55  
0000105E  1019                      56  ATOI            MOVE.B  (A1)+,D0    ; Move to next character in A1 and store in D0          
00001060  B03C 0030                 57                  CMP.B   #$30,D0
00001064  6D00 0040                 58                  BLT     INPUT_INVALID
00001068  B03C 0039                 59                  CMP.B   #$39,D0
0000106C  6E00 0016                 60                  BGT     ASCII_TO_HEX_LETTER
00001070  0400 0030                 61                  SUB.B   #$30,D0     ; Subtract by 30 to get the numbers 0-9
00001074  DA80                      62                  ADD.L   D0,D5
00001076  5341                      63                  SUBI    #1,D1       ; Decrement input's length to move to next character          
00001078  B23C 0000                 64                  CMP.B   #0,D1       ; Compare to see if we're at the last digit
0000107C  6700 0046                 65                  BEQ     LAST_DIGIT_CHECK
00001080  E98D                      66                  LSL.L   #4,D5
00001082  60DA                      67                  BRA     ATOI
00001084                            68  
00001084                            69    
00001084  B03C 0041                 70  ASCII_TO_HEX_LETTER     CMP.B   #$41,D0
00001088  6D00 001C                 71                          BLT     INPUT_INVALID
0000108C  B03C 0046                 72                          CMP.B   #$46, D0
00001090  6E00 0014                 73                          BGT     INPUT_INVALID 
00001094  0400 0031                 74                          SUB.B   #$31,D0     ; Subtract by 31 to get the numbers A-F
00001098  5D00                      75                          SUB.B   #6,D0
0000109A  DA80                      76                          ADD.L   D0,D5
0000109C  5341                      77                          SUBI    #1,D1
0000109E  6700 0024                 78                          BEQ     LAST_DIGIT_CHECK
000010A2  E98D                      79                          LSL.L   #4,D5
000010A4  60B8                      80                          BRA     ATOI     
000010A6                            81  
000010A6                            82                      
000010A6  43F9 00002E14             83  INPUT_INVALID   LEA     ERROR_MESSAGE, A1   ; Display error message
000010AC  103C 000E                 84                  MOVE.B  #14, D0
000010B0  4E4F                      85                  TRAP    #15
000010B2  4206                      86                  CLR.B   D6
000010B4                            87                  
000010B4  BC3C 0000                 88                  CMP.B   #0,D6           ; When D6 is 0
000010B8  6700 FF5E                 89                  BEQ     PROMPT_START    ; Go back to start prompt
000010BC  BC3C 0001                 90                  CMP.B   #1,D6           ; When D6 is 1
000010C0  6700 FF7C                 91                  BEQ     PROMPT_END      ; Go back to end prompt
000010C4                            92  
000010C4                            93                            
000010C4  2E05                      94  LAST_DIGIT_CHECK    MOVE.L  D5, D7          ; D7 used as temporary storage
000010C6  E20F                      95                      LSR.B   #1, D7          ; Check for carry bit to see if last digit is odd
000010C8  6500 002E                 96                      BCS     LAST_DIGIT_ODD  ; branch when there is a carry; this indicates odd last digit 
000010CC  4287                      97                      CLR.L   D7
000010CE  BC3C 0000                 98                      CMP.B   #0,D6
000010D2  6700 000A                 99                      BEQ     COMPLETE_START  
000010D6  BC3C 0001                100                      CMP.B   #1,D6
000010DA  6700 000A                101                      BEQ     COMPLETE_END
000010DE                           102  
000010DE  2845                     103  COMPLETE_START      MOVEA.L D5, A4  ; A4 holds the starting address
000010E0  4285                     104                      CLR.L   D5 
000010E2  6000 FF5A                105                      BRA PROMPT_END
000010E6                           106  
000010E6  2C45                     107  COMPLETE_END        MOVEA.L D5, A6  ; A6 holds the ending address
000010E8  2A4C                     108                      MOVEA.L A4, A5  ; Store starting address into current address
000010EA                           109                      
000010EA                           110                      *Clear the data and address registers used to obtain the starting and ending address 
000010EA  4280                     111                      CLR.L   D0
000010EC  4285                     112                      CLR.L   D5
000010EE  4286                     113                      CLR.L   D6
000010F0  327C 0000                114                      MOVEA   #0, A1
000010F4  6000 01B0                115                      BRA     START_DECODING  ; All inputs are valid, go to the decode process
000010F8                           116                      
000010F8  43F9 00002E32            117  LAST_DIGIT_ODD      LEA     ODD_ERROR_MESSAGE, A1 
000010FE  103C 000E                118                      MOVE.B  #14, D0
00001102  4E4F                     119                      TRAP    #15
00001104                           120                      
00001104  BC3C 0000                121                      CMP.B   #0,D6           ; When D6 is 0
00001108  6700 FF0E                122                      BEQ     PROMPT_START    ; Go back to start prompt
0000110C  BC3C 0001                123                      CMP.B   #1,D6           ; When D6 is 1
00001110  6700 FF2C                124                      BEQ     PROMPT_END      ; Go back to end prompt
00001114                           125  
00001114                           126  *--------------------------------------------------------------------------------------
00001114                           127  * param D2 data size to convert into ASCII
00001114                           128  * param A2 a pointer to decode_buf
00001114                           129  * param A5 the current address
00001114                           130  * itoa (D2, A2, A5) {
00001114                           131  * D0 byte data in ACII
00001114                           132  * D1 #sfhit
00001114                           133  * D7 long data to convert into ASCII
00001114                           134  * }
00001114                           135          
00001114                           136  ITOA                                ; convert integer to ASCII  
00001114  48E7 C000                137          MOVEM.L D0-D1,-(SP) 
00001118  B43C 0000                138          CMP.B   #%00, D2            ; byte
0000111C  6700 007E                139          BEQ     ITOA_BYTE
00001120  B43C 0001                140          CMP.B   #%01, D2            ; word
00001124  6700 0096                141          BEQ     ITOA_WORD
00001128  B43C 0002                142          CMP.B   #%10, D2            ; long
0000112C  6700 00CC                143          BEQ     ITOA_LONG
00001130  4EF9 0000122C            144          JMP     ITOA_LONGADDRESS    ; long address
00001136                           145          
00001136                           146  ITOA_MOVE                           ; convert integer to ASCII
00001136  48E7 C000                147          MOVEM.L D0-D1,-(SP) 
0000113A  B43C 0001                148          CMP.B   #%01, D2            ; byte
0000113E  6700 005C                149          BEQ     ITOA_BYTE
00001142  B43C 0003                150          CMP.B   #%11, D2            ; word
00001146  6700 0074                151          BEQ     ITOA_WORD
0000114A  B43C 0002                152          CMP.B   #%10,D2             ; long
0000114E  6700 00AA                153          BEQ     ITOA_LONG
00001152  4EF9 0000122C            154          JMP     ITOA_LONGADDRESS    ; long address
00001158                           155          
00001158                           156  ITOA_OPMODE                         ; convert integer to ASCII
00001158  48E7 C000                157          MOVEM.L D0-D1,-(SP) 
0000115C  B43C 0000                158          CMP.B   #%000,D2            ; When 0 then byte
00001160  6700 003A                159          BEQ     ITOA_BYTE
00001164  B43C 0004                160          CMP.B   #%100,D2            ; When 4 then byte
00001168  6700 0032                161          BEQ     ITOA_BYTE 
0000116C  B43C 0001                162          CMP.B   #%001,D2            ; When 1 then word
00001170  6700 004A                163          BEQ     ITOA_WORD
00001174  B43C 0003                164          CMP.B   #%011,D2            ; When 3 then word
00001178  6700 0042                165          BEQ     ITOA_WORD
0000117C  B43C 0005                166          CMP.B   #%101,D2            ; When 5 then word
00001180  6700 003A                167          BEQ     ITOA_WORD 
00001184  B43C 0002                168          CMP.B   #%010,D2            ; When 2 then long
00001188  6700 0070                169          BEQ     ITOA_LONG
0000118C  B43C 0006                170          CMP.B   #%110,D2            ; When 6 then long
00001190  6700 0068                171          BEQ     ITOA_LONG
00001194  B43C 0007                172          CMP.B   #%111,D2            ; When 7 then long
00001198  6700 0060                173          BEQ     ITOA_LONG
0000119C                           174          
0000119C                           175  ITOA_BYTE
0000119C  3E1D                     176          MOVE.W  (A5)+,D7
0000119E  4EB9 00001264            177          JSR     ITOA_BYTE_CONVERT
000011A4  4EF9 000012A0            178          JMP     ITOA_DONE
000011AA                           179  
000011AA                           180  ITOA_BYTE_BRANCH
000011AA  48E7 C000                181          MOVEM.L D0-D1,-(SP)
000011AE  3E05                     182          MOVE.W  D5,D7
000011B0  4EB9 00001264            183          JSR     ITOA_BYTE_CONVERT
000011B6  4EF9 000012A0            184          JMP     ITOA_DONE
000011BC                           185          
000011BC                           186  ITOA_WORD
000011BC  3E15                     187          MOVE.W  (A5),D7
000011BE  123C 0008                188          MOVE.B  #right8, D1
000011C2  E26F                     189          LSR.W   D1,D7
000011C4  4EB9 00001264            190          JSR     ITOA_BYTE_CONVERT
000011CA  3E1D                     191          MOVE.W  (A5)+, D7
000011CC  4EB9 00001264            192          JSR     ITOA_BYTE_CONVERT
000011D2  4EF9 000012A0            193          JMP     ITOA_DONE
000011D8                           194          
000011D8                           195  ITOA_WORD_BRANCH
000011D8  48E7 C000                196          MOVEM.L D0-D1,-(SP) 
000011DC  3E05                     197          MOVE.W  D5,D7
000011DE  123C 0008                198          MOVE.B  #right8, D1
000011E2  E26F                     199          LSR.W   D1,D7
000011E4  4EB9 00001264            200          JSR     ITOA_BYTE_CONVERT
000011EA  3E05                     201          MOVE.W  D5, D7
000011EC  361D                     202          MOVE.W  (A5)+, D3
000011EE  4EB9 00001264            203          JSR     ITOA_BYTE_CONVERT
000011F4  4EF9 000012A0            204          JMP     ITOA_DONE
000011FA                           205          
000011FA                           206  ITOA_LONG
000011FA  3E15                     207          MOVE.W  (A5),D7
000011FC  123C 0008                208          MOVE.B  #right8, D1
00001200  E26F                     209          LSR.W   D1, D7
00001202  4EB9 00001264            210          JSR     ITOA_BYTE_CONVERT
00001208  3E1D                     211          MOVE.W  (A5)+, D7
0000120A  4EB9 00001264            212          JSR     ITOA_BYTE_CONVERT
00001210                           213          
00001210  3E15                     214          MOVE.W  (A5),D7
00001212  123C 0008                215          MOVE.B  #right8, D1
00001216  E26F                     216          LSR.W   D1, D7
00001218  4EB9 00001264            217          JSR     ITOA_BYTE_CONVERT
0000121E  3E1D                     218          MOVE.W  (A5)+, D7
00001220  4EB9 00001264            219          JSR     ITOA_BYTE_CONVERT
00001226  4EF9 000012A0            220          JMP     ITOA_DONE
0000122C                           221  
0000122C                           222  ITOA_LONGADDRESS
0000122C  3E0D                     223          MOVE.W  A5,D7
0000122E  123C 0018                224          MOVE.B  #right24,D1
00001232  E26F                     225          LSR.W   D1,D7
00001234  4EB9 00001264            226          JSR     ITOA_BYTE_CONVERT
0000123A  3E0D                     227          MOVE.W  A5,D7
0000123C  123C 0010                228          MOVE.B  #right16,D1
00001240  E26F                     229          LSR.W   D1,D7
00001242  4EB9 00001264            230          JSR     ITOA_BYTE_CONVERT
00001248  3E0D                     231          MOVE.W  A5,D7
0000124A  123C 0008                232          MOVE.B  #right8,D1
0000124E  E26F                     233          LSR.W   D1,D7
00001250  4EB9 00001264            234          JSR     ITOA_BYTE_CONVERT
00001256  3E0D                     235          MOVE.W  A5,D7
00001258  4EB9 00001264            236          JSR     ITOA_BYTE_CONVERT   
0000125E  4EF9 000012A0            237          JMP     ITOA_DONE   
00001264                           238  
00001264                           239  ITOA_BYTE_CONVERT
00001264  3007                     240          MOVE.W  D7, D0 
00001266  0240 00F0                241          ANDI.W  #$F0, D0
0000126A  123C 0004                242          MOVE.B  #right4, D1
0000126E  E268                     243          LSR.W   D1, D0
00001270  4EB9 00001284            244          JSR     ITOA_NIBBLE_CONVERT
00001276                           245          
00001276  3007                     246          MOVE.W  D7, D0
00001278  0240 000F                247          ANDI.W  #$0F, D0
0000127C  4EB9 00001284            248          JSR     ITOA_NIBBLE_CONVERT
00001282  4E75                     249          RTS
00001284                           250          
00001284                           251  ITOA_NIBBLE_CONVERT
00001284  B03C 0009                252          CMP.B   #9, D0
00001288  6E00 000A                253          BGT     ITOA_CONVERT_A_TO_F
0000128C  0600 0030                254          ADD.B   #$30, D0
00001290  14C0                     255          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
00001292  4E75                     256          RTS
00001294                           257          
00001294                           258  ITOA_CONVERT_A_TO_F
00001294  0400 000A                259          SUBI.B  #10, D0
00001298  0600 0041                260          ADDI.B  #$41, D0
0000129C  14C0                     261          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
0000129E  4E75                     262          RTS
000012A0                           263  
000012A0                           264  ITOA_DONE
000012A0  4CDF 0003                265          MOVEM.L (SP)+, D0-D1
000012A4  4E75                     266          RTS
000012A6                           267  
000012A6                           268  *-------------------------------------------------------------------------------*
000012A6                           269  START_DECODING
000012A6  4282                     270          CLR.L   D2
000012A8                           271          
000012A8                           272  DECODING_ITERATION
000012A8                           273          ;decoding the current address
000012A8  4EB9 00001330            274          JSR     DECODE_MEMORY
000012AE  103C 000D                275          MOVE.B  #task13, D0
000012B2  43F9 00005000            276          LEA     decoded_buffer, A1
000012B8  4E4F                     277          TRAP    #15
000012BA                           278          
000012BA                           279          ;check if decoding has finished or if the screen is filled 
000012BA  BDCD                     280          CMP.L   A5, A6
000012BC  6F00 0022                281          BLE     CONTINUE_OR_END     ; If A6-A5 <= 0, go to CONTINUE_OR_END 
000012C0                           282          
000012C0                           283          ;have yet to reach the ending address
000012C0  5202                     284          ADDQ.B  #1, D2              ; D2 (screen_line_counter)++
000012C2  B43C 0014                285          CMP.B   #lines_p_screen, D2
000012C6  6C00 0004                286          BGE     DECODE_PAUSE
000012CA                           287          ;not yet reached the maximum lines per screen. 
000012CA  60DC                     288          BRA     DECODING_ITERATION
000012CC                           289  
000012CC                           290  DECODE_PAUSE
000012CC  103C 000E                291          MOVE.B  #task14, D0
000012D0  43F9 00003022            292          LEA     ENTER_PROMPT, A1
000012D6  4E4F                     293          TRAP    #15
000012D8  103C 0005                294          MOVE.B  #task5, D0
000012DC  4E4F                     295          TRAP    #15
000012DE  60C6                     296          BRA     START_DECODING
000012E0                           297  
000012E0                           298  CONTINUE_OR_END
000012E0  103C 000E                299          MOVE.B  #task14, D0
000012E4  43F9 0000303F            300          LEA     PROMPT_AGAIN, A1
000012EA  4E4F                     301          TRAP    #15
000012EC                           302          
000012EC  103C 0002                303          MOVE.B  #task2, D0
000012F0  43F9 00002D0C            304          LEA     ascii_y_n, A1
000012F6  4E4F                     305          TRAP    #15
000012F8                           306          
000012F8  1639 00002D0C            307          MOVE.B  ascii_y_n, D3
000012FE  0C03 0059                308          CMPI.B  #y_uppercase, D3
00001302  6700 FD14                309          BEQ     PROMPT_START
00001306  0C03 0079                310          CMPI.B  #y_lowercase, D3
0000130A  6700 FD0C                311          BEQ     PROMPT_START
0000130E  0C03 004E                312          CMPI.B  #n_uppercase, D3
00001312  6700 000C                313          BEQ     EXIT
00001316  0C03 006E                314          CMPI.B  #n_lowercase, D3
0000131A  6700 0004                315          BEQ     EXIT
0000131E  60C0                     316          BRA     CONTINUE_OR_END 
00001320                           317          
00001320                           318  EXIT
00001320  103C 000E                319          MOVE.B  #task14, D0
00001324  43F9 00003062            320          LEA     EXIT_PROMPT, A1
0000132A  4E4F                     321          TRAP    #15  
0000132C  6000 19DA                322          BRA     DONE             
00001330                           323  *---------------------------------------------------------------------------------*
00001330                           324  * D0: the current instruction. 
00001330                           325  * D1: used as temp storage
00001330                           326  * D2: data size 
00001330                           327  * D3: loop counter for the amount of lines per screen. 
00001330                           328  * D4: 
00001330                           329  * D5: #shifts
00001330                           330  * D6: store first nibble
00001330                           331  * D7: 
00001330                           332  * A0: 
00001330                           333  * A1: A pointer to the message to print out. 
00001330                           334  * A2: A pointer to the decode_buffer. 
00001330                           335  * A3: 
00001330                           336  * A4: Store the starting address and increment to the ending address. 
00001330                           337  * A5: The current address. 
00001330                           338  * A6: Store the ending address. 
00001330                           339  * A7: Stack pointer. 
00001330                           340  *---------------------------------------------------------------------------------*                             
00001330                           341  DECODE_MEMORY       
00001330  48E7 2002                342          MOVEM.L D2/A6, -(SP)
00001334                           343                  
00001334                           344          ;zero clear the decode_buffer
00001334  4EB9 0000136C            345          JSR     OP_CLEAR_DATA
0000133A  45F9 00005000            346          LEA     decoded_buffer, A2  Load decode buffer into A2
00001340                           347                  
00001340                           348          ;print out the current address
00001340  7403                     349          MOVE.L  #$0003, D2
00001342  4EB8 1114                350          JSR      ITOA
00001346                           351          
00001346  14FC 0009                352          MOVE.B  #$9, (A2)+  ; Add space after long address
0000134A                           353                  
0000134A                           354          ;load the next instruction and jump to the opcode table entry
0000134A  41F9 00001382            355          LEA     OP_TABLE, A0
00001350  4280                     356          CLR.L   D0
00001352  301D                     357          MOVE.W  (A5)+, D0       ; Store A5's value into D0, then increment A5
00001354  2200                     358          MOVE.L  D0, D1          ; Store A5's value from D0 into D1
00001356  1A3C 000C                359          MOVE.B  #right12, D5    ; Store 12 into D5
0000135A  EA69                     360          LSR.W   D5, D1          ; Shift first nibble into LSB position
0000135C  2C01                     361          MOVE.L  D1, D6          ; Store first nibble into D6
0000135E  C2FC 0006                362          MULU    #6, D1          ; Multiply 6 to D1
00001362  4EF0 1000                363          JMP     0(A0, D1)       ; Go to displacement (A0 + D1 * 6)      
00001366                           364  OP_FINISH
00001366  4CDF 4004                365          MOVEM.L (SP)+, D2/A6,
0000136A  4E75                     366          RTS
0000136C                           367  
0000136C                           368  *------------------------------------------------------------------------------------*
0000136C                           369  *Clear the 32 bits within the decoded_buffer       
0000136C                           370  OP_CLEAR_DATA
0000136C  4283                     371          CLR.L   D3
0000136E  163C 0040                372          MOVE.B  #buffer_size, D3
00001372  45F9 00005000            373          LEA     decoded_buffer, A2
00001378                           374          
00001378                           375  OP_CLEAR_DATA_LOOP
00001378  14FC 0000                376          MOVE.B  #0, (A2)+
0000137C  5343                     377          SUBI    #1, D3
0000137E  6EF8                     378          BGT     OP_CLEAR_DATA_LOOP
00001380  4E75                     379          RTS
00001382                           380  
00001382                           381  *------------------------------------------------------------------------------------*
00001382                           382  OP_TABLE
00001382  4EF9 000013E2            383          JMP     code0000    ; ADDI.bwl/ ANDI.bwl / CMPI.bwl / EORI.bwl / ORI.bwl / SUBI.bwl 
00001388  4EF9 000013FC            384          JMP     code0001    ; MOVE.b
0000138E  4EF9 00001400            385          JMP     code0010    ; MOVE.l / MOVEA.l
00001394  4EF9 00001418            386          JMP     code0011    ; MOVE.w / MOVEA.w
0000139A  4EF9 00001430            387          JMP     code0100    ; CLR.bwl / JMP / JSR / LEA / MOVEM.wl / NOP / NOT.bwl / RTS / STOP / TRAP
000013A0  4EF9 0000144A            388          JMP     code0101    ; ADDQ.bwl / SUBQ.bwl / Scc / Dbcc
000013A6  4EF9 0000144E            389          JMP     code0110    ; BRA.bw / BSR.bw / Bcc.bw
000013AC  4EF9 000014DA            390          JMP     code0111    ; MOVEQ
000013B2  4EF9 000014DE            391          JMP     code1000    ; DIVS / DIVU / CR.bwl
000013B8  4EF9 000014FE            392          JMP     code1001    ; SUB.bwl / SUBA.wl
000013BE  4EF9 00001502            393          JMP     code1010    ;   [unassigned]
000013C4  4EF9 00001506            394          JMP     code1011    ; CMP.bwl / CMPA.wl / EOR.bwl
000013CA  4EF9 0000150A            395          JMP     code1100    ; MULS / MULU / AND.bwl
000013D0  4EF9 00001524            396          JMP     code1101    ; ADD.bwl / ADDA.wl / ADDX.bwl
000013D6  4EF9 0000153E            397          JMP     code1110    ; ASL.bwl / ASR.bwl / LSL.bwl / LSR.bwl / ROR.bwl / ROL.bwl
000013DC  4EF9 000015BC            398          JMP     code1111    ;   [unassigned]
000013E2                           399          
000013E2                           400  code0000                            ; Opcodes ADDI and SUBI
000013E2  2200                     401          MOVE.L  D0,D1               ; D0 is current instruction word
000013E4  0241 0F00                402          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
000013E8  1A3C 0008                403          MOVE.B  #right8,D5          ; Used to shift 8 times to right
000013EC  EA69                     404          LSR.W   D5,D1               ; Shift nibble into LSB position
000013EE  C2FC 0006                405          MULU    #6, D1              ; Set displacement 
000013F2  41F9 000015C0            406          LEA     OP_0000_TABLE,A0    ; Load table into A0
000013F8  4EF0 1000                407          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000013FC                           408  
000013FC                           409  code0001                            ; Opcode MOVE.B
000013FC  6000 04AA                410          BRA     OP_MOVE             ; Go to opcode MOVE
00001400                           411  
00001400                           412  code0010                            ; Opcodes MOVE.L and MOVEA.L 
00001400  2200                     413          MOVE.L  D0,D1               ; D0 is current instruction word
00001402  0241 01C0                414          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001406  1A3C 0006                415          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000140A  EA69                     416          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000140C  B23C 0001                417          CMP.B   #1, D1              ; When 001 in destination mode
00001410  6700 0472                418          BEQ     OP_MOVEA            ; Go to opcode MOVEA
00001414  6000 0492                419          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001418                           420  
00001418                           421  code0011                            ; Opcodes MOVE.W and MOVEA.W 
00001418  2200                     422          MOVE.L  D0,D1               ; D0 is current instruction word
0000141A  0241 01C0                423          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000141E  1A3C 0006                424          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001422  EA69                     425          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001424  B23C 0001                426          CMP.B   #1, D1              ; When 001 in destination mode
00001428  6700 045A                427          BEQ     OP_MOVEA            ; Go to opcode MOVEA
0000142C  6000 047A                428          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001430                           429  
00001430                           430  code0100                            ; Opcodes CLR, JSR, LEA, MOVEM, NOP, RTS
00001430  2200                     431          MOVE.L  D0,D1               ; D0 is current instruction word
00001432  0241 0F00                432          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
00001436  1A3C 0008                433          MOVE.B  #right8,D5          ; Used to shift 8 times to right
0000143A  EA69                     434          LSR.W   D5,D1               ; Shift nibble into LSB position
0000143C  C2FC 0006                435          MULU    #6, D1              ; Set displacement 
00001440  41F9 00001620            436          LEA     OP_0100_TABLE,A0    ; Load table into A0
00001446  4EF0 1000                437          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
0000144A                           438  
0000144A                           439  code0101                            ; Opcode ADDQ.B/W/L
0000144A  6000 0520                440          BRA     OP_ADDQ             ; Go to opcode ADDQ
0000144E                           441  
0000144E                           442  code0110                            ; Opcodes BRA / BSR / BHI
0000144E  2200                     443          MOVE.L  D0,D1               ; D0 is current instruction word
00001450  0241 0F00                444          ANDI.W  #second_nibble,D1   ; Extract 2nd 4 bits from instruction word
00001454  1A3C 0008                445          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001458  EA69                     446          LSR.W   D5,D1               ; Shift nibble into LSB position
0000145A  B23C 0000                447          CMP.B   #0, D1              ; When 0000 in second nibble 
0000145E  6700 052C                448          BEQ     OP_BRA              ; Go to opcode BRA
00001462  B23C 0001                449          CMP.B   #1, D1              ; When 0001 in second nibble 
00001466  6700 0540                450          BEQ     OP_BSR              ; Go to opcode BSR
0000146A  B23C 0002                451          CMP.B   #2, D1              ; When 0010 in second nibble 
0000146E  6700 0554                452          BEQ     OP_BHI              ; Go to opcode BHI
00001472  B23C 0003                453          CMP.B   #3, D1              ; When 0011 in second nibble
00001476  6700 0568                454          BEQ     OP_BLS              ; Go to opcode BLS
0000147A  B23C 0004                455          CMP.B   #4, D1              ; When 0100 in second nibble
0000147E  6700 057C                456          BEQ     OP_BCC              ; Go to opcode BCC
00001482  B23C 0005                457          CMP.B   #5, D1              ; When 0101 in second nibble
00001486  6700 0590                458          BEQ     OP_BCS              ; Go to opcode BCS
0000148A  B23C 0006                459          CMP.B   #6, D1              ; When 0110 in second nibble
0000148E  6700 05A4                460          BEQ     OP_BNE              ; Go to opcode BNE
00001492  B23C 0007                461          CMP.B   #7, D1              ; When 0111 in second nibble
00001496  6700 05B8                462          BEQ     OP_BEQ              ; Go to opcode BEQ
0000149A  B23C 0008                463          CMP.B   #8, D1              ; When 1000 in second nibble
0000149E  6700 05CC                464          BEQ     OP_BVC              ; Go to opcode BVC
000014A2  B23C 0009                465          CMP.B   #9, D1              ; When 1001 in second nibble
000014A6  6700 05E0                466          BEQ     OP_BVS              ; Go to opcode BVS
000014AA  B23C 000A                467          CMP.B   #10, D1             ; When 1010 in second nibble
000014AE  6700 05F4                468          BEQ     OP_BPL              ; Go to opcode BPL
000014B2  B23C 000B                469          CMP.B   #11, D1             ; When 1011 in second nibble
000014B6  6700 0608                470          BEQ     OP_BMI              ; Go to opcode BMI
000014BA  B23C 000C                471          CMP.B   #12, D1             ; When 1100 in second nibble
000014BE  6700 061C                472          BEQ     OP_BGE              ; Go to opcode BGE
000014C2  B23C 000D                473          CMP.B   #13, D1             ; When 1101 in second nibble
000014C6  6700 0630                474          BEQ     OP_BLT              ; Go to opcode BLT
000014CA  B23C 000E                475          CMP.B   #14, D1             ; When 1110 in second nibble
000014CE  6700 0644                476          BEQ     OP_BGT              ; Go to opcode BGT
000014D2  B23C 000F                477          CMP.B   #15, D1             ; When 1111 in second nibble
000014D6  6700 0658                478          BEQ     OP_BLE              ; Go to opcode BLE
000014DA                           479  
000014DA                           480  code0111                            ; Opcode MOVEQ
000014DA  6000 0670                481          BRA     OP_MOVEQ            ; Go to opcode MOVEQ
000014DE                           482  
000014DE                           483  code1000                            ; Opcodes DIVU word and OR.B/W/L
000014DE  2200                     484          MOVE.L  D0,D1               ; D0 is current instruction word
000014E0  0241 01C0                485          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
000014E4  1A3C 0006                486          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000014E8  EA69                     487          LSR.W   D5,D1               ; Shift dst mode into LSB position
000014EA  B23C 0003                488          CMP.B   #3,D1               ; When 011 in destination mode
000014EE  6700 0684                489          BEQ     OP_DIVU             ; Go to opcode DIVU word
000014F2  B23C 0007                490          CMP.B   #7,D1               ; When 111
000014F6  6700 033C                491          BEQ     OP_UNSUPPORTED      ; Go to opcode unsupported
000014FA  6000 0698                492          BRA     OP_OR               ; Otherwise, go to opcode OR
000014FE                           493  
000014FE                           494  code1001                            ; Opcode SUB.B/W/L
000014FE  6000 06AC                495          BRA     OP_SUB              ; Go to opcode SUB   
00001502                           496  
00001502                           497  code1010                            ; Opcode not supported 
00001502  6000 0330                498          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
00001506                           499       
00001506                           500  code1011                            ; Opcode CMP.B/W/L
00001506  6000 06C0                501          BRA     OP_CMP              ; Go to opcode CMP
0000150A                           502  
0000150A                           503  code1100                            ; Opcodes MULS, MULU, AND.B/W/L
0000150A  2200                     504          MOVE.L  D0,D1               ; D0 is current instruction word
0000150C  0241 01C0                505          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001510  1A3C 0006                506          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001514  EA69                     507          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001516  C2FC 0006                508          MULU    #6, D1              ; Set displacement 
0000151A  41F9 00001680            509          LEA     OP_1100_TABLE,A0    ; Load table into A0
00001520  4EF0 1000                510          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
00001524                           511  
00001524                           512  code1101                            ; Opcodes ADD.B/W/L, ADDA.B/W/L
00001524  2200                     513          MOVE.L  D0,D1               ; D0 is current instruction word
00001526  0241 01C0                514          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000152A  1A3C 0006                515          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000152E  EA69                     516          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001530  C2FC 0006                517          MULU    #6, D1              ; Set displacement 
00001534  41F9 000016E0            518          LEA     OP_1101_TABLE,A0    ; Load table into A0
0000153A  4EF0 1000                519          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
0000153E                           520  
0000153E                           521  code1110                            ; Opcodes ASL.B/W/L, ASR.B/W/L, LSL.B/W/L, LSR.B/W/L, ROL.B/W/L, ROR.B/W/L   
0000153E  2200                     522          MOVE.L  D0,D1               ; D0 is current instruction word
00001540  0241 01C0                523          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00001544  1A3C 0006                524          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001548  EA69                     525          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000154A                           526     
0000154A                           527          ; Check Memory Shifts
0000154A  B23C 0007                528          CMP.B   #7, D1              ; When 111
0000154E  6700 0024                529          BEQ     MEMORY_1110_LEFT    ; Go to Memory Shift Left Side
00001552                           530      
00001552  B23C 0003                531          CMP.B   #3, D1              ; When 011
00001556  6700 0040                532          BEQ     MEMORY_1110_RIGHT   ; Go Memory Shift Right Side
0000155A                           533      
0000155A                           534          ; Check Register Shifts
0000155A  2200                     535          MOVE.L  D0,D1                       ; D0 is current instruction word
0000155C  0241 0038                536          ANDI.W  #src_mode,D1                ; Extract 5-3 bits from instruction word
00001560  1A3C 0003                537          MOVE.B  #right3,D5                  ; Used to shift 3 times to right
00001564  EA69                     538          LSR.W   D5,D1                       ; Shift 5-3 bits into LSB position
00001566  C2FC 0006                539          MULU    #6,D1                       ; Set displacement 
0000156A  41F9 00001740            540          LEA     OP_1110_TABLE_REGISTER,A0   ; Load table into A0
00001570  4EF0 1000                541          JMP     0(A0,D1)                    ; go to displacement (A0 + D1 * 6)
00001574                           542  
00001574                           543  MEMORY_1110_LEFT    
00001574  2200                     544          MOVE.L  D0,D1               ; D0 is current instruction word
00001576  0241 0E00                545          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
0000157A  1A3C 0009                546          MOVE.B  #right9,D5          ; Used to shift 9 times to right
0000157E  EA69                     547          LSR.W   D5,D1               ; Shift dst reg into LSB position
00001580  B23C 0000                548          CMP.B   #0,D1               ; When D1 is 0
00001584  6700 0712                549          BEQ     OP_ASL              ; Go to opcode ASL
00001588  B23C 0001                550          CMP.B   #1, D1              ; when D1 is 1
0000158C  6700 0742                551          BEQ     OP_LSL              ; Go to opcode LSL
00001590  B23C 0003                552          CMP.B   #3, D1              ; When D1 is 3
00001594  6700 0772                553          BEQ     OP_ROL              ; Go to opcode ROL
00001598                           554  
00001598                           555  MEMORY_1110_RIGHT
00001598  2200                     556          MOVE.L  D0,D1               ; D0 is current instruction word
0000159A  0241 0E00                557          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
0000159E  1A3C 0009                558          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000015A2  EA69                     559          LSR.W   D5,D1               ; Shift dst reg into LSB position
000015A4  B23C 0000                560          CMP.B   #0,D1               ; When D1 is 0
000015A8  6700 06D2                561          BEQ     OP_ASR              ; Go to opcode ASR
000015AC  B23C 0001                562          CMP.B   #1, D1              ; when D1 is 1
000015B0  6700 0702                563          BEQ     OP_LSR              ; Go to opcode LSR
000015B4  B23C 0003                564          CMP.B   #3, D1              ; When D1 is 3
000015B8  6700 0732                565          BEQ     OP_ROR              ; Go to opcode ROR
000015BC                           566  
000015BC                           567  code1111                            ; Opcode not supported 
000015BC  6000 0276                568          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
000015C0                           569           
000015C0                           570  OP_0000_TABLE
000015C0  4EF9 00001834            571          JMP     OP_UNSUPPORTED  ; 0 Go to opcode unsupported  
000015C6  4EF9 00001834            572          JMP     OP_UNSUPPORTED  ; 1 Go to opcode unsupported  
000015CC  4EF9 00001834            573          JMP     OP_UNSUPPORTED  ; 2 Go to opcode unsupported  
000015D2  4EF9 00001834            574          JMP     OP_UNSUPPORTED  ; 3 Go to opcode unsupported  
000015D8  4EF9 00001844            575          JMP     OP_SUBI         ; 4 Go to opcode SUBI
000015DE  4EF9 00001834            576          JMP     OP_UNSUPPORTED  ; 5 Go to opcode unsupported  
000015E4  4EF9 00001864            577          JMP     OP_ADDI         ; 6 Go to opcode ADDI
000015EA  4EF9 00001834            578          JMP     OP_UNSUPPORTED  ; 7 Go to opcode unsupported  
000015F0  4EF9 00001834            579          JMP     OP_UNSUPPORTED  ; 8 Go to opcode unsupported  
000015F6  4EF9 00001834            580          JMP     OP_UNSUPPORTED  ; 9 Go to opcode unsupported  
000015FC  4EF9 00001834            581          JMP     OP_UNSUPPORTED  ; A Go to opcode unsupported  
00001602  4EF9 00001834            582          JMP     OP_UNSUPPORTED  ; B Go to opcode unsupported  
00001608  4EF9 00001834            583          JMP     OP_UNSUPPORTED  ; C Go to opcode unsupported  
0000160E  4EF9 00001834            584          JMP     OP_UNSUPPORTED  ; D Go to opcode unsupported  
00001614  4EF9 00001834            585          JMP     OP_UNSUPPORTED  ; E Go to opcode unsupported  
0000161A  4EF9 00001834            586          JMP     OP_UNSUPPORTED  ; F Go to opcode unsupported  
00001620                           587      
00001620                           588  OP_0100_TABLE
00001620  4EF9 00001834            589          JMP     OP_UNSUPPORTED      ; 0 Go to opcode unsupported  
00001626  4EF9 00001950            590          JMP     OP_LEA              ; 1 Go to opcode LEA
0000162C  4EF9 000018C8            591          JMP     OP_CLR              ; 2 Go to opcode CLR
00001632  4EF9 00001950            592          JMP     OP_LEA              ; 3 Go to opcode LEA
00001638  4EF9 00001834            593          JMP     OP_UNSUPPORTED      ; 4 Go to opcode unsupported  
0000163E  4EF9 00001950            594          JMP     OP_LEA              ; 5 Go to opcode LEA
00001644  4EF9 00001864            595          JMP     OP_ADDI             ; 6 Go to opcode ADDI
0000164A  4EF9 00001950            596          JMP     OP_LEA              ; 7 Go to opcode LEA
00001650  4EF9 0000192C            597          JMP     OP_MOVEM            ; 8 Go to opcode MOVEM
00001656  4EF9 00001950            598          JMP     OP_LEA              ; 9 Go to opcode LEA
0000165C  4EF9 00001834            599          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
00001662  4EF9 00001950            600          JMP     OP_LEA              ; B Go to opcode LEA
00001668  4EF9 0000192C            601          JMP     OP_MOVEM            ; C Go to opcode MOVEM
0000166E  4EF9 00001950            602          JMP     OP_LEA              ; D Go to opcode LEA
00001674  4EF9 00001806            603          JMP     JSR_NOP_RTS         ; E Go to opcode JSR, NOP, or RTS
0000167A  4EF9 00001834            604          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001680                           605      
00001680                           606  OP_1100_TABLE
00001680  4EF9 00001C24            607          JMP     OP_AND              ; 0 Go to opcode AND 
00001686  4EF9 00001C24            608          JMP     OP_AND              ; 1 Go to opcode AND
0000168C  4EF9 00001C24            609          JMP     OP_AND              ; 2 Go to opcode AND
00001692  4EF9 00001BE4            610          JMP     OP_MULU             ; 3 Go to opcode MULU
00001698  4EF9 00001C24            611          JMP     OP_AND              ; 4 Go to opcode AND 
0000169E  4EF9 00001C24            612          JMP     OP_AND              ; 5 Go to opcode AND
000016A4  4EF9 00001C24            613          JMP     OP_AND              ; 6 Go to opcode AND
000016AA  4EF9 00001C04            614          JMP     OP_MULS             ; 7 Go to opcode MULS
000016B0  4EF9 00001834            615          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
000016B6  4EF9 00001834            616          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
000016BC  4EF9 00001834            617          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000016C2  4EF9 00001834            618          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
000016C8  4EF9 00001834            619          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
000016CE  4EF9 00001834            620          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
000016D4  4EF9 00001834            621          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
000016DA  4EF9 00001834            622          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000016E0                           623      
000016E0                           624  OP_1101_TABLE
000016E0  4EF9 00001C40            625          JMP     OP_ADD              ; 0 Go to opcode ADD 
000016E6  4EF9 00001C40            626          JMP     OP_ADD              ; 1 Go to opcode ADD
000016EC  4EF9 00001C40            627          JMP     OP_ADD              ; 2 Go to opcode ADD
000016F2  4EF9 00001C5C            628          JMP     OP_ADDA             ; 3 Go to opcode ADDA
000016F8  4EF9 00001C40            629          JMP     OP_ADD              ; 4 Go to opcode ADD 
000016FE  4EF9 00001C40            630          JMP     OP_ADD              ; 5 Go to opcode ADD
00001704  4EF9 00001C40            631          JMP     OP_ADD              ; 6 Go to opcode ADD
0000170A  4EF9 00001C5C            632          JMP     OP_ADDA             ; 7 Go to opcode ADDA
00001710  4EF9 00001834            633          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
00001716  4EF9 00001834            634          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
0000171C  4EF9 00001834            635          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
00001722  4EF9 00001834            636          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
00001728  4EF9 00001834            637          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
0000172E  4EF9 00001834            638          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
00001734  4EF9 00001834            639          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
0000173A  4EF9 00001834            640          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001740                           641      
00001740                           642  OP_1110_TABLE_REGISTER
00001740  4EF9 000017A0            643          JMP     OP_AS_CHECK         ; 0 Check if AS is left or right
00001746  4EF9 000017C2            644          JMP     OP_LS_CHECK         ; 1 Check if LS is left or right
0000174C  4EF9 00001834            645          JMP     OP_UNSUPPORTED      ; 2 Go to opcode unsupported  
00001752  4EF9 000017E4            646          JMP     OP_RO_CHECK         ; 3 Check if RO is left or right
00001758  4EF9 000017A0            647          JMP     OP_AS_CHECK         ; 4 Check if AS is left or right
0000175E  4EF9 000017C2            648          JMP     OP_LS_CHECK         ; 5 Check if LS is left or right
00001764  4EF9 00001834            649          JMP     OP_UNSUPPORTED      ; 6 Go to opcode unsupported 
0000176A  4EF9 000017E4            650          JMP     OP_RO_CHECK         ; 7 Check if RO is left or right
00001770  4EF9 00001834            651          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
00001776  4EF9 00001834            652          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
0000177C  4EF9 00001834            653          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
00001782  4EF9 00001834            654          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
00001788  4EF9 00001834            655          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
0000178E  4EF9 00001834            656          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
00001794  4EF9 00001834            657          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
0000179A  4EF9 00001834            658          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000017A0                           659  
000017A0                           660  OP_AS_CHECK
000017A0  2200                     661          MOVE.L  D0,D1               ; D0 is current instruction word
000017A2  0241 01C0                662          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000017A6  1A3C 0006                663          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000017AA  EA69                     664          LSR.W   D5,D1               ; Shift dst mode into LSB position
000017AC  0201 0004                665          ANDI.B  #4,D1               ; Get only bit 8 (dr)
000017B0  E449                     666          LSR.W   #2,D1
000017B2                           667  
000017B2  B23C 0001                668          CMP.B   #1,D1               ; Go left
000017B6  6700 04E0                669          BEQ     OP_ASL              ; 1 Go to opcode ASL
000017BA  B23C 0000                670          CMP.B   #0,D1               ; Go right
000017BE  6700 04BC                671          BEQ     OP_ASR              ; 0 Go to opcode ASR
000017C2                           672          
000017C2                           673  OP_LS_CHECK
000017C2  2200                     674          MOVE.L  D0,D1               ; D0 is current instruction word
000017C4  0241 01C0                675          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000017C8  1A3C 0006                676          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000017CC  EA69                     677          LSR.W   D5,D1               ; Shift dst mode into LSB position
000017CE  0201 0004                678          ANDI.B  #4,D1               ; Get only bit 8 (dr)
000017D2  E449                     679          LSR.W   #2,D1
000017D4                           680  
000017D4  B23C 0001                681          CMP.B   #1,D1               ; Go left
000017D8  6700 04F6                682          BEQ     OP_LSL              ; 1 Go to opcode LSL
000017DC  B23C 0000                683          CMP.B   #0,D1               ; Go right
000017E0  6700 04D2                684          BEQ     OP_LSR              ; 0 Go to opcode LSR
000017E4                           685          
000017E4                           686  OP_RO_CHECK
000017E4  2200                     687          MOVE.L  D0,D1               ; D0 is current instruction word
000017E6  0241 01C0                688          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000017EA  1A3C 0006                689          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000017EE  EA69                     690          LSR.W   D5,D1               ; Shift dst mode into LSB position
000017F0  0201 0004                691          ANDI.B  #4,D1               ; Get only bit 8 (dr)
000017F4  E449                     692          LSR.W   #2,D1
000017F6                           693  
000017F6  B23C 0001                694          CMP.B   #1,D1               ; Go left
000017FA  6700 050C                695          BEQ     OP_ROL              ; 1 Go to opcode ROL
000017FE  B23C 0000                696          CMP.B   #0,D1               ; Go right
00001802  6700 04E8                697          BEQ     OP_ROR              ; 0 Go to opcode ROR
00001806                           698          
00001806                           699  JSR_NOP_RTS
00001806  2200                     700          MOVE.L  D0,D1               ; D0 is current instruction word
00001808  0241 01C0                701          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000180C  1A3C 0006                702          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001810  EA69                     703          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001812  B23C 0002                704          CMP.B   #2, D1              ; When 010 in destination mode
00001816  6700 00F8                705          BEQ     OP_JSR              ; Go to opcode JSR
0000181A  2200                     706          MOVE.L  D0,D1               ; D0 is current instruction word
0000181C  0241 0007                707          ANDI.W  #src_reg,D1         ; Extract src reg position from instruction word
00001820  B23C 0001                708          CMP.B   #1,D1               ; When 001 in src register
00001824  6700 00BE                709          BEQ     OP_NOP              ; Go to opcode NOP
00001828  B23C 0005                710          CMP.B   #5,D1               ; When 005 in src register
0000182C  6700 00D2                711          BEQ     OP_RTS              ; Go to opcode RTS
00001830  6000 0002                712          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported 
00001834                           713  
00001834                           714  OP_UNSUPPORTED
00001834  43F9 00002DF9            715          LEA     OPCODE_INVALID,A1 
0000183A  103C 000E                716          MOVE.B  #14,D0
0000183E  4E4F                     717          TRAP    #15
00001840  6000 14C6                718          BRA     DONE
00001844                           719          
00001844                           720  *----------------------------------------------------------------------------------------------*
00001844                           721  * param D0 the current instruction in word
00001844                           722  * param D1 the EA type
00001844                           723  * param A2 a pointer to the decode_buffer
00001844                           724  * param A5 current address
00001844                           725  * ea_start(D0, D1, A2, A5){
00001844                           726  * D2: size
00001844                           727  * D3: src mode, dst mode
00001844                           728  * D4: src regs, dst regs
00001844                           729  * D5: #shifts
00001844                           730  * D7: immediate data
00001844                           731  * A0: EA_TYPE_TABLE
00001844                           732  *       0 = ea_immediate
00001844                           733  * }
00001844                           734  
00001844                           735  *----------------------------------------------------------------------------------------------*
00001844                           736  * First 4 bits: 0000
00001844                           737  OP_SUBI
00001844  14FC 0053                738          MOVE.B  #'S',(A2)+
00001848  14FC 0055                739          MOVE.B  #'U',(A2)+
0000184C  14FC 0042                740          MOVE.B  #'B',(A2)+
00001850  14FC 0049                741          MOVE.B  #'I',(A2)+
00001854  223C 00000000            742          MOVE.L  #ea_type_immediate,D1
0000185A  4EB9 00001D24            743          JSR     EA_START
00001860  4EF8 1366                744          JMP     OP_FINISH
00001864                           745          
00001864                           746  OP_ADDI
00001864  14FC 0041                747          MOVE.B  #'A',(A2)+
00001868  14FC 0044                748          MOVE.B  #'D',(A2)+
0000186C  14FC 0044                749          MOVE.B  #'D',(A2)+
00001870  14FC 0049                750          MOVE.B  #'I',(A2)+
00001874  223C 00000000            751          MOVE.L  #ea_type_immediate,D1
0000187A  4EB9 00001D24            752          JSR     EA_START
00001880  4EF8 1366                753          JMP     OP_FINISH
00001884                           754  
00001884                           755  *-----------------------------------------------------------------------------------------------*
00001884                           756  * First 4 bits: 0001
00001884                           757  OP_MOVEA
00001884  14FC 004D                758          MOVE.B  #'M',(A2)+
00001888  14FC 004F                759          MOVE.B  #'O',(A2)+
0000188C  14FC 0056                760          MOVE.B  #'V',(A2)+
00001890  14FC 0045                761          MOVE.B  #'E',(A2)+
00001894  14FC 0041                762          MOVE.B  #'A',(A2)+
00001898  223C 00000002            763          MOVE.L  #ea_type_movea,D1
0000189E  4EB9 00001D24            764          JSR     EA_START
000018A4  4EF8 1366                765          JMP     OP_FINISH
000018A8                           766  
000018A8                           767  *------------------------------------------------------------------------------------------------*
000018A8                           768  * First 4 bits: 0011
000018A8                           769  OP_MOVE
000018A8  14FC 004D                770          MOVE.B  #'M',(A2)+
000018AC  14FC 004F                771          MOVE.B  #'O',(A2)+
000018B0  14FC 0056                772          MOVE.B  #'V',(A2)+
000018B4  14FC 0045                773          MOVE.B  #'E',(A2)+
000018B8  223C 00000001            774          MOVE.L  #ea_type_move,D1
000018BE  4EB9 00001D24            775          JSR     EA_START
000018C4  4EF8 1366                776          JMP     OP_FINISH
000018C8                           777  
000018C8                           778  *------------------------------------------------------------------------------------------------*
000018C8                           779  * First 4 bits: 0100
000018C8                           780  OP_CLR
000018C8  14FC 0043                781          MOVE.B  #'C',(A2)+
000018CC  14FC 004C                782          MOVE.B  #'L',(A2)+
000018D0  14FC 0052                783          MOVE.B  #'R',(A2)+
000018D4  223C 00000004            784          MOVE.L  #ea_type_dstonly,D1
000018DA  4EB9 00001D24            785          JSR     EA_START
000018E0  4EF8 1366                786          JMP     OP_FINISH
000018E4                           787          
000018E4                           788  OP_NOP
000018E4  14FC 004E                789          MOVE.B  #'N',(A2)+
000018E8  14FC 004F                790          MOVE.B  #'O',(A2)+
000018EC  14FC 0050                791          MOVE.B  #'P',(A2)+
000018F0  223C 00000000            792          MOVE.L  #ea_type_immediate,D1
000018F6  4EB9 00001D24            793          JSR     EA_START
000018FC  4EF8 1366                794          JMP     OP_FINISH
00001900                           795          
00001900                           796  OP_RTS
00001900  14FC 0052                797          MOVE.B  #'R',(A2)+
00001904  14FC 0054                798          MOVE.B  #'T',(A2)+
00001908  14FC 0053                799          MOVE.B  #'S',(A2)+
0000190C  4EF8 1366                800          JMP     OP_FINISH
00001910                           801          
00001910                           802  OP_JSR
00001910  14FC 004A                803          MOVE.B  #'J',(A2)+
00001914  14FC 0053                804          MOVE.B  #'S',(A2)+
00001918  14FC 0052                805          MOVE.B  #'R',(A2)+
0000191C  223C 00000004            806          MOVE.L  #ea_type_dstonly,D1
00001922  4EB9 00001D24            807          JSR     EA_START
00001928  4EF8 1366                808          JMP     OP_FINISH
0000192C                           809  
0000192C                           810  OP_MOVEM
0000192C  14FC 004D                811          MOVE.B  #'M',(A2)+
00001930  14FC 004F                812          MOVE.B  #'O',(A2)+
00001934  14FC 0056                813          MOVE.B  #'V',(A2)+
00001938  14FC 0045                814          MOVE.B  #'E',(A2)+
0000193C  14FC 004D                815          MOVE.B  #'M',(A2)+
00001940  223C 00000006            816          MOVE.L  #ea_type_movem,D1
00001946  4EB9 00001D24            817          JSR     EA_START
0000194C  4EF8 1366                818          JMP     OP_FINISH
00001950                           819          
00001950                           820  OP_LEA
00001950  14FC 004C                821          MOVE.B  #'L',(A2)+
00001954  14FC 0045                822          MOVE.B  #'E',(A2)+
00001958  14FC 0041                823          MOVE.B  #'A',(A2)+
0000195C  223C 00000003            824          MOVE.L  #ea_type_lea,D1
00001962  4EB9 00001D24            825          JSR     EA_START
00001968  4EF8 1366                826          JMP     OP_FINISH
0000196C                           827  
0000196C                           828  *------------------------------------------------------------------------------------------------*
0000196C                           829  * First 4 bits: 0101
0000196C                           830  OP_ADDQ
0000196C  14FC 0041                831          MOVE.B  #'A',(A2)+
00001970  14FC 0044                832          MOVE.B  #'D',(A2)+
00001974  14FC 0044                833          MOVE.B  #'D',(A2)+
00001978  14FC 0051                834          MOVE.B  #'Q',(A2)+
0000197C  223C 00000008            835          MOVE.L  #ea_type_quick,D1
00001982  4EB9 00001D24            836          JSR     EA_START
00001988  4EF8 1366                837          JMP     OP_FINISH
0000198C                           838          
0000198C                           839  *------------------------------------------------------------------------------------------------*
0000198C                           840  * First 4 bits: 0110
0000198C                           841  OP_BRA
0000198C  14FC 0042                842          MOVE.B  #'B',(A2)+
00001990  14FC 0052                843          MOVE.B  #'R',(A2)+
00001994  14FC 0041                844          MOVE.B  #'A',(A2)+
00001998  223C 00000009            845          MOVE.L  #ea_type_branch,D1
0000199E  4EB9 00001D24            846          JSR     EA_START
000019A4  4EF8 1366                847          JMP     OP_FINISH
000019A8                           848  
000019A8                           849  OP_BSR
000019A8  14FC 0042                850          MOVE.B  #'B',(A2)+
000019AC  14FC 0053                851          MOVE.B  #'S',(A2)+
000019B0  14FC 0052                852          MOVE.B  #'R',(A2)+
000019B4  223C 00000009            853          MOVE.L  #ea_type_branch,D1
000019BA  4EB9 00001D24            854          JSR     EA_START
000019C0  4EF8 1366                855          JMP     OP_FINISH
000019C4                           856          
000019C4                           857  OP_BHI
000019C4  14FC 0042                858          MOVE.B  #'B',(A2)+
000019C8  14FC 0048                859          MOVE.B  #'H',(A2)+
000019CC  14FC 0049                860          MOVE.B  #'I',(A2)+
000019D0  223C 00000009            861          MOVE.L  #ea_type_branch,D1
000019D6  4EB9 00001D24            862          JSR     EA_START
000019DC  4EF8 1366                863          JMP     OP_FINISH
000019E0                           864  
000019E0                           865  OP_BLS
000019E0  14FC 0042                866          MOVE.B  #'B',(A2)+
000019E4  14FC 004C                867          MOVE.B  #'L',(A2)+
000019E8  14FC 0053                868          MOVE.B  #'S',(A2)+
000019EC  223C 00000009            869          MOVE.L  #ea_type_branch,D1
000019F2  4EB9 00001D24            870          JSR     EA_START
000019F8  4EF8 1366                871          JMP     OP_FINISH
000019FC                           872  
000019FC                           873  OP_BCC
000019FC  14FC 0042                874          MOVE.B  #'B',(A2)+
00001A00  14FC 0043                875          MOVE.B  #'C',(A2)+
00001A04  14FC 0043                876          MOVE.B  #'C',(A2)+
00001A08  223C 00000009            877          MOVE.L  #ea_type_branch,D1
00001A0E  4EB9 00001D24            878          JSR     EA_START
00001A14  4EF8 1366                879          JMP     OP_FINISH
00001A18                           880          
00001A18                           881  OP_BCS
00001A18  14FC 0042                882          MOVE.B  #'B',(A2)+
00001A1C  14FC 0043                883          MOVE.B  #'C',(A2)+
00001A20  14FC 0053                884          MOVE.B  #'S',(A2)+
00001A24  223C 00000009            885          MOVE.L  #ea_type_branch,D1
00001A2A  4EB9 00001D24            886          JSR     EA_START
00001A30  4EF8 1366                887          JMP     OP_FINISH
00001A34                           888  
00001A34                           889  OP_BNE
00001A34  14FC 0042                890          MOVE.B  #'B',(A2)+
00001A38  14FC 004E                891          MOVE.B  #'N',(A2)+
00001A3C  14FC 0045                892          MOVE.B  #'E',(A2)+
00001A40  223C 00000009            893          MOVE.L  #ea_type_branch,D1
00001A46  4EB9 00001D24            894          JSR     EA_START
00001A4C  4EF8 1366                895          JMP     OP_FINISH
00001A50                           896  
00001A50                           897  OP_BEQ
00001A50  14FC 0042                898          MOVE.B  #'B',(A2)+
00001A54  14FC 0045                899          MOVE.B  #'E',(A2)+
00001A58  14FC 0051                900          MOVE.B  #'Q',(A2)+
00001A5C  223C 00000009            901          MOVE.L  #ea_type_branch,D1
00001A62  4EB9 00001D24            902          JSR     EA_START
00001A68  4EF8 1366                903          JMP     OP_FINISH
00001A6C                           904  
00001A6C                           905  OP_BVC
00001A6C  14FC 0042                906          MOVE.B  #'B',(A2)+
00001A70  14FC 0056                907          MOVE.B  #'V',(A2)+
00001A74  14FC 0043                908          MOVE.B  #'C',(A2)+
00001A78  223C 00000009            909          MOVE.L  #ea_type_branch,D1
00001A7E  4EB9 00001D24            910          JSR     EA_START
00001A84  4EF8 1366                911          JMP     OP_FINISH
00001A88                           912  
00001A88                           913  OP_BVS
00001A88  14FC 0042                914          MOVE.B  #'B',(A2)+
00001A8C  14FC 0056                915          MOVE.B  #'V',(A2)+
00001A90  14FC 0053                916          MOVE.B  #'S',(A2)+
00001A94  223C 00000009            917          MOVE.L  #ea_type_branch,D1
00001A9A  4EB9 00001D24            918          JSR     EA_START
00001AA0  4EF8 1366                919          JMP     OP_FINISH
00001AA4                           920  
00001AA4                           921  OP_BPL
00001AA4  14FC 0042                922          MOVE.B  #'B',(A2)+
00001AA8  14FC 0050                923          MOVE.B  #'P',(A2)+
00001AAC  14FC 004C                924          MOVE.B  #'L',(A2)+
00001AB0  223C 00000009            925          MOVE.L  #ea_type_branch,D1
00001AB6  4EB9 00001D24            926          JSR     EA_START
00001ABC  4EF8 1366                927          JMP     OP_FINISH
00001AC0                           928  
00001AC0                           929  OP_BMI
00001AC0  14FC 0042                930          MOVE.B  #'B',(A2)+
00001AC4  14FC 004D                931          MOVE.B  #'M',(A2)+
00001AC8  14FC 0049                932          MOVE.B  #'I',(A2)+
00001ACC  223C 00000009            933          MOVE.L  #ea_type_branch,D1
00001AD2  4EB9 00001D24            934          JSR     EA_START
00001AD8  4EF8 1366                935          JMP     OP_FINISH
00001ADC                           936  
00001ADC                           937  OP_BGE
00001ADC  14FC 0042                938          MOVE.B  #'B',(A2)+
00001AE0  14FC 0047                939          MOVE.B  #'G',(A2)+
00001AE4  14FC 0045                940          MOVE.B  #'E',(A2)+
00001AE8  223C 00000009            941          MOVE.L  #ea_type_branch,D1
00001AEE  4EB9 00001D24            942          JSR     EA_START
00001AF4  4EF8 1366                943          JMP     OP_FINISH
00001AF8                           944  
00001AF8                           945  OP_BLT
00001AF8  14FC 0042                946          MOVE.B  #'B',(A2)+
00001AFC  14FC 004C                947          MOVE.B  #'L',(A2)+
00001B00  14FC 0054                948          MOVE.B  #'T',(A2)+
00001B04  223C 00000009            949          MOVE.L  #ea_type_branch,D1
00001B0A  4EB9 00001D24            950          JSR     EA_START
00001B10  4EF8 1366                951          JMP     OP_FINISH
00001B14                           952  
00001B14                           953  OP_BGT
00001B14  14FC 0042                954          MOVE.B  #'B',(A2)+
00001B18  14FC 0047                955          MOVE.B  #'G',(A2)+
00001B1C  14FC 0054                956          MOVE.B  #'T',(A2)+
00001B20  223C 00000009            957          MOVE.L  #ea_type_branch,D1
00001B26  4EB9 00001D24            958          JSR     EA_START
00001B2C  4EF8 1366                959          JMP     OP_FINISH
00001B30                           960  
00001B30                           961  OP_BLE
00001B30  14FC 0042                962          MOVE.B  #'B',(A2)+
00001B34  14FC 004C                963          MOVE.B  #'L',(A2)+
00001B38  14FC 0045                964          MOVE.B  #'E',(A2)+
00001B3C  223C 00000009            965          MOVE.L  #ea_type_branch,D1
00001B42  4EB9 00001D24            966          JSR     EA_START
00001B48  4EF8 1366                967          JMP     OP_FINISH
00001B4C                           968  *------------------------------------------------------------------------------------------------*
00001B4C                           969  * First 4 bits: 0111
00001B4C                           970  OP_MOVEQ
00001B4C  14FC 004D                971          MOVE.B  #'M',(A2)+
00001B50  14FC 004F                972          MOVE.B  #'O',(A2)+
00001B54  14FC 0056                973          MOVE.B  #'V',(A2)+
00001B58  14FC 0056                974          MOVE.B  #'V',(A2)+
00001B5C  14FC 0045                975          MOVE.B  #'E',(A2)+
00001B60  14FC 0051                976          MOVE.B  #'Q',(A2)+
00001B64  223C 00000008            977          MOVE.L  #ea_type_quick,D1
00001B6A  4EB9 00001D24            978          JSR     EA_START
00001B70  4EF8 1366                979          JMP     OP_FINISH
00001B74                           980          
00001B74                           981  *------------------------------------------------------------------------------------------------*
00001B74                           982  * First 4 bits: 1000
00001B74                           983  OP_DIVU
00001B74  14FC 0044                984          MOVE.B  #'D',(A2)+
00001B78  14FC 0049                985          MOVE.B  #'I',(A2)+
00001B7C  14FC 0056                986          MOVE.B  #'V',(A2)+
00001B80  14FC 0055                987          MOVE.B  #'U',(A2)+
00001B84  223C 00000005            988          MOVE.L  #ea_type_ext,D1
00001B8A  4EB9 00001D24            989          JSR     EA_START
00001B90  4EF8 1366                990          JMP     OP_FINISH
00001B94                           991    
00001B94                           992  OP_OR
00001B94  14FC 004F                993          MOVE.B  #'O',(A2)+
00001B98  14FC 0052                994          MOVE.B  #'R',(A2)+
00001B9C  223C 00000005            995          MOVE.L  #ea_type_ext,D1
00001BA2  4EB9 00001D24            996          JSR     EA_START
00001BA8  4EF8 1366                997          JMP     OP_FINISH
00001BAC                           998  
00001BAC                           999  *------------------------------------------------------------------------------------------------*
00001BAC                          1000  * First 4 bits: 1001
00001BAC                          1001  OP_SUB
00001BAC  14FC 0053               1002          MOVE.B  #'S',(A2)+
00001BB0  14FC 0055               1003          MOVE.B  #'U',(A2)+
00001BB4  14FC 0042               1004          MOVE.B  #'B',(A2)+
00001BB8  223C 00000005           1005          MOVE.L  #ea_type_ext,D1
00001BBE  4EB9 00001D24           1006          JSR     EA_START
00001BC4  4EF8 1366               1007          JMP     OP_FINISH
00001BC8                          1008          
00001BC8                          1009  *------------------------------------------------------------------------------------------------*
00001BC8                          1010  * First 4 bits: 1011
00001BC8                          1011  OP_CMP
00001BC8  14FC 0043               1012          MOVE.B  #'C',(A2)+
00001BCC  14FC 004D               1013          MOVE.B  #'M',(A2)+
00001BD0  14FC 0050               1014          MOVE.B  #'P',(A2)+
00001BD4  223C 00000005           1015          MOVE.L  #ea_type_ext,D1
00001BDA  4EB9 00001D24           1016          JSR     EA_START
00001BE0  4EF8 1366               1017          JMP     OP_FINISH
00001BE4                          1018          
00001BE4                          1019  *------------------------------------------------------------------------------------------------*
00001BE4                          1020  * First 4 bits: 1100
00001BE4                          1021  OP_MULU
00001BE4  14FC 004D               1022          MOVE.B  #'M',(A2)+
00001BE8  14FC 0055               1023          MOVE.B  #'U',(A2)+
00001BEC  14FC 004C               1024          MOVE.B  #'L',(A2)+
00001BF0  14FC 0055               1025          MOVE.B  #'U',(A2)+
00001BF4  223C 00000005           1026          MOVE.L  #ea_type_ext,D1
00001BFA  4EB9 00001D24           1027          JSR     EA_START
00001C00  4EF8 1366               1028          JMP     OP_FINISH
00001C04                          1029          
00001C04                          1030  OP_MULS
00001C04  14FC 004D               1031          MOVE.B  #'M',(A2)+
00001C08  14FC 0055               1032          MOVE.B  #'U',(A2)+
00001C0C  14FC 004C               1033          MOVE.B  #'L',(A2)+
00001C10  14FC 0053               1034          MOVE.B  #'S',(A2)+
00001C14  223C 00000005           1035          MOVE.L  #ea_type_ext,D1
00001C1A  4EB9 00001D24           1036          JSR     EA_START
00001C20  4EF8 1366               1037          JMP     OP_FINISH
00001C24                          1038          
00001C24                          1039  OP_AND
00001C24  14FC 0041               1040          MOVE.B  #'A',(A2)+
00001C28  14FC 004E               1041          MOVE.B  #'N',(A2)+
00001C2C  14FC 0044               1042          MOVE.B  #'D',(A2)+
00001C30  223C 00000005           1043          MOVE.L  #ea_type_ext,D1
00001C36  4EB9 00001D24           1044          JSR     EA_START
00001C3C  4EF8 1366               1045          JMP     OP_FINISH
00001C40                          1046          
00001C40                          1047  *------------------------------------------------------------------------------------------------*
00001C40                          1048  * First 4 bits: 1101
00001C40                          1049  OP_ADD
00001C40  14FC 0041               1050          MOVE.B  #'A',(A2)+
00001C44  14FC 0044               1051          MOVE.B  #'D',(A2)+
00001C48  14FC 0044               1052          MOVE.B  #'D',(A2)+
00001C4C  223C 00000005           1053          MOVE.L  #ea_type_ext,D1
00001C52  4EB9 00001D24           1054          JSR     EA_START
00001C58  4EF8 1366               1055          JMP     OP_FINISH
00001C5C                          1056  
00001C5C                          1057  OP_ADDA
00001C5C  14FC 0041               1058          MOVE.B  #'A',(A2)+
00001C60  14FC 0044               1059          MOVE.B  #'D',(A2)+
00001C64  14FC 0044               1060          MOVE.B  #'D',(A2)+
00001C68  14FC 0041               1061          MOVE.B  #'A',(A2)+
00001C6C  223C 00000005           1062          MOVE.L  #ea_type_ext,D1
00001C72  4EB9 00001D24           1063          JSR     EA_START
00001C78  4EF8 1366               1064          JMP     OP_FINISH
00001C7C                          1065          
00001C7C                          1066  *------------------------------------------------------------------------------------------------*
00001C7C                          1067  * First 4 bits: 1110
00001C7C                          1068  OP_ASR
00001C7C  14FC 0041               1069          MOVE.B  #'A',(A2)+
00001C80  14FC 0053               1070          MOVE.B  #'S',(A2)+
00001C84  14FC 0052               1071          MOVE.B  #'R',(A2)+
00001C88  223C 00000007           1072          MOVE.L  #ea_type_shifts,D1
00001C8E  4EB9 00001D24           1073          JSR     EA_START
00001C94  4EF8 1366               1074          JMP     OP_FINISH
00001C98                          1075  OP_ASL
00001C98  14FC 0041               1076          MOVE.B  #'A',(A2)+
00001C9C  14FC 0053               1077          MOVE.B  #'S',(A2)+
00001CA0  14FC 004C               1078          MOVE.B  #'L',(A2)+
00001CA4  223C 00000007           1079          MOVE.L  #ea_type_shifts,D1
00001CAA  4EB9 00001D24           1080          JSR     EA_START
00001CB0  4EF8 1366               1081          JMP     OP_FINISH
00001CB4                          1082          
00001CB4                          1083  OP_LSR
00001CB4  14FC 004C               1084          MOVE.B  #'L',(A2)+
00001CB8  14FC 0053               1085          MOVE.B  #'S',(A2)+
00001CBC  14FC 0052               1086          MOVE.B  #'R',(A2)+
00001CC0  223C 00000007           1087          MOVE.L  #ea_type_shifts,D1
00001CC6  4EB9 00001D24           1088          JSR     EA_START
00001CCC  4EF8 1366               1089          JMP     OP_FINISH
00001CD0                          1090         
00001CD0                          1091  OP_LSL
00001CD0  14FC 004C               1092          MOVE.B  #'L',(A2)+
00001CD4  14FC 0053               1093          MOVE.B  #'S',(A2)+
00001CD8  14FC 004C               1094          MOVE.B  #'L',(A2)+
00001CDC  223C 00000007           1095          MOVE.L  #ea_type_shifts,D1
00001CE2  4EB9 00001D24           1096          JSR     EA_START
00001CE8  4EF8 1366               1097          JMP     OP_FINISH
00001CEC                          1098          
00001CEC                          1099  OP_ROR
00001CEC  14FC 0052               1100          MOVE.B  #'R',(A2)+
00001CF0  14FC 004F               1101          MOVE.B  #'O',(A2)+
00001CF4  14FC 0052               1102          MOVE.B  #'R',(A2)+
00001CF8  223C 00000007           1103          MOVE.L  #ea_type_shifts,D1
00001CFE  4EB9 00001D24           1104          JSR     EA_START
00001D04  4EF8 1366               1105          JMP     OP_FINISH
00001D08                          1106          
00001D08                          1107  OP_ROL
00001D08  14FC 0052               1108          MOVE.B  #'R',(A2)+
00001D0C  14FC 004F               1109          MOVE.B  #'O',(A2)+
00001D10  14FC 004C               1110          MOVE.B  #'L',(A2)+
00001D14  223C 00000007           1111          MOVE.L  #ea_type_shifts,D1
00001D1A  4EB9 00001D24           1112          JSR     EA_START
00001D20  4EF8 1366               1113          JMP     OP_FINISH
00001D24                          1114          
00001D24                          1115  *-----------------------------------------------------------------------*   
00001D24                          1116  EA_START
00001D24  48E7 38C0               1117          MOVEM.L D2-D4/A0-A1, -(SP)
00001D28                          1118          
00001D28  41F9 00001D3C           1119          LEA     EA_TYPE_TABLE, A0
00001D2E  C2FC 0006               1120          MULU    #6, D1
00001D32  4EF0 1000               1121          JMP     0(A0, D1)
00001D36                          1122          
00001D36                          1123  EA_FINISH
00001D36  4CDF 031C               1124          MOVEM.L (SP)+, D2-D4/A0-A1
00001D3A  4E75                    1125          RTS
00001D3C                          1126          
00001D3C                          1127  EA_TYPE_TABLE
00001D3C  4EF9 00001E6E           1128          JMP     EA_IMMEDIATE        ; 0: ea_immediate
00001D42  4EF9 00001EC2           1129          JMP     EA_MOVE             ; 1: ea_move
00001D48  4EF9 00001F2A           1130          JMP     EA_MOVEA            ; 2: ea_movea
00001D4E  4EF9 00001F92           1131          JMP     EA_LEA              ; 3: ea_lea
00001D54  4EF9 00002008           1132          JMP     EA_DSTONLY          ; 4: ea_dstonly
00001D5A  4EF9 000020B2           1133          JMP     EA_EXT              ; 5: ea_ext
00001D60  4EF9 00002292           1134          JMP     EA_MOVEM            ; 6: ea_movem
00001D66  4EF9 000028F6           1135          JMP     EA_SHIFTS           ; 7: ea_shifts
00001D6C  4EF9 00002A6C           1136          JMP     EA_QUICK            ; 8: ea_quick
00001D72  4EF9 00002B2A           1137          JMP     EA_branch           ; 9: ea_branch
00001D78  4EF8 1D36               1138          JMP     EA_FINISH
00001D7C                          1139          
00001D7C                          1140  EA_SIZE_GENERAL
00001D7C  B43C 0000               1141          CMP.B   #%00,D2             ; .b
00001D80  6700 00CA               1142          BEQ     EA_SIZE_B       
00001D84  B43C 0001               1143          CMP.B   #%01,D2             ; .w
00001D88  6700 00CC               1144          BEQ     EA_SIZE_W       
00001D8C  B43C 0002               1145          CMP.B   #%10,D2             ; .l
00001D90  6700 00D0               1146          BEQ     EA_SIZE_L
00001D94  6000 0F22               1147          BRA     EA_WRONG_SIZE       ; wrong size
00001D98                          1148  
00001D98                          1149  EA_SIZE_MOVE
00001D98  B43C 0001               1150          CMP.B   #%01,D2             ; .b
00001D9C  6700 00AE               1151          BEQ     EA_SIZE_B       
00001DA0  B43C 0003               1152          CMP.B   #%11,D2             ; .w
00001DA4  6700 00B0               1153          BEQ     EA_SIZE_W       
00001DA8  B43C 0002               1154          CMP.B   #%10,D2             ; .l
00001DAC  6700 00B4               1155          BEQ     EA_SIZE_L
00001DB0  6000 0F06               1156          BRA     EA_WRONG_SIZE       ; wrong size
00001DB4                          1157  
00001DB4                          1158  EA_SIZE_MOVEA     
00001DB4  B43C 0003               1159          CMP.B   #%11,D2             ; .w
00001DB8  6700 009C               1160          BEQ     EA_SIZE_W       
00001DBC  B43C 0002               1161          CMP.B   #%10,D2             ; .l
00001DC0  6700 00A0               1162          BEQ     EA_SIZE_L
00001DC4  6000 0EF2               1163          BRA     EA_WRONG_SIZE       ; wrong size
00001DC8                          1164          
00001DC8                          1165  EA_SIZE_MOVEM     
00001DC8  B43C 0000               1166          CMP.B   #%0000,D2              ; .w
00001DCC  6700 0088               1167          BEQ     EA_SIZE_W       
00001DD0  B43C 0004               1168          CMP.B   #%0100,D2              ; .l
00001DD4  6700 008C               1169          BEQ     EA_SIZE_L
00001DD8  6000 0EDE               1170          BRA     EA_WRONG_SIZE       ; wrong size
00001DDC                          1171  
00001DDC                          1172  EA_SIZE_OPMODE_012456               ; Check opmode field for size
00001DDC  B43C 0000               1173          CMP.B   #%000,D2            ; When 0 then .b
00001DE0  6700 006A               1174          BEQ     EA_SIZE_B
00001DE4  B43C 0004               1175          CMP.B   #%100,D2            ; When 4 then .b
00001DE8  6700 0062               1176          BEQ     EA_SIZE_B  
00001DEC  B43C 0001               1177          CMP.B   #%001,D2            ; When 1 then .w
00001DF0  6700 0064               1178          BEQ     EA_SIZE_W
00001DF4  B43C 0005               1179          CMP.B   #%101,D2            ; When 5 then .w
00001DF8  6700 005C               1180          BEQ     EA_SIZE_W 
00001DFC  B43C 0002               1181          CMP.B   #%010,D2            ; When 2 then .l
00001E00  6700 0060               1182          BEQ     EA_SIZE_L
00001E04  B43C 0006               1183          CMP.B   #%110,D2            ; When 6 then .l
00001E08  6700 0058               1184          BEQ     EA_SIZE_L
00001E0C  6000 0EAA               1185          BRA     EA_WRONG_SIZE       ; wrong size
00001E10                          1186  
00001E10                          1187  EA_SIZE_ADDA                        ; Check opmode field for size
00001E10  B43C 0003               1188          CMP.B   #%011,D2            ; When 3 then .w
00001E14  6700 0040               1189          BEQ     EA_SIZE_W       
00001E18  B43C 0007               1190          CMP.B   #%111,D2            ; When 7 then .l
00001E1C  6700 0044               1191          BEQ     EA_SIZE_L
00001E20  6000 0E96               1192          BRA     EA_WRONG_SIZE       ; wrong size
00001E24                          1193          
00001E24                          1194  EA_SIZE_MULS_MULU_DIV               ; Check opmode field for size
00001E24  B43C 0003               1195          CMP.B   #%011,D2            ; When 3 then .w MULU, DIVU
00001E28  6700 002C               1196          BEQ     EA_SIZE_W       
00001E2C  B43C 0007               1197          CMP.B   #%111,D2            ; When 7 then .l MULS
00001E30  6700 0024               1198          BEQ     EA_SIZE_W
00001E34  6000 0E82               1199          BRA     EA_WRONG_SIZE       ; wrong size
00001E38                          1200          
00001E38                          1201  EA_SIZE_MEMORY_SHIFTS
00001E38  B43C 0000               1202          CMP.B   #%00,D2             ; .w
00001E3C  6700 0022               1203          BEQ     EA_SIZE_W_MEMORY      
00001E40  B43C 0001               1204          CMP.B   #%01,D2             ; .l
00001E44  6700 001C               1205          BEQ     EA_SIZE_L      
00001E48  6000 0E6E               1206          BRA     EA_WRONG_SIZE       ; wrong size
00001E4C                          1207  
00001E4C                          1208  EA_SIZE_B
00001E4C  14FC 002E               1209          MOVE.B  #'.',(A2)+
00001E50  14FC 0042               1210          MOVE.B  #'B',(A2)+
00001E54  4E75                    1211          RTS
00001E56                          1212  EA_SIZE_W
00001E56  14FC 002E               1213          MOVE.B  #'.',(A2)+
00001E5A  14FC 0057               1214          MOVE.B  #'W',(A2)+
00001E5E  4E75                    1215          RTS     
00001E60                          1216  EA_SIZE_W_MEMORY
00001E60  4E75                    1217          RTS        
00001E62                          1218  EA_SIZE_L
00001E62  14FC 002E               1219          MOVE.B  #'.',(A2)+
00001E66  14FC 004C               1220          MOVE.B  #'L',(A2)+
00001E6A  4E75                    1221          RTS
00001E6C                          1222  EA_SIZE_DONE
00001E6C  4E75                    1223          RTS
00001E6E                          1224          
00001E6E                          1225  EA_IMMEDIATE                        ; 0 ea_immediate
00001E6E  2200                    1226          MOVE.L  D0,D1
00001E70  0241 01C0               1227          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00001E74  1A3C 0006               1228          MOVE.B  #right6,D5          ; Store 6 into D5
00001E78  EA69                    1229          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00001E7A  0201 0003               1230          ANDI.B  #3,D1               ; Remove the front bit from D1
00001E7E  1401                    1231          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00001E80  4EB8 1D7C               1232          JSR     EA_SIZE_GENERAL     ; Get size 
00001E84                          1233          
00001E84  14FC 0020               1234          MOVE.B  #$20,(A2)+          ; Add space after size
00001E88  14FC 0020               1235          MOVE.B  #$20,(A2)+          ; Add space 
00001E8C                          1236  
00001E8C                          1237          ; Get source and store into decode buffer
00001E8C  7804                    1238          MOVE.L  #4,D4               ; Store 100 into D4 (Used to jump to immediate)
00001E8E  7607                    1239          MOVE.L  #7,D3               ; Store 111 into D3 (Go to absolute and immediate)
00001E90  4EB9 00002B7A           1240          JSR     EA_GEN_SRC          ; Get EA src print 
00001E96                          1241  
00001E96  14FC 002C               1242          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001E9A  14FC 0020               1243          MOVE.B  #$20,(A2)+          ; Add space after comma
00001E9E                          1244  
00001E9E                          1245          ; Get desination and store into decode buffer
00001E9E  2800                    1246          MOVE.L  D0,D4               ; Store the current address into D4 
00001EA0  0244 0007               1247          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00001EA4                          1248          
00001EA4  2600                    1249          MOVE.L  D0,D3               ; Store the current address into D3 
00001EA6  0243 0038               1250          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00001EAA  1A3C 0003               1251          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00001EAE  EA6B                    1252          LSR.W   D5,D3               ; do the actual shift 
00001EB0  B63C 0001               1253          CMP.B   #1,D3               ; If dest mode is 001: An
00001EB4  6700 0E22               1254          BEQ     DST_INVALID         ; Go to invalid message 
00001EB8  4EB9 00002B7A           1255          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00001EBE                          1256  
00001EBE  4EF8 1D36               1257          JMP     EA_FINISH           ; Opcode is finish
00001EC2                          1258  
00001EC2                          1259  EA_MOVE                             ; 1: ea_move
00001EC2  2200                    1260          MOVE.L  D0,D1
00001EC4  0241 F000               1261          ANDI.W  #first_nibble,D1
00001EC8  1A3C 000C               1262          MOVE.B  #right12,D5 
00001ECC  EA69                    1263          LSR.W   D5,D1
00001ECE  0201 0003               1264          ANDI.B  #3,D1
00001ED2  1401                    1265          MOVE.B  D1,D2
00001ED4  4EB8 1D98               1266          JSR     EA_SIZE_MOVE
00001ED8                          1267          
00001ED8  14FC 0020               1268          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001EDC  14FC 0020               1269          MOVE.B  #$20,(A2)+          ; Print out a space
00001EE0                          1270          
00001EE0                          1271          ; Get source and store into decode buffer
00001EE0  2800                    1272          MOVE.L  D0,D4               ; Store the src reg in D4
00001EE2  0244 0007               1273          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001EE6                          1274          
00001EE6  2600                    1275          MOVE.L  D0,D3               ; Store the src mode in D3
00001EE8  0243 0038               1276          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001EEC  1A3C 0003               1277          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001EF0  EA6B                    1278          LSR.W   D5,D3               ; Do the actual shift 
00001EF2  4EB9 00002B7A           1279          JSR     EA_GEN_SRC
00001EF8                          1280          
00001EF8  14FC 002C               1281          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001EFC  14FC 0020               1282          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F00                          1283          
00001F00                          1284          ; Get desination and store into decode buffer
00001F00  2800                    1285          MOVE.L  D0,D4               ; Store the dest reg in D4
00001F02  0244 0E00               1286          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001F06  1A3C 0009               1287          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001F0A  EA6C                    1288          LSR.W   D5,D4               ; Do the actual shift
00001F0C                          1289          
00001F0C  2600                    1290          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001F0E  0243 01C0               1291          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001F12  1A3C 0006               1292          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001F16  EA6B                    1293          LSR.W   D5,D3               ; Do the actual shift 
00001F18  B63C 0001               1294          CMP.B   #1,D3               ; If dest mode is 001: An
00001F1C  6700 0DBA               1295          BEQ     DST_INVALID         ; Go to invalid message 
00001F20  4EB9 00002B7A           1296          JSR     EA_GEN_SRC          ; Get EA print
00001F26                          1297          
00001F26  4EF8 1D36               1298          JMP     EA_FINISH           ; Opcode is finish
00001F2A                          1299  
00001F2A                          1300             
00001F2A                          1301  EA_MOVEA                            ; 2: ea_movea
00001F2A  2200                    1302          MOVE.L  D0,D1
00001F2C  0241 F000               1303          ANDI.W  #first_nibble,D1
00001F30  1A3C 000C               1304          MOVE.B  #right12,D5 
00001F34  EA69                    1305          LSR.W   D5,D1
00001F36  0201 0003               1306          ANDI.B  #3,D1
00001F3A  1401                    1307          MOVE.B  D1,D2
00001F3C  4EB8 1DB4               1308          JSR     EA_SIZE_MOVEA 
00001F40                          1309          
00001F40  14FC 0020               1310          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001F44                          1311          
00001F44                          1312          ; Get source and store into decode buffer
00001F44  2800                    1313          MOVE.L  D0,D4               ; Store the src reg in D4
00001F46  0244 0007               1314          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001F4A                          1315          
00001F4A  2600                    1316          MOVE.L  D0,D3               ; Store the src mode in D3
00001F4C  0243 0038               1317          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001F50  1A3C 0003               1318          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001F54  EA6B                    1319          LSR.W   D5,D3               ; Do the actual shift 
00001F56  4EB9 00002B7A           1320          JSR     EA_GEN_SRC
00001F5C                          1321          
00001F5C  14FC 002C               1322          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001F60  14FC 0020               1323          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F64                          1324          
00001F64                          1325          ; Get desination and store into decode buffer
00001F64  2800                    1326          MOVE.L  D0,D4               ; Store the dest reg in D4
00001F66  0244 0E00               1327          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001F6A  1A3C 0009               1328          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001F6E  EA6C                    1329          LSR.W   D5,D4               ; Do the actual shift
00001F70                          1330          
00001F70  2600                    1331          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001F72  0243 01C0               1332          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001F76  1A3C 0006               1333          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001F7A  EA6B                    1334          LSR.W   D5,D3               ; Do the actual shift 
00001F7C  B63C 0001               1335          CMP.B   #1,D3               ; If dst mode is 001: An 
00001F80  6700 0006               1336          BEQ     MOVEA_DST_VALID     ; dst is valid, so branch 
00001F84  6000 0D52               1337          BRA     DST_INVALID         ; Otherwise, go to invalid message 
00001F88                          1338          
00001F88                          1339  MOVEA_DST_VALID
00001F88  4EB9 00002B7A           1340          JSR     EA_GEN_SRC          ; Get EA print
00001F8E  4EF8 1D36               1341          JMP     EA_FINISH           ; Opcode is finish
00001F92                          1342  
00001F92                          1343  EA_LEA                              ; 3: ea_lea
00001F92  14FC 0020               1344          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00001F96  14FC 0020               1345          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00001F9A  14FC 0020               1346          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00001F9E  14FC 0020               1347          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00001FA2                          1348          
00001FA2  2800                    1349          MOVE.L  D0,D4               ; Store the src reg in D4
00001FA4  0244 0007               1350          ANDI.W  #src_reg,D4         ; get the bits at 2-0
00001FA8                          1351          
00001FA8  2600                    1352          MOVE.L  D0,D3               ; Store the src mode in D3
00001FAA  0243 0038               1353          ANDI.W  #src_mode,D3        ; get bits 5-3
00001FAE  1A3C 0003               1354          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB
00001FB2  EA6B                    1355          LSR.W   D5,D3               ; do the actual shift 
00001FB4  B67C 0002               1356          CMP     #2,D3               ; If D3 (src mode) is 010 (An)
00001FB8  6700 000E               1357          BEQ     LEA_SRC_VALID
00001FBC  B67C 0007               1358          CMP     #7,D3               ; If D3 (src mode) is 111 (W or L)
00001FC0  6700 0006               1359          BEQ     LEA_SRC_VALID
00001FC4  6000 0D22               1360          BRA     SRC_INVALID         ; when src mode is not 010 or 111, branch to error message
00001FC8                          1361          
00001FC8                          1362  LEA_SRC_VALID        
00001FC8  4EB9 00002B7A           1363          JSR     EA_GEN_SRC          ; Go to function 
00001FCE                          1364   
00001FCE  14FC 002C               1365          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001FD2  14FC 0020               1366          MOVE.B  #$20,(A2)+          ; Add space after comma
00001FD6                          1367  
00001FD6  2600                    1368          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001FD8  0243 01C0               1369          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001FDC  1A3C 0006               1370          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001FE0  EA6B                    1371          LSR.W   D5,D3               ; Do the actual shift
00001FE2  B63C 0007               1372          CMP.B   #7,D3               ; Check if D3 is 111
00001FE6  6700 0006               1373          BEQ     CHANGE_TO_001       ; change the D3 bits to 001 
00001FEA  6000 0CEC               1374          BRA     DST_INVALID         ; Print out an error message if bits 8-6 (dst mode) are not 111
00001FEE                          1375    
00001FEE                          1376  CHANGE_TO_001
00001FEE  163C 0001               1377          MOVE.B  #%001,D3            ; set D3 to 001 to ensure the print out A 
00001FF2                          1378          
00001FF2  2800                    1379          MOVE.L  D0,D4               ; Store the dest reg in D4 to get the Address register number
00001FF4  0244 0E00               1380          ANDI.W  #dst_reg,D4         ; get the bits at 11-9
00001FF8  1A3C 0009               1381          MOVE.B  #right9,D5          ; shift the bits 11-9 to the LSB
00001FFC  EA6C                    1382          LSR.W   D5,D4               ; do the actual shift
00001FFE  4EB9 00002B7A           1383          JSR     EA_GEN_SRC          ; Print out the address register
00002004  4EF8 1D36               1384          JMP     EA_FINISH           ; Opcode is finish
00002008                          1385  
00002008                          1386  EA_DSTONLY                          ; 4: ea_dstonly
00002008  2200                    1387          MOVE.L  D0,D1
0000200A  0241 0F00               1388          ANDI.W  #second_nibble,D1   ; get second nibble from D1
0000200E  1A3C 0008               1389          MOVE.B  #right8,D5 
00002012  EA69                    1390          LSR.W   D5,D1     
00002014  B23C 0002               1391          CMP.B   #2, D1              ; When 0010 for second nibble
00002018  6700 000E               1392          BEQ     EA_CLEAR            ; Then do EA_CLEAR
0000201C  B23C 000E               1393          CMP.B   #$E, D1             ; When 1110 for second nibble
00002020  6700 004C               1394          BEQ     EA_JSR              ; Then do EA_JSR
00002024  6000 0CB2               1395          BRA     DST_INVALID     
00002028                          1396          
00002028                          1397  EA_CLEAR
00002028  2200                    1398          MOVE.L  D0,D1
0000202A  0241 01C0               1399          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
0000202E  1A3C 0006               1400          MOVE.B  #right6,D5          ; Store 6 into D5
00002032  EA69                    1401          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002034  0201 0003               1402          ANDI.B  #3,D1               ; Remove the front bit from D1
00002038  1401                    1403          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
0000203A  4EB8 1D7C               1404          JSR     EA_SIZE_GENERAL     ; Get size 
0000203E                          1405          
0000203E  14FC 0020               1406          MOVE.B  #$20,(A2)+          ; Add space after size
00002042  14FC 0020               1407          MOVE.B  #$20,(A2)+          ; Add space 
00002046  14FC 0020               1408          MOVE.B  #$20,(A2)+          ; Add space 
0000204A                          1409          
0000204A                          1410          ; Get desination and store into decode buffer
0000204A  2800                    1411          MOVE.L  D0,D4               ; Store the current address into D4 
0000204C  0244 0007               1412          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00002050                          1413          
00002050  2600                    1414          MOVE.L  D0,D3               ; Store the current address into D3 
00002052  0243 0038               1415          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002056  1A3C 0003               1416          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
0000205A  EA6B                    1417          LSR.W   D5,D3               ; do the actual shift 
0000205C  B63C 0001               1418          CMP.B   #1,D3               ; If dest mode is 001: An
00002060  6700 0C76               1419          BEQ     DST_INVALID         ; Go to invalid message 
00002064  4EB9 00002B7A           1420          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
0000206A  4EF8 1D36               1421          JMP     EA_FINISH           ; Opcode is finish
0000206E                          1422          
0000206E  14FC 0020               1423  EA_JSR  MOVE.B  #$20,(A2)+          ; Add space 
00002072  14FC 0020               1424          MOVE.B  #$20,(A2)+          ; Add space 
00002076  14FC 0020               1425          MOVE.B  #$20,(A2)+          ; Add space 
0000207A  14FC 0020               1426          MOVE.B  #$20,(A2)+          ; Add space 
0000207E  14FC 0020               1427          MOVE.B  #$20,(A2)+          ; Add space 
00002082                          1428  
00002082                          1429          ; Get EA and store into decode buffer   
00002082  2800                    1430          MOVE.L  D0,D4               ; Store the current address into D4 
00002084  0244 0007               1431          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00002088                          1432          
00002088  2600                    1433          MOVE.L  D0,D3               ; Store the current address into D3 
0000208A  0243 0038               1434          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
0000208E  1A3C 0003               1435          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002092  EA6B                    1436          LSR.W   D5,D3               ; do the actual shift 
00002094  B67C 0002               1437          CMP     #2,D3               ; If D3 (src mode) is 010: (An)
00002098  6700 000E               1438          BEQ     JSR_EA_VALID
0000209C  B67C 0007               1439          CMP     #7,D3               ; If D3 (src mode) is 111: (W or L)
000020A0  6700 0006               1440          BEQ     JSR_EA_VALID
000020A4  6000 0C52               1441          BRA     EA_INVALID          ; Otherwise, branch to invalid message
000020A8                          1442          
000020A8                          1443  JSR_EA_VALID
000020A8  4EB9 00002B7A           1444          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
000020AE  4EF8 1D36               1445          JMP     EA_FINISH           ; Opcode is finish
000020B2                          1446  
000020B2                          1447  EA_EXT                              ; 5: ea_ext
000020B2  2200                    1448          MOVE.L  D0,D1
000020B4  0241 01C0               1449          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1 (get opmode)
000020B8  1A3C 0006               1450          MOVE.B  #right6,D5          ; Store 6 into D5
000020BC  EA69                    1451          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
000020BE  1401                    1452          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
000020C0  C2FC 0006               1453          MULU    #6, D1              ; Multiply 6 to D1 
000020C4  41F9 000020CE           1454          LEA     EA_EXT_TABLE,A0     ; Load table into A0
000020CA  4EF0 1000               1455          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000020CE                          1456  
000020CE                          1457  EA_EXT_TABLE
000020CE  4EF9 000020FE           1458          JMP     EA_OPMODE_012456    ; 000: ADD/SUB/CMP/OR/AND
000020D4  4EF9 000020FE           1459          JMP     EA_OPMODE_012456    ; 001: ADD/SUB/CMP/OR/AND
000020DA  4EF9 000020FE           1460          JMP     EA_OPMODE_012456    ; 010: ADD/SUB/CMP/OR/AND
000020E0  4EF9 000021E8           1461          JMP     EA_OPMODE_37        ; 011: ADDA/MULS/MULU/DIVU
000020E6  4EF9 000020FE           1462          JMP     EA_OPMODE_012456    ; 100: ADD/SUB/CMP/OR/AND
000020EC  4EF9 000020FE           1463          JMP     EA_OPMODE_012456    ; 101: ADD/SUB/CMP/OR/AND
000020F2  4EF9 000020FE           1464          JMP     EA_OPMODE_012456    ; 110: ADD/SUB/CMP/OR/AND
000020F8  4EF9 000021E8           1465          JMP     EA_OPMODE_37        ; 111: ADDA/MULS/MULU/DIVU
000020FE                          1466  
000020FE                          1467  EA_OPMODE_012456
000020FE  4EB8 1DDC               1468          JSR     EA_SIZE_OPMODE_012456    
00002102                          1469          
00002102  14FC 0020               1470          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002106  14FC 0020               1471          MOVE.B  #$20,(A2)+          ; Print out a space 
0000210A  14FC 0020               1472          MOVE.B  #$20,(A2)+          ; Print out a space
0000210E                          1473          
0000210E                          1474          ; Operation: <ea> + Dn -> Dn
0000210E  B43C 0000               1475          CMP.B   #%000,D2            ; When 0 then Dn is destination
00002112  6700 002E               1476          BEQ     Dn_DST
00002116  B43C 0001               1477          CMP.B   #%001,D2            ; When 1 then Dn is destination
0000211A  6700 0026               1478          BEQ     Dn_DST
0000211E  B43C 0002               1479          CMP.B   #%010,D2            ; When 2 then Dn is destination
00002122  6700 001E               1480          BEQ     Dn_DST
00002126                          1481          
00002126                          1482          ; Operation: Dn + <ea> -> <ea>
00002126  B43C 0004               1483          CMP.B   #%100,D2            ; When 4 then Dn is source
0000212A  6700 0054               1484          BEQ     Dn_SRC  
0000212E  B43C 0005               1485          CMP.B   #%101,D2            ; When 5 then Dn is source
00002132  6700 004C               1486          BEQ     Dn_SRC 
00002136  B43C 0006               1487          CMP.B   #%110,D2            ; When 6 then Dn is source
0000213A  6700 0044               1488          BEQ     Dn_SRC 
0000213E                          1489          
0000213E  6000 0BB8               1490          BRA     EA_INVALID
00002142                          1491  
00002142                          1492  Dn_DST
00002142                          1493          ; Get source and store into decode buffer
00002142  2800                    1494          MOVE.L  D0,D4               ; Store the src reg in D4
00002144  0244 0007               1495          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002148                          1496          
00002148  2600                    1497          MOVE.L  D0,D3               ; Store the src mode in D3
0000214A  0243 0038               1498          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000214E  1A3C 0003               1499          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002152  EA6B                    1500          LSR.W   D5,D3               ; Do the actual shift 
00002154  4EB9 000021C6           1501          JSR     AND_OR_CHECK 
0000215A  4EB9 00002B7A           1502          JSR     EA_GEN_SRC          ; Get EA print
00002160                          1503          
00002160  14FC 002C               1504          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002164  14FC 0020               1505          MOVE.B  #$20,(A2)+          ; Add space after comma
00002168                          1506          
00002168                          1507          ; Get desination and store into decode buffer
00002168  2800                    1508          MOVE.L  D0,D4               ; Store the dest reg in D4
0000216A  0244 0E00               1509          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000216E  1A3C 0009               1510          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002172  EA6C                    1511          LSR.W   D5,D4               ; Do the actual shift
00002174                          1512          
00002174  7600                    1513          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
00002176  4EB9 00002B7A           1514          JSR     EA_GEN_SRC          ; Get the Dn print
0000217C  4EF8 1D36               1515          JMP     EA_FINISH           ; Opcode is finish
00002180                          1516            
00002180                          1517  Dn_SRC  
00002180  BC3C 000B               1518          CMP.B   #11,D6              ; If first nibble is 1011 (indicates CMP opcode)
00002184  6700 0B72               1519          BEQ     EA_INVALID          ; Then branch to error message
00002188                          1520       
00002188                          1521          ; Get source and store into decode buffer
00002188  2800                    1522          MOVE.L  D0,D4               ; Store the src reg in D4
0000218A  0244 0E00               1523          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000218E  1A3C 0009               1524          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002192  EA6C                    1525          LSR.W   D5,D4               ; Do the actual shift
00002194                          1526          
00002194  7600                    1527          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
00002196  4EB9 00002B7A           1528          JSR     EA_GEN_SRC          ; Get the Dn print
0000219C                          1529          
0000219C  14FC 002C               1530          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000021A0  14FC 0020               1531          MOVE.B  #$20,(A2)+          ; Add space after comma
000021A4                          1532  
000021A4                          1533          ; Get destination and store into decode buffer
000021A4  2800                    1534          MOVE.L  D0,D4               ; Store the dst reg in D4
000021A6  0244 0007               1535          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000021AA                          1536          
000021AA  2600                    1537          MOVE.L  D0,D3               ; Store the dest mode in D3
000021AC  0243 0038               1538          ANDI.W  #src_mode,D3        ; Get bits 5-3
000021B0  1A3C 0003               1539          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000021B4  EA6B                    1540          LSR.W   D5,D3               ; Do the actual shift
000021B6  4EB9 00002C90           1541          JSR     An_CHECK            ; Check if mode is An
000021BC                          1542         
000021BC  4EB9 00002B7A           1543          JSR     EA_GEN_SRC          ; Get EA print
000021C2  4EF8 1D36               1544          JMP     EA_FINISH           ; Opcode is finish
000021C6                          1545  
000021C6                          1546  AND_OR_CHECK
000021C6  BC3C 000C               1547          CMP.B   #12,D6              ; If first nibble is 1100 (indicates AND opcode)
000021CA  6700 000C               1548          BEQ     EA_AND              
000021CE  BC3C 0008               1549          CMP.B   #8,D6               ; If first nibble is 1000 (indicates OR opcode)
000021D2  6700 000A               1550          BEQ     EA_OR 
000021D6  4E75                    1551          RTS
000021D8                          1552  EA_AND
000021D8  4EF9 00002C90           1553          JMP     An_CHECK            ; Go check if mode is An 
000021DE                          1554      
000021DE                          1555  EA_OR
000021DE  14FC 0020               1556          MOVE.B  #$20,(A2)+          ; Print out a space
000021E2  4EF9 00002C90           1557          JMP     An_CHECK            ; Check if mode is An
000021E8                          1558          
000021E8                          1559  EA_OPMODE_37
000021E8  BC3C 0008               1560          CMP.B   #8,D6               ; If first nibble 1000: DIVU
000021EC  6700 0012               1561          BEQ     EA_MULS_MULU_DIV
000021F0  BC3C 000C               1562          CMP.B   #12,D6              ; If first nibble 1100: MULS/MULU
000021F4  6700 000A               1563          BEQ     EA_MULS_MULU_DIV
000021F8  BC3C 000D               1564          CMP.B   #13,D6              ; If first nibble 1101: ADDA
000021FC  6700 0050               1565          BEQ     EA_ADDA                
00002200                          1566  
00002200                          1567  EA_MULS_MULU_DIV
00002200  4EB8 1E24               1568          JSR     EA_SIZE_MULS_MULU_DIV 
00002204  143C 0001               1569          MOVE.B  #1,D2               ; Set D2 to 1, since we know size is word   
00002208                          1570  
00002208  14FC 0020               1571          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000220C  14FC 0020               1572          MOVE.B  #$20,(A2)+          ; Print out a space
00002210                          1573          
00002210                          1574          ; Get source and store into decode buffer
00002210  2800                    1575          MOVE.L  D0,D4               ; Store the src reg in D4
00002212  0244 0007               1576          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002216                          1577          
00002216  2600                    1578          MOVE.L  D0,D3               ; Store the src mode in D3
00002218  0243 0038               1579          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000221C  1A3C 0003               1580          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002220  EA6B                    1581          LSR.W   D5,D3               ; Do the actual shift
00002222  4EB9 00002C90           1582          JSR     An_CHECK            ; Check if mode is An 
00002228  4EB9 00002B7A           1583          JSR     EA_GEN_SRC          ; Go get EA print
0000222E                          1584          
0000222E  14FC 002C               1585          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002232  14FC 0020               1586          MOVE.B  #$20,(A2)+          ; Add space after comma
00002236                          1587          
00002236                          1588          ; Get desination and store into decode buffer
00002236  2800                    1589          MOVE.L  D0,D4               ; Store the dest reg in D4
00002238  0244 0E00               1590          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000223C  1A3C 0009               1591          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002240  EA6C                    1592          LSR.W   D5,D4               ; Do the actual shift
00002242                          1593          
00002242  7600                    1594          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
00002244  4EB9 00002B7A           1595          JSR     EA_GEN_SRC          ; Go get EA print
0000224A  4EF8 1D36               1596          JMP     EA_FINISH           ; Opcode is finish
0000224E                          1597  
0000224E                          1598  EA_ADDA
0000224E  4EB8 1E10               1599          JSR     EA_SIZE_ADDA        ; Get size    
00002252                          1600  
00002252  14FC 0020               1601          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002256  14FC 0020               1602          MOVE.B  #$20,(A2)+          ; Print out a space
0000225A                          1603          
0000225A                          1604          ; Get source and store into decode buffer
0000225A  2800                    1605          MOVE.L  D0,D4               ; Store the src reg in D4
0000225C  0244 0007               1606          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002260                          1607          
00002260  2600                    1608          MOVE.L  D0,D3               ; Store the src mode in D3
00002262  0243 0038               1609          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002266  1A3C 0003               1610          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000226A  EA6B                    1611          LSR.W   D5,D3               ; Do the actual shift 
0000226C  4EB9 00002B7A           1612          JSR     EA_GEN_SRC
00002272                          1613          
00002272  14FC 002C               1614          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002276  14FC 0020               1615          MOVE.B  #$20,(A2)+          ; Add space after comma
0000227A                          1616          
0000227A                          1617          ; Get desination and store into decode buffer
0000227A  2800                    1618          MOVE.L  D0,D4               ; Store the dest reg in D4
0000227C  0244 0E00               1619          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002280  1A3C 0009               1620          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002284  EA6C                    1621          LSR.W   D5,D4               ; Do the actual shift
00002286                          1622          
00002286  7601                    1623          MOVE.L  #1,D3               ; Store 001 into D3, so it can jump to An 
00002288  4EB9 00002B7A           1624          JSR     EA_GEN_SRC          ; Go get EA print
0000228E  4EF8 1D36               1625          JMP     EA_FINISH           ; Opcode is finish
00002292                          1626  
00002292                          1627  EA_MOVEM        ; 6: ea_movem
00002292  2200                    1628          MOVE.L  D0, D1
00002294  0241 00F0               1629          ANDI.W  #third_nibble,D1
00002298  1A3C 0004               1630          MOVE.B  #right4,D5 
0000229C  EA69                    1631          LSR.W   D5,D1
0000229E  0201 0004               1632          ANDI.B  #4,D1
000022A2  1401                    1633          MOVE.B  D1,D2
000022A4  4EB8 1DC8               1634          JSR     EA_SIZE_MOVEM       ; get the size of the MOVEM as .W or .L 
000022A8                          1635  
000022A8  14FC 0020               1636          MOVE.B  #$20,(A2)+          ; Print out a space after the size
000022AC  14FC 0020               1637          MOVE.B  #$20,(A2)+          ; Print out a space
000022B0                          1638          
000022B0                          1639  *-----------------------------------------------------------------------------------*
000022B0                          1640  * HANDLE the case where src mode is 010. 
000022B0  2600                    1641          MOVE.L  D0,D3               ; Store the src mode in D3
000022B2  0243 0038               1642          ANDI.W  #src_mode,D3        ; Get bits 5-3
000022B6  1A3C 0003               1643          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000022BA  EA6B                    1644          LSR.W   D5,D3 
000022BC                          1645  
000022BC  B63C 0002               1646          CMP.B   #2, D3
000022C0  6700 0312               1647          BEQ     MEM_TO_REG        
000022C4                          1648  
000022C4                          1649  *-----------------------------------------------------------------------------------*
000022C4                          1650  
000022C4  2200                    1651          MOVE.L  D0, D1
000022C6  0241 0F00               1652          ANDI.W  #second_nibble,D1
000022CA  1A3C 0008               1653          MOVE.B  #right8,D5 
000022CE  EA69                    1654          LSR.W   D5,D1
000022D0  0201 0006               1655          ANDI.B  #6, D1              ; Get the Dr field
000022D4                          1656          
000022D4  B23C 0000               1657          CMP.B   #0, D1              ; check if Dr field is 0. 
000022D8  6700 000A               1658          BEQ     REG_TO_MEM
000022DC                          1659  
000022DC  B23C 0004               1660          CMP.B   #4, D1              ; check if Dr field is 1. 
000022E0  6700 02F2               1661          BEQ     MEM_TO_REG
000022E4                          1662  
000022E4                          1663  REG_TO_MEM                          ; pre-decrement - D7-D0,A7-A0
000022E4  3C15                    1664          MOVE.W  (A5), D6            ; store the register list mask field for REG to MEM
000022E6                          1665          
000022E6                          1666  * Print out the proper data and address registers. 
000022E6                          1667  * FIRST NIBBLE CHECK D0 - D3
000022E6                          1668  *-----------------------------------------------------------------------------------*
000022E6                          1669  * Print out D0 if mask field states to. 
000022E6                          1670  
000022E6  3606                    1671          MOVE.W  D6, D3
000022E8  0243 F000               1672          ANDI.W  #first_nibble,D3
000022EC  1A3C 000C               1673          MOVE.B  #right12,D5 
000022F0  EA6B                    1674          LSR.W   D5,D3
000022F2  0203 0008               1675          ANDI.B  #8,D3
000022F6  B63C 0008               1676          CMP.B   #8,D3
000022FA  6700 0006               1677          BEQ     D4_Dn_SETONE_0      ; SETONE refers to the set for reg to mem branch. 
000022FE  6000 0014               1678          BRA     CHECK1_BIT_14
00002302                          1679  D4_Dn_SETONE_0
00002302  183C 0000               1680          MOVE.B  #$0, D4
00002306                          1681          
00002306  6000 0002               1682          BRA     PRINT1_D0
0000230A                          1683          
0000230A                          1684  PRINT1_D0
0000230A  4EB9 00002BB8           1685          JSR     EA_Dn
00002310  14FC 002F               1686          MOVE.B  #$2F,(A2)+
00002314                          1687          
00002314                          1688  *-----------------------------------------------------------------------------------*
00002314                          1689  * Print out D1 if mask field states to. 
00002314                          1690  
00002314                          1691  CHECK1_BIT_14
00002314  3606                    1692          MOVE.W  D6, D3
00002316  0243 F000               1693          ANDI.W  #first_nibble,D3
0000231A  1A3C 000C               1694          MOVE.B  #right12,D5 
0000231E  EA6B                    1695          LSR.W   D5,D3
00002320  0203 0004               1696          ANDI.B  #4,D3
00002324  B63C 0004               1697          CMP.B   #4,D3
00002328  6700 0006               1698          BEQ     D4_Dn_SETONE_1      ; SETONE refers to the set for reg to mem branch. 
0000232C  6000 0014               1699          BRA     CHECK1_BIT_13
00002330                          1700  D4_Dn_SETONE_1
00002330  183C 0001               1701          MOVE.B  #$1, D4
00002334                          1702          
00002334  6000 0002               1703          BRA     PRINT1_D1
00002338                          1704          
00002338                          1705  PRINT1_D1
00002338  4EB9 00002BB8           1706          JSR     EA_Dn
0000233E  14FC 002F               1707          MOVE.B  #$2F,(A2)+
00002342                          1708  
00002342                          1709  *-----------------------------------------------------------------------------------*
00002342                          1710  * Print out D2 if mask field states to. 
00002342                          1711  
00002342                          1712  CHECK1_BIT_13
00002342  3606                    1713          MOVE.W  D6, D3
00002344  0243 F000               1714          ANDI.W  #first_nibble,D3
00002348  1A3C 000C               1715          MOVE.B  #right12,D5 
0000234C  EA6B                    1716          LSR.W   D5,D3
0000234E  0203 0002               1717          ANDI.B  #2,D3
00002352  B63C 0002               1718          CMP.B   #2,D3
00002356  6700 0006               1719          BEQ     D4_Dn_SETONE_2      ; SETONE refers to the set for reg to mem branch. 
0000235A  6000 0014               1720          BRA     CHECK1_BIT_12
0000235E                          1721  D4_Dn_SETONE_2
0000235E  183C 0002               1722          MOVE.B  #$2, D4
00002362                          1723          
00002362  6000 0002               1724          BRA     PRINT1_D2
00002366                          1725          
00002366                          1726  PRINT1_D2
00002366  4EB9 00002BB8           1727          JSR     EA_Dn
0000236C  14FC 002F               1728          MOVE.B  #$2F,(A2)+       
00002370                          1729  
00002370                          1730  *-----------------------------------------------------------------------------------*
00002370                          1731  * Print out D3 if mask field states to. 
00002370                          1732  
00002370                          1733  CHECK1_BIT_12
00002370  3606                    1734          MOVE.W  D6, D3
00002372  0243 F000               1735          ANDI.W  #first_nibble,D3
00002376  1A3C 000C               1736          MOVE.B  #right12,D5 
0000237A  EA6B                    1737          LSR.W   D5,D3
0000237C  0203 0001               1738          ANDI.B  #1,D3
00002380  B63C 0001               1739          CMP.B   #1,D3
00002384  6700 0006               1740          BEQ     D4_Dn_SETONE_3      ; SETONE refers to the set for reg to mem branch. 
00002388  6000 0014               1741          BRA     CHECK1_BIT_11
0000238C                          1742  D4_Dn_SETONE_3
0000238C  183C 0003               1743          MOVE.B  #$3, D4
00002390                          1744          
00002390  6000 0002               1745          BRA     PRINT1_D3
00002394                          1746          
00002394                          1747  PRINT1_D3
00002394  4EB9 00002BB8           1748          JSR     EA_Dn
0000239A  14FC 002F               1749          MOVE.B  #$2F,(A2)+ 
0000239E                          1750          
0000239E                          1751  * SECOND NIBBLE CHECK D4 - D7
0000239E                          1752  *-----------------------------------------------------------------------------------*
0000239E                          1753  * Print out D4 if mask field states to. 
0000239E                          1754  
0000239E                          1755  
0000239E                          1756  CHECK1_BIT_11
0000239E  3606                    1757          MOVE.W  D6, D3
000023A0  0243 0F00               1758          ANDI.W  #second_nibble,D3
000023A4  1A3C 0008               1759          MOVE.B  #right8,D5 
000023A8  EA6B                    1760          LSR.W   D5,D3
000023AA  0203 0008               1761          ANDI.B  #8,D3
000023AE  B63C 0008               1762          CMP.B   #8,D3
000023B2  6700 0006               1763          BEQ     D4_Dn_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
000023B6  6000 0014               1764          BRA     CHECK1_BIT_10
000023BA                          1765  D4_Dn_SETONE_4
000023BA  183C 0004               1766          MOVE.B  #$4, D4
000023BE                          1767          
000023BE  6000 0002               1768          BRA     PRINT1_D4
000023C2                          1769          
000023C2                          1770  PRINT1_D4
000023C2  4EB9 00002BB8           1771          JSR     EA_Dn
000023C8  14FC 002F               1772          MOVE.B  #$2F,(A2)+ 
000023CC                          1773  
000023CC                          1774  *-----------------------------------------------------------------------------------*
000023CC                          1775  * Print out D5 if mask field states to. 
000023CC                          1776  
000023CC                          1777  CHECK1_BIT_10
000023CC  3606                    1778          MOVE.W  D6, D3
000023CE  0243 0F00               1779          ANDI.W  #second_nibble,D3
000023D2  1A3C 0008               1780          MOVE.B  #right8,D5 
000023D6  EA6B                    1781          LSR.W   D5,D3
000023D8  0203 0004               1782          ANDI.B  #4,D3
000023DC  B63C 0004               1783          CMP.B   #4,D3
000023E0  6700 0006               1784          BEQ     D4_Dn_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
000023E4  6000 0014               1785          BRA     CHECK1_BIT_9
000023E8                          1786  D4_Dn_SETONE_5
000023E8  183C 0005               1787          MOVE.B  #$5, D4
000023EC                          1788          
000023EC  6000 0002               1789          BRA     PRINT1_D5
000023F0                          1790          
000023F0                          1791  PRINT1_D5
000023F0  4EB9 00002BB8           1792          JSR     EA_Dn
000023F6  14FC 002F               1793          MOVE.B  #$2F,(A2)+ 
000023FA                          1794  
000023FA                          1795  *-----------------------------------------------------------------------------------*
000023FA                          1796  * Print out D6 if mask field states to. 
000023FA                          1797  
000023FA                          1798  CHECK1_BIT_9
000023FA  3606                    1799          MOVE.W  D6, D3
000023FC  0243 0F00               1800          ANDI.W  #second_nibble,D3
00002400  1A3C 0008               1801          MOVE.B  #right8,D5 
00002404  EA6B                    1802          LSR.W   D5,D3
00002406  0203 0002               1803          ANDI.B  #2,D3
0000240A  B63C 0002               1804          CMP.B   #2,D3
0000240E  6700 0006               1805          BEQ     D4_Dn_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
00002412  6000 0014               1806          BRA     CHECK1_BIT_8
00002416                          1807  D4_Dn_SETONE_6
00002416  183C 0006               1808          MOVE.B  #$6, D4
0000241A                          1809          
0000241A  6000 0002               1810          BRA     PRINT1_D6
0000241E                          1811          
0000241E                          1812  PRINT1_D6
0000241E  4EB9 00002BB8           1813          JSR     EA_Dn
00002424  14FC 002F               1814          MOVE.B  #$2F,(A2)+ 
00002428                          1815          
00002428                          1816  *-----------------------------------------------------------------------------------*
00002428                          1817  * Print out D7 if mask field states to. 
00002428                          1818  
00002428                          1819  CHECK1_BIT_8
00002428  3606                    1820          MOVE.W  D6, D3
0000242A  0243 0F00               1821          ANDI.W  #second_nibble,D3
0000242E  1A3C 0008               1822          MOVE.B  #right8,D5 
00002432  EA6B                    1823          LSR.W   D5,D3
00002434  0203 0001               1824          ANDI.B  #1,D3
00002438  B63C 0001               1825          CMP.B   #1,D3
0000243C  6700 0006               1826          BEQ     D4_Dn_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
00002440  6000 0014               1827          BRA     CHECK1_BIT_7
00002444                          1828  D4_Dn_SETONE_7
00002444  183C 0007               1829          MOVE.B  #$7, D4
00002448                          1830          
00002448  6000 0002               1831          BRA     PRINT1_D7
0000244C                          1832          
0000244C                          1833  PRINT1_D7
0000244C  4EB9 00002BB8           1834          JSR     EA_Dn
00002452  14FC 002F               1835          MOVE.B  #$2F,(A2)+ 
00002456                          1836  
00002456                          1837  * THIRD NIBBLE CHECK - A0 / A3
00002456                          1838  *-----------------------------------------------------------------------------------*
00002456                          1839  * Print out A0 if mask field states to. 
00002456                          1840  
00002456                          1841  CHECK1_BIT_7
00002456  3606                    1842          MOVE.W  D6, D3
00002458  0243 00F0               1843          ANDI.W  #third_nibble,D3
0000245C  1A3C 0004               1844          MOVE.B  #right4,D5 
00002460  EA6B                    1845          LSR.W   D5,D3
00002462  0203 0008               1846          ANDI.B  #8,D3
00002466  B63C 0008               1847          CMP.B   #8,D3
0000246A  6700 0006               1848          BEQ     D4_An_SETONE_0       ; SETONE refers to the set for reg to mem branch. 
0000246E  6000 0014               1849          BRA     CHECK1_BIT_6
00002472                          1850  D4_An_SETONE_0
00002472  183C 0000               1851          MOVE.B  #$0, D4
00002476                          1852          
00002476  6000 0002               1853          BRA     PRINT1_A0
0000247A                          1854          
0000247A                          1855  PRINT1_A0
0000247A  4EB9 00002BC4           1856          JSR     EA_An
00002480  14FC 002F               1857          MOVE.B  #$2F,(A2)+ 
00002484                          1858          
00002484                          1859  *-----------------------------------------------------------------------------------*
00002484                          1860  * Print out A1 if mask field states to. 
00002484                          1861  
00002484                          1862  CHECK1_BIT_6
00002484  3606                    1863          MOVE.W  D6, D3
00002486  0243 00F0               1864          ANDI.W  #third_nibble,D3
0000248A  1A3C 0004               1865          MOVE.B  #right4,D5 
0000248E  EA6B                    1866          LSR.W   D5,D3
00002490  0203 0004               1867          ANDI.B  #4,D3
00002494  B63C 0004               1868          CMP.B   #4,D3
00002498  6700 0006               1869          BEQ     D4_An_SETONE_1       ; SETONE refers to the set for reg to mem branch. 
0000249C  6000 0014               1870          BRA     CHECK1_BIT_5
000024A0                          1871  D4_An_SETONE_1
000024A0  183C 0001               1872          MOVE.B  #$1, D4
000024A4                          1873          
000024A4  6000 0002               1874          BRA     PRINT1_A1
000024A8                          1875          
000024A8                          1876  PRINT1_A1
000024A8  4EB9 00002BC4           1877          JSR     EA_An
000024AE  14FC 002F               1878          MOVE.B  #$2F,(A2)+ 
000024B2                          1879  
000024B2                          1880  *-----------------------------------------------------------------------------------*
000024B2                          1881  * Print out A2 if mask field states to. 
000024B2                          1882  
000024B2                          1883  CHECK1_BIT_5
000024B2  3606                    1884          MOVE.W  D6, D3
000024B4  0243 00F0               1885          ANDI.W  #third_nibble,D3
000024B8  1A3C 0004               1886          MOVE.B  #right4,D5 
000024BC  EA6B                    1887          LSR.W   D5,D3
000024BE  0203 0002               1888          ANDI.B  #2,D3
000024C2  B63C 0002               1889          CMP.B   #2,D3
000024C6  6700 0006               1890          BEQ     D4_An_SETONE_2       ; SETONE refers to the set for reg to mem branch. 
000024CA  6000 0014               1891          BRA     CHECK1_BIT_4
000024CE                          1892  D4_An_SETONE_2
000024CE  183C 0002               1893          MOVE.B  #$2, D4
000024D2                          1894          
000024D2  6000 0002               1895          BRA     PRINT1_A2
000024D6                          1896          
000024D6                          1897  PRINT1_A2
000024D6  4EB9 00002BC4           1898          JSR     EA_An
000024DC  14FC 002F               1899          MOVE.B  #$2F,(A2)+ 
000024E0                          1900  
000024E0                          1901  *-----------------------------------------------------------------------------------*
000024E0                          1902  * Print out A3 if mask field states to. 
000024E0                          1903  
000024E0                          1904  CHECK1_BIT_4
000024E0  3606                    1905          MOVE.W  D6, D3
000024E2  0243 00F0               1906          ANDI.W  #third_nibble,D3
000024E6  1A3C 0004               1907          MOVE.B  #right4,D5 
000024EA  EA6B                    1908          LSR.W   D5,D3
000024EC  0203 0001               1909          ANDI.B  #1,D3
000024F0  B63C 0001               1910          CMP.B   #1,D3
000024F4  6700 0006               1911          BEQ     D4_An_SETONE_3       ; SETONE refers to the set for reg to mem branch. 
000024F8  6000 0014               1912          BRA     CHECK1_BIT_3
000024FC                          1913  D4_An_SETONE_3
000024FC  183C 0003               1914          MOVE.B  #$3, D4
00002500                          1915          
00002500  6000 0002               1916          BRA     PRINT1_A3
00002504                          1917          
00002504                          1918  PRINT1_A3
00002504  4EB9 00002BC4           1919          JSR     EA_An
0000250A  14FC 002F               1920          MOVE.B  #$2F,(A2)+ 
0000250E                          1921  
0000250E                          1922  * FOURTH NIBBLE CHECK A4 - A7 
0000250E                          1923  *-----------------------------------------------------------------------------------*
0000250E                          1924  * Print out A4 if mask field states to. 
0000250E                          1925  
0000250E                          1926  CHECK1_BIT_3
0000250E  3606                    1927          MOVE.W  D6, D3
00002510  0243 000F               1928          ANDI.W  #fourth_nibble,D3
00002514  0203 0008               1929          ANDI.B  #8,D3
00002518  B63C 0008               1930          CMP.B   #8,D3
0000251C  6700 0006               1931          BEQ     D4_An_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
00002520  6000 0014               1932          BRA     CHECK1_BIT_2
00002524                          1933  D4_An_SETONE_4
00002524  183C 0004               1934          MOVE.B  #$4, D4
00002528                          1935          
00002528  6000 0002               1936          BRA     PRINT1_A4
0000252C                          1937          
0000252C                          1938  PRINT1_A4
0000252C  4EB9 00002BC4           1939          JSR     EA_An
00002532  14FC 002F               1940          MOVE.B  #$2F,(A2)+ 
00002536                          1941  
00002536                          1942  *-----------------------------------------------------------------------------------*
00002536                          1943  * Print out A5 if mask field states to. 
00002536                          1944  
00002536                          1945  CHECK1_BIT_2
00002536  3606                    1946          MOVE.W  D6, D3
00002538  0243 000F               1947          ANDI.W  #fourth_nibble,D3
0000253C  0203 0004               1948          ANDI.B  #4,D3
00002540  B63C 0004               1949          CMP.B   #4,D3
00002544  6700 0006               1950          BEQ     D4_An_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
00002548  6000 0014               1951          BRA     CHECK1_BIT_1
0000254C                          1952  D4_An_SETONE_5
0000254C  183C 0005               1953          MOVE.B  #$5, D4
00002550                          1954          
00002550  6000 0002               1955          BRA     PRINT1_A5
00002554                          1956          
00002554                          1957  PRINT1_A5
00002554  4EB9 00002BC4           1958          JSR     EA_An
0000255A  14FC 002F               1959          MOVE.B  #$2F,(A2)+ 
0000255E                          1960  
0000255E                          1961  *-----------------------------------------------------------------------------------*
0000255E                          1962  * Print out A6 if mask field states to. 
0000255E                          1963  
0000255E                          1964  CHECK1_BIT_1
0000255E  3606                    1965          MOVE.W  D6, D3
00002560  0243 000F               1966          ANDI.W  #fourth_nibble,D3
00002564  0203 0002               1967          ANDI.B  #2,D3
00002568  B63C 0002               1968          CMP.B   #2,D3
0000256C  6700 0006               1969          BEQ     D4_An_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
00002570  6000 0014               1970          BRA     CHECK1_BIT_0
00002574                          1971  D4_An_SETONE_6
00002574  183C 0006               1972          MOVE.B  #$6, D4
00002578                          1973          
00002578  6000 0002               1974          BRA     PRINT1_A6
0000257C                          1975          
0000257C                          1976  PRINT1_A6
0000257C  4EB9 00002BC4           1977          JSR     EA_An
00002582  14FC 002F               1978          MOVE.B  #$2F,(A2)+ 
00002586                          1979  
00002586                          1980  *-----------------------------------------------------------------------------------*
00002586                          1981  * Print out A7 if mask field states to. 
00002586                          1982  
00002586                          1983  CHECK1_BIT_0
00002586  3606                    1984          MOVE.W  D6, D3
00002588  0243 000F               1985          ANDI.W  #fourth_nibble,D3
0000258C  0203 0001               1986          ANDI.B  #1,D3
00002590  B63C 0001               1987          CMP.B   #1,D3
00002594  6700 0006               1988          BEQ     D4_An_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
00002598  6000 0014               1989          BRA     FINISH_REG_TO_MEM
0000259C                          1990  D4_An_SETONE_7
0000259C  183C 0007               1991          MOVE.B  #$7, D4
000025A0                          1992          
000025A0  6000 0002               1993          BRA     PRINT1_A7
000025A4                          1994          
000025A4                          1995  PRINT1_A7
000025A4  4EB9 00002BC4           1996          JSR     EA_An
000025AA  14FC 002F               1997          MOVE.B  #$2F,(A2)+ 
000025AE                          1998  
000025AE                          1999  FINISH_REG_TO_MEM
000025AE  14FC 002C               2000          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000025B2  14FC 0020               2001          MOVE.B  #$20,(A2)+          ; Add space after comma
000025B6                          2002  
000025B6  2800                    2003          MOVE.L  D0,D4               ; Store the src reg in D4
000025B8  0244 0007               2004          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000025BC                          2005          
000025BC  2600                    2006          MOVE.L  D0,D3               ; Store the src mode in D3
000025BE  0243 0038               2007          ANDI.W  #src_mode,D3        ; Get bits 5-3
000025C2  1A3C 0003               2008          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000025C6  EA6B                    2009          LSR.W   D5,D3               ; Do the actual shift 
000025C8  4EB9 00002B7A           2010          JSR     EA_GEN_SRC
000025CE                          2011          
000025CE  301D                    2012          MOVE.W  (A5)+, D0 
000025D0                          2013  
000025D0  4EF8 1D36               2014          JMP     EA_FINISH
000025D4                          2015  
000025D4                          2016  MEM_TO_REG                          ; post-increment + A7-A0,D7-D0
000025D4                          2017  
000025D4  B63C 0002               2018          CMP.B   #2, D3              ; check if the destination is (An)
000025D8  6700 0022               2019          BEQ     MEM_TO_REG_CONTINUE ; branch to print out the address and data registers. 
000025DC                          2020          
000025DC  2800                    2021          MOVE.L  D0,D4               ; Store the src reg in D4
000025DE  0244 0007               2022          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000025E2                          2023          
000025E2  2600                    2024          MOVE.L  D0,D3               ; Store the src mode in D3
000025E4  0243 0038               2025          ANDI.W  #src_mode,D3        ; Get bits 5-3
000025E8  1A3C 0003               2026          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000025EC  EA6B                    2027          LSR.W   D5,D3               ; Do the actual shift 
000025EE  4EB9 00002B7A           2028          JSR     EA_GEN_SRC
000025F4                          2029          
000025F4  14FC 002C               2030          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000025F8  14FC 0020               2031          MOVE.B  #$20,(A2)+          ; Add space after comma
000025FC                          2032  
000025FC                          2033          
000025FC                          2034  * Print out the proper data and address registers. 
000025FC                          2035  * FIRST NIBBLE CHECK A7 - A4
000025FC                          2036  *-----------------------------------------------------------------------------------*
000025FC                          2037  * Print out A7 if mask field states to. 
000025FC                          2038  MEM_TO_REG_CONTINUE
000025FC  3C15                    2039          MOVE.W  (A5), D6            ; store the register list mask field for MEM to REG
000025FE                          2040          
000025FE  3606                    2041          MOVE.W  D6, D3
00002600  0243 F000               2042          ANDI.W  #first_nibble,D3
00002604  1A3C 000C               2043          MOVE.B  #right12,D5 
00002608  EA6B                    2044          LSR.W   D5,D3
0000260A  0203 0008               2045          ANDI.B  #8,D3
0000260E  B63C 0008               2046          CMP.B   #8,D3
00002612  6700 0006               2047          BEQ     D4_An_SET_7
00002616  6000 0014               2048          BRA     CHECK_BIT_14
0000261A                          2049  D4_An_SET_7
0000261A  183C 0007               2050          MOVE.B  #$7, D4
0000261E                          2051          
0000261E  6000 0002               2052          BRA     PRINT_A7
00002622                          2053          
00002622                          2054  PRINT_A7
00002622  4EB9 00002BC4           2055          JSR     EA_An
00002628  14FC 002F               2056          MOVE.B  #$2F,(A2)+
0000262C                          2057          
0000262C                          2058  *-----------------------------------------------------------------------------------*
0000262C                          2059  * Print out A6 if mask field states to. 
0000262C                          2060  
0000262C                          2061  CHECK_BIT_14
0000262C  3606                    2062          MOVE.W  D6, D3
0000262E  0243 F000               2063          ANDI.W  #first_nibble,D3
00002632  1A3C 000C               2064          MOVE.B  #right12,D5 
00002636  EA6B                    2065          LSR.W   D5,D3
00002638  0203 0004               2066          ANDI.B  #4,D3
0000263C  B63C 0004               2067          CMP.B   #4,D3
00002640  6700 0006               2068          BEQ     D4_An_SET_6
00002644  6000 0014               2069          BRA     CHECK_BIT_13
00002648                          2070  D4_An_SET_6
00002648  183C 0006               2071          MOVE.B  #$6, D4
0000264C                          2072          
0000264C  6000 0002               2073          BRA     PRINT_A6
00002650                          2074          
00002650                          2075  PRINT_A6
00002650  4EB9 00002BC4           2076          JSR     EA_An
00002656  14FC 002F               2077          MOVE.B  #$2F,(A2)+
0000265A                          2078  
0000265A                          2079  *-----------------------------------------------------------------------------------*
0000265A                          2080  * Print out A5 if mask field states to. 
0000265A                          2081  
0000265A                          2082  CHECK_BIT_13
0000265A  3606                    2083          MOVE.W  D6, D3
0000265C  0243 F000               2084          ANDI.W  #first_nibble,D3
00002660  1A3C 000C               2085          MOVE.B  #right12,D5 
00002664  EA6B                    2086          LSR.W   D5,D3
00002666  0203 0002               2087          ANDI.B  #2,D3
0000266A  B63C 0002               2088          CMP.B   #2,D3
0000266E  6700 0006               2089          BEQ     D4_An_SET_5
00002672  6000 0014               2090          BRA     CHECK_BIT_12
00002676                          2091  D4_An_SET_5
00002676  183C 0005               2092          MOVE.B  #$5, D4
0000267A                          2093          
0000267A  6000 0002               2094          BRA     PRINT_A5
0000267E                          2095          
0000267E                          2096  PRINT_A5
0000267E  4EB9 00002BC4           2097          JSR     EA_An
00002684  14FC 002F               2098          MOVE.B  #$2F,(A2)+
00002688                          2099  
00002688                          2100  *-----------------------------------------------------------------------------------*
00002688                          2101  * Print out A4 if mask field states to. 
00002688                          2102          
00002688                          2103  CHECK_BIT_12
00002688  3606                    2104          MOVE.W  D6, D3
0000268A  0243 F000               2105          ANDI.W  #first_nibble,D3
0000268E  1A3C 000C               2106          MOVE.B  #right12,D5 
00002692  EA6B                    2107          LSR.W   D5,D3
00002694  0203 0001               2108          ANDI.B  #1,D3
00002698  B63C 0001               2109          CMP.B   #1,D3
0000269C  6700 0006               2110          BEQ     D4_An_SET_4
000026A0  6000 0014               2111          BRA     CHECK_BIT_11
000026A4                          2112  D4_An_SET_4
000026A4  183C 0004               2113          MOVE.B  #$4, D4
000026A8                          2114          
000026A8  6000 0002               2115          BRA     PRINT_A4
000026AC                          2116          
000026AC                          2117  PRINT_A4
000026AC  4EB9 00002BC4           2118          JSR     EA_An
000026B2  14FC 002F               2119          MOVE.B  #$2F,(A2)+
000026B6                          2120  
000026B6                          2121  *-----------------------------------------------------------------------------------*
000026B6                          2122  * Print out A3 if mask field states to. 
000026B6                          2123  * SECOND NIBBLE CHECK A7 - A4
000026B6                          2124    
000026B6                          2125  CHECK_BIT_11
000026B6  3606                    2126          MOVE.W  D6, D3
000026B8  0243 0F00               2127          ANDI.W  #second_nibble,D3
000026BC  1A3C 0008               2128          MOVE.B  #right8,D5 
000026C0  EA6B                    2129          LSR.W   D5,D3
000026C2  0203 0008               2130          ANDI.B  #8,D3
000026C6  B63C 0008               2131          CMP.B   #8,D3
000026CA  6700 0006               2132          BEQ     D4_An_SET_3
000026CE  6000 0014               2133          BRA     CHECK_BIT_10
000026D2                          2134  D4_An_SET_3
000026D2  183C 0003               2135          MOVE.B  #$3, D4
000026D6                          2136          
000026D6  6000 0002               2137          BRA     PRINT_A3
000026DA                          2138          
000026DA                          2139  PRINT_A3
000026DA  4EB9 00002BC4           2140          JSR     EA_An
000026E0  14FC 002F               2141          MOVE.B  #$2F,(A2)+     
000026E4                          2142  
000026E4                          2143  *-----------------------------------------------------------------------------------*
000026E4                          2144  * Print out A2 if mask field states to. 
000026E4                          2145    
000026E4                          2146  CHECK_BIT_10
000026E4  3606                    2147          MOVE.W  D6, D3
000026E6  0243 0F00               2148          ANDI.W  #second_nibble,D3
000026EA  1A3C 0008               2149          MOVE.B  #right8,D5 
000026EE  EA6B                    2150          LSR.W   D5,D3
000026F0  0203 0004               2151          ANDI.B  #4,D3
000026F4  B63C 0004               2152          CMP.B   #4,D3
000026F8  6700 0006               2153          BEQ     D4_An_SET_2
000026FC  6000 0014               2154          BRA     CHECK_BIT_9
00002700                          2155  D4_An_SET_2
00002700  183C 0002               2156          MOVE.B  #$2, D4
00002704                          2157          
00002704  6000 0002               2158          BRA     PRINT_A2
00002708                          2159          
00002708                          2160  PRINT_A2
00002708  4EB9 00002BC4           2161          JSR     EA_An
0000270E  14FC 002F               2162          MOVE.B  #$2F,(A2)+  
00002712                          2163  
00002712                          2164  *-----------------------------------------------------------------------------------*
00002712                          2165  * Print out A1 if mask field states to. 
00002712                          2166    
00002712                          2167  CHECK_BIT_9
00002712  3606                    2168          MOVE.W  D6, D3
00002714  0243 0F00               2169          ANDI.W  #second_nibble,D3
00002718  1A3C 0008               2170          MOVE.B  #right8,D5 
0000271C  EA6B                    2171          LSR.W   D5,D3
0000271E  0203 0002               2172          ANDI.B  #2,D3
00002722  B63C 0002               2173          CMP.B   #2,D3
00002726  6700 0006               2174          BEQ     D4_An_SET_1
0000272A  6000 0012               2175          BRA     CHECK_BIT_8
0000272E                          2176  D4_An_SET_1
0000272E  183C 0001               2177          MOVE.B  #$1, D4
00002732                          2178          
00002732  60D4                    2179          BRA     PRINT_A2
00002734                          2180          
00002734                          2181  PRINT_A1
00002734  4EB9 00002BC4           2182          JSR     EA_An
0000273A  14FC 002F               2183          MOVE.B  #$2F,(A2)+ 
0000273E                          2184  
0000273E                          2185  *-----------------------------------------------------------------------------------*
0000273E                          2186  * Print out A0 if mask field states to. 
0000273E                          2187    
0000273E                          2188  CHECK_BIT_8
0000273E  3606                    2189          MOVE.W  D6, D3
00002740  0243 0F00               2190          ANDI.W  #second_nibble,D3
00002744  1A3C 0008               2191          MOVE.B  #right8,D5 
00002748  EA6B                    2192          LSR.W   D5,D3
0000274A  0203 0001               2193          ANDI.B  #1,D3
0000274E  B63C 0001               2194          CMP.B   #1,D3
00002752  6700 0006               2195          BEQ     D4_An_SET_0
00002756  6000 0014               2196          BRA     CHECK_BIT_7
0000275A                          2197  D4_An_SET_0
0000275A  183C 0000               2198          MOVE.B  #$0, D4
0000275E                          2199          
0000275E  6000 0002               2200          BRA     PRINT_A0
00002762                          2201          
00002762                          2202  PRINT_A0
00002762  4EB9 00002BC4           2203          JSR     EA_An
00002768  14FC 002F               2204          MOVE.B  #$2F,(A2)+        
0000276C                          2205  
0000276C                          2206  *-----------------------------------------------------------------------------------*
0000276C                          2207  * Print out D7 if mask field states to. 
0000276C                          2208  * THIRD NIBBLE CHECK D7-D0
0000276C                          2209  
0000276C                          2210  CHECK_BIT_7
0000276C  3606                    2211          MOVE.W  D6, D3
0000276E  0243 00F0               2212          ANDI.W  #third_nibble,D3
00002772  1A3C 0004               2213          MOVE.B  #right4,D5 
00002776  EA6B                    2214          LSR.W   D5,D3
00002778  0203 0008               2215          ANDI.B  #8,D3
0000277C  B63C 0008               2216          CMP.B   #8,D3
00002780  6700 0006               2217          BEQ     D4_Dn_SET_7
00002784  6000 0014               2218          BRA     CHECK_BIT_6
00002788                          2219  D4_Dn_SET_7
00002788  183C 0007               2220          MOVE.B  #$7, D4
0000278C                          2221          
0000278C  6000 0002               2222          BRA     PRINT_D7
00002790                          2223          
00002790                          2224  PRINT_D7
00002790  4EB9 00002BB8           2225          JSR     EA_Dn
00002796  14FC 002F               2226          MOVE.B  #$2F,(A2)+
0000279A                          2227  
0000279A                          2228  *-----------------------------------------------------------------------------------*
0000279A                          2229  * Print out D6 if mask field states to. 
0000279A                          2230  
0000279A                          2231  CHECK_BIT_6
0000279A  3606                    2232          MOVE.W  D6, D3
0000279C  0243 00F0               2233          ANDI.W  #third_nibble,D3
000027A0  1A3C 0004               2234          MOVE.B  #right4,D5 
000027A4  EA6B                    2235          LSR.W   D5,D3
000027A6  0203 0004               2236          ANDI.B  #4,D3
000027AA  B63C 0004               2237          CMP.B   #4,D3
000027AE  6700 0006               2238          BEQ     D4_Dn_SET_6
000027B2  6000 0014               2239          BRA     CHECK_BIT_5
000027B6                          2240  D4_Dn_SET_6
000027B6  183C 0006               2241          MOVE.B  #$6, D4
000027BA                          2242          
000027BA  6000 0002               2243          BRA     PRINT_D6
000027BE                          2244          
000027BE                          2245  PRINT_D6
000027BE  4EB9 00002BB8           2246          JSR     EA_Dn
000027C4  14FC 002F               2247          MOVE.B  #$2F,(A2)+
000027C8                          2248  
000027C8                          2249  *-----------------------------------------------------------------------------------*
000027C8                          2250  * Print out D5 if mask field states to. 
000027C8                          2251  
000027C8                          2252  CHECK_BIT_5
000027C8  3606                    2253          MOVE.W  D6, D3
000027CA  0243 00F0               2254          ANDI.W  #third_nibble,D3
000027CE  1A3C 0004               2255          MOVE.B  #right4,D5 
000027D2  EA6B                    2256          LSR.W   D5,D3
000027D4  0203 0002               2257          ANDI.B  #2,D3
000027D8  B63C 0002               2258          CMP.B   #2,D3
000027DC  6700 0006               2259          BEQ     D4_Dn_SET_5
000027E0  6000 0014               2260          BRA     CHECK_BIT_4
000027E4                          2261  D4_Dn_SET_5
000027E4  183C 0005               2262          MOVE.B  #$5, D4
000027E8                          2263          
000027E8  6000 0002               2264          BRA     PRINT_D5
000027EC                          2265          
000027EC                          2266  PRINT_D5
000027EC  4EB9 00002BB8           2267          JSR     EA_Dn
000027F2  14FC 002F               2268          MOVE.B  #$2F,(A2)+
000027F6                          2269  
000027F6                          2270  *-----------------------------------------------------------------------------------*
000027F6                          2271  * Print out D4 if mask field states to. 
000027F6                          2272  
000027F6                          2273  CHECK_BIT_4
000027F6  3606                    2274          MOVE.W  D6, D3
000027F8  0243 00F0               2275          ANDI.W  #third_nibble,D3
000027FC  1A3C 0004               2276          MOVE.B  #right4,D5 
00002800  EA6B                    2277          LSR.W   D5,D3
00002802  0203 0001               2278          ANDI.B  #1,D3
00002806  B63C 0001               2279          CMP.B   #1,D3
0000280A  6700 0006               2280          BEQ     D4_Dn_SET_4
0000280E  6000 0014               2281          BRA     CHECK_BIT_3
00002812                          2282  D4_Dn_SET_4
00002812  183C 0004               2283          MOVE.B  #$4, D4
00002816                          2284          
00002816  6000 0002               2285          BRA     PRINT_D4
0000281A                          2286          
0000281A                          2287  PRINT_D4
0000281A  4EB9 00002BB8           2288          JSR     EA_Dn
00002820  14FC 002F               2289          MOVE.B  #$2F,(A2)+
00002824                          2290  
00002824                          2291  *-----------------------------------------------------------------------------------*
00002824                          2292  * Print out D3 if mask field states to. 
00002824                          2293  * FOURTH NIBBLE CHECK / D3 - D0
00002824                          2294  
00002824                          2295  CHECK_BIT_3
00002824  3606                    2296          MOVE.W  D6, D3
00002826  0243 000F               2297          ANDI.W  #fourth_nibble,D3
0000282A  0203 0008               2298          ANDI.B  #8,D3
0000282E  B63C 0008               2299          CMP.B   #8,D3
00002832  6700 0006               2300          BEQ     D4_Dn_SET_3
00002836  6000 0014               2301          BRA     CHECK_BIT_2
0000283A                          2302  D4_Dn_SET_3
0000283A  183C 0003               2303          MOVE.B  #$3, D4
0000283E                          2304          
0000283E  6000 0002               2305          BRA     PRINT_D3
00002842                          2306          
00002842                          2307  PRINT_D3
00002842  4EB9 00002BB8           2308          JSR     EA_Dn
00002848  14FC 002F               2309          MOVE.B  #$2F,(A2)+
0000284C                          2310  
0000284C                          2311  *-----------------------------------------------------------------------------------*
0000284C                          2312  * Print out D2 if mask field states to. 
0000284C                          2313  
0000284C                          2314  CHECK_BIT_2
0000284C  3606                    2315          MOVE.W  D6, D3
0000284E  0243 000F               2316          ANDI.W  #fourth_nibble,D3
00002852  0203 0004               2317          ANDI.B  #4,D3
00002856  B63C 0004               2318          CMP.B   #4,D3
0000285A  6700 0006               2319          BEQ     D4_Dn_SET_2
0000285E  6000 0014               2320          BRA     CHECK_BIT_1
00002862                          2321  D4_Dn_SET_2
00002862  183C 0002               2322          MOVE.B  #$2, D4
00002866                          2323          
00002866  6000 0002               2324          BRA     PRINT_D2
0000286A                          2325          
0000286A                          2326  PRINT_D2
0000286A  4EB9 00002BB8           2327          JSR     EA_Dn
00002870  14FC 002F               2328          MOVE.B  #$2F,(A2)+
00002874                          2329  
00002874                          2330  *-----------------------------------------------------------------------------------*
00002874                          2331  * Print out D1 if mask field states to. 
00002874                          2332  
00002874                          2333  CHECK_BIT_1
00002874  3606                    2334          MOVE.W  D6, D3
00002876  0243 000F               2335          ANDI.W  #fourth_nibble,D3
0000287A  0203 0002               2336          ANDI.B  #2,D3
0000287E  B63C 0002               2337          CMP.B   #2,D3
00002882  6700 0006               2338          BEQ     D4_Dn_SET_1
00002886  6000 0014               2339          BRA     CHECK_BIT_0
0000288A                          2340  D4_Dn_SET_1
0000288A  183C 0001               2341          MOVE.B  #$1, D4
0000288E                          2342          
0000288E  6000 0002               2343          BRA     PRINT_D1
00002892                          2344          
00002892                          2345  PRINT_D1
00002892  4EB9 00002BB8           2346          JSR     EA_Dn
00002898  14FC 002F               2347          MOVE.B  #$2F,(A2)+
0000289C                          2348  
0000289C                          2349  *-----------------------------------------------------------------------------------*
0000289C                          2350  * Print out D0 if mask field states to. 
0000289C                          2351  
0000289C                          2352  CHECK_BIT_0
0000289C  3606                    2353          MOVE.W  D6, D3
0000289E  0243 000F               2354          ANDI.W  #fourth_nibble,D3
000028A2  0203 0001               2355          ANDI.B  #1,D3
000028A6  B63C 0001               2356          CMP.B   #1,D3
000028AA  6700 0006               2357          BEQ     D4_Dn_SET_0
000028AE  6000 0014               2358          BRA     FINISH_MOVEM_MEM_TO_REG
000028B2                          2359  D4_Dn_SET_0
000028B2  183C 0000               2360          MOVE.B  #$0, D4
000028B6                          2361          
000028B6  6000 0002               2362          BRA     PRINT_D0
000028BA                          2363          
000028BA                          2364  PRINT_D0
000028BA  4EB9 00002BB8           2365          JSR     EA_Dn
000028C0  14FC 002F               2366          MOVE.B  #$2F,(A2)+
000028C4                          2367  
000028C4                          2368  FINISH_MOVEM_MEM_TO_REG
000028C4                          2369          
000028C4  2600                    2370          MOVE.L  D0,D3               ; Store the src mode in D3
000028C6  0243 0038               2371          ANDI.W  #src_mode,D3        ; Get bits 5-3
000028CA  1A3C 0003               2372          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000028CE  EA6B                    2373          LSR.W   D5,D3               ; Do the actual shift
000028D0                          2374  
000028D0  2800                    2375          MOVE.L  D0,D4               ; Store the dst reg in D4
000028D2  0244 0007               2376          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000028D6                          2377   
000028D6  B63C 0002               2378          CMP.B   #2, D3
000028DA  6700 0006               2379          BEQ     An_FINISH           ; branch to print out (An) 
000028DE  6000 0010               2380          BRA     NORMAL_FINISH       ; branch to the normal finish
000028E2                          2381  
000028E2                          2382  An_FINISH
000028E2  14FC 002C               2383          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000028E6  14FC 0020               2384          MOVE.B  #$20,(A2)+          ; Add space after comma
000028EA                          2385          
000028EA                          2386                      
000028EA  4EB9 00002B7A           2387          JSR     EA_GEN_SRC
000028F0                          2388  
000028F0                          2389  NORMAL_FINISH
000028F0  301D                    2390          MOVE.W  (A5)+, D0
000028F2                          2391          
000028F2  4EF8 1D36               2392          JMP     EA_FINISH
000028F6                          2393  
000028F6                          2394  
000028F6                          2395  EA_SHIFTS       ; 7: ea_shifts
000028F6  2200                    2396          MOVE.L  D0,D1               ; D0 is current instruction word
000028F8  0241 01C0               2397          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000028FC  1A3C 0006               2398          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00002900  EA69                    2399          LSR.W   D5,D1               ; Shift dst mode into LSB position
00002902  C2FC 0006               2400          MULU    #6, D1              ; Set displacement 
00002906  41F9 00002910           2401          LEA     EA_SHIFTS_TABLE,A0  ; Load table into A0
0000290C  4EF0 1000               2402          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00002910                          2403  
00002910                          2404  EA_SHIFTS_TABLE
00002910  4EF9 000029B2           2405          JMP     EA_REGISTER_SHIFTS  ; 000 Register
00002916  4EF9 000029B2           2406          JMP     EA_REGISTER_SHIFTS  ; 001 Register
0000291C  4EF9 000029B2           2407          JMP     EA_REGISTER_SHIFTS  ; 010 Register
00002922  4EF9 00002940           2408          JMP     EA_MEMORY_SHIFTS    ; 011 Memory
00002928  4EF9 000029B2           2409          JMP     EA_REGISTER_SHIFTS  ; 100 Register
0000292E  4EF9 000029B2           2410          JMP     EA_REGISTER_SHIFTS  ; 101 Register
00002934  4EF9 000029B2           2411          JMP     EA_REGISTER_SHIFTS  ; 110 Register
0000293A  4EF9 00002940           2412          JMP     EA_MEMORY_SHIFTS    ; 111 Memory
00002940                          2413          
00002940                          2414  EA_MEMORY_SHIFTS
00002940                          2415          ; Get EA and store into decode buffer
00002940  2800                    2416          MOVE.L  D0,D4               ; Store the EA reg in D4
00002942  0244 0007               2417          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002946                          2418          
00002946  2600                    2419          MOVE.L  D0,D3               ; Store the EA mode in D3
00002948  0243 0038               2420          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000294C  1A3C 0003               2421          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002950  EA6B                    2422          LSR.W   D5,D3               ; Do the actual shift
00002952  4EB9 00002C90           2423          JSR     An_CHECK            ; Check if mode is An 
00002958  4EB9 00002C9A           2424          JSR     Dn_CHECK            ; Check if mode is Dn
0000295E  4EB9 00002CA4           2425          JSR     IMMEDIATE_CHECK     ; Check if mode is immediate
00002964                          2426          
00002964  14FC 0020               2427          MOVE.B  #$20,(A2)+          ; Print out a space 
00002968  14FC 0020               2428          MOVE.B  #$20,(A2)+          ; Print out a space
0000296C  14FC 0020               2429          MOVE.B  #$20,(A2)+          ; Print out a space
00002970  14FC 0020               2430          MOVE.B  #$20,(A2)+          ; Print out a space
00002974                          2431          
00002974  4EB9 0000298C           2432          JSR     FRONT_FORMAT
0000297A  4EB9 00002B7A           2433          JSR     EA_GEN_SRC          ; Go get EA print
00002980  B63C 002A               2434          CMP.B   #$2A,D3             ; When mode is 111 * 6 (2A)
00002984  6700 001E               2435          BEQ     BACK_PARENTHESIS  
00002988  4EF8 1D36               2436          JMP     EA_FINISH           ; Opcode is finish
0000298C                          2437  
0000298C                          2438  FRONT_FORMAT
0000298C  B63C 0007               2439          CMP.B   #7,D3               ; When mode is 111
00002990  6700 0008               2440          BEQ     ADD_PARENTHESIS
00002994  14FC 0020               2441          MOVE.B  #$20,(A2)+          ; Print out a space
00002998  4E75                    2442          RTS
0000299A                          2443          
0000299A                          2444  ADD_PARENTHESIS
0000299A  14FC 0020               2445          MOVE.B  #$20,(A2)+          ; Print out a space
0000299E  14FC 0028               2446          MOVE.B  #'(',(A2)+
000029A2  4E75                    2447          RTS
000029A4                          2448          
000029A4                          2449  BACK_PARENTHESIS            
000029A4  14FC 0029               2450          MOVE.B  #')',(A2)+
000029A8  1404                    2451          MOVE.B  D4,D2
000029AA  4EB8 1E38               2452          JSR     EA_SIZE_MEMORY_SHIFTS
000029AE  4EF8 1D36               2453          JMP     EA_FINISH           ; Opcode is finish
000029B2                          2454      
000029B2                          2455  EA_REGISTER_SHIFTS
000029B2  2200                    2456          MOVE.L  D0,D1
000029B4  0241 01C0               2457          ANDI.W  #dst_mode,D1
000029B8  1A3C 0006               2458          MOVE.B  #right6,D5 
000029BC  EA69                    2459          LSR.W   D5,D1
000029BE  0201 0003               2460          ANDI.B  #3,D1               ; Remove bit 8 and get bits 7-6
000029C2  1401                    2461          MOVE.B  D1,D2
000029C4  4EB8 1D7C               2462          JSR     EA_SIZE_GENERAL
000029C8                          2463          
000029C8  2600                    2464          MOVE.L  D0,D3               ; Store the instruction in D3
000029CA  0243 0038               2465          ANDI.W  #src_mode,D3        ; Get bits 5-3
000029CE  1A3C 0003               2466          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000029D2  EA6B                    2467          LSR.W   D5,D3               ; Do the actual shift 
000029D4  0203 0004               2468          ANDI.B  #4,D3               ; Get bit 5(ir) from bits 5-3
000029D8  E44B                    2469          LSR.W   #2,D3
000029DA                          2470  
000029DA  B63C 0000               2471          CMP.B   #0,D3               ; When D1 is 0 (immediate)
000029DE  6700 0006               2472          BEQ     IMMEDIATE_SRC
000029E2  6000 0052               2473          BRA     REGISTER_SRC        ; When D1 is 1 (register)
000029E6                          2474          
000029E6                          2475  IMMEDIATE_SRC
000029E6  14FC 0020               2476          MOVE.B  #$20,(A2)+          ; Add space
000029EA  14FC 0020               2477          MOVE.B  #$20,(A2)+          ; Add space
000029EE  14FC 0020               2478          MOVE.B  #$20,(A2)+          ; Add space
000029F2                          2479          
000029F2                          2480          ; Get source and store into decode buffer
000029F2  2800                    2481          MOVE.L  D0,D4               ; Store the src reg in D4
000029F4  0244 0E00               2482          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
000029F8  1A3C 0009               2483          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
000029FC  EA6C                    2484          LSR.W   D5,D4               ; Do the actual shift
000029FE  4EB9 00002A26           2485          JSR     CHECK_IF_ZERO       ; Check if register is 0
00002A04                          2486          
00002A04  14FC 0023               2487          MOVE.B  #$23,(A2)+          ; Add # symbol
00002A08  0604 0030               2488          ADDI.B  #$30,D4             ; Convert hex to ASCII
00002A0C  14C4                    2489          MOVE.B  D4,(A2)+            ; Store into buffer
00002A0E                          2490          
00002A0E  14FC 002C               2491          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002A12  14FC 0020               2492          MOVE.B  #$20,(A2)+          ; Add space after comma
00002A16                          2493  
00002A16                          2494          ; Get destination and store into decode buffer
00002A16  2800                    2495          MOVE.L  D0,D4               ; Store the src reg in D4
00002A18  0244 0007               2496          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002A1C  4EB9 00002BB8           2497          JSR     EA_Dn               ; store Dn into decode buffer
00002A22  4EF8 1D36               2498          JMP     EA_FINISH           ; Opcode is finish
00002A26                          2499                
00002A26                          2500  CHECK_IF_ZERO
00002A26  B83C 0000               2501          CMP.B   #0,D4               ; When D4 is 0 
00002A2A  6700 0004               2502          BEQ     IMMEDIATE_EIGHT     ; Branch
00002A2E  4E75                    2503          RTS
00002A30                          2504  
00002A30                          2505  IMMEDIATE_EIGHT
00002A30  183C 0008               2506          MOVE.B  #8,D4               ; Store 8 into D4 
00002A34  4E75                    2507          RTS
00002A36                          2508  
00002A36                          2509  REGISTER_SRC        
00002A36  14FC 0020               2510          MOVE.B  #$20,(A2)+          ; Add space
00002A3A  14FC 0020               2511          MOVE.B  #$20,(A2)+          ; Add space
00002A3E  14FC 0020               2512          MOVE.B  #$20,(A2)+          ; Add space
00002A42                          2513          
00002A42                          2514          ; Get source and store into decode buffer
00002A42  2800                    2515          MOVE.L  D0,D4               ; Store the src reg in D4
00002A44  0244 0E00               2516          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002A48  1A3C 0009               2517          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002A4C  EA6C                    2518          LSR.W   D5,D4               ; Do the actual shift
00002A4E  4EB9 00002BB8           2519          JSR     EA_Dn               ; store Dn into decode buffer
00002A54                          2520          
00002A54  14FC 002C               2521          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002A58  14FC 0020               2522          MOVE.B  #$20,(A2)+          ; Add space after comma
00002A5C                          2523  
00002A5C                          2524          ; Get destination and store into decode buffer
00002A5C  2800                    2525          MOVE.L  D0,D4               ; Store the src reg in D4
00002A5E  0244 0007               2526          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002A62  4EB9 00002BB8           2527          JSR     EA_Dn               ; store Dn into decode buffer
00002A68  4EF8 1D36               2528          JMP     EA_FINISH           ; Opcode is finish
00002A6C                          2529  
00002A6C                          2530  EA_QUICK        ; 8: ea_quick
00002A6C  BC3C 0005               2531          CMP.B   #5, D6              ; check if the first nibble is 5 for ADDQ
00002A70  6700 000A               2532          BEQ     ADDQ_EA_CALC
00002A74                          2533          
00002A74  BC3C 0007               2534          CMP.B   #7, D6              ; check if the first nibble is 7 for MOVEQ
00002A78  6700 006E               2535          BEQ     MOVEQ_EA_CALC
00002A7C                          2536          
00002A7C                          2537  ADDQ_EA_CALC
00002A7C  2200                    2538          MOVE.L  D0,D1
00002A7E  0241 01C0               2539          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00002A82  1A3C 0006               2540          MOVE.B  #right6,D5          ; Store 6 into D5
00002A86  EA69                    2541          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002A88  0201 0003               2542          ANDI.B  #3,D1               ; Remove the front bit from D1
00002A8C  1401                    2543          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002A8E  4EB8 1D7C               2544          JSR     EA_SIZE_GENERAL     ; Get size and print size.
00002A92                          2545          
00002A92  14FC 0020               2546          MOVE.B  #$20,(A2)+          ; Add space after size
00002A96  14FC 0020               2547          MOVE.B  #$20,(A2)+          ; Add space
00002A9A                          2548          
00002A9A  14FC 0023               2549          MOVE.B  #$23,(A2)+          ; Add # symbol
00002A9E  14FC 0024               2550          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002AA2                          2551          
00002AA2  2800                    2552          MOVE.L  D0,D4               ; Store the data in D4
00002AA4  0244 0E00               2553          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002AA8  1A3C 0009               2554          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002AAC  EA6C                    2555          LSR.W   D5,D4               ; Do the actual shift
00002AAE                          2556          
00002AAE  B83C 0000               2557          CMP.B   #0, D4
00002AB2  6700 0006               2558          BEQ     CHANGE_TO_EIGHT
00002AB6                          2559          
00002AB6  6000 0006               2560          BRA     DONT_CHANGE
00002ABA                          2561  
00002ABA                          2562  CHANGE_TO_EIGHT
00002ABA  183C 0008               2563          MOVE.B  #8, D4
00002ABE                          2564  
00002ABE                          2565  DONT_CHANGE        
00002ABE  0604 0030               2566          ADDI.B  #$30, D4
00002AC2  14C4                    2567          MOVE.B  D4, (A2)+      
00002AC4                          2568          
00002AC4  14FC 002C               2569          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002AC8  14FC 0020               2570          MOVE.B  #$20,(A2)+          ; Add space after comma
00002ACC                          2571          
00002ACC  2800                    2572          MOVE.L  D0,D4               ; Store the src reg in D4
00002ACE  0244 0007               2573          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002AD2                          2574          
00002AD2  2600                    2575          MOVE.L  D0,D3               ; Store the src mode in D3
00002AD4  0243 0038               2576          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002AD8  1A3C 0003               2577          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002ADC  EA6B                    2578          LSR.W   D5,D3               ; Do the actual shift 
00002ADE  4EB9 00002B7A           2579          JSR     EA_GEN_SRC
00002AE4                          2580          
00002AE4  4EF8 1D36               2581          JMP     EA_FINISH
00002AE8                          2582  
00002AE8                          2583  MOVEQ_EA_CALC
00002AE8  14FC 0020               2584          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002AEC  14FC 0020               2585          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002AF0  14FC 0020               2586          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002AF4  14FC 0020               2587          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002AF8  14FC 0023               2588          MOVE.B  #$23,(A2)+          ; Add # symbol
00002AFC  14FC 0024               2589          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002B00                          2590          
00002B00  2200                    2591          MOVE.L  D0, D1              ; move D0 to D1
00002B02  0241 00FF               2592          ANDI.W  #second_half, D1    ; get the second 8 bits of D1
00002B06  1A01                    2593          MOVE.B  D1, D5              ; move D1 to D5 to convert it to ASCII
00002B08                          2594          
00002B08  4EB8 11AA               2595          JSR     ITOA_BYTE_BRANCH    ; print out the bit of data
00002B0C                          2596          
00002B0C  14FC 002C               2597          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B10  14FC 0020               2598          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B14                          2599          
00002B14  2800                    2600          MOVE.L  D0,D4               ; Store the data in D4
00002B16  0244 0E00               2601          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B1A  1A3C 0009               2602          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B1E  EA6C                    2603          LSR.W   D5,D4               ; Do the actual shift
00002B20  4EB9 00002B7A           2604          JSR     EA_GEN_SRC
00002B26                          2605          
00002B26  4EF8 1D36               2606          JMP     EA_FINISH
00002B2A                          2607  
00002B2A                          2608  EA_BRANCH       ; 9: ea_branch
00002B2A  14FC 0020               2609          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002B2E  14FC 0020               2610          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002B32  14FC 0020               2611          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002B36  14FC 0020               2612          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002B3A                          2613  
00002B3A  2600                    2614          MOVE.L  D0,D3               ; D0 is current instruction word
00002B3C  0243 00F0               2615          ANDI.W  #third_nibble,D3   ; Extract 3rd nibble from instruction word
00002B40  1A3C 0004               2616          MOVE.B  #right4,D5
00002B44                          2617          
00002B44  2800                    2618          MOVE.L  D0,D4               ; D0 is current instruction word
00002B46  0244 000F               2619          ANDI.W  #fourth_nibble,D4   ; Extract 4th nibble from instruction word
00002B4A                          2620           
00002B4A  B63C 0000               2621          CMP.B   #0,D3               ; check if 3rd nibble is 0. 
00002B4E  6700 0006               2622          BEQ     FOURTH_NIBBLE_CHECK
00002B52                          2623          
00002B52  6000 0018               2624          BRA     BRANCH_WORD_CHECK
00002B56                          2625          
00002B56                          2626  FOURTH_NIBBLE_CHECK                 
00002B56  B83C 0000               2627          CMP.B   #0,D4               ; check if the 4th nibble is 0. 
00002B5A                          2628          
00002B5A  3A15                    2629          MOVE.W  (A5), D5            ; store the 16-bit displacement into D5
00002B5C                          2630          
00002B5C  260D                    2631          MOVE.L  A5, D3              ; Store A5 address into D3
00002B5E                          2632          
00002B5E  DA43                    2633          ADD.W   D3, D5              ; Add the address to D5 to get the displacement. 
00002B60                          2634          
00002B60  14FC 0024               2635          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002B64                          2636          
00002B64  4EB8 11D8               2637          JSR     ITOA_WORD_BRANCH    ; Print. 
00002B68                          2638  
00002B68  4EF8 1D36               2639          JMP     EA_FINISH
00002B6C                          2640  
00002B6C                          2641  BRANCH_WORD_CHECK
00002B6C  4245                    2642          CLR     D5                  ; handles 8-bit displacement. 
00002B6E  DA03                    2643          ADD.B   D3,D5               ; add d3 and d4 to d5
00002B70  DA04                    2644          ADD.B   D4,D5
00002B72                          2645          
00002B72  4EB8 11AA               2646          JSR     ITOA_BYTE_BRANCH    ; Print. 
00002B76                          2647  
00002B76  4EF8 1D36               2648          JMP     EA_FINISH
00002B7A                          2649  
00002B7A                          2650  EA_REG
00002B7A                          2651  
00002B7A                          2652  EA_GEN_SRC
00002B7A  41F9 00002B88           2653          LEA     EA_GEN_TABLE_SRC, A0
00002B80  C6FC 0006               2654          MULU    #6, D3              ; use D3 to jump to the proper src mode and dst mode. 
00002B84  4EF0 3000               2655          JMP     0(A0,D3)            ; jump to each ea src generation table entry 
00002B88                          2656  
00002B88                          2657  EA_GEN_TABLE_SRC
00002B88  4EF9 00002BB8           2658          JMP     EA_Dn                       ; 000: Dn
00002B8E  4EF9 00002BC4           2659          JMP     EA_An                       ; 001: An
00002B94  4EF9 00002BD0           2660          JMP     EA_An_Indirect              ; 010: (An)
00002B9A  4EF9 00002BE4           2661          JMP     EA_An_Indirect_Inc          ; 011: (An)+
00002BA0  4EF9 00002BFC           2662          JMP     EA_An_Indirect_Dec          ; 100: -(An)
00002BA6  4EF9 00002C14           2663          JMP     EA_UNSUPPORTED              ; 101: Unsupported EA
00002BAC  4EF9 00002C14           2664          JMP     EA_UNSUPPORTED              ; 110: Unsupported EA
00002BB2  4EF9 00002C22           2665          JMP     EA_Absolute_And_Immediate   ; 111: (xxx).W,(xxx).L, or #<data>
00002BB8                          2666  
00002BB8                          2667  EA_Dn               ; 000: Dn
00002BB8  14FC 0044               2668          MOVE.B  #'D',(A2)+
00002BBC  0604 0030               2669          ADDI.B  #$30,D4
00002BC0  14C4                    2670          MOVE.B  D4,(A2)+
00002BC2  4E75                    2671          RTS
00002BC4                          2672  
00002BC4                          2673  EA_An               ; 001: An
00002BC4  14FC 0041               2674          MOVE.B  #'A',(A2)+
00002BC8  0604 0030               2675          ADDI.B  #$30,D4
00002BCC  14C4                    2676          MOVE.B  D4,(A2)+
00002BCE  4E75                    2677          RTS
00002BD0                          2678  
00002BD0                          2679  EA_An_Indirect      ; 010: (An)
00002BD0  14FC 0028               2680          MOVE.B  #'(',(A2)+
00002BD4  14FC 0041               2681          MOVE.B  #'A',(A2)+
00002BD8  0604 0030               2682          ADDI.B  #$30,D4
00002BDC  14C4                    2683          MOVE.B  D4,(A2)+
00002BDE  14FC 0029               2684          MOVE.B  #')',(A2)+
00002BE2  4E75                    2685          RTS
00002BE4                          2686          
00002BE4                          2687  EA_An_Indirect_Inc  ; 011: (An)+
00002BE4  14FC 0028               2688          MOVE.B  #'(',(A2)+
00002BE8  14FC 0041               2689          MOVE.B  #'A',(A2)+
00002BEC  0604 0030               2690          ADDI.B  #$30, D4
00002BF0  14C4                    2691          MOVE.B  D4,(A2)+
00002BF2  14FC 0029               2692          MOVE.B  #')',(A2)+
00002BF6  14FC 002B               2693          MOVE.B  #'+',(A2)+
00002BFA  4E75                    2694          RTS
00002BFC                          2695          
00002BFC                          2696  EA_An_Indirect_Dec  ; 100: -(An)
00002BFC  14FC 002D               2697          MOVE.B  #'-',(A2)+
00002C00  14FC 0028               2698          MOVE.B  #'(',(A2)+
00002C04  14FC 0041               2699          MOVE.B  #'A',(A2)+
00002C08  0604 0030               2700          ADDI.B  #$30,D4
00002C0C  14C4                    2701          MOVE.B  D4,(A2)+
00002C0E  14FC 0029               2702          MOVE.B  #')',(A2)+
00002C12  4E75                    2703          RTS
00002C14                          2704  
00002C14                          2705  EA_UNSUPPORTED
00002C14  43F9 00002D57           2706          LEA     EA_TYPE_ERROR,A1
00002C1A  103C 000E               2707          MOVE.B  #14,D0
00002C1E  4E4F                    2708          TRAP    #15  
00002C20  4E75                    2709          RTS 
00002C22                          2710          
00002C22                          2711  EA_Absolute_And_Immediate           ; 111: (xxx).W,(xxx).L, or #<data>
00002C22  B83C 0000               2712          CMP.B   #0,D4               ; If D4 is (xxx).W
00002C26  6700 0016               2713          BEQ     ABSOLUTE_WORD
00002C2A                          2714          
00002C2A  B83C 0001               2715          CMP.B   #1,D4               ; If D4 is (xxx).L
00002C2E  6700 001A               2716          BEQ     ABSOLUTE_LONG
00002C32                          2717          
00002C32  B83C 0004               2718          CMP.B   #4,D4               ; If D4 is #<data>  
00002C36  6700 001E               2719          BEQ     IMMEDIATE
00002C3A                          2720          
00002C3A  6000 008C               2721          BRA     ABSOLUTE_IMMEDIATE_ERROR    
00002C3E                          2722  
00002C3E                          2723  ABSOLUTE_WORD
00002C3E  14FC 0024               2724          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C42  7401                    2725          MOVE.L  #1,D2               ; Insert 1 to D2 
00002C44  4EB8 1114               2726          JSR     ITOA                ; Convert word hex values to ITOA
00002C48  4E75                    2727          RTS
00002C4A                          2728          
00002C4A                          2729  ABSOLUTE_LONG
00002C4A  14FC 0024               2730          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C4E  7402                    2731          MOVE.L  #2,D2               ; Insert 2 to D2
00002C50  4EB8 1114               2732          JSR     ITOA                ; Convert long hex values to ITOA
00002C54  4E75                    2733          RTS
00002C56                          2734     
00002C56                          2735  IMMEDIATE
00002C56  14FC 0023               2736          MOVE.B  #$23,(A2)+          ; Add # symbol
00002C5A  14FC 0024               2737          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C5E                          2738  
00002C5E  BC3C 0001               2739          CMP.B   #1,D6               ; If MOVE.b (code0001)
00002C62  6700 0020               2740          BEQ     DO_ITOA_MOVE
00002C66  BC3C 0002               2741          CMP.B   #2, D6              ; If MOVE.l / MOVEA.l (code0010)
00002C6A  6700 0018               2742          BEQ     DO_ITOA_MOVE
00002C6E  BC3C 0003               2743          CMP.B   #3, D6              ; If MOVE.w / MOVEA.w (code0011)
00002C72  6700 0010               2744          BEQ     DO_ITOA_MOVE        
00002C76  BC3C 000D               2745          CMP.B   #13, D6             ; If ADD / ADDA (code1101)
00002C7A  6700 000E               2746          BEQ     DO_ITOA_OPMODE
00002C7E                          2747          
00002C7E  4EB8 1114               2748          JSR     ITOA                ; Go to ITOA when not a move instruction
00002C82  4E75                    2749          RTS
00002C84                          2750          
00002C84                          2751  DO_ITOA_MOVE
00002C84  4EB8 1136               2752          JSR ITOA_MOVE
00002C88  4E75                    2753          RTS
00002C8A                          2754                
00002C8A                          2755  DO_ITOA_OPMODE
00002C8A  4EB8 1158               2756          JSR ITOA_OPMODE
00002C8E  4E75                    2757          RTS
00002C90                          2758  
00002C90                          2759  An_CHECK 
00002C90  B63C 0001               2760          CMP.B   #1,D3               ; If mode is An     
00002C94  6700 0062               2761          BEQ     EA_INVALID          ; Then branch to error message
00002C98  4E75                    2762          RTS   
00002C9A                          2763        
00002C9A                          2764  Dn_CHECK 
00002C9A  B63C 0000               2765          CMP.B   #0,D3               ; If mode is An     
00002C9E  6700 0058               2766          BEQ     EA_INVALID          ; Then branch to error message
00002CA2  4E75                    2767          RTS    
00002CA4                          2768       
00002CA4                          2769  IMMEDIATE_CHECK
00002CA4  B63C 0007               2770          CMP.B   #7,D3
00002CA8  6700 0004               2771          BEQ     REGISTER_CHECK
00002CAC  4E75                    2772          RTS
00002CAE                          2773          
00002CAE                          2774  REGISTER_CHECK
00002CAE  B63C 0004               2775          CMP.B   #4,D3               ; If 100 in register
00002CB2  6700 0044               2776          BEQ     EA_INVALID          ; Branch to invalid
00002CB6  4E75                    2777          RTS   
00002CB8                          2778                
00002CB8                          2779  EA_WRONG_SIZE 
00002CB8  43F9 00002D0D           2780          LEA     WRONG_SIZE_MESSAGE, A1 
00002CBE  103C 000E               2781          MOVE.B  #14, D0
00002CC2  4E4F                    2782          TRAP    #15
00002CC4  6000 0042               2783          BRA     DONE
00002CC8                          2784          
00002CC8                          2785  ABSOLUTE_IMMEDIATE_ERROR  
00002CC8  43F9 00002D1B           2786          LEA     ABSOLUTE_WRONGREG, A1 
00002CCE  103C 000E               2787          MOVE.B  #14, D0
00002CD2  4E4F                    2788          TRAP    #15
00002CD4  6000 0032               2789          BRA     DONE
00002CD8                          2790          
00002CD8                          2791  DST_INVALID
00002CD8  43F9 00002D79           2792          LEA     DST_INVALID_MSG, A1 
00002CDE  103C 000E               2793          MOVE.B  #14, D0
00002CE2  4E4F                    2794          TRAP    #15
00002CE4  6000 0022               2795          BRA     DONE
00002CE8                          2796          
00002CE8                          2797  SRC_INVALID 
00002CE8  43F9 00002DAB           2798          LEA     SRC_INVALID_MSG, A1 
00002CEE  103C 000E               2799          MOVE.B  #14, D0
00002CF2  4E4F                    2800          TRAP    #15
00002CF4  6000 0012               2801          BRA     DONE
00002CF8                          2802          
00002CF8                          2803  EA_INVALID  
00002CF8  43F9 00002DD8           2804          LEA     EA_INVALID_MSG, A1 
00002CFE  103C 000E               2805          MOVE.B  #14, D0
00002D02  4E4F                    2806          TRAP    #15
00002D04  6000 0002               2807          BRA     DONE
00002D08                          2808           
00002D08  FFFF FFFF               2809  DONE    SIMHALT             ; halt simulator
00002D0C                          2810  
00002D0C                          2811  * Put variables and constants here
00002D0C                          2812     
00002D0C                          2813         
00002D0C  =00000040               2814  buffer_size         EQU         64 
00002D0C  =00005000               2815  decoded_buffer      EQU         $5000
00002D0C                          2816     
00002D0C  =0000000D               2817  CR                  EQU         $0D
00002D0C  =0000000A               2818  LF                  EQU         $0A
00002D0C  =0000A000               2819  stack               EQU         $0000A000
00002D0C  =00000014               2820  lines_p_screen      EQU         20
00002D0C  =00000003               2821  right3              EQU         3
00002D0C  =00000004               2822  right4              EQU         4
00002D0C  =00000006               2823  right6              EQU         6
00002D0C  =00000008               2824  right8              EQU         8
00002D0C  =00000009               2825  right9              EQU         9
00002D0C  =0000000C               2826  right12             EQU         12
00002D0C  =00000010               2827  right16             EQU         16
00002D0C  =00000018               2828  right24             EQU         24
00002D0C= 20                      2829  ascii_y_n           DC.B        32
00002D0D  =00000059               2830  y_uppercase         EQU         $59         
00002D0D  =00000079               2831  y_lowercase         EQU         $79
00002D0D  =0000004E               2832  n_uppercase         EQU         $4E
00002D0D  =0000006E               2833  n_lowercase         EQU         $6E
00002D0D  =00000002               2834  task2               EQU         $02
00002D0D  =00000005               2835  task5               EQU         $05
00002D0D  =00000009               2836  task9               EQU         $09
00002D0D  =0000000D               2837  task13              EQU         $0D
00002D0D  =0000000E               2838  task14              EQU         $0E
00002D0D  =0000F000               2839  first_nibble        EQU         $F000
00002D0D  =00000F00               2840  second_nibble       EQU         $0F00   
00002D0D  =000000F0               2841  third_nibble        EQU         $00F0
00002D0D  =0000000F               2842  fourth_nibble       EQU         $000F
00002D0D  =000000FF               2843  second_half         EQU         $00FF
00002D0D  =000001C0               2844  dst_mode            EQU         $01C0
00002D0D  =00000E00               2845  dst_reg             EQU         $0E00
00002D0D  =00000038               2846  src_mode            EQU         $0038
00002D0D  =00000007               2847  src_reg             EQU         $0007
00002D0D  =00000100               2848  bit8                EQU         $0100
00002D0D                          2849  
00002D0D  =00000000               2850  ea_type_immediate   EQU     0       ; EA Type = immediate
00002D0D  =00000001               2851  ea_type_move        EQU     1       ; EA Type = move
00002D0D  =00000002               2852  ea_type_movea       EQU     2       ; EA Type = movea
00002D0D  =0000000C               2853  ea_type_movea6      EQU     12      ; EA Type = movea * 6
00002D0D  =00000003               2854  ea_type_lea         EQU     3       ; EA Type = lea
00002D0D  =00000004               2855  ea_type_dstonly     EQU     4       ; EA Type = clr, neg, not, jsr, jmp
00002D0D  =00000005               2856  ea_type_ext         EQU     5       ; EA Type = ext, add, adda
00002D0D  =00000006               2857  ea_type_movem       EQU     6       ; EA Type = movem
00002D0D  =00000007               2858  ea_type_shifts      EQU     7       ; EA Type = ASL/ASR/LSL/LSR/ROL/ROR
00002D0D                          2859  ; ea_type_trap        EQU     7       ; EA Type = trap
00002D0D  =00000008               2860  ea_type_quick       EQU     8       ; EA Type = addq, subq
00002D0D  =00000009               2861  ea_type_branch      EQU     9       ; EA Type = bra, bsr, bcc
00002D0D  =00000000               2862  ea_bcc_flag         EQU     0       ; EA Type = branch, flag = bcc
00002D0D  =00000001               2863  ea_dbcc_flag        EQU     1       ; EA Type = branch, flag = dbcc
00002D0D  =00000002               2864  ea_scc_flag         EQU     2       ; EA Type = branch, flag = scc
00002D0D  =00000007               2865  ea_type_shifts      EQU     7
00002D0D                          2866  
00002D0D= 57 72 6F 6E 67 20 ...   2867  WRONG_SIZE_MESSAGE  DC.B    'Wrong size.',CR,LF,0
00002D1B= 45 52 52 4F 52 3A ...   2868  ABSOLUTE_WRONGREG   DC.B    'ERROR: Register does not exist for Absolute and immediate',CR,LF,0
00002D57= 45 52 52 4F 52 3A ...   2869  EA_TYPE_ERROR       DC.B    'ERROR: EA type is not supported',CR,LF,0
00002D79= 45 52 52 4F 52 3A ...   2870  DST_INVALID_MSG     DC.B    'ERROR: Destination effective address is invalid',CR,LF,0
00002DAB= 45 52 52 4F 52 3A ...   2871  SRC_INVALID_MSG     DC.B    'ERROR: Source effective address is invalid',CR,LF,0
00002DD8= 45 52 52 4F 52 3A ...   2872  EA_INVALID_MSG      DC.B    'ERROR: Invalid addressing mode',CR,LF,0
00002DF9= 45 52 52 4F 52 3A ...   2873  OPCODE_INVALID      DC.B    'ERROR: Opcode is invalid',CR,LF,0
00002E14= 45 52 52 4F 52 3A ...   2874  ERROR_MESSAGE       DC.B    'ERROR: The input is invalid',CR,LF,0  
00002E32= 45 52 52 4F 52 3A ...   2875  ODD_ERROR_MESSAGE   DC.B    'ERROR: The last digit of the address is odd, which is invalid',CR,LF,0  
00002E72                          2876               
00002E72= 57 65 6C 63 6F 6D ...   2877  WELCOME             DC.B        'Welcome to the 68k Disassembler of Avery and Alan',CR,LF,CR,LF,0
00002EA8                          2878  
00002EA8= 50 6C 65 61 73 65 ...   2879  USER_INST           DC.B        'Please follow the proper input instructions below: ',CR,LF
00002EDD= 2D 20 53 74 61 72 ...   2880                      DC.B        '- Starting address must be lower than ending address.',CR,LF
00002F14= 2D 20 54 68 65 20 ...   2881                      DC.B        '- The values for the starting and ending address must be an even value.',CR,LF
00002F5D= 2D 20 53 74 61 72 ...   2882                      DC.B        '- Starting and ending address must be inputted as hexadecimal value.',CR,LF
00002FA3= 2D 20 44 6F 20 6E ...   2883                      DC.B        '- Do not put spaces in between input characters.',CR,LF
00002FD5= 2D 20 56 61 6C 69 ...   2884                      DC.B        '- Valid characters include: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F',CR,LF,0
00003022                          2885                  
00003022= 50 72 65 73 73 20 ...   2886  ENTER_PROMPT        DC.B        'Press enter to continue...',CR,LF,0
0000303F= 50 72 65 73 73 20 ...   2887  PROMPT_AGAIN        DC.B        'Press Y to continue / N to exit.',CR,LF,0
00003062= 50 72 6F 67 72 61 ...   2888  EXIT_PROMPT         DC.B        'Program has execution has stopped.',CR,LF,0
00003087                          2889        
00003087= 45 6E 74 65 72 20 ...   2890  START_IN            DC.B        'Enter a starting address: ',CR,LF,0 
000030A4= 45 6E 74 65 72 20 ...   2891  END_IN              DC.B        'Enter an ending address: ',CR,LF,0 
000030C0                          2892  START_ADDRESS       DS.B        32     
000030E0                          2893  END_ADDRESS         DS.B        32 
00003100                          2894       
00003100                          2895  
00003100                          2896      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_IMMEDIATE_ERROR  2CC8
ABSOLUTE_LONG       2C4A
ABSOLUTE_WORD       2C3E
ABSOLUTE_WRONGREG   2D1B
ADDQ_EA_CALC        2A7C
ADD_PARENTHESIS     299A
AND_OR_CHECK        21C6
AN_CHECK            2C90
AN_FINISH           28E2
ASCII_TO_HEX_LETTER  1084
ASCII_Y_N           2D0C
ATOI                105E
BACK_PARENTHESIS    29A4
BIT8                100
BRANCH_WORD_CHECK   2B6C
BUFFER_SIZE         40
CHANGE_TO_001       1FEE
CHANGE_TO_EIGHT     2ABA
CHECK1_BIT_0        2586
CHECK1_BIT_1        255E
CHECK1_BIT_10       23CC
CHECK1_BIT_11       239E
CHECK1_BIT_12       2370
CHECK1_BIT_13       2342
CHECK1_BIT_14       2314
CHECK1_BIT_2        2536
CHECK1_BIT_3        250E
CHECK1_BIT_4        24E0
CHECK1_BIT_5        24B2
CHECK1_BIT_6        2484
CHECK1_BIT_7        2456
CHECK1_BIT_8        2428
CHECK1_BIT_9        23FA
CHECK_BIT_0         289C
CHECK_BIT_1         2874
CHECK_BIT_10        26E4
CHECK_BIT_11        26B6
CHECK_BIT_12        2688
CHECK_BIT_13        265A
CHECK_BIT_14        262C
CHECK_BIT_2         284C
CHECK_BIT_3         2824
CHECK_BIT_4         27F6
CHECK_BIT_5         27C8
CHECK_BIT_6         279A
CHECK_BIT_7         276C
CHECK_BIT_8         273E
CHECK_BIT_9         2712
CHECK_IF_ZERO       2A26
CODE0000            13E2
CODE0001            13FC
CODE0010            1400
CODE0011            1418
CODE0100            1430
CODE0101            144A
CODE0110            144E
CODE0111            14DA
CODE1000            14DE
CODE1001            14FE
CODE1010            1502
CODE1011            1506
CODE1100            150A
CODE1101            1524
CODE1110            153E
CODE1111            15BC
COMPLETE_END        10E6
COMPLETE_START      10DE
CONTINUE_OR_END     12E0
CR                  D
D4_AN_SETONE_0      2472
D4_AN_SETONE_1      24A0
D4_AN_SETONE_2      24CE
D4_AN_SETONE_3      24FC
D4_AN_SETONE_4      2524
D4_AN_SETONE_5      254C
D4_AN_SETONE_6      2574
D4_AN_SETONE_7      259C
D4_AN_SET_0         275A
D4_AN_SET_1         272E
D4_AN_SET_2         2700
D4_AN_SET_3         26D2
D4_AN_SET_4         26A4
D4_AN_SET_5         2676
D4_AN_SET_6         2648
D4_AN_SET_7         261A
D4_DN_SETONE_0      2302
D4_DN_SETONE_1      2330
D4_DN_SETONE_2      235E
D4_DN_SETONE_3      238C
D4_DN_SETONE_4      23BA
D4_DN_SETONE_5      23E8
D4_DN_SETONE_6      2416
D4_DN_SETONE_7      2444
D4_DN_SET_0         28B2
D4_DN_SET_1         288A
D4_DN_SET_2         2862
D4_DN_SET_3         283A
D4_DN_SET_4         2812
D4_DN_SET_5         27E4
D4_DN_SET_6         27B6
D4_DN_SET_7         2788
DECODED_BUFFER      5000
DECODE_MEMORY       1330
DECODE_PAUSE        12CC
DECODING_ITERATION  12A8
DISP_UI             100C
DISP_W              1000
DN_CHECK            2C9A
DN_DST              2142
DN_SRC              2180
DONE                2D08
DONT_CHANGE         2ABE
DO_ITOA_MOVE        2C84
DO_ITOA_OPMODE      2C8A
DST_INVALID         2CD8
DST_INVALID_MSG     2D79
DST_MODE            1C0
DST_REG             E00
EA_ABSOLUTE_AND_IMMEDIATE  2C22
EA_ADDA             224E
EA_AN               2BC4
EA_AND              21D8
EA_AN_INDIRECT      2BD0
EA_AN_INDIRECT_DEC  2BFC
EA_AN_INDIRECT_INC  2BE4
EA_BCC_FLAG         0
EA_BRANCH           2B2A
EA_CLEAR            2028
EA_DBCC_FLAG        1
EA_DN               2BB8
EA_DSTONLY          2008
EA_EXT              20B2
EA_EXT_TABLE        20CE
EA_FINISH           1D36
EA_GEN_SRC          2B7A
EA_GEN_TABLE_SRC    2B88
EA_IMMEDIATE        1E6E
EA_INVALID          2CF8
EA_INVALID_MSG      2DD8
EA_JSR              206E
EA_LEA              1F92
EA_MEMORY_SHIFTS    2940
EA_MOVE             1EC2
EA_MOVEA            1F2A
EA_MOVEM            2292
EA_MULS_MULU_DIV    2200
EA_OPMODE_012456    20FE
EA_OPMODE_37        21E8
EA_OR               21DE
EA_QUICK            2A6C
EA_REG              2B7A
EA_REGISTER_SHIFTS  29B2
EA_SCC_FLAG         2
EA_SHIFTS           28F6
EA_SHIFTS_TABLE     2910
EA_SIZE_ADDA        1E10
EA_SIZE_B           1E4C
EA_SIZE_DONE        1E6C
EA_SIZE_GENERAL     1D7C
EA_SIZE_L           1E62
EA_SIZE_MEMORY_SHIFTS  1E38
EA_SIZE_MOVE        1D98
EA_SIZE_MOVEA       1DB4
EA_SIZE_MOVEM       1DC8
EA_SIZE_MULS_MULU_DIV  1E24
EA_SIZE_OPMODE_012456  1DDC
EA_SIZE_W           1E56
EA_SIZE_W_MEMORY    1E60
EA_START            1D24
EA_TYPE_BRANCH      9
EA_TYPE_DSTONLY     4
EA_TYPE_ERROR       2D57
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_SHIFTS      7
EA_TYPE_TABLE       1D3C
EA_UNSUPPORTED      2C14
EA_WRONG_SIZE       2CB8
END_ADDRESS         30E0
END_IN              30A4
ENTER_PROMPT        3022
ERROR_MESSAGE       2E14
EXIT                1320
EXIT_PROMPT         3062
FINISH_MOVEM_MEM_TO_REG  28C4
FINISH_REG_TO_MEM   25AE
FIRST_NIBBLE        F000
FOURTH_NIBBLE       F
FOURTH_NIBBLE_CHECK  2B56
FRONT_FORMAT        298C
IMMEDIATE           2C56
IMMEDIATE_CHECK     2CA4
IMMEDIATE_EIGHT     2A30
IMMEDIATE_SRC       29E6
INPUT_INVALID       10A6
ITOA                1114
ITOA_BYTE           119C
ITOA_BYTE_BRANCH    11AA
ITOA_BYTE_CONVERT   1264
ITOA_CONVERT_A_TO_F  1294
ITOA_DONE           12A0
ITOA_LONG           11FA
ITOA_LONGADDRESS    122C
ITOA_MOVE           1136
ITOA_NIBBLE_CONVERT  1284
ITOA_OPMODE         1158
ITOA_WORD           11BC
ITOA_WORD_BRANCH    11D8
JSR_EA_VALID        20A8
JSR_NOP_RTS         1806
LAST_DIGIT_CHECK    10C4
LAST_DIGIT_ODD      10F8
LEA_SRC_VALID       1FC8
LF                  A
LINES_P_SCREEN      14
MEMORY_1110_LEFT    1574
MEMORY_1110_RIGHT   1598
MEM_TO_REG          25D4
MEM_TO_REG_CONTINUE  25FC
MOVEA_DST_VALID     1F88
MOVEQ_EA_CALC       2AE8
NORMAL_FINISH       28F0
N_LOWERCASE         6E
N_UPPERCASE         4E
ODD_ERROR_MESSAGE   2E32
OPCODE_INVALID      2DF9
OP_0000_TABLE       15C0
OP_0100_TABLE       1620
OP_1100_TABLE       1680
OP_1101_TABLE       16E0
OP_1110_TABLE_REGISTER  1740
OP_ADD              1C40
OP_ADDA             1C5C
OP_ADDI             1864
OP_ADDQ             196C
OP_AND              1C24
OP_ASL              1C98
OP_ASR              1C7C
OP_AS_CHECK         17A0
OP_BCC              19FC
OP_BCS              1A18
OP_BEQ              1A50
OP_BGE              1ADC
OP_BGT              1B14
OP_BHI              19C4
OP_BLE              1B30
OP_BLS              19E0
OP_BLT              1AF8
OP_BMI              1AC0
OP_BNE              1A34
OP_BPL              1AA4
OP_BRA              198C
OP_BSR              19A8
OP_BVC              1A6C
OP_BVS              1A88
OP_CLEAR_DATA       136C
OP_CLEAR_DATA_LOOP  1378
OP_CLR              18C8
OP_CMP              1BC8
OP_DIVU             1B74
OP_FINISH           1366
OP_JSR              1910
OP_LEA              1950
OP_LSL              1CD0
OP_LSR              1CB4
OP_LS_CHECK         17C2
OP_MOVE             18A8
OP_MOVEA            1884
OP_MOVEM            192C
OP_MOVEQ            1B4C
OP_MULS             1C04
OP_MULU             1BE4
OP_NOP              18E4
OP_OR               1B94
OP_ROL              1D08
OP_ROR              1CEC
OP_RO_CHECK         17E4
OP_RTS              1900
OP_SUB              1BAC
OP_SUBI             1844
OP_TABLE            1382
OP_UNSUPPORTED      1834
PRINT1_A0           247A
PRINT1_A1           24A8
PRINT1_A2           24D6
PRINT1_A3           2504
PRINT1_A4           252C
PRINT1_A5           2554
PRINT1_A6           257C
PRINT1_A7           25A4
PRINT1_D0           230A
PRINT1_D1           2338
PRINT1_D2           2366
PRINT1_D3           2394
PRINT1_D4           23C2
PRINT1_D5           23F0
PRINT1_D6           241E
PRINT1_D7           244C
PRINT_A0            2762
PRINT_A1            2734
PRINT_A2            2708
PRINT_A3            26DA
PRINT_A4            26AC
PRINT_A5            267E
PRINT_A6            2650
PRINT_A7            2622
PRINT_D0            28BA
PRINT_D1            2892
PRINT_D2            286A
PRINT_D3            2842
PRINT_D4            281A
PRINT_D5            27EC
PRINT_D6            27BE
PRINT_D7            2790
PROMPT_AGAIN        303F
PROMPT_END          103E
PROMPT_START        1018
READ_END            104A
READ_START          102A
REGISTER_CHECK      2CAE
REGISTER_SRC        2A36
REG_TO_MEM          22E4
RIGHT12             C
RIGHT16             10
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT6              6
RIGHT8              8
RIGHT9              9
SECOND_HALF         FF
SECOND_NIBBLE       F00
SRC_INVALID         2CE8
SRC_INVALID_MSG     2DAB
SRC_MODE            38
SRC_REG             7
STACK               A000
START               1000
START_ADDRESS       30C0
START_DECODING      12A6
START_IN            3087
TASK13              D
TASK14              E
TASK2               2
TASK5               5
TASK9               9
THIRD_NIBBLE        F0
USER_INST           2EA8
VALIDATE_END        105A
VALIDATE_START      103A
WELCOME             2E72
WRONG_SIZE_MESSAGE  2D0D
Y_LOWERCASE         79
Y_UPPERCASE         59
