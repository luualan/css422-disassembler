00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/10/2020 1:46:44 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler for the Motorola MC68000 Microprocessor
00000000                             3  * Written by :  Avery Mortenson & Alan Luu
00000000                             4  * Date       :  2/12/2020
00000000                             5  * Description:  An inverse assembler (disassembler) that will 
00000000                             6  * convert a memory image of instructions and data back 
00000000                             7  * to the MC68000 assembly code and that will output the 
00000000                             8  * disassembled code to the display.
00000000                             9  *-----------------------------------------------------------
00001000                            10      ORG    $1000
00001000                            11  START:            
00001000                            12  *------------------------------------------------------------*
00001000                            13  * D0: used for the tasks
00001000                            14  * D1: used to hold the size of the input obtained. 
00001000                            15  * D5: used to store the starting and ending address 
00001000                            16  * temporarily before moving them to A4 and A6 correspondingly. 
00001000                            17  * D6: used to check the last digit to see if the input 
00001000                            18  * for the starting and ending address causes a bus error. 
00001000                            19  * A1: a pointer to the message to print out. 
00001000                            20  *------------------------------------------------------------*
00001000  103C 000E                 21  DISP_W      MOVE.B  #14,D0                  ; Display Welcome Message. 
00001004  43F9 00002E5F             22              LEA     WELCOME,A1
0000100A  4E4F                      23              TRAP    #15
0000100C                            24  
0000100C                            25  * Put program code here
0000100C                            26  
0000100C  103C 000E                 27  DISP_UI         MOVE.B  #14,D0              ; Display User Instructions. 
00001010  43F9 00002E95             28                  LEA     USER_INST,A1
00001016  4E4F                      29                  TRAP    #15    
00001018                            30  
00001018  4285                      31  PROMPT_START    CLR.L   D5
0000101A  4FF9 0000A000             32                  LEA     stack, SP           ; SP = stack ($A0000)
00001020  43F9 000030F5             33                  LEA     START_IN,A1         ; Display starting address message
00001026  103C 000E                 34                  MOVE.B  #14,D0
0000102A  4E4F                      35                  TRAP    #15       
0000102C                            36       
0000102C  43F9 0000312E             37  READ_START      LEA     START_ADDRESS,A1    ; Store user's starting address input
00001032  103C 0002                 38                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001036  4E4F                      39                  TRAP    #15
00001038  1C3C 0000                 40                  MOVE.B  #0,D6               ; Used to indicate we are at start address
0000103C                            41  
0000103C  6000 0036                 42  VALIDATE_START  BRA     ATOI
00001040                            43  
00001040  4285                      44  PROMPT_END      CLR.L   D5
00001042  43F9 00003112             45                  LEA     END_IN,A1           ; Display ending address message
00001048  103C 000E                 46                  MOVE.B  #14,D0
0000104C  4E4F                      47                  TRAP    #15
0000104E  6000 0010                 48                  BRA     READ_END
00001052                            49  
00001052  4285                      50  PROMPT_VA_END   CLR.L   D5                  ; prompt a valid ending address
00001054  43F9 00003074             51                  LEA     PROMPT_V_END,A1     ; Display ending address message
0000105A  103C 000E                 52                  MOVE.B  #14,D0
0000105E  4E4F                      53                  TRAP    #15
00001060                            54              
00001060  43F9 0000314E             55  READ_END        LEA     END_ADDRESS,A1      ; Store user's starting address input
00001066  103C 0002                 56                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
0000106A  4E4F                      57                  TRAP    #15
0000106C  1C3C 0001                 58                  MOVE.B  #1,D6               ; Used to indicate we are at end address
00001070                            59  
00001070  6000 0002                 60  VALIDATE_END    BRA     ATOI
00001074                            61                 
00001074                            62  * D0 stores the value to pushed from A1.
00001074                            63  
00001074  1019                      64  ATOI            MOVE.B  (A1)+,D0    ; Move to next character in A1 and store in D0          
00001076  B03C 0030                 65                  CMP.B   #$30,D0
0000107A  6D00 0040                 66                  BLT     INPUT_INVALID
0000107E  B03C 0039                 67                  CMP.B   #$39,D0
00001082  6E00 0016                 68                  BGT     ASCII_TO_HEX_LETTER
00001086  0400 0030                 69                  SUB.B   #$30,D0     ; Subtract by 30 to get the numbers 0-9
0000108A  DA80                      70                  ADD.L   D0,D5
0000108C  5341                      71                  SUBI    #1,D1       ; Decrement input's length to move to next character          
0000108E  B23C 0000                 72                  CMP.B   #0,D1       ; Compare to see if we're at the last digit
00001092  6700 0046                 73                  BEQ     LAST_DIGIT_CHECK
00001096  E98D                      74                  LSL.L   #4,D5
00001098  60DA                      75                  BRA     ATOI
0000109A                            76  
0000109A                            77    
0000109A  B03C 0041                 78  ASCII_TO_HEX_LETTER     CMP.B   #$41,D0
0000109E  6D00 001C                 79                          BLT     INPUT_INVALID
000010A2  B03C 0046                 80                          CMP.B   #$46, D0
000010A6  6E00 0014                 81                          BGT     INPUT_INVALID 
000010AA  0400 0031                 82                          SUB.B   #$31,D0     ; Subtract by 31 to get the numbers A-F
000010AE  5D00                      83                          SUB.B   #6,D0
000010B0  DA80                      84                          ADD.L   D0,D5
000010B2  5341                      85                          SUBI    #1,D1
000010B4  6700 0024                 86                          BEQ     LAST_DIGIT_CHECK
000010B8  E98D                      87                          LSL.L   #4,D5
000010BA  60B8                      88                          BRA     ATOI     
000010BC                            89  
000010BC                            90                      
000010BC  43F9 00003095             91  INPUT_INVALID   LEA     ERROR_MESSAGE, A1   ; Display error message
000010C2  103C 000E                 92                  MOVE.B  #14, D0
000010C6  4E4F                      93                  TRAP    #15
000010C8  4206                      94                  CLR.B   D6
000010CA                            95                  
000010CA  BC3C 0000                 96                  CMP.B   #0,D6           ; When D6 is 0
000010CE  6700 FF48                 97                  BEQ     PROMPT_START    ; Go back to start prompt
000010D2  BC3C 0001                 98                  CMP.B   #1,D6           ; When D6 is 1
000010D6  6700 FF68                 99                  BEQ     PROMPT_END      ; Go back to end prompt
000010DA                           100  
000010DA                           101                            
000010DA  2E05                     102  LAST_DIGIT_CHECK    MOVE.L  D5, D7          ; D7 used as temporary storage
000010DC  E20F                     103                      LSR.B   #1, D7          ; Check for carry bit to see if last digit is odd
000010DE  6500 0036                104                      BCS     LAST_DIGIT_ODD  ; branch when there is a carry; this indicates odd last digit 
000010E2  4287                     105                      CLR.L   D7
000010E4  BC3C 0000                106                      CMP.B   #0,D6
000010E8  6700 000A                107                      BEQ     COMPLETE_START  
000010EC  BC3C 0001                108                      CMP.B   #1,D6
000010F0  6700 000A                109                      BEQ     COMPLETE_END
000010F4                           110  
000010F4  2845                     111  COMPLETE_START      MOVEA.L D5, A4  ; A4 holds the starting address
000010F6  4285                     112                      CLR.L   D5 
000010F8  6000 FF46                113                      BRA PROMPT_END
000010FC                           114  
000010FC  2C45                     115  COMPLETE_END        MOVEA.L D5, A6  ; A6 holds the ending address
000010FE                           116  
000010FE  3A0C                     117                      MOVE.W  A4, D5          ; move starting address to D5
00001100  BA4E                     118                      CMP.W   A6, D5          ; check if the ending address is less than starting address. 
00001102  6E00 FF4E                119                      BGT     PROMPT_VA_END   ; branch to prompt new ending address if so. 
00001106                           120              
00001106  2A4C                     121                      MOVEA.L A4, A5  ; Store starting address into current address
00001108                           122                      
00001108                           123                      *Clear the data and address registers used to obtain the starting and ending address 
00001108  4280                     124                      CLR.L   D0
0000110A  4285                     125                      CLR.L   D5
0000110C  4286                     126                      CLR.L   D6
0000110E  327C 0000                127                      MOVEA   #0, A1
00001112  6000 01D0                128                      BRA     START_DECODING  ; All inputs are valid, go to the decode process
00001116                           129                      
00001116  43F9 000030B4            130  LAST_DIGIT_ODD      LEA     ODD_ERROR_MESSAGE, A1 
0000111C  103C 000E                131                      MOVE.B  #14, D0
00001120  4E4F                     132                      TRAP    #15
00001122                           133                      
00001122  BC3C 0000                134                      CMP.B   #0,D6           ; When D6 is 0
00001126  6700 FEF0                135                      BEQ     PROMPT_START    ; Go back to start prompt
0000112A  BC3C 0001                136                      CMP.B   #1,D6           ; When D6 is 1
0000112E  6700 FF10                137                      BEQ     PROMPT_END      ; Go back to end prompt
00001132                           138  *--------------------------------------------------------------------------------------
00001132                           139  * param D2 data size to convert into ASCII
00001132                           140  * param A2 a pointer to decode_buf
00001132                           141  * param A5 the current address
00001132                           142  * itoa (D2, A2, A5) {
00001132                           143  * D0 byte data in ACII
00001132                           144  * D1 #sfhit
00001132                           145  * D7 long data to convert into ASCII
00001132                           146  * }
00001132                           147          
00001132                           148  ITOA                                ; convert integer to ASCII  
00001132  48E7 C000                149          MOVEM.L D0-D1,-(SP) 
00001136  B43C 0000                150          CMP.B   #%00, D2            ; byte
0000113A  6700 007E                151          BEQ     ITOA_BYTE
0000113E  B43C 0001                152          CMP.B   #%01, D2            ; word
00001142  6700 0096                153          BEQ     ITOA_WORD
00001146  B43C 0002                154          CMP.B   #%10, D2            ; long
0000114A  6700 00EC                155          BEQ     ITOA_LONG
0000114E  4EF9 0000126A            156          JMP     ITOA_LONGADDRESS    ; long address
00001154                           157          
00001154                           158  ITOA_MOVE                           ; convert integer to ASCII
00001154  48E7 C000                159          MOVEM.L D0-D1,-(SP) 
00001158  B43C 0001                160          CMP.B   #%01, D2            ; byte
0000115C  6700 005C                161          BEQ     ITOA_BYTE
00001160  B43C 0003                162          CMP.B   #%11, D2            ; word
00001164  6700 0074                163          BEQ     ITOA_WORD
00001168  B43C 0002                164          CMP.B   #%10,D2             ; long
0000116C  6700 00CA                165          BEQ     ITOA_LONG
00001170  4EF9 0000126A            166          JMP     ITOA_LONGADDRESS    ; long address
00001176                           167          
00001176                           168  ITOA_OPMODE                         ; convert integer to ASCII
00001176  48E7 C000                169          MOVEM.L D0-D1,-(SP) 
0000117A  B43C 0000                170          CMP.B   #%000,D2            ; When 0 then byte
0000117E  6700 003A                171          BEQ     ITOA_BYTE
00001182  B43C 0004                172          CMP.B   #%100,D2            ; When 4 then byte
00001186  6700 0032                173          BEQ     ITOA_BYTE 
0000118A  B43C 0001                174          CMP.B   #%001,D2            ; When 1 then word
0000118E  6700 004A                175          BEQ     ITOA_WORD
00001192  B43C 0003                176          CMP.B   #%011,D2            ; When 3 then word
00001196  6700 0042                177          BEQ     ITOA_WORD
0000119A  B43C 0005                178          CMP.B   #%101,D2            ; When 5 then word
0000119E  6700 003A                179          BEQ     ITOA_WORD 
000011A2  B43C 0002                180          CMP.B   #%010,D2            ; When 2 then long
000011A6  6700 0090                181          BEQ     ITOA_LONG
000011AA  B43C 0006                182          CMP.B   #%110,D2            ; When 6 then long
000011AE  6700 0088                183          BEQ     ITOA_LONG
000011B2  B43C 0007                184          CMP.B   #%111,D2            ; When 7 then long
000011B6  6700 0080                185          BEQ     ITOA_LONG
000011BA                           186          
000011BA                           187  ITOA_BYTE
000011BA  3E1D                     188          MOVE.W  (A5)+,D7
000011BC  4EB9 000012A2            189          JSR     ITOA_BYTE_CONVERT
000011C2  4EF9 000012DE            190          JMP     ITOA_DONE
000011C8                           191  
000011C8                           192  ITOA_BYTE_BRANCH
000011C8  48E7 C000                193          MOVEM.L D0-D1,-(SP)
000011CC  3E05                     194          MOVE.W  D5,D7
000011CE  4EB9 000012A2            195          JSR     ITOA_BYTE_CONVERT
000011D4  4EF9 000012DE            196          JMP     ITOA_DONE
000011DA                           197          
000011DA                           198  ITOA_WORD
000011DA  3E15                     199          MOVE.W  (A5),D7
000011DC  123C 0008                200          MOVE.B  #right8, D1
000011E0  E26F                     201          LSR.W   D1,D7
000011E2  4EB9 000012A2            202          JSR     ITOA_BYTE_CONVERT
000011E8  3E1D                     203          MOVE.W  (A5)+, D7
000011EA  4EB9 000012A2            204          JSR     ITOA_BYTE_CONVERT
000011F0  4EF9 000012DE            205          JMP     ITOA_DONE
000011F6                           206          
000011F6                           207  ITOA_WORD_BRANCH
000011F6  48E7 C000                208          MOVEM.L D0-D1,-(SP) 
000011FA  3E05                     209          MOVE.W  D5,D7
000011FC  123C 0008                210          MOVE.B  #right8, D1
00001200  E26F                     211          LSR.W   D1,D7
00001202  4EB9 000012A2            212          JSR     ITOA_BYTE_CONVERT
00001208  3E05                     213          MOVE.W  D5, D7
0000120A  361D                     214          MOVE.W  (A5)+,D3
0000120C  4EB9 000012A2            215          JSR     ITOA_BYTE_CONVERT
00001212  4EF9 000012DE            216          JMP     ITOA_DONE
00001218                           217          
00001218                           218  ITOA_WORD_ERROR
00001218  48E7 C000                219          MOVEM.L D0-D1,-(SP) 
0000121C  3E05                     220          MOVE.W  D5,D7
0000121E  123C 0008                221          MOVE.B  #right8, D1
00001222  E26F                     222          LSR.W   D1,D7
00001224  4EB9 000012A2            223          JSR     ITOA_BYTE_CONVERT
0000122A  3E05                     224          MOVE.W  D5,D7
0000122C  4EB9 000012A2            225          JSR     ITOA_BYTE_CONVERT
00001232  4EF9 000012DE            226          JMP     ITOA_DONE
00001238                           227          
00001238                           228  ITOA_LONG
00001238  3E15                     229          MOVE.W  (A5),D7
0000123A  123C 0008                230          MOVE.B  #right8, D1
0000123E  E26F                     231          LSR.W   D1, D7
00001240  4EB9 000012A2            232          JSR     ITOA_BYTE_CONVERT
00001246  3E1D                     233          MOVE.W  (A5)+, D7
00001248  4EB9 000012A2            234          JSR     ITOA_BYTE_CONVERT
0000124E                           235          
0000124E  3E15                     236          MOVE.W  (A5),D7
00001250  123C 0008                237          MOVE.B  #right8, D1
00001254  E26F                     238          LSR.W   D1, D7
00001256  4EB9 000012A2            239          JSR     ITOA_BYTE_CONVERT
0000125C  3E1D                     240          MOVE.W  (A5)+, D7
0000125E  4EB9 000012A2            241          JSR     ITOA_BYTE_CONVERT
00001264  4EF9 000012DE            242          JMP     ITOA_DONE
0000126A                           243  
0000126A                           244  ITOA_LONGADDRESS
0000126A  3E0D                     245          MOVE.W  A5,D7
0000126C  123C 0018                246          MOVE.B  #right24,D1
00001270  E26F                     247          LSR.W   D1,D7
00001272  4EB9 000012A2            248          JSR     ITOA_BYTE_CONVERT
00001278  3E0D                     249          MOVE.W  A5,D7
0000127A  123C 0010                250          MOVE.B  #right16,D1
0000127E  E26F                     251          LSR.W   D1,D7
00001280  4EB9 000012A2            252          JSR     ITOA_BYTE_CONVERT
00001286  3E0D                     253          MOVE.W  A5,D7
00001288  123C 0008                254          MOVE.B  #right8,D1
0000128C  E26F                     255          LSR.W   D1,D7
0000128E  4EB9 000012A2            256          JSR     ITOA_BYTE_CONVERT
00001294  3E0D                     257          MOVE.W  A5,D7
00001296  4EB9 000012A2            258          JSR     ITOA_BYTE_CONVERT   
0000129C  4EF9 000012DE            259          JMP     ITOA_DONE   
000012A2                           260  
000012A2                           261  ITOA_BYTE_CONVERT
000012A2  3007                     262          MOVE.W  D7, D0 
000012A4  0240 00F0                263          ANDI.W  #$F0, D0
000012A8  123C 0004                264          MOVE.B  #right4, D1
000012AC  E268                     265          LSR.W   D1, D0
000012AE  4EB9 000012C2            266          JSR     ITOA_NIBBLE_CONVERT
000012B4                           267          
000012B4  3007                     268          MOVE.W  D7, D0
000012B6  0240 000F                269          ANDI.W  #$0F, D0
000012BA  4EB9 000012C2            270          JSR     ITOA_NIBBLE_CONVERT
000012C0  4E75                     271          RTS
000012C2                           272          
000012C2                           273  ITOA_NIBBLE_CONVERT
000012C2  B03C 0009                274          CMP.B   #9, D0
000012C6  6E00 000A                275          BGT     ITOA_CONVERT_A_TO_F
000012CA  0600 0030                276          ADD.B   #$30, D0
000012CE  14C0                     277          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
000012D0  4E75                     278          RTS
000012D2                           279          
000012D2                           280  ITOA_CONVERT_A_TO_F
000012D2  0400 000A                281          SUBI.B  #10, D0
000012D6  0600 0041                282          ADDI.B  #$41, D0
000012DA  14C0                     283          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
000012DC  4E75                     284          RTS
000012DE                           285  
000012DE                           286  ITOA_DONE
000012DE  4CDF 0003                287          MOVEM.L (SP)+, D0-D1
000012E2  4E75                     288          RTS
000012E4                           289  *-------------------------------------------------------------------------------*
000012E4                           290  START_DECODING
000012E4  4282                     291          CLR.L   D2
000012E6                           292          
000012E6                           293  DECODING_ITERATION
000012E6                           294          ;decoding the current address
000012E6  4EB9 00001396            295          JSR     DECODE_MEMORY
000012EC  103C 000D                296          MOVE.B  #task13, D0
000012F0  43F9 00005000            297          LEA     decoded_buffer, A1
000012F6  4E4F                     298          TRAP    #15
000012F8                           299          
000012F8                           300          ;check if decoding has finished or if the screen is filled 
000012F8  BDCD                     301          CMP.L   A5, A6
000012FA  6F00 0022                302          BLE     CONTINUE_OR_END     ; If A6-A5 <= 0, go to CONTINUE_OR_END 
000012FE                           303          
000012FE                           304          ;have yet to reach the ending address
000012FE  5202                     305          ADDQ.B  #1, D2              ; D2 (screen_line_counter)++
00001300  B43C 001E                306          CMP.B   #lines_p_screen, D2
00001304  6C00 0004                307          BGE     DECODE_PAUSE
00001308                           308          ;not yet reached the maximum lines per screen. 
00001308  60DC                     309          BRA     DECODING_ITERATION
0000130A                           310  
0000130A                           311  DECODE_PAUSE
0000130A  103C 000E                312          MOVE.B  #task14, D0
0000130E  43F9 0000300F            313          LEA     ENTER_PROMPT, A1
00001314  4E4F                     314          TRAP    #15
00001316  103C 0005                315          MOVE.B  #task5, D0
0000131A  4E4F                     316          TRAP    #15
0000131C  60C6                     317          BRA     START_DECODING
0000131E                           318  
0000131E                           319  CONTINUE_OR_END
0000131E  4280                     320          CLR.L   D0
00001320  4281                     321          CLR.L   D1
00001322  4282                     322          CLR.L   D2
00001324  4283                     323          CLR.L   D3
00001326  4284                     324          CLR.L   D4
00001328  4285                     325          CLR.L   D5
0000132A  4286                     326          CLR.L   D6
0000132C  4287                     327          CLR.L   D7
0000132E  327C 0000                328          MOVEA   #0,A1
00001332  347C 0000                329          MOVEA   #0,A2
00001336  367C 0000                330          MOVEA   #0,A3
0000133A  387C 0000                331          MOVEA   #0,A4
0000133E  3A7C 0000                332          MOVEA   #0,A5
00001342  3C7C 0000                333          MOVEA   #0,A6
00001346                           334  
00001346  103C 000E                335          MOVE.B  #task14, D0
0000134A  43F9 0000302C            336          LEA     PROMPT_AGAIN, A1
00001350  4E4F                     337          TRAP    #15
00001352                           338          
00001352  103C 0002                339          MOVE.B  #task2, D0
00001356  43F9 00002E5E            340          LEA     ascii_y_n, A1
0000135C  4E4F                     341          TRAP    #15
0000135E                           342          
0000135E  1639 00002E5E            343          MOVE.B  ascii_y_n, D3
00001364  0C03 0059                344          CMPI.B  #y_uppercase, D3
00001368  6700 FCAE                345          BEQ     PROMPT_START
0000136C  0C03 0079                346          CMPI.B  #y_lowercase, D3
00001370  6700 FCA6                347          BEQ     PROMPT_START
00001374  0C03 004E                348          CMPI.B  #n_uppercase, D3
00001378  6700 000C                349          BEQ     EXIT
0000137C  0C03 006E                350          CMPI.B  #n_lowercase, D3
00001380  6700 0004                351          BEQ     EXIT
00001384  6098                     352          BRA     CONTINUE_OR_END 
00001386                           353          
00001386                           354  EXIT
00001386  103C 000E                355          MOVE.B  #task14, D0
0000138A  43F9 0000304F            356          LEA     EXIT_PROMPT, A1
00001390  4E4F                     357          TRAP    #15  
00001392  6000 1AC6                358          BRA     DONE             
00001396                           359  *---------------------------------------------------------------------------------*
00001396                           360  * D0: the current instruction. 
00001396                           361  * D1: used as temp storage
00001396                           362  * D2: data size 
00001396                           363  * D3: loop counter for the amount of lines per screen. 
00001396                           364  * D4: 
00001396                           365  * D5: #shifts
00001396                           366  * D6: store first nibble
00001396                           367  * D7: 
00001396                           368  * A0: 
00001396                           369  * A1: A pointer to the message to print out. 
00001396                           370  * A2: A pointer to the decode_buffer. 
00001396                           371  * A3: 
00001396                           372  * A4: Store the starting address and increment to the ending address. 
00001396                           373  * A5: The current address. 
00001396                           374  * A6: Store the ending address. 
00001396                           375  * A7: Stack pointer. 
00001396                           376  *---------------------------------------------------------------------------------*                             
00001396                           377  DECODE_MEMORY       
00001396  48E7 2002                378          MOVEM.L D2/A6, -(SP)
0000139A                           379                  
0000139A                           380          ;zero clear the decode_buffer
0000139A  4EB9 000013D2            381          JSR     OP_CLEAR_DATA
000013A0  45F9 00005000            382          LEA     decoded_buffer, A2  Load decode buffer into A2
000013A6                           383                  
000013A6                           384          ;print out the current address
000013A6  7403                     385          MOVE.L  #$0003, D2
000013A8  4EB8 1132                386          JSR      ITOA
000013AC                           387          
000013AC  14FC 0009                388          MOVE.B  #$9, (A2)+  ; Add space after long address
000013B0                           389                  
000013B0                           390          ;load the next instruction and jump to the opcode table entry
000013B0  41F9 000013E8            391          LEA     OP_TABLE, A0
000013B6  4280                     392          CLR.L   D0
000013B8  301D                     393          MOVE.W  (A5)+, D0       ; Store A5's value into D0, then increment A5
000013BA  2200                     394          MOVE.L  D0, D1          ; Store A5's value from D0 into D1
000013BC  1A3C 000C                395          MOVE.B  #right12, D5    ; Store 12 into D5
000013C0  EA69                     396          LSR.W   D5, D1          ; Shift first nibble into LSB position
000013C2  2C01                     397          MOVE.L  D1, D6          ; Store first nibble into D6
000013C4  C2FC 0006                398          MULU    #6, D1          ; Multiply 6 to D1
000013C8  4EF0 1000                399          JMP     0(A0, D1)       ; Go to displacement (A0 + D1 * 6)      
000013CC                           400  OP_FINISH
000013CC  4CDF 4004                401          MOVEM.L (SP)+, D2/A6,
000013D0  4E75                     402          RTS
000013D2                           403  *------------------------------------------------------------------------------------*
000013D2                           404  *Clear the 32 bits within the decoded_buffer       
000013D2                           405  OP_CLEAR_DATA
000013D2  4283                     406          CLR.L   D3
000013D4  163C 0040                407          MOVE.B  #buffer_size, D3
000013D8  45F9 00005000            408          LEA     decoded_buffer, A2
000013DE                           409          
000013DE                           410  OP_CLEAR_DATA_LOOP
000013DE  14FC 0000                411          MOVE.B  #0, (A2)+
000013E2  5343                     412          SUBI    #1, D3
000013E4  6EF8                     413          BGT     OP_CLEAR_DATA_LOOP
000013E6  4E75                     414          RTS
000013E8                           415  
000013E8                           416  *------------------------------------------------------------------------------------*
000013E8                           417  OP_TABLE
000013E8  4EF9 00001448            418          JMP     code0000    ; ADDI.bwl/ ANDI.bwl / CMPI.bwl / EORI.bwl / ORI.bwl / SUBI.bwl 
000013EE  4EF9 00001462            419          JMP     code0001    ; MOVE.b
000013F4  4EF9 00001466            420          JMP     code0010    ; MOVE.l / MOVEA.l
000013FA  4EF9 0000147E            421          JMP     code0011    ; MOVE.w / MOVEA.w
00001400  4EF9 00001496            422          JMP     code0100    ; CLR.bwl / JMP / JSR / LEA / MOVEM.wl / NOP / NOT.bwl / RTS / STOP / TRAP
00001406  4EF9 000014B0            423          JMP     code0101    ; ADDQ.bwl / SUBQ.bwl / Scc / Dbcc
0000140C  4EF9 000014B4            424          JMP     code0110    ; BRA.bw / BSR.bw / Bcc.bw
00001412  4EF9 00001540            425          JMP     code0111    ; MOVEQ
00001418  4EF9 00001544            426          JMP     code1000    ; DIVS / DIVU / CR.bwl
0000141E  4EF9 00001564            427          JMP     code1001    ; SUB.bwl / SUBA.wl
00001424  4EF9 00001568            428          JMP     code1010    ;   [unassigned]
0000142A  4EF9 0000156C            429          JMP     code1011    ; CMP.bwl / CMPA.wl / EOR.bwl
00001430  4EF9 00001570            430          JMP     code1100    ; MULS / MULU / AND.bwl
00001436  4EF9 0000158A            431          JMP     code1101    ; ADD.bwl / ADDA.wl / ADDX.bwl
0000143C  4EF9 000015A4            432          JMP     code1110    ; ASL.bwl / ASR.bwl / LSL.bwl / LSR.bwl / ROR.bwl / ROL.bwl
00001442  4EF9 00001622            433          JMP     code1111    ;   [unassigned]
00001448                           434          
00001448                           435  code0000                            ; Opcodes ADDI and SUBI
00001448  2200                     436          MOVE.L  D0,D1               ; D0 is current instruction word
0000144A  0241 0F00                437          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
0000144E  1A3C 0008                438          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001452  EA69                     439          LSR.W   D5,D1               ; Shift nibble into LSB position
00001454  C2FC 0006                440          MULU    #6, D1              ; Set displacement 
00001458  41F9 00001626            441          LEA     OP_0000_TABLE,A0    ; Load table into A0
0000145E  4EF0 1000                442          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00001462                           443  
00001462                           444  code0001                            ; Opcode MOVE.B
00001462  6000 052E                445          BRA     OP_MOVE             ; Go to opcode MOVE
00001466                           446  
00001466                           447  code0010                            ; Opcodes MOVE.L and MOVEA.L 
00001466  2200                     448          MOVE.L  D0,D1               ; D0 is current instruction word
00001468  0241 01C0                449          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000146C  1A3C 0006                450          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001470  EA69                     451          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001472  B23C 0001                452          CMP.B   #1,D1               ; When 001 in destination mode
00001476  6700 04F6                453          BEQ     OP_MOVEA            ; Go to opcode MOVEA
0000147A  6000 0516                454          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
0000147E                           455  
0000147E                           456  code0011                            ; Opcodes MOVE.W and MOVEA.W 
0000147E  2200                     457          MOVE.L  D0,D1               ; D0 is current instruction word
00001480  0241 01C0                458          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001484  1A3C 0006                459          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001488  EA69                     460          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000148A  B23C 0001                461          CMP.B   #1,D1               ; When 001 in destination mode
0000148E  6700 04DE                462          BEQ     OP_MOVEA            ; Go to opcode MOVEA
00001492  6000 04FE                463          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001496                           464  
00001496                           465  code0100                            ; Opcodes CLR, JSR, LEA, MOVEM, NOP, RTS
00001496  2200                     466          MOVE.L  D0,D1               ; D0 is current instruction word
00001498  0241 0F00                467          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
0000149C  1A3C 0008                468          MOVE.B  #right8,D5          ; Used to shift 8 times to right
000014A0  EA69                     469          LSR.W   D5,D1               ; Shift nibble into LSB position
000014A2  C2FC 0006                470          MULU    #6, D1              ; Set displacement 
000014A6  41F9 00001686            471          LEA     OP_0100_TABLE,A0    ; Load table into A0
000014AC  4EF0 1000                472          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000014B0                           473  
000014B0                           474  code0101                            ; Opcode ADDQ.B/W/L
000014B0  6000 0598                475          BRA     OP_ADDQ             ; Go to opcode ADDQ
000014B4                           476  
000014B4                           477  code0110                            ; Opcodes BRA / BSR / BHI
000014B4  2200                     478          MOVE.L  D0,D1               ; D0 is current instruction word
000014B6  0241 0F00                479          ANDI.W  #second_nibble,D1   ; Extract 2nd 4 bits from instruction word
000014BA  1A3C 0008                480          MOVE.B  #right8,D5          ; Used to shift 8 times to right
000014BE  EA69                     481          LSR.W   D5,D1               ; Shift nibble into LSB position
000014C0  B23C 0000                482          CMP.B   #0, D1              ; When 0000 in second nibble 
000014C4  6700 05A4                483          BEQ     OP_BRA              ; Go to opcode BRA
000014C8  B23C 0001                484          CMP.B   #1, D1              ; When 0001 in second nibble 
000014CC  6700 05B8                485          BEQ     OP_BSR              ; Go to opcode BSR
000014D0  B23C 0002                486          CMP.B   #2, D1              ; When 0010 in second nibble 
000014D4  6700 05CC                487          BEQ     OP_BHI              ; Go to opcode BHI
000014D8  B23C 0003                488          CMP.B   #3, D1              ; When 0011 in second nibble
000014DC  6700 05E0                489          BEQ     OP_BLS              ; Go to opcode BLS
000014E0  B23C 0004                490          CMP.B   #4, D1              ; When 0100 in second nibble
000014E4  6700 05F4                491          BEQ     OP_BCC              ; Go to opcode BCC
000014E8  B23C 0005                492          CMP.B   #5, D1              ; When 0101 in second nibble
000014EC  6700 0608                493          BEQ     OP_BCS              ; Go to opcode BCS
000014F0  B23C 0006                494          CMP.B   #6, D1              ; When 0110 in second nibble
000014F4  6700 061C                495          BEQ     OP_BNE              ; Go to opcode BNE
000014F8  B23C 0007                496          CMP.B   #7, D1              ; When 0111 in second nibble
000014FC  6700 0630                497          BEQ     OP_BEQ              ; Go to opcode BEQ
00001500  B23C 0008                498          CMP.B   #8, D1              ; When 1000 in second nibble
00001504  6700 0644                499          BEQ     OP_BVC              ; Go to opcode BVC
00001508  B23C 0009                500          CMP.B   #9, D1              ; When 1001 in second nibble
0000150C  6700 0658                501          BEQ     OP_BVS              ; Go to opcode BVS
00001510  B23C 000A                502          CMP.B   #10, D1             ; When 1010 in second nibble
00001514  6700 066C                503          BEQ     OP_BPL              ; Go to opcode BPL
00001518  B23C 000B                504          CMP.B   #11, D1             ; When 1011 in second nibble
0000151C  6700 0680                505          BEQ     OP_BMI              ; Go to opcode BMI
00001520  B23C 000C                506          CMP.B   #12, D1             ; When 1100 in second nibble
00001524  6700 0694                507          BEQ     OP_BGE              ; Go to opcode BGE
00001528  B23C 000D                508          CMP.B   #13, D1             ; When 1101 in second nibble
0000152C  6700 06A8                509          BEQ     OP_BLT              ; Go to opcode BLT
00001530  B23C 000E                510          CMP.B   #14, D1             ; When 1110 in second nibble
00001534  6700 06BC                511          BEQ     OP_BGT              ; Go to opcode BGT
00001538  B23C 000F                512          CMP.B   #15, D1             ; When 1111 in second nibble
0000153C  6700 06D0                513          BEQ     OP_BLE              ; Go to opcode BLE
00001540                           514  
00001540                           515  code0111                            ; Opcode MOVEQ
00001540  6000 06E8                516          BRA     OP_MOVEQ            ; Go to opcode MOVEQ
00001544                           517  
00001544                           518  code1000                            ; Opcodes DIVU word and OR.B/W/L
00001544  2200                     519          MOVE.L  D0,D1               ; D0 is current instruction word
00001546  0241 01C0                520          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000154A  1A3C 0006                521          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000154E  EA69                     522          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001550  B23C 0003                523          CMP.B   #3,D1               ; When 011 in destination mode
00001554  6700 06F8                524          BEQ     OP_DIVU             ; Go to opcode DIVU word
00001558  B23C 0007                525          CMP.B   #7,D1               ; When 111
0000155C  6700 03CC                526          BEQ     OP_UNSUPPORTED      ; Go to opcode unsupported
00001560  6000 070C                527          BRA     OP_OR               ; Otherwise, go to opcode OR
00001564                           528  
00001564                           529  code1001                            ; Opcode SUB.B/W/L
00001564  6000 0720                530          BRA     OP_SUB              ; Go to opcode SUB   
00001568                           531          
00001568                           532  code1010                            ; Opcode not supported 
00001568  6000 03C0                533          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
0000156C                           534       
0000156C                           535  code1011                            ; Opcode CMP.B/W/L
0000156C  6000 0734                536          BRA     OP_CMP              ; Go to opcode CMP
00001570                           537  
00001570                           538  code1100                            ; Opcodes MULS, MULU, AND.B/W/L
00001570  2200                     539          MOVE.L  D0,D1               ; D0 is current instruction word
00001572  0241 01C0                540          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001576  1A3C 0006                541          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000157A  EA69                     542          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000157C  C2FC 0006                543          MULU    #6, D1              ; Set displacement 
00001580  41F9 000016E6            544          LEA     OP_1100_TABLE,A0    ; Load table into A0
00001586  4EF0 1000                545          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
0000158A                           546  
0000158A                           547  code1101                            ; Opcodes ADD.B/W/L, ADDA.B/W/L
0000158A  2200                     548          MOVE.L  D0,D1               ; D0 is current instruction word
0000158C  0241 01C0                549          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001590  1A3C 0006                550          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001594  EA69                     551          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001596  C2FC 0006                552          MULU    #6, D1              ; Set displacement 
0000159A  41F9 00001746            553          LEA     OP_1101_TABLE,A0    ; Load table into A0
000015A0  4EF0 1000                554          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
000015A4                           555  
000015A4                           556  code1110                            ; Opcodes ASL.B/W/L, ASR.B/W/L, LSL.B/W/L, LSR.B/W/L, ROL.B/W/L, ROR.B/W/L   
000015A4  2200                     557          MOVE.L  D0,D1               ; D0 is current instruction word
000015A6  0241 01C0                558          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000015AA  1A3C 0006                559          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000015AE  EA69                     560          LSR.W   D5,D1               ; Shift dst mode into LSB position
000015B0                           561     
000015B0                           562          ; Check Memory Shifts
000015B0  B23C 0007                563          CMP.B   #7, D1              ; When 111
000015B4  6700 0024                564          BEQ     MEMORY_1110_LEFT    ; Go to Memory Shift Left Side
000015B8                           565      
000015B8  B23C 0003                566          CMP.B   #3, D1              ; When 011
000015BC  6700 0040                567          BEQ     MEMORY_1110_RIGHT   ; Go Memory Shift Right Side
000015C0                           568      
000015C0                           569          ; Check Register Shifts
000015C0  2200                     570          MOVE.L  D0,D1                       ; D0 is current instruction word
000015C2  0241 0038                571          ANDI.W  #src_mode,D1                ; Extract 5-3 bits from instruction word
000015C6  1A3C 0003                572          MOVE.B  #right3,D5                  ; Used to shift 3 times to right
000015CA  EA69                     573          LSR.W   D5,D1                       ; Shift 5-3 bits into LSB position
000015CC  C2FC 0006                574          MULU    #6,D1                       ; Set displacement 
000015D0  41F9 000017A6            575          LEA     OP_1110_TABLE_REGISTER,A0   ; Load table into A0
000015D6  4EF0 1000                576          JMP     0(A0,D1)                    ; go to displacement (A0 + D1 * 6)
000015DA                           577  
000015DA                           578  MEMORY_1110_LEFT    
000015DA  2200                     579          MOVE.L  D0,D1               ; D0 is current instruction word
000015DC  0241 0E00                580          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
000015E0  1A3C 0009                581          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000015E4  EA69                     582          LSR.W   D5,D1               ; Shift dst reg into LSB position
000015E6  B23C 0000                583          CMP.B   #0,D1               ; When D1 is 0
000015EA  6700 0786                584          BEQ     OP_ASL              ; Go to opcode ASL
000015EE  B23C 0001                585          CMP.B   #1, D1              ; when D1 is 1
000015F2  6700 07B6                586          BEQ     OP_LSL              ; Go to opcode LSL
000015F6  B23C 0003                587          CMP.B   #3, D1              ; When D1 is 3
000015FA  6700 07E6                588          BEQ     OP_ROL              ; Go to opcode ROL
000015FE                           589  
000015FE                           590  MEMORY_1110_RIGHT
000015FE  2200                     591          MOVE.L  D0,D1               ; D0 is current instruction word
00001600  0241 0E00                592          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
00001604  1A3C 0009                593          MOVE.B  #right9,D5          ; Used to shift 9 times to right
00001608  EA69                     594          LSR.W   D5,D1               ; Shift dst reg into LSB position
0000160A  B23C 0000                595          CMP.B   #0,D1               ; When D1 is 0
0000160E  6700 0746                596          BEQ     OP_ASR              ; Go to opcode ASR
00001612  B23C 0001                597          CMP.B   #1, D1              ; when D1 is 1
00001616  6700 0776                598          BEQ     OP_LSR              ; Go to opcode LSR
0000161A  B23C 0003                599          CMP.B   #3, D1              ; When D1 is 3
0000161E  6700 07A6                600          BEQ     OP_ROR              ; Go to opcode ROR
00001622                           601  
00001622                           602  code1111                            ; Opcode not supported 
00001622  6000 0306                603          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
00001626                           604           
00001626                           605  OP_0000_TABLE
00001626  4EF9 0000192A            606          JMP     OP_UNSUPPORTED  ; 0 Go to opcode unsupported  
0000162C  4EF9 0000192A            607          JMP     OP_UNSUPPORTED  ; 1 Go to opcode unsupported  
00001632  4EF9 0000192A            608          JMP     OP_UNSUPPORTED  ; 2 Go to opcode unsupported  
00001638  4EF9 0000192A            609          JMP     OP_UNSUPPORTED  ; 3 Go to opcode unsupported  
0000163E  4EF9 0000192E            610          JMP     OP_SUBI         ; 4 Go to opcode SUBI
00001644  4EF9 0000192A            611          JMP     OP_UNSUPPORTED  ; 5 Go to opcode unsupported  
0000164A  4EF9 0000194E            612          JMP     OP_ADDI         ; 6 Go to opcode ADDI
00001650  4EF9 0000192A            613          JMP     OP_UNSUPPORTED  ; 7 Go to opcode unsupported  
00001656  4EF9 0000192A            614          JMP     OP_UNSUPPORTED  ; 8 Go to opcode unsupported  
0000165C  4EF9 0000192A            615          JMP     OP_UNSUPPORTED  ; 9 Go to opcode unsupported  
00001662  4EF9 0000192A            616          JMP     OP_UNSUPPORTED  ; A Go to opcode unsupported  
00001668  4EF9 0000192A            617          JMP     OP_UNSUPPORTED  ; B Go to opcode unsupported  
0000166E  4EF9 0000192A            618          JMP     OP_UNSUPPORTED  ; C Go to opcode unsupported  
00001674  4EF9 0000192A            619          JMP     OP_UNSUPPORTED  ; D Go to opcode unsupported  
0000167A  4EF9 0000192A            620          JMP     OP_UNSUPPORTED  ; E Go to opcode unsupported  
00001680  4EF9 0000192A            621          JMP     OP_UNSUPPORTED  ; F Go to opcode unsupported  
00001686                           622      
00001686                           623  OP_0100_TABLE
00001686  4EF9 0000192A            624          JMP     OP_UNSUPPORTED      ; 0 Go to opcode unsupported  
0000168C  4EF9 00001A2E            625          JMP     OP_LEA              ; 1 Go to opcode LEA
00001692  4EF9 000019B2            626          JMP     OP_CLR              ; 2 Go to opcode CLR
00001698  4EF9 00001A2E            627          JMP     OP_LEA              ; 3 Go to opcode LEA
0000169E  4EF9 0000192A            628          JMP     OP_UNSUPPORTED      ; 4 Go to opcode unsupported  
000016A4  4EF9 00001A2E            629          JMP     OP_LEA              ; 5 Go to opcode LEA
000016AA  4EF9 0000192A            630          JMP     OP_UNSUPPORTED      ; 6 Go to opcode unsupported
000016B0  4EF9 00001A2E            631          JMP     OP_LEA              ; 7 Go to opcode LEA
000016B6  4EF9 00001A0A            632          JMP     OP_MOVEM            ; 8 Go to opcode MOVEM
000016BC  4EF9 00001A2E            633          JMP     OP_LEA              ; 9 Go to opcode LEA
000016C2  4EF9 0000192A            634          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000016C8  4EF9 00001A2E            635          JMP     OP_LEA              ; B Go to opcode LEA
000016CE  4EF9 00001A0A            636          JMP     OP_MOVEM            ; C Go to opcode MOVEM
000016D4  4EF9 00001A2E            637          JMP     OP_LEA              ; D Go to opcode LEA
000016DA  4EF9 0000186C            638          JMP     JSR_NOP_RTS         ; E Go to opcode JSR, NOP, or RTS
000016E0  4EF9 0000192A            639          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000016E6                           640      
000016E6                           641  OP_1100_TABLE
000016E6  4EF9 00001CFE            642          JMP     OP_AND              ; 0 Go to opcode AND 
000016EC  4EF9 00001CFE            643          JMP     OP_AND              ; 1 Go to opcode AND
000016F2  4EF9 00001CFE            644          JMP     OP_AND              ; 2 Go to opcode AND
000016F8  4EF9 00001CBE            645          JMP     OP_MULU             ; 3 Go to opcode MULU
000016FE  4EF9 00001CFE            646          JMP     OP_AND              ; 4 Go to opcode AND 
00001704  4EF9 00001CFE            647          JMP     OP_AND              ; 5 Go to opcode AND
0000170A  4EF9 00001CFE            648          JMP     OP_AND              ; 6 Go to opcode AND
00001710  4EF9 00001CDE            649          JMP     OP_MULS             ; 7 Go to opcode MULS
00001716  4EF9 0000192A            650          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000171C  4EF9 0000192A            651          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001722  4EF9 0000192A            652          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
00001728  4EF9 0000192A            653          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
0000172E  4EF9 0000192A            654          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001734  4EF9 0000192A            655          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000173A  4EF9 0000192A            656          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001740  4EF9 0000192A            657          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001746                           658      
00001746                           659  OP_1101_TABLE
00001746  4EF9 00001D1A            660          JMP     OP_ADD              ; 0 Go to opcode ADD 
0000174C  4EF9 00001D1A            661          JMP     OP_ADD              ; 1 Go to opcode ADD
00001752  4EF9 00001D1A            662          JMP     OP_ADD              ; 2 Go to opcode ADD
00001758  4EF9 00001D36            663          JMP     OP_ADDA             ; 3 Go to opcode ADDA
0000175E  4EF9 00001D1A            664          JMP     OP_ADD              ; 4 Go to opcode ADD 
00001764  4EF9 00001D1A            665          JMP     OP_ADD              ; 5 Go to opcode ADD
0000176A  4EF9 00001D1A            666          JMP     OP_ADD              ; 6 Go to opcode ADD
00001770  4EF9 00001D36            667          JMP     OP_ADDA             ; 7 Go to opcode ADDA
00001776  4EF9 0000192A            668          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000177C  4EF9 0000192A            669          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001782  4EF9 0000192A            670          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
00001788  4EF9 0000192A            671          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
0000178E  4EF9 0000192A            672          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001794  4EF9 0000192A            673          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000179A  4EF9 0000192A            674          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
000017A0  4EF9 0000192A            675          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000017A6                           676      
000017A6                           677  OP_1110_TABLE_REGISTER
000017A6  4EF9 00001806            678          JMP     OP_AS_CHECK         ; 0 Check if AS is left or right
000017AC  4EF9 00001828            679          JMP     OP_LS_CHECK         ; 1 Check if LS is left or right
000017B2  4EF9 0000192A            680          JMP     OP_UNSUPPORTED      ; 2 Go to opcode unsupported  
000017B8  4EF9 0000184A            681          JMP     OP_RO_CHECK         ; 3 Check if RO is left or right
000017BE  4EF9 00001806            682          JMP     OP_AS_CHECK         ; 4 Check if AS is left or right
000017C4  4EF9 00001828            683          JMP     OP_LS_CHECK         ; 5 Check if LS is left or right
000017CA  4EF9 0000192A            684          JMP     OP_UNSUPPORTED      ; 6 Go to opcode unsupported 
000017D0  4EF9 0000184A            685          JMP     OP_RO_CHECK         ; 7 Check if RO is left or right
000017D6  4EF9 0000192A            686          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
000017DC  4EF9 0000192A            687          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
000017E2  4EF9 0000192A            688          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000017E8  4EF9 0000192A            689          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
000017EE  4EF9 0000192A            690          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
000017F4  4EF9 0000192A            691          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
000017FA  4EF9 0000192A            692          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001800  4EF9 0000192A            693          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001806                           694  
00001806                           695  OP_AS_CHECK
00001806  2200                     696          MOVE.L  D0,D1               ; D0 is current instruction word
00001808  0241 01C0                697          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
0000180C  1A3C 0006                698          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001810  EA69                     699          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001812  0201 0004                700          ANDI.B  #4,D1               ; Get only bit 8 (dr)
00001816  E449                     701          LSR.W   #2,D1
00001818                           702  
00001818  B23C 0001                703          CMP.B   #1,D1               ; Go left
0000181C  6700 0554                704          BEQ     OP_ASL              ; 1 Go to opcode ASL
00001820  B23C 0000                705          CMP.B   #0,D1               ; Go right
00001824  6700 0530                706          BEQ     OP_ASR              ; 0 Go to opcode ASR
00001828                           707          
00001828                           708  OP_LS_CHECK
00001828  2200                     709          MOVE.L  D0,D1               ; D0 is current instruction word
0000182A  0241 01C0                710          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
0000182E  1A3C 0006                711          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001832  EA69                     712          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001834  0201 0004                713          ANDI.B  #4,D1               ; Get only bit 8 (dr)
00001838  E449                     714          LSR.W   #2,D1
0000183A                           715  
0000183A  B23C 0001                716          CMP.B   #1,D1               ; Go left
0000183E  6700 056A                717          BEQ     OP_LSL              ; 1 Go to opcode LSL
00001842  B23C 0000                718          CMP.B   #0,D1               ; Go right
00001846  6700 0546                719          BEQ     OP_LSR              ; 0 Go to opcode LSR
0000184A                           720          
0000184A                           721  OP_RO_CHECK
0000184A  2200                     722          MOVE.L  D0,D1               ; D0 is current instruction word
0000184C  0241 01C0                723          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00001850  1A3C 0006                724          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001854  EA69                     725          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001856  0201 0004                726          ANDI.B  #4,D1               ; Get only bit 8 (dr)
0000185A  E449                     727          LSR.W   #2,D1
0000185C                           728  
0000185C  B23C 0001                729          CMP.B   #1,D1               ; Go left
00001860  6700 0580                730          BEQ     OP_ROL              ; 1 Go to opcode ROL
00001864  B23C 0000                731          CMP.B   #0,D1               ; Go right
00001868  6700 055C                732          BEQ     OP_ROR              ; 0 Go to opcode ROR
0000186C                           733          
0000186C                           734  JSR_NOP_RTS
0000186C  2200                     735          MOVE.L  D0,D1               ; D0 is current instruction word
0000186E  0241 01C0                736          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001872  1A3C 0006                737          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001876  EA69                     738          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001878  B23C 0002                739          CMP.B   #2, D1              ; When 010 in destination mode
0000187C  6700 0170                740          BEQ     OP_JSR              ; Go to opcode JSR
00001880                           741          
00001880  2200                     742          MOVE.L  D0,D1               ; D0 is current instruction word
00001882  0241 000F                743          ANDI.W  #fourth_nibble,D1   ; Extract dst mode position from instruction word
00001886  B23C 0001                744          CMP.B   #1, D1  
0000188A  6700 000E                745          BEQ     NOP_CHECK
0000188E  B23C 0005                746          CMP.B   #5, D1  
00001892  6700 004E                747          BEQ     RTS_CHECK
00001896  6000 0092                748          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000189A                           749          
0000189A                           750  NOP_CHECK
0000189A  2200                     751          MOVE.L  D0,D1               ; D0 is current instruction word
0000189C  0241 F000                752          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
000018A0  1A3C 000C                753          MOVE.B  #right12,D5         ; Used to shift 6 times to right
000018A4  EA69                     754          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018A6  B23C 0004                755          CMP.B   #4, D1              
000018AA  6700 0006                756          BEQ     NOP_CHECK_TWO
000018AE  6000 007A                757          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018B2                           758          
000018B2                           759  NOP_CHECK_TWO
000018B2  2200                     760          MOVE.L  D0,D1               ; D0 is current instruction word
000018B4  0241 0F00                761          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
000018B8  1A3C 0008                762          MOVE.B  #right8,D5          ; Used to shift 6 times to right
000018BC  EA69                     763          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018BE  B23C 000E                764          CMP.B   #14, D1            
000018C2  6700 0006                765          BEQ     NOP_CHECK_THREE
000018C6  6000 0062                766          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018CA                           767  
000018CA                           768  NOP_CHECK_THREE
000018CA  2200                     769          MOVE.L  D0,D1               ; D0 is current instruction word
000018CC  0241 00F0                770          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
000018D0  1A3C 0004                771          MOVE.B  #right4,D5          ; Used to shift 6 times to right
000018D4  EA69                     772          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018D6  B23C 0007                773          CMP.B   #7, D1              
000018DA  6700 00F2                774          BEQ     OP_NOP
000018DE  6000 004A                775          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018E2                           776       
000018E2                           777  RTS_CHECK
000018E2  2200                     778          MOVE.L  D0,D1               ; D0 is current instruction word
000018E4  0241 F000                779          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
000018E8  1A3C 000C                780          MOVE.B  #right12,D5         ; Used to shift 6 times to right
000018EC  EA69                     781          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018EE  B23C 0004                782          CMP.B   #4, D1              
000018F2  6700 0006                783          BEQ     RTS_CHECK_TWO
000018F6  6000 0032                784          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018FA                           785          
000018FA                           786  RTS_CHECK_TWO
000018FA  2200                     787          MOVE.L  D0,D1               ; D0 is current instruction word
000018FC  0241 0F00                788          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
00001900  1A3C 0008                789          MOVE.B  #right8,D5          ; Used to shift 6 times to right
00001904  EA69                     790          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001906  B23C 000E                791          CMP.B   #14, D1             
0000190A  6700 0006                792          BEQ     RTS_CHECK_THREE
0000190E  6000 001A                793          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
00001912                           794  
00001912                           795  RTS_CHECK_THREE
00001912  2200                     796          MOVE.L  D0,D1               ; D0 is current instruction word
00001914  0241 00F0                797          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
00001918  1A3C 0004                798          MOVE.B  #right4,D5          ; Used to shift 6 times to right
0000191C  EA69                     799          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000191E  B23C 0007                800          CMP.B   #7, D1             
00001922  6700 00BA                801          BEQ     OP_RTS
00001926  6000 0002                802          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000192A                           803  
0000192A                           804  OP_UNSUPPORTED
0000192A  6000 14B4                805       BRA OP_ERROR       
0000192E                           806  *----------------------------------------------------------------------------------------------*
0000192E                           807  * param D0 the current instruction in word
0000192E                           808  * param D1 the EA type
0000192E                           809  * param A2 a pointer to the decode_buffer
0000192E                           810  * param A5 current address
0000192E                           811  * ea_start(D0, D1, A2, A5){
0000192E                           812  * D2: size
0000192E                           813  * D3: src mode, dst mode
0000192E                           814  * D4: src regs, dst regs
0000192E                           815  * D5: #shifts
0000192E                           816  * D7: immediate data
0000192E                           817  * A0: EA_TYPE_TABLE
0000192E                           818  *       0 = ea_immediate
0000192E                           819  * }
0000192E                           820  
0000192E                           821  *----------------------------------------------------------------------------------------------*
0000192E                           822  * First 4 bits: 0000
0000192E                           823  OP_SUBI
0000192E  14FC 0053                824          MOVE.B  #'S',(A2)+
00001932  14FC 0055                825          MOVE.B  #'U',(A2)+
00001936  14FC 0042                826          MOVE.B  #'B',(A2)+
0000193A  14FC 0049                827          MOVE.B  #'I',(A2)+
0000193E  223C 00000000            828          MOVE.L  #ea_type_immediate,D1
00001944  4EB9 00001DFE            829          JSR     EA_START
0000194A  4EF8 13CC                830          JMP     OP_FINISH
0000194E                           831          
0000194E                           832  OP_ADDI
0000194E  14FC 0041                833          MOVE.B  #'A',(A2)+
00001952  14FC 0044                834          MOVE.B  #'D',(A2)+
00001956  14FC 0044                835          MOVE.B  #'D',(A2)+
0000195A  14FC 0049                836          MOVE.B  #'I',(A2)+
0000195E  223C 00000000            837          MOVE.L  #ea_type_immediate,D1
00001964  4EB9 00001DFE            838          JSR     EA_START
0000196A  4EF8 13CC                839          JMP     OP_FINISH
0000196E                           840  
0000196E                           841  *-----------------------------------------------------------------------------------------------*
0000196E                           842  * First 4 bits: 0001
0000196E                           843  OP_MOVEA
0000196E  14FC 004D                844          MOVE.B  #'M',(A2)+
00001972  14FC 004F                845          MOVE.B  #'O',(A2)+
00001976  14FC 0056                846          MOVE.B  #'V',(A2)+
0000197A  14FC 0045                847          MOVE.B  #'E',(A2)+
0000197E  14FC 0041                848          MOVE.B  #'A',(A2)+
00001982  223C 00000002            849          MOVE.L  #ea_type_movea,D1
00001988  4EB9 00001DFE            850          JSR     EA_START
0000198E  4EF8 13CC                851          JMP     OP_FINISH
00001992                           852  
00001992                           853  *------------------------------------------------------------------------------------------------*
00001992                           854  * First 4 bits: 0011
00001992                           855  OP_MOVE
00001992  14FC 004D                856          MOVE.B  #'M',(A2)+
00001996  14FC 004F                857          MOVE.B  #'O',(A2)+
0000199A  14FC 0056                858          MOVE.B  #'V',(A2)+
0000199E  14FC 0045                859          MOVE.B  #'E',(A2)+
000019A2  223C 00000001            860          MOVE.L  #ea_type_move,D1
000019A8  4EB9 00001DFE            861          JSR     EA_START
000019AE  4EF8 13CC                862          JMP     OP_FINISH
000019B2                           863  
000019B2                           864  *------------------------------------------------------------------------------------------------*
000019B2                           865  * First 4 bits: 0100
000019B2                           866  OP_CLR
000019B2  14FC 0043                867          MOVE.B  #'C',(A2)+
000019B6  14FC 004C                868          MOVE.B  #'L',(A2)+
000019BA  14FC 0052                869          MOVE.B  #'R',(A2)+
000019BE  223C 00000004            870          MOVE.L  #ea_type_dstonly,D1
000019C4  4EB9 00001DFE            871          JSR     EA_START
000019CA  4EF8 13CC                872          JMP     OP_FINISH
000019CE                           873          
000019CE                           874  OP_NOP
000019CE  14FC 004E                875          MOVE.B  #'N',(A2)+
000019D2  14FC 004F                876          MOVE.B  #'O',(A2)+
000019D6  14FC 0050                877          MOVE.B  #'P',(A2)+
000019DA  4EF8 13CC                878          JMP     OP_FINISH
000019DE                           879          
000019DE                           880  OP_RTS
000019DE  14FC 0052                881          MOVE.B  #'R',(A2)+
000019E2  14FC 0054                882          MOVE.B  #'T',(A2)+
000019E6  14FC 0053                883          MOVE.B  #'S',(A2)+
000019EA  4EF8 13CC                884          JMP     OP_FINISH
000019EE                           885          
000019EE                           886  OP_JSR
000019EE  14FC 004A                887          MOVE.B  #'J',(A2)+
000019F2  14FC 0053                888          MOVE.B  #'S',(A2)+
000019F6  14FC 0052                889          MOVE.B  #'R',(A2)+
000019FA  223C 00000004            890          MOVE.L  #ea_type_dstonly,D1
00001A00  4EB9 00001DFE            891          JSR     EA_START
00001A06  4EF8 13CC                892          JMP     OP_FINISH
00001A0A                           893  
00001A0A                           894  OP_MOVEM
00001A0A  14FC 004D                895          MOVE.B  #'M',(A2)+
00001A0E  14FC 004F                896          MOVE.B  #'O',(A2)+
00001A12  14FC 0056                897          MOVE.B  #'V',(A2)+
00001A16  14FC 0045                898          MOVE.B  #'E',(A2)+
00001A1A  14FC 004D                899          MOVE.B  #'M',(A2)+
00001A1E  223C 00000006            900          MOVE.L  #ea_type_movem,D1
00001A24  4EB9 00001DFE            901          JSR     EA_START
00001A2A  4EF8 13CC                902          JMP     OP_FINISH
00001A2E                           903          
00001A2E                           904  OP_LEA
00001A2E  14FC 004C                905          MOVE.B  #'L',(A2)+
00001A32  14FC 0045                906          MOVE.B  #'E',(A2)+
00001A36  14FC 0041                907          MOVE.B  #'A',(A2)+
00001A3A  223C 00000003            908          MOVE.L  #ea_type_lea,D1
00001A40  4EB9 00001DFE            909          JSR     EA_START
00001A46  4EF8 13CC                910          JMP     OP_FINISH
00001A4A                           911  
00001A4A                           912  *------------------------------------------------------------------------------------------------*
00001A4A                           913  * First 4 bits: 0101
00001A4A                           914  OP_ADDQ
00001A4A  14FC 0041                915          MOVE.B  #'A',(A2)+
00001A4E  14FC 0044                916          MOVE.B  #'D',(A2)+
00001A52  14FC 0044                917          MOVE.B  #'D',(A2)+
00001A56  14FC 0051                918          MOVE.B  #'Q',(A2)+
00001A5A  223C 00000008            919          MOVE.L  #ea_type_quick,D1
00001A60  4EB9 00001DFE            920          JSR     EA_START
00001A66  4EF8 13CC                921          JMP     OP_FINISH
00001A6A                           922          
00001A6A                           923  *------------------------------------------------------------------------------------------------*
00001A6A                           924  * First 4 bits: 0110
00001A6A                           925  OP_BRA
00001A6A  14FC 0042                926          MOVE.B  #'B',(A2)+
00001A6E  14FC 0052                927          MOVE.B  #'R',(A2)+
00001A72  14FC 0041                928          MOVE.B  #'A',(A2)+
00001A76  223C 00000009            929          MOVE.L  #ea_type_branch,D1
00001A7C  4EB9 00001DFE            930          JSR     EA_START
00001A82  4EF8 13CC                931          JMP     OP_FINISH
00001A86                           932  
00001A86                           933  OP_BSR
00001A86  14FC 0042                934          MOVE.B  #'B',(A2)+
00001A8A  14FC 0053                935          MOVE.B  #'S',(A2)+
00001A8E  14FC 0052                936          MOVE.B  #'R',(A2)+
00001A92  223C 00000009            937          MOVE.L  #ea_type_branch,D1
00001A98  4EB9 00001DFE            938          JSR     EA_START
00001A9E  4EF8 13CC                939          JMP     OP_FINISH
00001AA2                           940          
00001AA2                           941  OP_BHI
00001AA2  14FC 0042                942          MOVE.B  #'B',(A2)+
00001AA6  14FC 0048                943          MOVE.B  #'H',(A2)+
00001AAA  14FC 0049                944          MOVE.B  #'I',(A2)+
00001AAE  223C 00000009            945          MOVE.L  #ea_type_branch,D1
00001AB4  4EB9 00001DFE            946          JSR     EA_START
00001ABA  4EF8 13CC                947          JMP     OP_FINISH
00001ABE                           948  
00001ABE                           949  OP_BLS
00001ABE  14FC 0042                950          MOVE.B  #'B',(A2)+
00001AC2  14FC 004C                951          MOVE.B  #'L',(A2)+
00001AC6  14FC 0053                952          MOVE.B  #'S',(A2)+
00001ACA  223C 00000009            953          MOVE.L  #ea_type_branch,D1
00001AD0  4EB9 00001DFE            954          JSR     EA_START
00001AD6  4EF8 13CC                955          JMP     OP_FINISH
00001ADA                           956  
00001ADA                           957  OP_BCC
00001ADA  14FC 0042                958          MOVE.B  #'B',(A2)+
00001ADE  14FC 0043                959          MOVE.B  #'C',(A2)+
00001AE2  14FC 0043                960          MOVE.B  #'C',(A2)+
00001AE6  223C 00000009            961          MOVE.L  #ea_type_branch,D1
00001AEC  4EB9 00001DFE            962          JSR     EA_START
00001AF2  4EF8 13CC                963          JMP     OP_FINISH
00001AF6                           964          
00001AF6                           965  OP_BCS
00001AF6  14FC 0042                966          MOVE.B  #'B',(A2)+
00001AFA  14FC 0043                967          MOVE.B  #'C',(A2)+
00001AFE  14FC 0053                968          MOVE.B  #'S',(A2)+
00001B02  223C 00000009            969          MOVE.L  #ea_type_branch,D1
00001B08  4EB9 00001DFE            970          JSR     EA_START
00001B0E  4EF8 13CC                971          JMP     OP_FINISH
00001B12                           972  
00001B12                           973  OP_BNE
00001B12  14FC 0042                974          MOVE.B  #'B',(A2)+
00001B16  14FC 004E                975          MOVE.B  #'N',(A2)+
00001B1A  14FC 0045                976          MOVE.B  #'E',(A2)+
00001B1E  223C 00000009            977          MOVE.L  #ea_type_branch,D1
00001B24  4EB9 00001DFE            978          JSR     EA_START
00001B2A  4EF8 13CC                979          JMP     OP_FINISH
00001B2E                           980  
00001B2E                           981  OP_BEQ
00001B2E  14FC 0042                982          MOVE.B  #'B',(A2)+
00001B32  14FC 0045                983          MOVE.B  #'E',(A2)+
00001B36  14FC 0051                984          MOVE.B  #'Q',(A2)+
00001B3A  223C 00000009            985          MOVE.L  #ea_type_branch,D1
00001B40  4EB9 00001DFE            986          JSR     EA_START
00001B46  4EF8 13CC                987          JMP     OP_FINISH
00001B4A                           988  
00001B4A                           989  OP_BVC
00001B4A  14FC 0042                990          MOVE.B  #'B',(A2)+
00001B4E  14FC 0056                991          MOVE.B  #'V',(A2)+
00001B52  14FC 0043                992          MOVE.B  #'C',(A2)+
00001B56  223C 00000009            993          MOVE.L  #ea_type_branch,D1
00001B5C  4EB9 00001DFE            994          JSR     EA_START
00001B62  4EF8 13CC                995          JMP     OP_FINISH
00001B66                           996  
00001B66                           997  OP_BVS
00001B66  14FC 0042                998          MOVE.B  #'B',(A2)+
00001B6A  14FC 0056                999          MOVE.B  #'V',(A2)+
00001B6E  14FC 0053               1000          MOVE.B  #'S',(A2)+
00001B72  223C 00000009           1001          MOVE.L  #ea_type_branch,D1
00001B78  4EB9 00001DFE           1002          JSR     EA_START
00001B7E  4EF8 13CC               1003          JMP     OP_FINISH
00001B82                          1004  
00001B82                          1005  OP_BPL
00001B82  14FC 0042               1006          MOVE.B  #'B',(A2)+
00001B86  14FC 0050               1007          MOVE.B  #'P',(A2)+
00001B8A  14FC 004C               1008          MOVE.B  #'L',(A2)+
00001B8E  223C 00000009           1009          MOVE.L  #ea_type_branch,D1
00001B94  4EB9 00001DFE           1010          JSR     EA_START
00001B9A  4EF8 13CC               1011          JMP     OP_FINISH
00001B9E                          1012  
00001B9E                          1013  OP_BMI
00001B9E  14FC 0042               1014          MOVE.B  #'B',(A2)+
00001BA2  14FC 004D               1015          MOVE.B  #'M',(A2)+
00001BA6  14FC 0049               1016          MOVE.B  #'I',(A2)+
00001BAA  223C 00000009           1017          MOVE.L  #ea_type_branch,D1
00001BB0  4EB9 00001DFE           1018          JSR     EA_START
00001BB6  4EF8 13CC               1019          JMP     OP_FINISH
00001BBA                          1020  
00001BBA                          1021  OP_BGE
00001BBA  14FC 0042               1022          MOVE.B  #'B',(A2)+
00001BBE  14FC 0047               1023          MOVE.B  #'G',(A2)+
00001BC2  14FC 0045               1024          MOVE.B  #'E',(A2)+
00001BC6  223C 00000009           1025          MOVE.L  #ea_type_branch,D1
00001BCC  4EB9 00001DFE           1026          JSR     EA_START
00001BD2  4EF8 13CC               1027          JMP     OP_FINISH
00001BD6                          1028  
00001BD6                          1029  OP_BLT
00001BD6  14FC 0042               1030          MOVE.B  #'B',(A2)+
00001BDA  14FC 004C               1031          MOVE.B  #'L',(A2)+
00001BDE  14FC 0054               1032          MOVE.B  #'T',(A2)+
00001BE2  223C 00000009           1033          MOVE.L  #ea_type_branch,D1
00001BE8  4EB9 00001DFE           1034          JSR     EA_START
00001BEE  4EF8 13CC               1035          JMP     OP_FINISH
00001BF2                          1036  
00001BF2                          1037  OP_BGT
00001BF2  14FC 0042               1038          MOVE.B  #'B',(A2)+
00001BF6  14FC 0047               1039          MOVE.B  #'G',(A2)+
00001BFA  14FC 0054               1040          MOVE.B  #'T',(A2)+
00001BFE  223C 00000009           1041          MOVE.L  #ea_type_branch,D1
00001C04  4EB9 00001DFE           1042          JSR     EA_START
00001C0A  4EF8 13CC               1043          JMP     OP_FINISH
00001C0E                          1044  
00001C0E                          1045  OP_BLE
00001C0E  14FC 0042               1046          MOVE.B  #'B',(A2)+
00001C12  14FC 004C               1047          MOVE.B  #'L',(A2)+
00001C16  14FC 0045               1048          MOVE.B  #'E',(A2)+
00001C1A  223C 00000009           1049          MOVE.L  #ea_type_branch,D1
00001C20  4EB9 00001DFE           1050          JSR     EA_START
00001C26  4EF8 13CC               1051          JMP     OP_FINISH
00001C2A                          1052  *------------------------------------------------------------------------------------------------*
00001C2A                          1053  * First 4 bits: 0111
00001C2A                          1054  OP_MOVEQ
00001C2A  14FC 004D               1055          MOVE.B  #'M',(A2)+
00001C2E  14FC 004F               1056          MOVE.B  #'O',(A2)+
00001C32  14FC 0056               1057          MOVE.B  #'V',(A2)+
00001C36  14FC 0045               1058          MOVE.B  #'E',(A2)+
00001C3A  14FC 0051               1059          MOVE.B  #'Q',(A2)+
00001C3E  223C 00000008           1060          MOVE.L  #ea_type_quick,D1
00001C44  4EB9 00001DFE           1061          JSR     EA_START
00001C4A  4EF8 13CC               1062          JMP     OP_FINISH
00001C4E                          1063          
00001C4E                          1064  *------------------------------------------------------------------------------------------------*
00001C4E                          1065  * First 4 bits: 1000
00001C4E                          1066  OP_DIVU
00001C4E  14FC 0044               1067          MOVE.B  #'D',(A2)+
00001C52  14FC 0049               1068          MOVE.B  #'I',(A2)+
00001C56  14FC 0056               1069          MOVE.B  #'V',(A2)+
00001C5A  14FC 0055               1070          MOVE.B  #'U',(A2)+
00001C5E  223C 00000005           1071          MOVE.L  #ea_type_ext,D1
00001C64  4EB9 00001DFE           1072          JSR     EA_START
00001C6A  4EF8 13CC               1073          JMP     OP_FINISH
00001C6E                          1074    
00001C6E                          1075  OP_OR
00001C6E  14FC 004F               1076          MOVE.B  #'O',(A2)+
00001C72  14FC 0052               1077          MOVE.B  #'R',(A2)+
00001C76  223C 00000005           1078          MOVE.L  #ea_type_ext,D1
00001C7C  4EB9 00001DFE           1079          JSR     EA_START
00001C82  4EF8 13CC               1080          JMP     OP_FINISH
00001C86                          1081  
00001C86                          1082  *------------------------------------------------------------------------------------------------*
00001C86                          1083  * First 4 bits: 1001
00001C86                          1084  OP_SUB
00001C86  14FC 0053               1085          MOVE.B  #'S',(A2)+
00001C8A  14FC 0055               1086          MOVE.B  #'U',(A2)+
00001C8E  14FC 0042               1087          MOVE.B  #'B',(A2)+
00001C92  223C 00000005           1088          MOVE.L  #ea_type_ext,D1
00001C98  4EB9 00001DFE           1089          JSR     EA_START
00001C9E  4EF8 13CC               1090          JMP     OP_FINISH
00001CA2                          1091          
00001CA2                          1092  *------------------------------------------------------------------------------------------------*
00001CA2                          1093  * First 4 bits: 1011
00001CA2                          1094  OP_CMP
00001CA2  14FC 0043               1095          MOVE.B  #'C',(A2)+
00001CA6  14FC 004D               1096          MOVE.B  #'M',(A2)+
00001CAA  14FC 0050               1097          MOVE.B  #'P',(A2)+
00001CAE  223C 00000005           1098          MOVE.L  #ea_type_ext,D1
00001CB4  4EB9 00001DFE           1099          JSR     EA_START
00001CBA  4EF8 13CC               1100          JMP     OP_FINISH
00001CBE                          1101          
00001CBE                          1102  *------------------------------------------------------------------------------------------------*
00001CBE                          1103  * First 4 bits: 1100
00001CBE                          1104  OP_MULU
00001CBE  14FC 004D               1105          MOVE.B  #'M',(A2)+
00001CC2  14FC 0055               1106          MOVE.B  #'U',(A2)+
00001CC6  14FC 004C               1107          MOVE.B  #'L',(A2)+
00001CCA  14FC 0055               1108          MOVE.B  #'U',(A2)+
00001CCE  223C 00000005           1109          MOVE.L  #ea_type_ext,D1
00001CD4  4EB9 00001DFE           1110          JSR     EA_START
00001CDA  4EF8 13CC               1111          JMP     OP_FINISH
00001CDE                          1112          
00001CDE                          1113  OP_MULS
00001CDE  14FC 004D               1114          MOVE.B  #'M',(A2)+
00001CE2  14FC 0055               1115          MOVE.B  #'U',(A2)+
00001CE6  14FC 004C               1116          MOVE.B  #'L',(A2)+
00001CEA  14FC 0053               1117          MOVE.B  #'S',(A2)+
00001CEE  223C 00000005           1118          MOVE.L  #ea_type_ext,D1
00001CF4  4EB9 00001DFE           1119          JSR     EA_START
00001CFA  4EF8 13CC               1120          JMP     OP_FINISH
00001CFE                          1121          
00001CFE                          1122  OP_AND
00001CFE  14FC 0041               1123          MOVE.B  #'A',(A2)+
00001D02  14FC 004E               1124          MOVE.B  #'N',(A2)+
00001D06  14FC 0044               1125          MOVE.B  #'D',(A2)+
00001D0A  223C 00000005           1126          MOVE.L  #ea_type_ext,D1
00001D10  4EB9 00001DFE           1127          JSR     EA_START
00001D16  4EF8 13CC               1128          JMP     OP_FINISH
00001D1A                          1129          
00001D1A                          1130  *------------------------------------------------------------------------------------------------*
00001D1A                          1131  * First 4 bits: 1101
00001D1A                          1132  OP_ADD
00001D1A  14FC 0041               1133          MOVE.B  #'A',(A2)+
00001D1E  14FC 0044               1134          MOVE.B  #'D',(A2)+
00001D22  14FC 0044               1135          MOVE.B  #'D',(A2)+
00001D26  223C 00000005           1136          MOVE.L  #ea_type_ext,D1
00001D2C  4EB9 00001DFE           1137          JSR     EA_START
00001D32  4EF8 13CC               1138          JMP     OP_FINISH
00001D36                          1139  
00001D36                          1140  OP_ADDA
00001D36  14FC 0041               1141          MOVE.B  #'A',(A2)+
00001D3A  14FC 0044               1142          MOVE.B  #'D',(A2)+
00001D3E  14FC 0044               1143          MOVE.B  #'D',(A2)+
00001D42  14FC 0041               1144          MOVE.B  #'A',(A2)+
00001D46  223C 00000005           1145          MOVE.L  #ea_type_ext,D1
00001D4C  4EB9 00001DFE           1146          JSR     EA_START
00001D52  4EF8 13CC               1147          JMP     OP_FINISH
00001D56                          1148          
00001D56                          1149  *------------------------------------------------------------------------------------------------*
00001D56                          1150  * First 4 bits: 1110
00001D56                          1151  OP_ASR
00001D56  14FC 0041               1152          MOVE.B  #'A',(A2)+
00001D5A  14FC 0053               1153          MOVE.B  #'S',(A2)+
00001D5E  14FC 0052               1154          MOVE.B  #'R',(A2)+
00001D62  223C 00000007           1155          MOVE.L  #ea_type_shifts,D1
00001D68  4EB9 00001DFE           1156          JSR     EA_START
00001D6E  4EF8 13CC               1157          JMP     OP_FINISH
00001D72                          1158  OP_ASL
00001D72  14FC 0041               1159          MOVE.B  #'A',(A2)+
00001D76  14FC 0053               1160          MOVE.B  #'S',(A2)+
00001D7A  14FC 004C               1161          MOVE.B  #'L',(A2)+
00001D7E  223C 00000007           1162          MOVE.L  #ea_type_shifts,D1
00001D84  4EB9 00001DFE           1163          JSR     EA_START
00001D8A  4EF8 13CC               1164          JMP     OP_FINISH
00001D8E                          1165          
00001D8E                          1166  OP_LSR
00001D8E  14FC 004C               1167          MOVE.B  #'L',(A2)+
00001D92  14FC 0053               1168          MOVE.B  #'S',(A2)+
00001D96  14FC 0052               1169          MOVE.B  #'R',(A2)+
00001D9A  223C 00000007           1170          MOVE.L  #ea_type_shifts,D1
00001DA0  4EB9 00001DFE           1171          JSR     EA_START
00001DA6  4EF8 13CC               1172          JMP     OP_FINISH
00001DAA                          1173         
00001DAA                          1174  OP_LSL
00001DAA  14FC 004C               1175          MOVE.B  #'L',(A2)+
00001DAE  14FC 0053               1176          MOVE.B  #'S',(A2)+
00001DB2  14FC 004C               1177          MOVE.B  #'L',(A2)+
00001DB6  223C 00000007           1178          MOVE.L  #ea_type_shifts,D1
00001DBC  4EB9 00001DFE           1179          JSR     EA_START
00001DC2  4EF8 13CC               1180          JMP     OP_FINISH
00001DC6                          1181          
00001DC6                          1182  OP_ROR
00001DC6  14FC 0052               1183          MOVE.B  #'R',(A2)+
00001DCA  14FC 004F               1184          MOVE.B  #'O',(A2)+
00001DCE  14FC 0052               1185          MOVE.B  #'R',(A2)+
00001DD2  223C 00000007           1186          MOVE.L  #ea_type_shifts,D1
00001DD8  4EB9 00001DFE           1187          JSR     EA_START
00001DDE  4EF8 13CC               1188          JMP     OP_FINISH
00001DE2                          1189          
00001DE2                          1190  OP_ROL
00001DE2  14FC 0052               1191          MOVE.B  #'R',(A2)+
00001DE6  14FC 004F               1192          MOVE.B  #'O',(A2)+
00001DEA  14FC 004C               1193          MOVE.B  #'L',(A2)+
00001DEE  223C 00000007           1194          MOVE.L  #ea_type_shifts,D1
00001DF4  4EB9 00001DFE           1195          JSR     EA_START
00001DFA  4EF8 13CC               1196          JMP     OP_FINISH
00001DFE                          1197          
00001DFE                          1198  *------------------------------------------------------------------------------------------------*
00001DFE                          1199  EA_START
00001DFE  48E7 38C0               1200          MOVEM.L D2-D4/A0-A1, -(SP)
00001E02                          1201          
00001E02  41F9 00001E16           1202          LEA     EA_TYPE_TABLE, A0
00001E08  C2FC 0006               1203          MULU    #6, D1
00001E0C  4EF0 1000               1204          JMP     0(A0, D1)
00001E10                          1205          
00001E10                          1206  EA_FINISH
00001E10  4CDF 031C               1207          MOVEM.L (SP)+, D2-D4/A0-A1
00001E14  4E75                    1208          RTS
00001E16                          1209          
00001E16                          1210  EA_TYPE_TABLE
00001E16  4EF9 00001F34           1211          JMP     EA_IMMEDIATE        ; 0: ea_immediate
00001E1C  4EF9 00001F90           1212          JMP     EA_MOVE             ; 1: ea_move
00001E22  4EF9 00002000           1213          JMP     EA_MOVEA            ; 2: ea_movea
00001E28  4EF9 0000206C           1214          JMP     EA_LEA              ; 3: ea_lea
00001E2E  4EF9 000020F0           1215          JMP     EA_DSTONLY          ; 4: ea_dstonly
00001E34  4EF9 000021B6           1216          JMP     EA_EXT              ; 5: ea_ext
00001E3A  4EF9 000023AC           1217          JMP     EA_MOVEM            ; 6: ea_movem
00001E40  4EF9 00002A10           1218          JMP     EA_SHIFTS           ; 7: ea_shifts
00001E46  4EF9 00002B92           1219          JMP     EA_QUICK            ; 8: ea_quick
00001E4C  4EF9 00002C54           1220          JMP     EA_branch           ; 9: ea_branch
00001E52  4EF8 1E10               1221          JMP     EA_FINISH
00001E56                          1222          
00001E56                          1223  EA_SIZE_GENERAL
00001E56  B43C 0000               1224          CMP.B   #%00,D2             ; .b
00001E5A  6700 00B6               1225          BEQ     EA_SIZE_B       
00001E5E  B43C 0001               1226          CMP.B   #%01,D2             ; .w
00001E62  6700 00B8               1227          BEQ     EA_SIZE_W       
00001E66  B43C 0002               1228          CMP.B   #%10,D2             ; .l
00001E6A  6700 00BC               1229          BEQ     EA_SIZE_L
00001E6E  6000 0FA2               1230          BRA     EA_ERROR          ; wrong size
00001E72                          1231  
00001E72                          1232  EA_SIZE_MOVE
00001E72  B43C 0001               1233          CMP.B   #%01,D2             ; .b
00001E76  6700 009A               1234          BEQ     EA_SIZE_B       
00001E7A  B43C 0003               1235          CMP.B   #%11,D2             ; .w
00001E7E  6700 009C               1236          BEQ     EA_SIZE_W       
00001E82  B43C 0002               1237          CMP.B   #%10,D2             ; .l
00001E86  6700 00A0               1238          BEQ     EA_SIZE_L
00001E8A  6000 0F86               1239          BRA     EA_ERROR            ; wrong size
00001E8E                          1240  
00001E8E                          1241  EA_SIZE_MOVEA     
00001E8E  B43C 0003               1242          CMP.B   #%11,D2             ; .w
00001E92  6700 0088               1243          BEQ     EA_SIZE_W       
00001E96  B43C 0002               1244          CMP.B   #%10,D2             ; .l
00001E9A  6700 008C               1245          BEQ     EA_SIZE_L
00001E9E  6000 0F72               1246          BRA     EA_ERROR            ; wrong size
00001EA2                          1247          
00001EA2                          1248  EA_SIZE_MOVEM     
00001EA2  B43C 0000               1249          CMP.B   #%0000,D2           ; .w
00001EA6  6700 0074               1250          BEQ     EA_SIZE_W       
00001EAA  B43C 0004               1251          CMP.B   #%0100,D2           ; .l
00001EAE  6700 0078               1252          BEQ     EA_SIZE_L
00001EB2  6000 0F5E               1253          BRA     EA_ERROR            ; wrong size
00001EB6                          1254  
00001EB6                          1255  EA_SIZE_OPMODE_012456               ; Check opmode field for size
00001EB6  B43C 0000               1256          CMP.B   #%000,D2            ; When 0 then .b
00001EBA  6700 0056               1257          BEQ     EA_SIZE_B
00001EBE  B43C 0004               1258          CMP.B   #%100,D2            ; When 4 then .b
00001EC2  6700 004E               1259          BEQ     EA_SIZE_B  
00001EC6  B43C 0001               1260          CMP.B   #%001,D2            ; When 1 then .w
00001ECA  6700 0050               1261          BEQ     EA_SIZE_W
00001ECE  B43C 0005               1262          CMP.B   #%101,D2            ; When 5 then .w
00001ED2  6700 0048               1263          BEQ     EA_SIZE_W 
00001ED6  B43C 0002               1264          CMP.B   #%010,D2            ; When 2 then .l
00001EDA  6700 004C               1265          BEQ     EA_SIZE_L
00001EDE  B43C 0006               1266          CMP.B   #%110,D2            ; When 6 then .l
00001EE2  6700 0044               1267          BEQ     EA_SIZE_L
00001EE6  6000 0F2A               1268          BRA     EA_ERROR            ; wrong size
00001EEA                          1269  
00001EEA                          1270  EA_SIZE_ADDA                        ; Check opmode field for size
00001EEA  B43C 0003               1271          CMP.B   #%011,D2            ; When 3 then .w
00001EEE  6700 002C               1272          BEQ     EA_SIZE_W       
00001EF2  B43C 0007               1273          CMP.B   #%111,D2            ; When 7 then .l
00001EF6  6700 0030               1274          BEQ     EA_SIZE_L
00001EFA  6000 0F16               1275          BRA     EA_ERROR            ; wrong size
00001EFE                          1276                  
00001EFE                          1277  EA_SIZE_MEMORY_SHIFTS
00001EFE  B43C 0000               1278          CMP.B   #%00,D2             ; .w
00001F02  6700 0022               1279          BEQ     EA_SIZE_W_MEMORY      
00001F06  B43C 0001               1280          CMP.B   #%01,D2             ; .l
00001F0A  6700 001C               1281          BEQ     EA_SIZE_L      
00001F0E  6000 0F02               1282          BRA     EA_ERROR            ; wrong size
00001F12                          1283  
00001F12                          1284  EA_SIZE_B
00001F12  14FC 002E               1285          MOVE.B  #'.',(A2)+
00001F16  14FC 0042               1286          MOVE.B  #'B',(A2)+
00001F1A  4E75                    1287          RTS
00001F1C                          1288  EA_SIZE_W
00001F1C  14FC 002E               1289          MOVE.B  #'.',(A2)+
00001F20  14FC 0057               1290          MOVE.B  #'W',(A2)+
00001F24  4E75                    1291          RTS     
00001F26                          1292  EA_SIZE_W_MEMORY
00001F26  4E75                    1293          RTS        
00001F28                          1294  EA_SIZE_L
00001F28  14FC 002E               1295          MOVE.B  #'.',(A2)+
00001F2C  14FC 004C               1296          MOVE.B  #'L',(A2)+
00001F30  4E75                    1297          RTS
00001F32                          1298  EA_SIZE_DONE
00001F32  4E75                    1299          RTS
00001F34                          1300  *------------------------------------------------------------------------------------------------*     
00001F34                          1301  EA_IMMEDIATE                        ; 0 ea_immediate
00001F34  2200                    1302          MOVE.L  D0,D1
00001F36  0241 01C0               1303          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00001F3A  1A3C 0006               1304          MOVE.B  #right6,D5          ; Store 6 into D5
00001F3E  EA69                    1305          LSR.W   D5,D1               ; Shift D1 six times to LSB position
00001F40  0201 0003               1306          ANDI.B  #3,D1               ; Remove the front bit from D1
00001F44  1401                    1307          MOVE.B  D1,D2               ; Store D1 into D2 (used to check size)
00001F46  4EB8 1E56               1308          JSR     EA_SIZE_GENERAL     ; Get size 
00001F4A                          1309          
00001F4A  14FC 0020               1310          MOVE.B  #$20,(A2)+          ; Add space after size
00001F4E  14FC 0020               1311          MOVE.B  #$20,(A2)+          ; Add space 
00001F52  14FC 0020               1312          MOVE.B  #$20,(A2)+          ; Add space
00001F56                          1313  
00001F56                          1314          ; Get source and store into decode buffer
00001F56  7804                    1315          MOVE.L  #4,D4               ; Store 100 into D4 (jump to immed)
00001F58  7607                    1316          MOVE.L  #7,D3               ; Store 111 into D3 (Go abs and immed)
00001F5A  4EB9 00002CAC           1317          JSR     EA_GEN_SRC          ; Get EA src print 
00001F60                          1318  
00001F60  14FC 002C               1319          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001F64  14FC 0020               1320          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F68                          1321  
00001F68                          1322          ; Get desination and store into decode buffer
00001F68  2800                    1323          MOVE.L  D0,D4               ; Store the current address into D4 
00001F6A  0244 0007               1324          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00001F6E                          1325          
00001F6E  2600                    1326          MOVE.L  D0,D3               ; Store the current address into D3 
00001F70  0243 0038               1327          ANDI.W  #src_mode,D3        ; Get bits 5-3 (D3 stores EA mode)
00001F74  1A3C 0003               1328          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB position
00001F78  EA6B                    1329          LSR.W   D5,D3               ; Do the actual shift 
00001F7A  4EB9 00002DB8           1330          JSR     An_CHECK            ; Check if mode is An
00001F80  4EB9 00002DCC           1331          JSR     IMMEDIATE_CHECK     ; Check if mode is Immediate
00001F86  4EB9 00002CAC           1332          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00001F8C  4EF8 1E10               1333          JMP     EA_FINISH           ; Opcode is finish
00001F90                          1334  *------------------------------------------------------------------------------------------------*
00001F90                          1335  EA_MOVE                             ; 1: ea_move
00001F90  2200                    1336          MOVE.L  D0,D1
00001F92  0241 F000               1337          ANDI.W  #first_nibble,D1
00001F96  1A3C 000C               1338          MOVE.B  #right12,D5 
00001F9A  EA69                    1339          LSR.W   D5,D1
00001F9C  0201 0003               1340          ANDI.B  #3,D1
00001FA0  1401                    1341          MOVE.B  D1,D2
00001FA2  4EB8 1E72               1342          JSR     EA_SIZE_MOVE
00001FA6                          1343          
00001FA6  14FC 0020               1344          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001FAA  14FC 0020               1345          MOVE.B  #$20,(A2)+          ; Print out a space
00001FAE  14FC 0020               1346          MOVE.B  #$20,(A2)+          ; Print out a space
00001FB2                          1347          
00001FB2                          1348          ; Get source and store into decode buffer
00001FB2  2800                    1349          MOVE.L  D0,D4               ; Store the src reg in D4
00001FB4  0244 0007               1350          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001FB8                          1351          
00001FB8  2600                    1352          MOVE.L  D0,D3               ; Store the src mode in D3
00001FBA  0243 0038               1353          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001FBE  1A3C 0003               1354          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001FC2  EA6B                    1355          LSR.W   D5,D3               ; Do the actual shift 
00001FC4  4EB9 00002CAC           1356          JSR     EA_GEN_SRC
00001FCA                          1357          
00001FCA  14FC 002C               1358          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001FCE  14FC 0020               1359          MOVE.B  #$20,(A2)+          ; Add space after comma
00001FD2                          1360          
00001FD2                          1361          ; Get desination and store into decode buffer
00001FD2  2800                    1362          MOVE.L  D0,D4               ; Store the dest reg in D4
00001FD4  0244 0E00               1363          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001FD8  1A3C 0009               1364          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001FDC  EA6C                    1365          LSR.W   D5,D4               ; Do the actual shift
00001FDE                          1366          
00001FDE  2600                    1367          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001FE0  0243 01C0               1368          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001FE4  1A3C 0006               1369          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001FE8  EA6B                    1370          LSR.W   D5,D3               ; Do the actual shift 
00001FEA  4EB9 00002DB8           1371          JSR     An_CHECK            ; Check if dest mode is 001: An
00001FF0  4EB9 00002DCC           1372          JSR     IMMEDIATE_CHECK     ; Check if immediate 
00001FF6  4EB9 00002CAC           1373          JSR     EA_GEN_SRC          ; Get EA print        
00001FFC  4EF8 1E10               1374          JMP     EA_FINISH           ; Opcode is finish
00002000                          1375  *------------------------------------------------------------------------------------------------*          
00002000                          1376  EA_MOVEA                            ; 2: ea_movea
00002000  2200                    1377          MOVE.L  D0,D1
00002002  0241 F000               1378          ANDI.W  #first_nibble,D1
00002006  1A3C 000C               1379          MOVE.B  #right12,D5 
0000200A  EA69                    1380          LSR.W   D5,D1
0000200C  0201 0003               1381          ANDI.B  #3,D1
00002010  1401                    1382          MOVE.B  D1,D2
00002012  4EB8 1E8E               1383          JSR     EA_SIZE_MOVEA 
00002016                          1384          
00002016  14FC 0020               1385          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000201A  14FC 0020               1386          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000201E                          1387          
0000201E                          1388          ; Get source and store into decode buffer
0000201E  2800                    1389          MOVE.L  D0,D4               ; Store the src reg in D4
00002020  0244 0007               1390          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002024                          1391          
00002024  2600                    1392          MOVE.L  D0,D3               ; Store the src mode in D3
00002026  0243 0038               1393          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000202A  1A3C 0003               1394          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000202E  EA6B                    1395          LSR.W   D5,D3               ; Do the actual shift 
00002030  4EB9 00002CAC           1396          JSR     EA_GEN_SRC
00002036                          1397          
00002036  14FC 002C               1398          MOVE.B  #$2C,(A2)+          ; Add comma after size print
0000203A  14FC 0020               1399          MOVE.B  #$20,(A2)+          ; Add space after comma
0000203E                          1400          
0000203E                          1401          ; Get desination and store into decode buffer
0000203E  2800                    1402          MOVE.L  D0,D4               ; Store the dest reg in D4
00002040  0244 0E00               1403          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002044  1A3C 0009               1404          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002048  EA6C                    1405          LSR.W   D5,D4               ; Do the actual shift
0000204A                          1406          
0000204A  2600                    1407          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
0000204C  0243 01C0               1408          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00002050  1A3C 0006               1409          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00002054  EA6B                    1410          LSR.W   D5,D3               ; Do the actual shift 
00002056  B63C 0001               1411          CMP.B   #1,D3               ; If dst mode is 001: An 
0000205A  6700 0006               1412          BEQ     MOVEA_DST_VALID     ; dst is valid, so branch 
0000205E  6000 0DB2               1413          BRA     EA_ERROR            ; Otherwise, go to invalid message 
00002062                          1414          
00002062                          1415  MOVEA_DST_VALID
00002062  4EB9 00002CAC           1416          JSR     EA_GEN_SRC          ; Get EA print
00002068  4EF8 1E10               1417          JMP     EA_FINISH           ; Opcode is finish
0000206C                          1418  *------------------------------------------------------------------------------------------------*
0000206C                          1419  EA_LEA                              ; 3: ea_lea
0000206C  14FC 0020               1420          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002070  14FC 0020               1421          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002074  14FC 0020               1422          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002078  14FC 0020               1423          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000207C  14FC 0020               1424          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002080  14FC 0020               1425          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002084                          1426  
00002084  2800                    1427          MOVE.L  D0,D4               ; Store the src reg in D4
00002086  0244 0007               1428          ANDI.W  #src_reg,D4         ; get the bits at 2-0
0000208A                          1429          
0000208A  2600                    1430          MOVE.L  D0,D3               ; Store the src mode in D3
0000208C  0243 0038               1431          ANDI.W  #src_mode,D3        ; get bits 5-3
00002090  1A3C 0003               1432          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB
00002094  EA6B                    1433          LSR.W   D5,D3               ; do the actual shift 
00002096  B67C 0002               1434          CMP     #2,D3               ; If D3 (src mode) is 010 (An)
0000209A  6700 000E               1435          BEQ     LEA_SRC_VALID
0000209E  B67C 0007               1436          CMP     #7,D3               ; If D3 (src mode) is 111 (W or L)
000020A2  6700 0006               1437          BEQ     LEA_SRC_VALID
000020A6  6000 0D6A               1438          BRA     EA_ERROR            ; when src mode is not 010 or 111, branch to error message
000020AA                          1439          
000020AA                          1440  LEA_SRC_VALID
000020AA  4EB9 00002DCC           1441          JSR     IMMEDIATE_CHECK     ; Check if src is immediate        
000020B0  4EB9 00002CAC           1442          JSR     EA_GEN_SRC          ; Go to function 
000020B6                          1443   
000020B6  14FC 002C               1444          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000020BA  14FC 0020               1445          MOVE.B  #$20,(A2)+          ; Add space after comma
000020BE                          1446  
000020BE  2600                    1447          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
000020C0  0243 01C0               1448          ANDI.W  #dst_mode,D3        ; Get bits 8-6
000020C4  1A3C 0006               1449          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
000020C8  EA6B                    1450          LSR.W   D5,D3               ; Do the actual shift
000020CA  B63C 0007               1451          CMP.B   #7,D3               ; Check if D3 is 111
000020CE  6700 0006               1452          BEQ     CHANGE_TO_001       ; change the D3 bits to 001 
000020D2  6000 0D3E               1453          BRA     EA_ERROR            ; Print out an error message if bits 8-6 (dst mode) are not 111
000020D6                          1454    
000020D6                          1455  CHANGE_TO_001
000020D6  163C 0001               1456          MOVE.B  #%001,D3            ; set D3 to 001 to ensure the print out A 
000020DA                          1457          
000020DA  2800                    1458          MOVE.L  D0,D4               ; Store the dest reg in D4 to get the Address register number
000020DC  0244 0E00               1459          ANDI.W  #dst_reg,D4         ; get the bits at 11-9
000020E0  1A3C 0009               1460          MOVE.B  #right9,D5          ; shift the bits 11-9 to the LSB
000020E4  EA6C                    1461          LSR.W   D5,D4               ; do the actual shift
000020E6  4EB9 00002CAC           1462          JSR     EA_GEN_SRC          ; Print out the address register
000020EC  4EF8 1E10               1463          JMP     EA_FINISH           ; Opcode is finish
000020F0                          1464  *------------------------------------------------------------------------------------------------*
000020F0                          1465  EA_DSTONLY                          ; 4: ea_dstonly
000020F0  2200                    1466          MOVE.L  D0,D1
000020F2  0241 0F00               1467          ANDI.W  #second_nibble,D1   ; get second nibble from D1
000020F6  1A3C 0008               1468          MOVE.B  #right8,D5 
000020FA  EA69                    1469          LSR.W   D5,D1     
000020FC  B23C 0002               1470          CMP.B   #2, D1              ; When 0010 for second nibble
00002100  6700 000E               1471          BEQ     EA_CLEAR            ; Then do EA_CLEAR
00002104  B23C 000E               1472          CMP.B   #$E, D1             ; When 1110 for second nibble
00002108  6700 0054               1473          BEQ     EA_JSR              ; Then do EA_JSR
0000210C  6000 0D04               1474          BRA     EA_ERROR     
00002110                          1475          
00002110                          1476  EA_CLEAR
00002110  2200                    1477          MOVE.L  D0,D1
00002112  0241 01C0               1478          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00002116  1A3C 0006               1479          MOVE.B  #right6,D5          ; Store 6 into D5
0000211A  EA69                    1480          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
0000211C  0201 0003               1481          ANDI.B  #3,D1               ; Remove the front bit from D1
00002120  1401                    1482          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002122  4EB8 1E56               1483          JSR     EA_SIZE_GENERAL     ; Get size 
00002126                          1484          
00002126  14FC 0020               1485          MOVE.B  #$20,(A2)+          ; Add space after size
0000212A  14FC 0020               1486          MOVE.B  #$20,(A2)+          ; Add space 
0000212E  14FC 0020               1487          MOVE.B  #$20,(A2)+          ; Add space 
00002132  14FC 0020               1488          MOVE.B  #$20,(A2)+          ; Add space
00002136                          1489          
00002136                          1490          ; Get desination and store into decode buffer
00002136  2800                    1491          MOVE.L  D0,D4               ; Store the current address into D4 
00002138  0244 0007               1492          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
0000213C                          1493          
0000213C  2600                    1494          MOVE.L  D0,D3               ; Store the current address into D3 
0000213E  0243 0038               1495          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002142  1A3C 0003               1496          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002146  EA6B                    1497          LSR.W   D5,D3               ; do the actual shift 
00002148  4EB9 00002DB8           1498          JSR     An_CHECK            ; Check if dest mode is 001: An
0000214E  4EB9 00002DCC           1499          JSR     IMMEDIATE_CHECK     ; Check if immediate
00002154  4EB9 00002CAC           1500          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
0000215A  4EF8 1E10               1501          JMP     EA_FINISH           ; Opcode is finish
0000215E                          1502          
0000215E  14FC 0020               1503  EA_JSR  MOVE.B  #$20,(A2)+          ; Add space 
00002162  14FC 0020               1504          MOVE.B  #$20,(A2)+          ; Add space 
00002166  14FC 0020               1505          MOVE.B  #$20,(A2)+          ; Add space 
0000216A  14FC 0020               1506          MOVE.B  #$20,(A2)+          ; Add space 
0000216E  14FC 0020               1507          MOVE.B  #$20,(A2)+          ; Add space 
00002172  14FC 0020               1508          MOVE.B  #$20,(A2)+          ; Add space
00002176                          1509  
00002176                          1510          ; Get EA and store into decode buffer   
00002176  2800                    1511          MOVE.L  D0,D4               ; Store the current address into D4 
00002178  0244 0007               1512          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
0000217C                          1513          
0000217C  2600                    1514          MOVE.L  D0,D3               ; Store the current address into D3 
0000217E  0243 0038               1515          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002182  1A3C 0003               1516          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002186  EA6B                    1517          LSR.W   D5,D3               ; do the actual shift 
00002188  B67C 0002               1518          CMP     #2,D3               ; If D3 (src mode) is 010: (An)
0000218C  6700 000E               1519          BEQ     JSR_An_VALID
00002190  B67C 0007               1520          CMP     #7,D3               ; If D3 (src mode) is 111: (W or L)
00002194  6700 0010               1521          BEQ     JSR_ABSOLUTE_CHECK
00002198  6000 0C78               1522          BRA     EA_ERROR            ; Otherwise, branch to invalid message
0000219C                          1523          
0000219C                          1524  JSR_An_VALID
0000219C  4EB9 00002CAC           1525          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
000021A2  4EF8 1E10               1526          JMP     EA_FINISH           ; Opcode is finish
000021A6                          1527          
000021A6                          1528  JSR_ABSOLUTE_CHECK
000021A6  4EB9 00002DCC           1529          JSR     IMMEDIATE_CHECK     ; Check if immediate
000021AC  4EB9 00002CAC           1530          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
000021B2  4EF8 1E10               1531          JMP     EA_FINISH           ; Opcode is finish
000021B6                          1532  *------------------------------------------------------------------------------------------------*
000021B6                          1533  EA_EXT                              ; 5: ea_ext
000021B6  2200                    1534          MOVE.L  D0,D1
000021B8  0241 01C0               1535          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1 (get opmode)
000021BC  1A3C 0006               1536          MOVE.B  #right6,D5          ; Store 6 into D5
000021C0  EA69                    1537          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
000021C2  1401                    1538          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
000021C4  C2FC 0006               1539          MULU    #6, D1              ; Multiply 6 to D1 
000021C8  41F9 000021D2           1540          LEA     EA_EXT_TABLE,A0     ; Load table into A0
000021CE  4EF0 1000               1541          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000021D2                          1542  
000021D2                          1543  EA_EXT_TABLE
000021D2  4EF9 00002202           1544          JMP     EA_OPMODE_012456    ; 000: ADD/SUB/CMP/OR/AND
000021D8  4EF9 00002202           1545          JMP     EA_OPMODE_012456    ; 001: ADD/SUB/CMP/OR/AND
000021DE  4EF9 00002202           1546          JMP     EA_OPMODE_012456    ; 010: ADD/SUB/CMP/OR/AND
000021E4  4EF9 000022F6           1547          JMP     EA_OPMODE_37        ; 011: ADDA/MULS/MULU/DIVU
000021EA  4EF9 00002202           1548          JMP     EA_OPMODE_012456    ; 100: ADD/SUB/CMP/OR/AND
000021F0  4EF9 00002202           1549          JMP     EA_OPMODE_012456    ; 101: ADD/SUB/CMP/OR/AND
000021F6  4EF9 00002202           1550          JMP     EA_OPMODE_012456    ; 110: ADD/SUB/CMP/OR/AND
000021FC  4EF9 000022F6           1551          JMP     EA_OPMODE_37        ; 111: ADDA/MULS/MULU/DIVU
00002202                          1552  
00002202                          1553  EA_OPMODE_012456
00002202  4EB8 1EB6               1554          JSR     EA_SIZE_OPMODE_012456    
00002206                          1555          
00002206  14FC 0020               1556          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000220A  14FC 0020               1557          MOVE.B  #$20,(A2)+          ; Print out a space 
0000220E  14FC 0020               1558          MOVE.B  #$20,(A2)+          ; Print out a space
00002212  14FC 0020               1559          MOVE.B  #$20,(A2)+          ; Add space
00002216                          1560          
00002216                          1561          ; Operation: <ea> + Dn -> Dn
00002216  B43C 0000               1562          CMP.B   #%000,D2            ; When 0 then Dn is destination
0000221A  6700 002E               1563          BEQ     Dn_DST
0000221E  B43C 0001               1564          CMP.B   #%001,D2            ; When 1 then Dn is destination
00002222  6700 0026               1565          BEQ     Dn_DST
00002226  B43C 0002               1566          CMP.B   #%010,D2            ; When 2 then Dn is destination
0000222A  6700 001E               1567          BEQ     Dn_DST
0000222E                          1568          
0000222E                          1569          ; Operation: Dn + <ea> -> <ea>
0000222E  B43C 0004               1570          CMP.B   #%100,D2            ; When 4 then Dn is source
00002232  6700 0054               1571          BEQ     Dn_SRC  
00002236  B43C 0005               1572          CMP.B   #%101,D2            ; When 5 then Dn is source
0000223A  6700 004C               1573          BEQ     Dn_SRC 
0000223E  B43C 0006               1574          CMP.B   #%110,D2            ; When 6 then Dn is source
00002242  6700 0044               1575          BEQ     Dn_SRC 
00002246                          1576          
00002246  6000 0BCA               1577          BRA     EA_ERROR
0000224A                          1578  
0000224A                          1579  Dn_DST
0000224A                          1580          ; Get source and store into decode buffer
0000224A  2800                    1581          MOVE.L  D0,D4               ; Store the src reg in D4
0000224C  0244 0007               1582          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002250                          1583          
00002250  2600                    1584          MOVE.L  D0,D3               ; Store the src mode in D3
00002252  0243 0038               1585          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002256  1A3C 0003               1586          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000225A  EA6B                    1587          LSR.W   D5,D3               ; Do the actual shift 
0000225C  4EB9 000022D4           1588          JSR     AND_OR_CHECK 
00002262  4EB9 00002CAC           1589          JSR     EA_GEN_SRC          ; Get EA print
00002268                          1590          
00002268  14FC 002C               1591          MOVE.B  #$2C,(A2)+          ; Add comma after size print
0000226C  14FC 0020               1592          MOVE.B  #$20,(A2)+          ; Add space after comma
00002270                          1593          
00002270                          1594          ; Get desination and store into decode buffer
00002270  2800                    1595          MOVE.L  D0,D4               ; Store the dest reg in D4
00002272  0244 0E00               1596          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002276  1A3C 0009               1597          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000227A  EA6C                    1598          LSR.W   D5,D4               ; Do the actual shift
0000227C                          1599          
0000227C  7600                    1600          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000227E  4EB9 00002CAC           1601          JSR     EA_GEN_SRC          ; Get the Dn print
00002284  4EF8 1E10               1602          JMP     EA_FINISH           ; Opcode is finish
00002288                          1603            
00002288                          1604  Dn_SRC  
00002288  BC3C 000B               1605          CMP.B   #11,D6              ; If first nibble is 1011 (indicates CMP opcode)
0000228C  6700 0B84               1606          BEQ     EA_ERROR            ; Then branch to error message
00002290                          1607       
00002290                          1608          ; Get source and store into decode buffer
00002290  2800                    1609          MOVE.L  D0,D4               ; Store the src reg in D4
00002292  0244 0E00               1610          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002296  1A3C 0009               1611          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000229A  EA6C                    1612          LSR.W   D5,D4               ; Do the actual shift
0000229C                          1613          
0000229C  7600                    1614          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000229E  4EB9 00002CAC           1615          JSR     EA_GEN_SRC          ; Get the Dn print
000022A4                          1616          
000022A4  14FC 002C               1617          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000022A8  14FC 0020               1618          MOVE.B  #$20,(A2)+          ; Add space after comma
000022AC                          1619  
000022AC                          1620          ; Get destination and store into decode buffer
000022AC  2800                    1621          MOVE.L  D0,D4               ; Store the dst reg in D4
000022AE  0244 0007               1622          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000022B2                          1623          
000022B2  2600                    1624          MOVE.L  D0,D3               ; Store the dest mode in D3
000022B4  0243 0038               1625          ANDI.W  #src_mode,D3        ; Get bits 5-3
000022B8  1A3C 0003               1626          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000022BC  EA6B                    1627          LSR.W   D5,D3               ; Do the actual shift
000022BE  4EB9 00002DB8           1628          JSR     An_CHECK            ; Check if mode is An
000022C4  4EB9 00002DCC           1629          JSR     IMMEDIATE_CHECK     ; Check if mode is immediate
000022CA                          1630          ; JSR     Dn_CHECK          ; Check if mode is Dn
000022CA                          1631         
000022CA  4EB9 00002CAC           1632          JSR     EA_GEN_SRC          ; Get EA print
000022D0  4EF8 1E10               1633          JMP     EA_FINISH           ; Opcode is finish
000022D4                          1634  
000022D4                          1635  AND_OR_CHECK
000022D4  BC3C 000C               1636          CMP.B   #12,D6              ; If first nibble is 1100 (indicates AND opcode)
000022D8  6700 000C               1637          BEQ     EA_AND              
000022DC  BC3C 0008               1638          CMP.B   #8,D6               ; If first nibble is 1000 (indicates OR opcode)
000022E0  6700 000A               1639          BEQ     EA_OR 
000022E4  4E75                    1640          RTS
000022E6                          1641  EA_AND
000022E6  4EF9 00002DB8           1642          JMP     An_CHECK            ; Go check if mode is An 
000022EC                          1643      
000022EC                          1644  EA_OR
000022EC  14FC 0020               1645          MOVE.B  #$20,(A2)+          ; Add space
000022F0  4EF9 00002DB8           1646          JMP     An_CHECK            ; Check if mode is An
000022F6                          1647          
000022F6                          1648  EA_OPMODE_37
000022F6  BC3C 0008               1649          CMP.B   #8,D6               ; If first nibble 1000: DIVU
000022FA  6700 0012               1650          BEQ     EA_MULS_MULU_DIV
000022FE  BC3C 000C               1651          CMP.B   #12,D6              ; If first nibble 1100: MULS/MULU
00002302  6700 000A               1652          BEQ     EA_MULS_MULU_DIV
00002306  BC3C 000D               1653          CMP.B   #13,D6              ; If first nibble 1101: ADDA
0000230A  6700 0058               1654          BEQ     EA_ADDA                
0000230E                          1655  
0000230E                          1656  EA_MULS_MULU_DIV
0000230E  143C 0001               1657          MOVE.B  #1,D2               ; Set D2 to 1, since we know size is word   
00002312                          1658  
00002312  14FC 0020               1659          MOVE.B  #$20,(A2)+          ; Print out a space
00002316  14FC 0020               1660          MOVE.B  #$20,(A2)+          ; Print out a space
0000231A  14FC 0020               1661          MOVE.B  #$20,(A2)+          ; Print out a space
0000231E  14FC 0020               1662          MOVE.B  #$20,(A2)+          ; Add space
00002322  14FC 0020               1663          MOVE.B  #$20,(A2)+          ; Add space
00002326                          1664  
00002326                          1665          ; Get source and store into decode buffer
00002326  2800                    1666          MOVE.L  D0,D4               ; Store the src reg in D4
00002328  0244 0007               1667          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000232C                          1668          
0000232C  2600                    1669          MOVE.L  D0,D3               ; Store the src mode in D3
0000232E  0243 0038               1670          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002332  1A3C 0003               1671          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002336  EA6B                    1672          LSR.W   D5,D3               ; Do the actual shift
00002338  4EB9 00002DB8           1673          JSR     An_CHECK            ; Check if mode is An 
0000233E  4EB9 00002CAC           1674          JSR     EA_GEN_SRC          ; Go get EA print
00002344                          1675          
00002344  14FC 002C               1676          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002348  14FC 0020               1677          MOVE.B  #$20,(A2)+          ; Add space after comma
0000234C                          1678          
0000234C                          1679          ; Get desination and store into decode buffer
0000234C  2800                    1680          MOVE.L  D0,D4               ; Store the dest reg in D4
0000234E  0244 0E00               1681          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002352  1A3C 0009               1682          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002356  EA6C                    1683          LSR.W   D5,D4               ; Do the actual shift
00002358                          1684          
00002358  7600                    1685          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000235A  4EB9 00002CAC           1686          JSR     EA_GEN_SRC          ; Go get EA print
00002360  4EF8 1E10               1687          JMP     EA_FINISH           ; Opcode is finish
00002364                          1688  
00002364                          1689  EA_ADDA
00002364  4EB8 1EEA               1690          JSR     EA_SIZE_ADDA        ; Get size    
00002368                          1691  
00002368  14FC 0020               1692          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000236C  14FC 0020               1693          MOVE.B  #$20,(A2)+          ; Print out a space
00002370  14FC 0020               1694          MOVE.B  #$20,(A2)+          ; Add space        
00002374                          1695          
00002374                          1696          
00002374                          1697          ; Get source and store into decode buffer
00002374  2800                    1698          MOVE.L  D0,D4               ; Store the src reg in D4
00002376  0244 0007               1699          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000237A                          1700          
0000237A  2600                    1701          MOVE.L  D0,D3               ; Store the src mode in D3
0000237C  0243 0038               1702          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002380  1A3C 0003               1703          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002384  EA6B                    1704          LSR.W   D5,D3               ; Do the actual shift 
00002386  4EB9 00002CAC           1705          JSR     EA_GEN_SRC
0000238C                          1706          
0000238C  14FC 002C               1707          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002390  14FC 0020               1708          MOVE.B  #$20,(A2)+          ; Add space after comma
00002394                          1709          
00002394                          1710          ; Get desination and store into decode buffer
00002394  2800                    1711          MOVE.L  D0,D4               ; Store the dest reg in D4
00002396  0244 0E00               1712          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000239A  1A3C 0009               1713          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000239E  EA6C                    1714          LSR.W   D5,D4               ; Do the actual shift
000023A0                          1715          
000023A0  7601                    1716          MOVE.L  #1,D3               ; Store 001 into D3, so it can jump to An 
000023A2  4EB9 00002CAC           1717          JSR     EA_GEN_SRC          ; Go get EA print
000023A8  4EF8 1E10               1718          JMP     EA_FINISH           ; Opcode is finish
000023AC                          1719  *------------------------------------------------------------------------------------------------*
000023AC                          1720  EA_MOVEM        ; 6: ea_movem
000023AC  2200                    1721          MOVE.L  D0, D1
000023AE  0241 00F0               1722          ANDI.W  #third_nibble,D1
000023B2  1A3C 0004               1723          MOVE.B  #right4,D5 
000023B6  EA69                    1724          LSR.W   D5,D1
000023B8  0201 0004               1725          ANDI.B  #4,D1
000023BC  1401                    1726          MOVE.B  D1,D2
000023BE  4EB8 1EA2               1727          JSR     EA_SIZE_MOVEM       ; get the size of the MOVEM as .W or .L 
000023C2                          1728  
000023C2  14FC 0020               1729          MOVE.B  #$20,(A2)+          ; Print out a space after the size
000023C6  14FC 0020               1730          MOVE.B  #$20,(A2)+          ; Print out a space
000023CA                          1731          
000023CA                          1732  *-----------------------------------------------------------------------------------*
000023CA                          1733  * HANDLE the case where src mode is 010. 
000023CA  2600                    1734          MOVE.L  D0,D3               ; Store the src mode in D3
000023CC  0243 0038               1735          ANDI.W  #src_mode,D3        ; Get bits 5-3
000023D0  1A3C 0003               1736          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000023D4  EA6B                    1737          LSR.W   D5,D3 
000023D6                          1738  
000023D6  B63C 0002               1739          CMP.B   #2, D3
000023DA  6700 0312               1740          BEQ     MEM_TO_REG        
000023DE                          1741  
000023DE                          1742  *-----------------------------------------------------------------------------------*
000023DE                          1743  
000023DE  2200                    1744          MOVE.L  D0, D1
000023E0  0241 0F00               1745          ANDI.W  #second_nibble,D1
000023E4  1A3C 0008               1746          MOVE.B  #right8,D5 
000023E8  EA69                    1747          LSR.W   D5,D1
000023EA  0201 0006               1748          ANDI.B  #6, D1              ; Get the Dr field
000023EE                          1749          
000023EE  B23C 0000               1750          CMP.B   #0, D1              ; check if Dr field is 0. 
000023F2  6700 000A               1751          BEQ     REG_TO_MEM
000023F6                          1752  
000023F6  B23C 0004               1753          CMP.B   #4, D1              ; check if Dr field is 1. 
000023FA  6700 02F2               1754          BEQ     MEM_TO_REG
000023FE                          1755  
000023FE                          1756  REG_TO_MEM                          ; pre-decrement - D7-D0,A7-A0
000023FE  3C15                    1757          MOVE.W  (A5), D6            ; store the register list mask field for REG to MEM
00002400                          1758          
00002400                          1759  * Print out the proper data and address registers. 
00002400                          1760  * FIRST NIBBLE CHECK D0 - D3
00002400                          1761  *-----------------------------------------------------------------------------------*
00002400                          1762  * Print out D0 if mask field states to. 
00002400                          1763  
00002400  3606                    1764          MOVE.W  D6, D3
00002402  0243 F000               1765          ANDI.W  #first_nibble,D3
00002406  1A3C 000C               1766          MOVE.B  #right12,D5 
0000240A  EA6B                    1767          LSR.W   D5,D3
0000240C  0203 0008               1768          ANDI.B  #8,D3
00002410  B63C 0008               1769          CMP.B   #8,D3
00002414  6700 0006               1770          BEQ     D4_Dn_SETONE_0      ; SETONE refers to the set for reg to mem branch. 
00002418  6000 0014               1771          BRA     CHECK1_BIT_14
0000241C                          1772  D4_Dn_SETONE_0
0000241C  183C 0000               1773          MOVE.B  #$0, D4
00002420                          1774          
00002420  6000 0002               1775          BRA     PRINT1_D0
00002424                          1776          
00002424                          1777  PRINT1_D0
00002424  4EB9 00002CEA           1778          JSR     EA_Dn
0000242A  14FC 002F               1779          MOVE.B  #$2F,(A2)+
0000242E                          1780          
0000242E                          1781  *-----------------------------------------------------------------------------------*
0000242E                          1782  * Print out D1 if mask field states to. 
0000242E                          1783  
0000242E                          1784  CHECK1_BIT_14
0000242E  3606                    1785          MOVE.W  D6, D3
00002430  0243 F000               1786          ANDI.W  #first_nibble,D3
00002434  1A3C 000C               1787          MOVE.B  #right12,D5 
00002438  EA6B                    1788          LSR.W   D5,D3
0000243A  0203 0004               1789          ANDI.B  #4,D3
0000243E  B63C 0004               1790          CMP.B   #4,D3
00002442  6700 0006               1791          BEQ     D4_Dn_SETONE_1      ; SETONE refers to the set for reg to mem branch. 
00002446  6000 0014               1792          BRA     CHECK1_BIT_13
0000244A                          1793  D4_Dn_SETONE_1
0000244A  183C 0001               1794          MOVE.B  #$1, D4
0000244E                          1795          
0000244E  6000 0002               1796          BRA     PRINT1_D1
00002452                          1797          
00002452                          1798  PRINT1_D1
00002452  4EB9 00002CEA           1799          JSR     EA_Dn
00002458  14FC 002F               1800          MOVE.B  #$2F,(A2)+
0000245C                          1801  
0000245C                          1802  *-----------------------------------------------------------------------------------*
0000245C                          1803  * Print out D2 if mask field states to. 
0000245C                          1804  
0000245C                          1805  CHECK1_BIT_13
0000245C  3606                    1806          MOVE.W  D6, D3
0000245E  0243 F000               1807          ANDI.W  #first_nibble,D3
00002462  1A3C 000C               1808          MOVE.B  #right12,D5 
00002466  EA6B                    1809          LSR.W   D5,D3
00002468  0203 0002               1810          ANDI.B  #2,D3
0000246C  B63C 0002               1811          CMP.B   #2,D3
00002470  6700 0006               1812          BEQ     D4_Dn_SETONE_2      ; SETONE refers to the set for reg to mem branch. 
00002474  6000 0014               1813          BRA     CHECK1_BIT_12
00002478                          1814  D4_Dn_SETONE_2
00002478  183C 0002               1815          MOVE.B  #$2, D4
0000247C                          1816          
0000247C  6000 0002               1817          BRA     PRINT1_D2
00002480                          1818          
00002480                          1819  PRINT1_D2
00002480  4EB9 00002CEA           1820          JSR     EA_Dn
00002486  14FC 002F               1821          MOVE.B  #$2F,(A2)+       
0000248A                          1822  
0000248A                          1823  *-----------------------------------------------------------------------------------*
0000248A                          1824  * Print out D3 if mask field states to. 
0000248A                          1825  
0000248A                          1826  CHECK1_BIT_12
0000248A  3606                    1827          MOVE.W  D6, D3
0000248C  0243 F000               1828          ANDI.W  #first_nibble,D3
00002490  1A3C 000C               1829          MOVE.B  #right12,D5 
00002494  EA6B                    1830          LSR.W   D5,D3
00002496  0203 0001               1831          ANDI.B  #1,D3
0000249A  B63C 0001               1832          CMP.B   #1,D3
0000249E  6700 0006               1833          BEQ     D4_Dn_SETONE_3      ; SETONE refers to the set for reg to mem branch. 
000024A2  6000 0014               1834          BRA     CHECK1_BIT_11
000024A6                          1835  D4_Dn_SETONE_3
000024A6  183C 0003               1836          MOVE.B  #$3, D4
000024AA                          1837          
000024AA  6000 0002               1838          BRA     PRINT1_D3
000024AE                          1839          
000024AE                          1840  PRINT1_D3
000024AE  4EB9 00002CEA           1841          JSR     EA_Dn
000024B4  14FC 002F               1842          MOVE.B  #$2F,(A2)+ 
000024B8                          1843          
000024B8                          1844  * SECOND NIBBLE CHECK D4 - D7
000024B8                          1845  *-----------------------------------------------------------------------------------*
000024B8                          1846  * Print out D4 if mask field states to. 
000024B8                          1847  
000024B8                          1848  
000024B8                          1849  CHECK1_BIT_11
000024B8  3606                    1850          MOVE.W  D6, D3
000024BA  0243 0F00               1851          ANDI.W  #second_nibble,D3
000024BE  1A3C 0008               1852          MOVE.B  #right8,D5 
000024C2  EA6B                    1853          LSR.W   D5,D3
000024C4  0203 0008               1854          ANDI.B  #8,D3
000024C8  B63C 0008               1855          CMP.B   #8,D3
000024CC  6700 0006               1856          BEQ     D4_Dn_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
000024D0  6000 0014               1857          BRA     CHECK1_BIT_10
000024D4                          1858  D4_Dn_SETONE_4
000024D4  183C 0004               1859          MOVE.B  #$4, D4
000024D8                          1860          
000024D8  6000 0002               1861          BRA     PRINT1_D4
000024DC                          1862          
000024DC                          1863  PRINT1_D4
000024DC  4EB9 00002CEA           1864          JSR     EA_Dn
000024E2  14FC 002F               1865          MOVE.B  #$2F,(A2)+ 
000024E6                          1866  
000024E6                          1867  *-----------------------------------------------------------------------------------*
000024E6                          1868  * Print out D5 if mask field states to. 
000024E6                          1869  
000024E6                          1870  CHECK1_BIT_10
000024E6  3606                    1871          MOVE.W  D6, D3
000024E8  0243 0F00               1872          ANDI.W  #second_nibble,D3
000024EC  1A3C 0008               1873          MOVE.B  #right8,D5 
000024F0  EA6B                    1874          LSR.W   D5,D3
000024F2  0203 0004               1875          ANDI.B  #4,D3
000024F6  B63C 0004               1876          CMP.B   #4,D3
000024FA  6700 0006               1877          BEQ     D4_Dn_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
000024FE  6000 0014               1878          BRA     CHECK1_BIT_9
00002502                          1879  D4_Dn_SETONE_5
00002502  183C 0005               1880          MOVE.B  #$5, D4
00002506                          1881          
00002506  6000 0002               1882          BRA     PRINT1_D5
0000250A                          1883          
0000250A                          1884  PRINT1_D5
0000250A  4EB9 00002CEA           1885          JSR     EA_Dn
00002510  14FC 002F               1886          MOVE.B  #$2F,(A2)+ 
00002514                          1887  
00002514                          1888  *-----------------------------------------------------------------------------------*
00002514                          1889  * Print out D6 if mask field states to. 
00002514                          1890  
00002514                          1891  CHECK1_BIT_9
00002514  3606                    1892          MOVE.W  D6, D3
00002516  0243 0F00               1893          ANDI.W  #second_nibble,D3
0000251A  1A3C 0008               1894          MOVE.B  #right8,D5 
0000251E  EA6B                    1895          LSR.W   D5,D3
00002520  0203 0002               1896          ANDI.B  #2,D3
00002524  B63C 0002               1897          CMP.B   #2,D3
00002528  6700 0006               1898          BEQ     D4_Dn_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
0000252C  6000 0014               1899          BRA     CHECK1_BIT_8
00002530                          1900  D4_Dn_SETONE_6
00002530  183C 0006               1901          MOVE.B  #$6, D4
00002534                          1902          
00002534  6000 0002               1903          BRA     PRINT1_D6
00002538                          1904          
00002538                          1905  PRINT1_D6
00002538  4EB9 00002CEA           1906          JSR     EA_Dn
0000253E  14FC 002F               1907          MOVE.B  #$2F,(A2)+ 
00002542                          1908          
00002542                          1909  *-----------------------------------------------------------------------------------*
00002542                          1910  * Print out D7 if mask field states to. 
00002542                          1911  
00002542                          1912  CHECK1_BIT_8
00002542  3606                    1913          MOVE.W  D6, D3
00002544  0243 0F00               1914          ANDI.W  #second_nibble,D3
00002548  1A3C 0008               1915          MOVE.B  #right8,D5 
0000254C  EA6B                    1916          LSR.W   D5,D3
0000254E  0203 0001               1917          ANDI.B  #1,D3
00002552  B63C 0001               1918          CMP.B   #1,D3
00002556  6700 0006               1919          BEQ     D4_Dn_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
0000255A  6000 0014               1920          BRA     CHECK1_BIT_7
0000255E                          1921  D4_Dn_SETONE_7
0000255E  183C 0007               1922          MOVE.B  #$7, D4
00002562                          1923          
00002562  6000 0002               1924          BRA     PRINT1_D7
00002566                          1925          
00002566                          1926  PRINT1_D7
00002566  4EB9 00002CEA           1927          JSR     EA_Dn
0000256C  14FC 002F               1928          MOVE.B  #$2F,(A2)+ 
00002570                          1929  
00002570                          1930  * THIRD NIBBLE CHECK - A0 / A3
00002570                          1931  *-----------------------------------------------------------------------------------*
00002570                          1932  * Print out A0 if mask field states to. 
00002570                          1933  
00002570                          1934  CHECK1_BIT_7
00002570  3606                    1935          MOVE.W  D6, D3
00002572  0243 00F0               1936          ANDI.W  #third_nibble,D3
00002576  1A3C 0004               1937          MOVE.B  #right4,D5 
0000257A  EA6B                    1938          LSR.W   D5,D3
0000257C  0203 0008               1939          ANDI.B  #8,D3
00002580  B63C 0008               1940          CMP.B   #8,D3
00002584  6700 0006               1941          BEQ     D4_An_SETONE_0       ; SETONE refers to the set for reg to mem branch. 
00002588  6000 0014               1942          BRA     CHECK1_BIT_6
0000258C                          1943  D4_An_SETONE_0
0000258C  183C 0000               1944          MOVE.B  #$0, D4
00002590                          1945          
00002590  6000 0002               1946          BRA     PRINT1_A0
00002594                          1947          
00002594                          1948  PRINT1_A0
00002594  4EB9 00002CF6           1949          JSR     EA_An
0000259A  14FC 002F               1950          MOVE.B  #$2F,(A2)+ 
0000259E                          1951          
0000259E                          1952  *-----------------------------------------------------------------------------------*
0000259E                          1953  * Print out A1 if mask field states to. 
0000259E                          1954  
0000259E                          1955  CHECK1_BIT_6
0000259E  3606                    1956          MOVE.W  D6, D3
000025A0  0243 00F0               1957          ANDI.W  #third_nibble,D3
000025A4  1A3C 0004               1958          MOVE.B  #right4,D5 
000025A8  EA6B                    1959          LSR.W   D5,D3
000025AA  0203 0004               1960          ANDI.B  #4,D3
000025AE  B63C 0004               1961          CMP.B   #4,D3
000025B2  6700 0006               1962          BEQ     D4_An_SETONE_1       ; SETONE refers to the set for reg to mem branch. 
000025B6  6000 0014               1963          BRA     CHECK1_BIT_5
000025BA                          1964  D4_An_SETONE_1
000025BA  183C 0001               1965          MOVE.B  #$1, D4
000025BE                          1966          
000025BE  6000 0002               1967          BRA     PRINT1_A1
000025C2                          1968          
000025C2                          1969  PRINT1_A1
000025C2  4EB9 00002CF6           1970          JSR     EA_An
000025C8  14FC 002F               1971          MOVE.B  #$2F,(A2)+ 
000025CC                          1972  
000025CC                          1973  *-----------------------------------------------------------------------------------*
000025CC                          1974  * Print out A2 if mask field states to. 
000025CC                          1975  
000025CC                          1976  CHECK1_BIT_5
000025CC  3606                    1977          MOVE.W  D6, D3
000025CE  0243 00F0               1978          ANDI.W  #third_nibble,D3
000025D2  1A3C 0004               1979          MOVE.B  #right4,D5 
000025D6  EA6B                    1980          LSR.W   D5,D3
000025D8  0203 0002               1981          ANDI.B  #2,D3
000025DC  B63C 0002               1982          CMP.B   #2,D3
000025E0  6700 0006               1983          BEQ     D4_An_SETONE_2       ; SETONE refers to the set for reg to mem branch. 
000025E4  6000 0014               1984          BRA     CHECK1_BIT_4
000025E8                          1985  D4_An_SETONE_2
000025E8  183C 0002               1986          MOVE.B  #$2, D4
000025EC                          1987          
000025EC  6000 0002               1988          BRA     PRINT1_A2
000025F0                          1989          
000025F0                          1990  PRINT1_A2
000025F0  4EB9 00002CF6           1991          JSR     EA_An
000025F6  14FC 002F               1992          MOVE.B  #$2F,(A2)+ 
000025FA                          1993  
000025FA                          1994  *-----------------------------------------------------------------------------------*
000025FA                          1995  * Print out A3 if mask field states to. 
000025FA                          1996  
000025FA                          1997  CHECK1_BIT_4
000025FA  3606                    1998          MOVE.W  D6, D3
000025FC  0243 00F0               1999          ANDI.W  #third_nibble,D3
00002600  1A3C 0004               2000          MOVE.B  #right4,D5 
00002604  EA6B                    2001          LSR.W   D5,D3
00002606  0203 0001               2002          ANDI.B  #1,D3
0000260A  B63C 0001               2003          CMP.B   #1,D3
0000260E  6700 0006               2004          BEQ     D4_An_SETONE_3       ; SETONE refers to the set for reg to mem branch. 
00002612  6000 0014               2005          BRA     CHECK1_BIT_3
00002616                          2006  D4_An_SETONE_3
00002616  183C 0003               2007          MOVE.B  #$3, D4
0000261A                          2008          
0000261A  6000 0002               2009          BRA     PRINT1_A3
0000261E                          2010          
0000261E                          2011  PRINT1_A3
0000261E  4EB9 00002CF6           2012          JSR     EA_An
00002624  14FC 002F               2013          MOVE.B  #$2F,(A2)+ 
00002628                          2014  
00002628                          2015  * FOURTH NIBBLE CHECK A4 - A7 
00002628                          2016  *-----------------------------------------------------------------------------------*
00002628                          2017  * Print out A4 if mask field states to. 
00002628                          2018  
00002628                          2019  CHECK1_BIT_3
00002628  3606                    2020          MOVE.W  D6, D3
0000262A  0243 000F               2021          ANDI.W  #fourth_nibble,D3
0000262E  0203 0008               2022          ANDI.B  #8,D3
00002632  B63C 0008               2023          CMP.B   #8,D3
00002636  6700 0006               2024          BEQ     D4_An_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
0000263A  6000 0014               2025          BRA     CHECK1_BIT_2
0000263E                          2026  D4_An_SETONE_4
0000263E  183C 0004               2027          MOVE.B  #$4, D4
00002642                          2028          
00002642  6000 0002               2029          BRA     PRINT1_A4
00002646                          2030          
00002646                          2031  PRINT1_A4
00002646  4EB9 00002CF6           2032          JSR     EA_An
0000264C  14FC 002F               2033          MOVE.B  #$2F,(A2)+ 
00002650                          2034  
00002650                          2035  *-----------------------------------------------------------------------------------*
00002650                          2036  * Print out A5 if mask field states to. 
00002650                          2037  
00002650                          2038  CHECK1_BIT_2
00002650  3606                    2039          MOVE.W  D6, D3
00002652  0243 000F               2040          ANDI.W  #fourth_nibble,D3
00002656  0203 0004               2041          ANDI.B  #4,D3
0000265A  B63C 0004               2042          CMP.B   #4,D3
0000265E  6700 0006               2043          BEQ     D4_An_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
00002662  6000 0014               2044          BRA     CHECK1_BIT_1
00002666                          2045  D4_An_SETONE_5
00002666  183C 0005               2046          MOVE.B  #$5, D4
0000266A                          2047          
0000266A  6000 0002               2048          BRA     PRINT1_A5
0000266E                          2049          
0000266E                          2050  PRINT1_A5
0000266E  4EB9 00002CF6           2051          JSR     EA_An
00002674  14FC 002F               2052          MOVE.B  #$2F,(A2)+ 
00002678                          2053  
00002678                          2054  *-----------------------------------------------------------------------------------*
00002678                          2055  * Print out A6 if mask field states to. 
00002678                          2056  
00002678                          2057  CHECK1_BIT_1
00002678  3606                    2058          MOVE.W  D6, D3
0000267A  0243 000F               2059          ANDI.W  #fourth_nibble,D3
0000267E  0203 0002               2060          ANDI.B  #2,D3
00002682  B63C 0002               2061          CMP.B   #2,D3
00002686  6700 0006               2062          BEQ     D4_An_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
0000268A  6000 0014               2063          BRA     CHECK1_BIT_0
0000268E                          2064  D4_An_SETONE_6
0000268E  183C 0006               2065          MOVE.B  #$6, D4
00002692                          2066          
00002692  6000 0002               2067          BRA     PRINT1_A6
00002696                          2068          
00002696                          2069  PRINT1_A6
00002696  4EB9 00002CF6           2070          JSR     EA_An
0000269C  14FC 002F               2071          MOVE.B  #$2F,(A2)+ 
000026A0                          2072  
000026A0                          2073  *-----------------------------------------------------------------------------------*
000026A0                          2074  * Print out A7 if mask field states to. 
000026A0                          2075  
000026A0                          2076  CHECK1_BIT_0
000026A0  3606                    2077          MOVE.W  D6, D3
000026A2  0243 000F               2078          ANDI.W  #fourth_nibble,D3
000026A6  0203 0001               2079          ANDI.B  #1,D3
000026AA  B63C 0001               2080          CMP.B   #1,D3
000026AE  6700 0006               2081          BEQ     D4_An_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
000026B2  6000 0014               2082          BRA     FINISH_REG_TO_MEM
000026B6                          2083  D4_An_SETONE_7
000026B6  183C 0007               2084          MOVE.B  #$7, D4
000026BA                          2085          
000026BA  6000 0002               2086          BRA     PRINT1_A7
000026BE                          2087          
000026BE                          2088  PRINT1_A7
000026BE  4EB9 00002CF6           2089          JSR     EA_An
000026C4  14FC 002F               2090          MOVE.B  #$2F,(A2)+ 
000026C8                          2091  
000026C8                          2092  FINISH_REG_TO_MEM
000026C8  14FC 002C               2093          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000026CC  14FC 0020               2094          MOVE.B  #$20,(A2)+          ; Add space after comma
000026D0                          2095  
000026D0  2800                    2096          MOVE.L  D0,D4               ; Store the src reg in D4
000026D2  0244 0007               2097          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000026D6                          2098          
000026D6  2600                    2099          MOVE.L  D0,D3               ; Store the src mode in D3
000026D8  0243 0038               2100          ANDI.W  #src_mode,D3        ; Get bits 5-3
000026DC  1A3C 0003               2101          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000026E0  EA6B                    2102          LSR.W   D5,D3               ; Do the actual shift 
000026E2  4EB9 00002CAC           2103          JSR     EA_GEN_SRC
000026E8                          2104          
000026E8  301D                    2105          MOVE.W  (A5)+, D0 
000026EA                          2106  
000026EA  4EF8 1E10               2107          JMP     EA_FINISH
000026EE                          2108  
000026EE                          2109  MEM_TO_REG                          ; post-increment + A7-A0,D7-D0
000026EE                          2110  
000026EE  B63C 0002               2111          CMP.B   #2, D3              ; check if the destination is (An)
000026F2  6700 0022               2112          BEQ     MEM_TO_REG_CONTINUE ; branch to print out the address and data registers. 
000026F6                          2113          
000026F6  2800                    2114          MOVE.L  D0,D4               ; Store the src reg in D4
000026F8  0244 0007               2115          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000026FC                          2116          
000026FC  2600                    2117          MOVE.L  D0,D3               ; Store the src mode in D3
000026FE  0243 0038               2118          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002702  1A3C 0003               2119          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002706  EA6B                    2120          LSR.W   D5,D3               ; Do the actual shift 
00002708  4EB9 00002CAC           2121          JSR     EA_GEN_SRC
0000270E                          2122          
0000270E  14FC 002C               2123          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002712  14FC 0020               2124          MOVE.B  #$20,(A2)+          ; Add space after comma
00002716                          2125  
00002716                          2126          
00002716                          2127  * Print out the proper data and address registers. 
00002716                          2128  * FIRST NIBBLE CHECK A7 - A4
00002716                          2129  *-----------------------------------------------------------------------------------*
00002716                          2130  * Print out A7 if mask field states to. 
00002716                          2131  MEM_TO_REG_CONTINUE
00002716  3C15                    2132          MOVE.W  (A5), D6            ; store the register list mask field for MEM to REG
00002718                          2133          
00002718  3606                    2134          MOVE.W  D6, D3
0000271A  0243 F000               2135          ANDI.W  #first_nibble,D3
0000271E  1A3C 000C               2136          MOVE.B  #right12,D5 
00002722  EA6B                    2137          LSR.W   D5,D3
00002724  0203 0008               2138          ANDI.B  #8,D3
00002728  B63C 0008               2139          CMP.B   #8,D3
0000272C  6700 0006               2140          BEQ     D4_An_SET_7
00002730  6000 0014               2141          BRA     CHECK_BIT_14
00002734                          2142  D4_An_SET_7
00002734  183C 0007               2143          MOVE.B  #$7, D4
00002738                          2144          
00002738  6000 0002               2145          BRA     PRINT_A7
0000273C                          2146          
0000273C                          2147  PRINT_A7
0000273C  4EB9 00002CF6           2148          JSR     EA_An
00002742  14FC 002F               2149          MOVE.B  #$2F,(A2)+
00002746                          2150          
00002746                          2151  *-----------------------------------------------------------------------------------*
00002746                          2152  * Print out A6 if mask field states to. 
00002746                          2153  
00002746                          2154  CHECK_BIT_14
00002746  3606                    2155          MOVE.W  D6, D3
00002748  0243 F000               2156          ANDI.W  #first_nibble,D3
0000274C  1A3C 000C               2157          MOVE.B  #right12,D5 
00002750  EA6B                    2158          LSR.W   D5,D3
00002752  0203 0004               2159          ANDI.B  #4,D3
00002756  B63C 0004               2160          CMP.B   #4,D3
0000275A  6700 0006               2161          BEQ     D4_An_SET_6
0000275E  6000 0014               2162          BRA     CHECK_BIT_13
00002762                          2163  D4_An_SET_6
00002762  183C 0006               2164          MOVE.B  #$6, D4
00002766                          2165          
00002766  6000 0002               2166          BRA     PRINT_A6
0000276A                          2167          
0000276A                          2168  PRINT_A6
0000276A  4EB9 00002CF6           2169          JSR     EA_An
00002770  14FC 002F               2170          MOVE.B  #$2F,(A2)+
00002774                          2171  
00002774                          2172  *-----------------------------------------------------------------------------------*
00002774                          2173  * Print out A5 if mask field states to. 
00002774                          2174  
00002774                          2175  CHECK_BIT_13
00002774  3606                    2176          MOVE.W  D6, D3
00002776  0243 F000               2177          ANDI.W  #first_nibble,D3
0000277A  1A3C 000C               2178          MOVE.B  #right12,D5 
0000277E  EA6B                    2179          LSR.W   D5,D3
00002780  0203 0002               2180          ANDI.B  #2,D3
00002784  B63C 0002               2181          CMP.B   #2,D3
00002788  6700 0006               2182          BEQ     D4_An_SET_5
0000278C  6000 0014               2183          BRA     CHECK_BIT_12
00002790                          2184  D4_An_SET_5
00002790  183C 0005               2185          MOVE.B  #$5, D4
00002794                          2186          
00002794  6000 0002               2187          BRA     PRINT_A5
00002798                          2188          
00002798                          2189  PRINT_A5
00002798  4EB9 00002CF6           2190          JSR     EA_An
0000279E  14FC 002F               2191          MOVE.B  #$2F,(A2)+
000027A2                          2192  
000027A2                          2193  *-----------------------------------------------------------------------------------*
000027A2                          2194  * Print out A4 if mask field states to. 
000027A2                          2195          
000027A2                          2196  CHECK_BIT_12
000027A2  3606                    2197          MOVE.W  D6, D3
000027A4  0243 F000               2198          ANDI.W  #first_nibble,D3
000027A8  1A3C 000C               2199          MOVE.B  #right12,D5 
000027AC  EA6B                    2200          LSR.W   D5,D3
000027AE  0203 0001               2201          ANDI.B  #1,D3
000027B2  B63C 0001               2202          CMP.B   #1,D3
000027B6  6700 0006               2203          BEQ     D4_An_SET_4
000027BA  6000 0014               2204          BRA     CHECK_BIT_11
000027BE                          2205  D4_An_SET_4
000027BE  183C 0004               2206          MOVE.B  #$4, D4
000027C2                          2207          
000027C2  6000 0002               2208          BRA     PRINT_A4
000027C6                          2209          
000027C6                          2210  PRINT_A4
000027C6  4EB9 00002CF6           2211          JSR     EA_An
000027CC  14FC 002F               2212          MOVE.B  #$2F,(A2)+
000027D0                          2213  
000027D0                          2214  *-----------------------------------------------------------------------------------*
000027D0                          2215  * Print out A3 if mask field states to. 
000027D0                          2216  * SECOND NIBBLE CHECK A7 - A4
000027D0                          2217    
000027D0                          2218  CHECK_BIT_11
000027D0  3606                    2219          MOVE.W  D6, D3
000027D2  0243 0F00               2220          ANDI.W  #second_nibble,D3
000027D6  1A3C 0008               2221          MOVE.B  #right8,D5 
000027DA  EA6B                    2222          LSR.W   D5,D3
000027DC  0203 0008               2223          ANDI.B  #8,D3
000027E0  B63C 0008               2224          CMP.B   #8,D3
000027E4  6700 0006               2225          BEQ     D4_An_SET_3
000027E8  6000 0014               2226          BRA     CHECK_BIT_10
000027EC                          2227  D4_An_SET_3
000027EC  183C 0003               2228          MOVE.B  #$3, D4
000027F0                          2229          
000027F0  6000 0002               2230          BRA     PRINT_A3
000027F4                          2231          
000027F4                          2232  PRINT_A3
000027F4  4EB9 00002CF6           2233          JSR     EA_An
000027FA  14FC 002F               2234          MOVE.B  #$2F,(A2)+     
000027FE                          2235  
000027FE                          2236  *-----------------------------------------------------------------------------------*
000027FE                          2237  * Print out A2 if mask field states to. 
000027FE                          2238    
000027FE                          2239  CHECK_BIT_10
000027FE  3606                    2240          MOVE.W  D6, D3
00002800  0243 0F00               2241          ANDI.W  #second_nibble,D3
00002804  1A3C 0008               2242          MOVE.B  #right8,D5 
00002808  EA6B                    2243          LSR.W   D5,D3
0000280A  0203 0004               2244          ANDI.B  #4,D3
0000280E  B63C 0004               2245          CMP.B   #4,D3
00002812  6700 0006               2246          BEQ     D4_An_SET_2
00002816  6000 0014               2247          BRA     CHECK_BIT_9
0000281A                          2248  D4_An_SET_2
0000281A  183C 0002               2249          MOVE.B  #$2, D4
0000281E                          2250          
0000281E  6000 0002               2251          BRA     PRINT_A2
00002822                          2252          
00002822                          2253  PRINT_A2
00002822  4EB9 00002CF6           2254          JSR     EA_An
00002828  14FC 002F               2255          MOVE.B  #$2F,(A2)+  
0000282C                          2256  
0000282C                          2257  *-----------------------------------------------------------------------------------*
0000282C                          2258  * Print out A1 if mask field states to. 
0000282C                          2259    
0000282C                          2260  CHECK_BIT_9
0000282C  3606                    2261          MOVE.W  D6, D3
0000282E  0243 0F00               2262          ANDI.W  #second_nibble,D3
00002832  1A3C 0008               2263          MOVE.B  #right8,D5 
00002836  EA6B                    2264          LSR.W   D5,D3
00002838  0203 0002               2265          ANDI.B  #2,D3
0000283C  B63C 0002               2266          CMP.B   #2,D3
00002840  6700 0006               2267          BEQ     D4_An_SET_1
00002844  6000 0012               2268          BRA     CHECK_BIT_8
00002848                          2269  D4_An_SET_1
00002848  183C 0001               2270          MOVE.B  #$1, D4
0000284C                          2271          
0000284C  60D4                    2272          BRA     PRINT_A2
0000284E                          2273          
0000284E                          2274  PRINT_A1
0000284E  4EB9 00002CF6           2275          JSR     EA_An
00002854  14FC 002F               2276          MOVE.B  #$2F,(A2)+ 
00002858                          2277  
00002858                          2278  *-----------------------------------------------------------------------------------*
00002858                          2279  * Print out A0 if mask field states to. 
00002858                          2280    
00002858                          2281  CHECK_BIT_8
00002858  3606                    2282          MOVE.W  D6, D3
0000285A  0243 0F00               2283          ANDI.W  #second_nibble,D3
0000285E  1A3C 0008               2284          MOVE.B  #right8,D5 
00002862  EA6B                    2285          LSR.W   D5,D3
00002864  0203 0001               2286          ANDI.B  #1,D3
00002868  B63C 0001               2287          CMP.B   #1,D3
0000286C  6700 0006               2288          BEQ     D4_An_SET_0
00002870  6000 0014               2289          BRA     CHECK_BIT_7
00002874                          2290  D4_An_SET_0
00002874  183C 0000               2291          MOVE.B  #$0, D4
00002878                          2292          
00002878  6000 0002               2293          BRA     PRINT_A0
0000287C                          2294          
0000287C                          2295  PRINT_A0
0000287C  4EB9 00002CF6           2296          JSR     EA_An
00002882  14FC 002F               2297          MOVE.B  #$2F,(A2)+        
00002886                          2298  
00002886                          2299  *-----------------------------------------------------------------------------------*
00002886                          2300  * Print out D7 if mask field states to. 
00002886                          2301  * THIRD NIBBLE CHECK D7-D0
00002886                          2302  
00002886                          2303  CHECK_BIT_7
00002886  3606                    2304          MOVE.W  D6, D3
00002888  0243 00F0               2305          ANDI.W  #third_nibble,D3
0000288C  1A3C 0004               2306          MOVE.B  #right4,D5 
00002890  EA6B                    2307          LSR.W   D5,D3
00002892  0203 0008               2308          ANDI.B  #8,D3
00002896  B63C 0008               2309          CMP.B   #8,D3
0000289A  6700 0006               2310          BEQ     D4_Dn_SET_7
0000289E  6000 0014               2311          BRA     CHECK_BIT_6
000028A2                          2312  D4_Dn_SET_7
000028A2  183C 0007               2313          MOVE.B  #$7, D4
000028A6                          2314          
000028A6  6000 0002               2315          BRA     PRINT_D7
000028AA                          2316          
000028AA                          2317  PRINT_D7
000028AA  4EB9 00002CEA           2318          JSR     EA_Dn
000028B0  14FC 002F               2319          MOVE.B  #$2F,(A2)+
000028B4                          2320  
000028B4                          2321  *-----------------------------------------------------------------------------------*
000028B4                          2322  * Print out D6 if mask field states to. 
000028B4                          2323  
000028B4                          2324  CHECK_BIT_6
000028B4  3606                    2325          MOVE.W  D6, D3
000028B6  0243 00F0               2326          ANDI.W  #third_nibble,D3
000028BA  1A3C 0004               2327          MOVE.B  #right4,D5 
000028BE  EA6B                    2328          LSR.W   D5,D3
000028C0  0203 0004               2329          ANDI.B  #4,D3
000028C4  B63C 0004               2330          CMP.B   #4,D3
000028C8  6700 0006               2331          BEQ     D4_Dn_SET_6
000028CC  6000 0014               2332          BRA     CHECK_BIT_5
000028D0                          2333  D4_Dn_SET_6
000028D0  183C 0006               2334          MOVE.B  #$6, D4
000028D4                          2335          
000028D4  6000 0002               2336          BRA     PRINT_D6
000028D8                          2337          
000028D8                          2338  PRINT_D6
000028D8  4EB9 00002CEA           2339          JSR     EA_Dn
000028DE  14FC 002F               2340          MOVE.B  #$2F,(A2)+
000028E2                          2341  
000028E2                          2342  *-----------------------------------------------------------------------------------*
000028E2                          2343  * Print out D5 if mask field states to. 
000028E2                          2344  
000028E2                          2345  CHECK_BIT_5
000028E2  3606                    2346          MOVE.W  D6, D3
000028E4  0243 00F0               2347          ANDI.W  #third_nibble,D3
000028E8  1A3C 0004               2348          MOVE.B  #right4,D5 
000028EC  EA6B                    2349          LSR.W   D5,D3
000028EE  0203 0002               2350          ANDI.B  #2,D3
000028F2  B63C 0002               2351          CMP.B   #2,D3
000028F6  6700 0006               2352          BEQ     D4_Dn_SET_5
000028FA  6000 0014               2353          BRA     CHECK_BIT_4
000028FE                          2354  D4_Dn_SET_5
000028FE  183C 0005               2355          MOVE.B  #$5, D4
00002902                          2356          
00002902  6000 0002               2357          BRA     PRINT_D5
00002906                          2358          
00002906                          2359  PRINT_D5
00002906  4EB9 00002CEA           2360          JSR     EA_Dn
0000290C  14FC 002F               2361          MOVE.B  #$2F,(A2)+
00002910                          2362  
00002910                          2363  *-----------------------------------------------------------------------------------*
00002910                          2364  * Print out D4 if mask field states to. 
00002910                          2365  
00002910                          2366  CHECK_BIT_4
00002910  3606                    2367          MOVE.W  D6, D3
00002912  0243 00F0               2368          ANDI.W  #third_nibble,D3
00002916  1A3C 0004               2369          MOVE.B  #right4,D5 
0000291A  EA6B                    2370          LSR.W   D5,D3
0000291C  0203 0001               2371          ANDI.B  #1,D3
00002920  B63C 0001               2372          CMP.B   #1,D3
00002924  6700 0006               2373          BEQ     D4_Dn_SET_4
00002928  6000 0014               2374          BRA     CHECK_BIT_3
0000292C                          2375  D4_Dn_SET_4
0000292C  183C 0004               2376          MOVE.B  #$4, D4
00002930                          2377          
00002930  6000 0002               2378          BRA     PRINT_D4
00002934                          2379          
00002934                          2380  PRINT_D4
00002934  4EB9 00002CEA           2381          JSR     EA_Dn
0000293A  14FC 002F               2382          MOVE.B  #$2F,(A2)+
0000293E                          2383  
0000293E                          2384  *-----------------------------------------------------------------------------------*
0000293E                          2385  * Print out D3 if mask field states to. 
0000293E                          2386  * FOURTH NIBBLE CHECK / D3 - D0
0000293E                          2387  
0000293E                          2388  CHECK_BIT_3
0000293E  3606                    2389          MOVE.W  D6, D3
00002940  0243 000F               2390          ANDI.W  #fourth_nibble,D3
00002944  0203 0008               2391          ANDI.B  #8,D3
00002948  B63C 0008               2392          CMP.B   #8,D3
0000294C  6700 0006               2393          BEQ     D4_Dn_SET_3
00002950  6000 0014               2394          BRA     CHECK_BIT_2
00002954                          2395  D4_Dn_SET_3
00002954  183C 0003               2396          MOVE.B  #$3, D4
00002958                          2397          
00002958  6000 0002               2398          BRA     PRINT_D3
0000295C                          2399          
0000295C                          2400  PRINT_D3
0000295C  4EB9 00002CEA           2401          JSR     EA_Dn
00002962  14FC 002F               2402          MOVE.B  #$2F,(A2)+
00002966                          2403  
00002966                          2404  *-----------------------------------------------------------------------------------*
00002966                          2405  * Print out D2 if mask field states to. 
00002966                          2406  
00002966                          2407  CHECK_BIT_2
00002966  3606                    2408          MOVE.W  D6, D3
00002968  0243 000F               2409          ANDI.W  #fourth_nibble,D3
0000296C  0203 0004               2410          ANDI.B  #4,D3
00002970  B63C 0004               2411          CMP.B   #4,D3
00002974  6700 0006               2412          BEQ     D4_Dn_SET_2
00002978  6000 0014               2413          BRA     CHECK_BIT_1
0000297C                          2414  D4_Dn_SET_2
0000297C  183C 0002               2415          MOVE.B  #$2, D4
00002980                          2416          
00002980  6000 0002               2417          BRA     PRINT_D2
00002984                          2418          
00002984                          2419  PRINT_D2
00002984  4EB9 00002CEA           2420          JSR     EA_Dn
0000298A  14FC 002F               2421          MOVE.B  #$2F,(A2)+
0000298E                          2422  
0000298E                          2423  *-----------------------------------------------------------------------------------*
0000298E                          2424  * Print out D1 if mask field states to. 
0000298E                          2425  
0000298E                          2426  CHECK_BIT_1
0000298E  3606                    2427          MOVE.W  D6, D3
00002990  0243 000F               2428          ANDI.W  #fourth_nibble,D3
00002994  0203 0002               2429          ANDI.B  #2,D3
00002998  B63C 0002               2430          CMP.B   #2,D3
0000299C  6700 0006               2431          BEQ     D4_Dn_SET_1
000029A0  6000 0014               2432          BRA     CHECK_BIT_0
000029A4                          2433  D4_Dn_SET_1
000029A4  183C 0001               2434          MOVE.B  #$1, D4
000029A8                          2435          
000029A8  6000 0002               2436          BRA     PRINT_D1
000029AC                          2437          
000029AC                          2438  PRINT_D1
000029AC  4EB9 00002CEA           2439          JSR     EA_Dn
000029B2  14FC 002F               2440          MOVE.B  #$2F,(A2)+
000029B6                          2441  
000029B6                          2442  *-----------------------------------------------------------------------------------*
000029B6                          2443  * Print out D0 if mask field states to. 
000029B6                          2444  
000029B6                          2445  CHECK_BIT_0
000029B6  3606                    2446          MOVE.W  D6, D3
000029B8  0243 000F               2447          ANDI.W  #fourth_nibble,D3
000029BC  0203 0001               2448          ANDI.B  #1,D3
000029C0  B63C 0001               2449          CMP.B   #1,D3
000029C4  6700 0006               2450          BEQ     D4_Dn_SET_0
000029C8  6000 0014               2451          BRA     FINISH_MOVEM_MEM_TO_REG
000029CC                          2452  D4_Dn_SET_0
000029CC  183C 0000               2453          MOVE.B  #$0, D4
000029D0                          2454          
000029D0  6000 0002               2455          BRA     PRINT_D0
000029D4                          2456          
000029D4                          2457  PRINT_D0
000029D4  4EB9 00002CEA           2458          JSR     EA_Dn
000029DA  14FC 002F               2459          MOVE.B  #$2F,(A2)+
000029DE                          2460  
000029DE                          2461  FINISH_MOVEM_MEM_TO_REG
000029DE                          2462          
000029DE  2600                    2463          MOVE.L  D0,D3               ; Store the src mode in D3
000029E0  0243 0038               2464          ANDI.W  #src_mode,D3        ; Get bits 5-3
000029E4  1A3C 0003               2465          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000029E8  EA6B                    2466          LSR.W   D5,D3               ; Do the actual shift
000029EA                          2467  
000029EA  2800                    2468          MOVE.L  D0,D4               ; Store the dst reg in D4
000029EC  0244 0007               2469          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000029F0                          2470   
000029F0  B63C 0002               2471          CMP.B   #2, D3
000029F4  6700 0006               2472          BEQ     An_FINISH           ; branch to print out (An) 
000029F8  6000 0010               2473          BRA     NORMAL_FINISH       ; branch to the normal finish
000029FC                          2474  
000029FC                          2475  An_FINISH
000029FC  14FC 002C               2476          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002A00  14FC 0020               2477          MOVE.B  #$20,(A2)+          ; Add space after comma
00002A04                          2478          
00002A04                          2479                      
00002A04  4EB9 00002CAC           2480          JSR     EA_GEN_SRC
00002A0A                          2481  
00002A0A                          2482  NORMAL_FINISH
00002A0A  301D                    2483          MOVE.W  (A5)+, D0
00002A0C                          2484          
00002A0C  4EF8 1E10               2485          JMP     EA_FINISH
00002A10                          2486  *------------------------------------------------------------------------------------------------*
00002A10                          2487  EA_SHIFTS       ; 7: ea_shifts
00002A10  2200                    2488          MOVE.L  D0,D1               ; D0 is current instruction word
00002A12  0241 01C0               2489          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00002A16  1A3C 0006               2490          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00002A1A  EA69                    2491          LSR.W   D5,D1               ; Shift dst mode into LSB position
00002A1C  C2FC 0006               2492          MULU    #6, D1              ; Set displacement 
00002A20  41F9 00002A2A           2493          LEA     EA_SHIFTS_TABLE,A0  ; Load table into A0
00002A26  4EF0 1000               2494          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00002A2A                          2495  
00002A2A                          2496  EA_SHIFTS_TABLE
00002A2A  4EF9 00002AD0           2497          JMP     EA_REGISTER_SHIFTS  ; 000 Register
00002A30  4EF9 00002AD0           2498          JMP     EA_REGISTER_SHIFTS  ; 001 Register
00002A36  4EF9 00002AD0           2499          JMP     EA_REGISTER_SHIFTS  ; 010 Register
00002A3C  4EF9 00002A5A           2500          JMP     EA_MEMORY_SHIFTS    ; 011 Memory
00002A42  4EF9 00002AD0           2501          JMP     EA_REGISTER_SHIFTS  ; 100 Register
00002A48  4EF9 00002AD0           2502          JMP     EA_REGISTER_SHIFTS  ; 101 Register
00002A4E  4EF9 00002AD0           2503          JMP     EA_REGISTER_SHIFTS  ; 110 Register
00002A54  4EF9 00002A5A           2504          JMP     EA_MEMORY_SHIFTS    ; 111 Memory
00002A5A                          2505          
00002A5A                          2506  EA_MEMORY_SHIFTS
00002A5A                          2507          ; Get EA and store into decode buffer
00002A5A  2800                    2508          MOVE.L  D0,D4               ; Store the EA reg in D4
00002A5C  0244 0007               2509          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002A60                          2510          
00002A60  2600                    2511          MOVE.L  D0,D3               ; Store the EA mode in D3
00002A62  0243 0038               2512          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002A66  1A3C 0003               2513          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002A6A  EA6B                    2514          LSR.W   D5,D3               ; Do the actual shift
00002A6C  4EB9 00002DB8           2515          JSR     An_CHECK            ; Check if mode is An 
00002A72  4EB9 00002DC2           2516          JSR     Dn_CHECK            ; Check if mode is Dn
00002A78  4EB9 00002DCC           2517          JSR     IMMEDIATE_CHECK     ; Check if mode is immediate
00002A7E                          2518          
00002A7E  14FC 0020               2519          MOVE.B  #$20,(A2)+          ; Print out a space 
00002A82  14FC 0020               2520          MOVE.B  #$20,(A2)+          ; Print out a space
00002A86  14FC 0020               2521          MOVE.B  #$20,(A2)+          ; Print out a space
00002A8A  14FC 0020               2522          MOVE.B  #$20,(A2)+          ; Print out a space
00002A8E  14FC 0020               2523          MOVE.B  #$20,(A2)+          ; Add space
00002A92                          2524          
00002A92  4EB9 00002AAA           2525          JSR     FRONT_FORMAT
00002A98  4EB9 00002CAC           2526          JSR     EA_GEN_SRC          ; Go get EA print
00002A9E  B63C 002A               2527          CMP.B   #$2A,D3             ; When mode is 111 * 6 (2A)
00002AA2  6700 001E               2528          BEQ     BACK_PARENTHESIS  
00002AA6  4EF8 1E10               2529          JMP     EA_FINISH           ; Opcode is finish
00002AAA                          2530  
00002AAA                          2531  FRONT_FORMAT
00002AAA  B63C 0007               2532          CMP.B   #7,D3               ; When mode is 111
00002AAE  6700 0008               2533          BEQ     ADD_PARENTHESIS
00002AB2  14FC 0020               2534          MOVE.B  #$20,(A2)+          ; Print out a space
00002AB6  4E75                    2535          RTS
00002AB8                          2536          
00002AB8                          2537  ADD_PARENTHESIS
00002AB8  14FC 0020               2538          MOVE.B  #$20,(A2)+          ; Print out a space
00002ABC  14FC 0028               2539          MOVE.B  #'(',(A2)+
00002AC0  4E75                    2540          RTS
00002AC2                          2541          
00002AC2                          2542  BACK_PARENTHESIS            
00002AC2  14FC 0029               2543          MOVE.B  #')',(A2)+
00002AC6  1404                    2544          MOVE.B  D4,D2
00002AC8  4EB8 1EFE               2545          JSR     EA_SIZE_MEMORY_SHIFTS
00002ACC  4EF8 1E10               2546          JMP     EA_FINISH           ; Opcode is finish
00002AD0                          2547      
00002AD0                          2548  EA_REGISTER_SHIFTS
00002AD0  2200                    2549          MOVE.L  D0,D1
00002AD2  0241 01C0               2550          ANDI.W  #dst_mode,D1
00002AD6  1A3C 0006               2551          MOVE.B  #right6,D5 
00002ADA  EA69                    2552          LSR.W   D5,D1
00002ADC  0201 0003               2553          ANDI.B  #3,D1               ; Remove bit 8 and get bits 7-6
00002AE0  1401                    2554          MOVE.B  D1,D2
00002AE2  4EB8 1E56               2555          JSR     EA_SIZE_GENERAL
00002AE6                          2556          
00002AE6  2600                    2557          MOVE.L  D0,D3               ; Store the instruction in D3
00002AE8  0243 0038               2558          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002AEC  1A3C 0003               2559          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002AF0  EA6B                    2560          LSR.W   D5,D3               ; Do the actual shift 
00002AF2  0203 0004               2561          ANDI.B  #4,D3               ; Get bit 5(ir) from bits 5-3
00002AF6  E44B                    2562          LSR.W   #2,D3
00002AF8                          2563  
00002AF8  B63C 0000               2564          CMP.B   #0,D3               ; When D1 is 0 (immediate)
00002AFC  6700 0006               2565          BEQ     IMMEDIATE_SRC
00002B00  6000 0056               2566          BRA     REGISTER_SRC        ; When D1 is 1 (register)
00002B04                          2567          
00002B04                          2568  IMMEDIATE_SRC
00002B04  14FC 0020               2569          MOVE.B  #$20,(A2)+          ; Add space
00002B08  14FC 0020               2570          MOVE.B  #$20,(A2)+          ; Add space
00002B0C  14FC 0020               2571          MOVE.B  #$20,(A2)+          ; Add space
00002B10  14FC 0020               2572          MOVE.B  #$20,(A2)+          ; Add space
00002B14                          2573          
00002B14                          2574          ; Get source and store into decode buffer
00002B14  2800                    2575          MOVE.L  D0,D4               ; Store the src reg in D4
00002B16  0244 0E00               2576          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B1A  1A3C 0009               2577          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B1E  EA6C                    2578          LSR.W   D5,D4               ; Do the actual shift
00002B20  4EB9 00002B48           2579          JSR     CHECK_IF_ZERO       ; Check if register is 0
00002B26                          2580          
00002B26  14FC 0023               2581          MOVE.B  #$23,(A2)+          ; Add # symbol
00002B2A  0604 0030               2582          ADDI.B  #$30,D4             ; Convert hex to ASCII
00002B2E  14C4                    2583          MOVE.B  D4,(A2)+            ; Store into buffer
00002B30                          2584          
00002B30  14FC 002C               2585          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B34  14FC 0020               2586          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B38                          2587  
00002B38                          2588          ; Get destination and store into decode buffer
00002B38  2800                    2589          MOVE.L  D0,D4               ; Store the src reg in D4
00002B3A  0244 0007               2590          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002B3E  4EB9 00002CEA           2591          JSR     EA_Dn               ; store Dn into decode buffer
00002B44  4EF8 1E10               2592          JMP     EA_FINISH           ; Opcode is finish
00002B48                          2593                
00002B48                          2594  CHECK_IF_ZERO
00002B48  B83C 0000               2595          CMP.B   #0,D4               ; When D4 is 0 
00002B4C  6700 0004               2596          BEQ     IMMEDIATE_EIGHT     ; Branch
00002B50  4E75                    2597          RTS
00002B52                          2598  
00002B52                          2599  IMMEDIATE_EIGHT
00002B52  183C 0008               2600          MOVE.B  #8,D4               ; Store 8 into D4 
00002B56  4E75                    2601          RTS
00002B58                          2602  
00002B58                          2603  REGISTER_SRC        
00002B58  14FC 0020               2604          MOVE.B  #$20,(A2)+          ; Add space
00002B5C  14FC 0020               2605          MOVE.B  #$20,(A2)+          ; Add space
00002B60  14FC 0020               2606          MOVE.B  #$20,(A2)+          ; Add space
00002B64  14FC 0020               2607          MOVE.B  #$20,(A2)+          ; Add space
00002B68                          2608  
00002B68                          2609          ; Get source and store into decode buffer
00002B68  2800                    2610          MOVE.L  D0,D4               ; Store the src reg in D4
00002B6A  0244 0E00               2611          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B6E  1A3C 0009               2612          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B72  EA6C                    2613          LSR.W   D5,D4               ; Do the actual shift
00002B74  4EB9 00002CEA           2614          JSR     EA_Dn               ; store Dn into decode buffer
00002B7A                          2615          
00002B7A  14FC 002C               2616          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B7E  14FC 0020               2617          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B82                          2618  
00002B82                          2619          ; Get destination and store into decode buffer
00002B82  2800                    2620          MOVE.L  D0,D4               ; Store the src reg in D4
00002B84  0244 0007               2621          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002B88  4EB9 00002CEA           2622          JSR     EA_Dn               ; store Dn into decode buffer
00002B8E  4EF8 1E10               2623          JMP     EA_FINISH           ; Opcode is finish
00002B92                          2624  *------------------------------------------------------------------------------------------------*
00002B92                          2625  EA_QUICK        ; 8: ea_quick
00002B92  BC3C 0005               2626          CMP.B   #5, D6              ; check if the first nibble is 5 for ADDQ
00002B96  6700 000A               2627          BEQ     ADDQ_EA_CALC
00002B9A                          2628          
00002B9A  BC3C 0007               2629          CMP.B   #7, D6              ; check if the first nibble is 7 for MOVEQ
00002B9E  6700 0072               2630          BEQ     MOVEQ_EA_CALC
00002BA2                          2631          
00002BA2                          2632  ADDQ_EA_CALC
00002BA2  2200                    2633          MOVE.L  D0,D1
00002BA4  0241 01C0               2634          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00002BA8  1A3C 0006               2635          MOVE.B  #right6,D5          ; Store 6 into D5
00002BAC  EA69                    2636          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002BAE  0201 0003               2637          ANDI.B  #3,D1               ; Remove the front bit from D1
00002BB2  1401                    2638          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002BB4  4EB8 1E56               2639          JSR     EA_SIZE_GENERAL     ; Get size and print size.
00002BB8                          2640          
00002BB8  14FC 0020               2641          MOVE.B  #$20,(A2)+          ; Add space after size
00002BBC  14FC 0020               2642          MOVE.B  #$20,(A2)+          ; Add space
00002BC0  14FC 0020               2643          MOVE.B  #$20,(A2)+          ; Add space
00002BC4                          2644          
00002BC4  14FC 0023               2645          MOVE.B  #$23,(A2)+          ; Add # symbol
00002BC8  14FC 0024               2646          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002BCC                          2647          
00002BCC  2800                    2648          MOVE.L  D0,D4               ; Store the data in D4
00002BCE  0244 0E00               2649          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002BD2  1A3C 0009               2650          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002BD6  EA6C                    2651          LSR.W   D5,D4               ; Do the actual shift
00002BD8                          2652          
00002BD8  B83C 0000               2653          CMP.B   #0, D4
00002BDC  6700 0006               2654          BEQ     CHANGE_TO_EIGHT
00002BE0                          2655          
00002BE0  6000 0006               2656          BRA     DONT_CHANGE
00002BE4                          2657  
00002BE4                          2658  CHANGE_TO_EIGHT
00002BE4  183C 0008               2659          MOVE.B  #8, D4
00002BE8                          2660  
00002BE8                          2661  DONT_CHANGE        
00002BE8  0604 0030               2662          ADDI.B  #$30, D4
00002BEC  14C4                    2663          MOVE.B  D4, (A2)+      
00002BEE                          2664          
00002BEE  14FC 002C               2665          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002BF2  14FC 0020               2666          MOVE.B  #$20,(A2)+          ; Add space after comma
00002BF6                          2667          
00002BF6  2800                    2668          MOVE.L  D0,D4               ; Store the src reg in D4
00002BF8  0244 0007               2669          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002BFC                          2670          
00002BFC  2600                    2671          MOVE.L  D0,D3               ; Store the src mode in D3
00002BFE  0243 0038               2672          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002C02  1A3C 0003               2673          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002C06  EA6B                    2674          LSR.W   D5,D3               ; Do the actual shift 
00002C08  4EB9 00002CAC           2675          JSR     EA_GEN_SRC
00002C0E                          2676          
00002C0E  4EF8 1E10               2677          JMP     EA_FINISH
00002C12                          2678  
00002C12                          2679  MOVEQ_EA_CALC
00002C12  14FC 0020               2680          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002C16  14FC 0020               2681          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002C1A  14FC 0020               2682          MOVE.B  #$20,(A2)+          ; Add space
00002C1E  14FC 0020               2683          MOVE.B  #$20,(A2)+          ; Add space
00002C22                          2684  
00002C22  14FC 0023               2685          MOVE.B  #$23,(A2)+          ; Add # symbol
00002C26  14FC 0024               2686          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C2A                          2687          
00002C2A  2200                    2688          MOVE.L  D0, D1              ; move D0 to D1
00002C2C  0241 00FF               2689          ANDI.W  #second_half, D1    ; get the second 8 bits of D1
00002C30  1A01                    2690          MOVE.B  D1, D5              ; move D1 to D5 to convert it to ASCII
00002C32                          2691          
00002C32  4EB8 11C8               2692          JSR     ITOA_BYTE_BRANCH    ; print out the bit of data
00002C36                          2693          
00002C36  14FC 002C               2694          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002C3A  14FC 0020               2695          MOVE.B  #$20,(A2)+          ; Add space after comma
00002C3E                          2696          
00002C3E  2800                    2697          MOVE.L  D0,D4               ; Store the data in D4
00002C40  0244 0E00               2698          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002C44  1A3C 0009               2699          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002C48  EA6C                    2700          LSR.W   D5,D4               ; Do the actual shift
00002C4A  4EB9 00002CAC           2701          JSR     EA_GEN_SRC
00002C50                          2702          
00002C50  4EF8 1E10               2703          JMP     EA_FINISH
00002C54                          2704  *------------------------------------------------------------------------------------------------*
00002C54                          2705  EA_BRANCH       ; 9: ea_branch
00002C54  14FC 0020               2706          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C58  14FC 0020               2707          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C5C  14FC 0020               2708          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C60  14FC 0020               2709          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C64  14FC 0020               2710          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C68  14FC 0020               2711          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C6C                          2712  
00002C6C  2600                    2713          MOVE.L  D0,D3               ; D0 is current instruction word
00002C6E  0243 00F0               2714          ANDI.W  #third_nibble,D3   ; Extract 3rd nibble from instruction word
00002C72  1A3C 0004               2715          MOVE.B  #right4,D5
00002C76                          2716          
00002C76  2800                    2717          MOVE.L  D0,D4               ; D0 is current instruction word
00002C78  0244 000F               2718          ANDI.W  #fourth_nibble,D4   ; Extract 4th nibble from instruction word
00002C7C                          2719           
00002C7C  B63C 0000               2720          CMP.B   #0,D3               ; check if 3rd nibble is 0. 
00002C80  6700 0006               2721          BEQ     FOURTH_NIBBLE_CHECK
00002C84                          2722          
00002C84  6000 0018               2723          BRA     BRANCH_WORD_CHECK
00002C88                          2724          
00002C88                          2725  FOURTH_NIBBLE_CHECK                 
00002C88  B83C 0000               2726          CMP.B   #0,D4               ; check if the 4th nibble is 0. 
00002C8C                          2727          
00002C8C  3A15                    2728          MOVE.W  (A5),D5            ; store the 16-bit displacement into D5
00002C8E                          2729          
00002C8E  260D                    2730          MOVE.L  A5,D3              ; Store A5 address into D3
00002C90                          2731          
00002C90  DA43                    2732          ADD.W   D3,D5              ; Add the address to D5 to get the displacement. 
00002C92                          2733          
00002C92  14FC 0024               2734          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C96                          2735          
00002C96  4EB8 11F6               2736          JSR     ITOA_WORD_BRANCH    ; Print. 
00002C9A                          2737  
00002C9A  4EF8 1E10               2738          JMP     EA_FINISH
00002C9E                          2739  
00002C9E                          2740  BRANCH_WORD_CHECK
00002C9E  4245                    2741          CLR     D5                  ; handles 8-bit displacement. 
00002CA0  DA03                    2742          ADD.B   D3,D5               ; add d3 and d4 to d5
00002CA2  DA04                    2743          ADD.B   D4,D5
00002CA4                          2744          
00002CA4  4EB8 11C8               2745          JSR     ITOA_BYTE_BRANCH    ; Print. 
00002CA8                          2746  
00002CA8  4EF8 1E10               2747          JMP     EA_FINISH
00002CAC                          2748  
00002CAC                          2749  EA_GEN_SRC
00002CAC  41F9 00002CBA           2750          LEA     EA_GEN_TABLE_SRC, A0
00002CB2  C6FC 0006               2751          MULU    #6, D3              ; use D3 to jump to the proper src mode and dst mode. 
00002CB6  4EF0 3000               2752          JMP     0(A0,D3)            ; jump to each ea src generation table entry 
00002CBA                          2753  
00002CBA                          2754  EA_GEN_TABLE_SRC
00002CBA  4EF9 00002CEA           2755          JMP     EA_Dn                       ; 000: Dn
00002CC0  4EF9 00002CF6           2756          JMP     EA_An                       ; 001: An
00002CC6  4EF9 00002D02           2757          JMP     EA_An_Indirect              ; 010: (An)
00002CCC  4EF9 00002D16           2758          JMP     EA_An_Indirect_Inc          ; 011: (An)+
00002CD2  4EF9 00002D2E           2759          JMP     EA_An_Indirect_Dec          ; 100: -(An)
00002CD8  4EF9 00002D46           2760          JMP     EA_UNSUPPORTED              ; 101: Unsupported EA
00002CDE  4EF9 00002D46           2761          JMP     EA_UNSUPPORTED              ; 110: Unsupported EA
00002CE4  4EF9 00002D4A           2762          JMP     EA_Absolute_And_Immediate   ; 111: (xxx).W,(xxx).L, or #<data>
00002CEA                          2763  
00002CEA                          2764  EA_Dn               ; 000: Dn
00002CEA  14FC 0044               2765          MOVE.B  #'D',(A2)+
00002CEE  0604 0030               2766          ADDI.B  #$30,D4
00002CF2  14C4                    2767          MOVE.B  D4,(A2)+
00002CF4  4E75                    2768          RTS
00002CF6                          2769  
00002CF6                          2770  EA_An               ; 001: An
00002CF6  14FC 0041               2771          MOVE.B  #'A',(A2)+
00002CFA  0604 0030               2772          ADDI.B  #$30,D4
00002CFE  14C4                    2773          MOVE.B  D4,(A2)+
00002D00  4E75                    2774          RTS
00002D02                          2775  
00002D02                          2776  EA_An_Indirect      ; 010: (An)
00002D02  14FC 0028               2777          MOVE.B  #'(',(A2)+
00002D06  14FC 0041               2778          MOVE.B  #'A',(A2)+
00002D0A  0604 0030               2779          ADDI.B  #$30,D4
00002D0E  14C4                    2780          MOVE.B  D4,(A2)+
00002D10  14FC 0029               2781          MOVE.B  #')',(A2)+
00002D14  4E75                    2782          RTS
00002D16                          2783          
00002D16                          2784  EA_An_Indirect_Inc  ; 011: (An)+
00002D16  14FC 0028               2785          MOVE.B  #'(',(A2)+
00002D1A  14FC 0041               2786          MOVE.B  #'A',(A2)+
00002D1E  0604 0030               2787          ADDI.B  #$30, D4
00002D22  14C4                    2788          MOVE.B  D4,(A2)+
00002D24  14FC 0029               2789          MOVE.B  #')',(A2)+
00002D28  14FC 002B               2790          MOVE.B  #'+',(A2)+
00002D2C  4E75                    2791          RTS
00002D2E                          2792          
00002D2E                          2793  EA_An_Indirect_Dec  ; 100: -(An)
00002D2E  14FC 002D               2794          MOVE.B  #'-',(A2)+
00002D32  14FC 0028               2795          MOVE.B  #'(',(A2)+
00002D36  14FC 0041               2796          MOVE.B  #'A',(A2)+
00002D3A  0604 0030               2797          ADDI.B  #$30,D4
00002D3E  14C4                    2798          MOVE.B  D4,(A2)+
00002D40  14FC 0029               2799          MOVE.B  #')',(A2)+
00002D44  4E75                    2800          RTS
00002D46                          2801  
00002D46                          2802  EA_UNSUPPORTED
00002D46  6000 00CA               2803          BRA     EA_ERROR
00002D4A                          2804          
00002D4A                          2805  EA_Absolute_And_Immediate           ; 111: (xxx).W,(xxx).L, or #<data>
00002D4A  B83C 0000               2806          CMP.B   #0,D4               ; If D4 is (xxx).W
00002D4E  6700 0016               2807          BEQ     ABSOLUTE_WORD
00002D52                          2808          
00002D52  B83C 0001               2809          CMP.B   #1,D4               ; If D4 is (xxx).L
00002D56  6700 001A               2810          BEQ     ABSOLUTE_LONG
00002D5A                          2811          
00002D5A  B83C 0004               2812          CMP.B   #4,D4               ; If D4 is #<data>  
00002D5E  6700 001E               2813          BEQ     IMMEDIATE
00002D62                          2814          
00002D62  6000 00AE               2815          BRA     EA_ERROR    
00002D66                          2816  
00002D66                          2817  ABSOLUTE_WORD
00002D66  14FC 0024               2818          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D6A  7401                    2819          MOVE.L  #1,D2               ; Insert 1 to D2 
00002D6C  4EB8 1132               2820          JSR     ITOA                ; Convert word hex values to ITOA
00002D70  4E75                    2821          RTS
00002D72                          2822          
00002D72                          2823  ABSOLUTE_LONG
00002D72  14FC 0024               2824          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D76  7402                    2825          MOVE.L  #2,D2               ; Insert 2 to D2
00002D78  4EB8 1132               2826          JSR     ITOA                ; Convert long hex values to ITOA
00002D7C  4E75                    2827          RTS
00002D7E                          2828     
00002D7E                          2829  IMMEDIATE
00002D7E  14FC 0023               2830          MOVE.B  #$23,(A2)+          ; Add # symbol
00002D82  14FC 0024               2831          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D86                          2832  
00002D86  BC3C 0001               2833          CMP.B   #1,D6               ; If MOVE.b (code0001)
00002D8A  6700 0020               2834          BEQ     DO_ITOA_MOVE
00002D8E  BC3C 0002               2835          CMP.B   #2, D6              ; If MOVE.l / MOVEA.l (code0010)
00002D92  6700 0018               2836          BEQ     DO_ITOA_MOVE
00002D96  BC3C 0003               2837          CMP.B   #3, D6              ; If MOVE.w / MOVEA.w (code0011)
00002D9A  6700 0010               2838          BEQ     DO_ITOA_MOVE        
00002D9E  BC3C 000D               2839          CMP.B   #13, D6             ; If ADD / ADDA (code1101)
00002DA2  6700 000E               2840          BEQ     DO_ITOA_OPMODE
00002DA6                          2841          
00002DA6  4EB8 1132               2842          JSR     ITOA                ; Go to ITOA when not a move instruction
00002DAA  4E75                    2843          RTS
00002DAC                          2844          
00002DAC                          2845  DO_ITOA_MOVE
00002DAC  4EB8 1154               2846          JSR ITOA_MOVE
00002DB0  4E75                    2847          RTS
00002DB2                          2848                
00002DB2                          2849  DO_ITOA_OPMODE
00002DB2  4EB8 1176               2850          JSR ITOA_OPMODE
00002DB6  4E75                    2851          RTS
00002DB8                          2852  
00002DB8                          2853  An_CHECK 
00002DB8  B63C 0001               2854          CMP.B   #1,D3               ; If mode is An     
00002DBC  6700 0054               2855          BEQ     EA_ERROR            ; Then branch to error message
00002DC0  4E75                    2856          RTS   
00002DC2                          2857        
00002DC2                          2858  Dn_CHECK 
00002DC2  B63C 0000               2859          CMP.B   #0,D3               ; If mode is Dn     
00002DC6  6700 004A               2860          BEQ     EA_ERROR            ; Then branch to error message
00002DCA  4E75                    2861          RTS  
00002DCC                          2862                
00002DCC                          2863  IMMEDIATE_CHECK
00002DCC  B63C 0007               2864          CMP.B   #7,D3
00002DD0  6700 0004               2865          BEQ     IMMEDIATE_REGISTER_CHECK
00002DD4  4E75                    2866          RTS
00002DD6                          2867          
00002DD6                          2868  IMMEDIATE_REGISTER_CHECK
00002DD6  B83C 0004               2869          CMP.B   #4,D4               ; If 100 in register
00002DDA  6700 0036               2870          BEQ     EA_ERROR            ; Branch to invalid
00002DDE  4E75                    2871          RTS   
00002DE0                          2872                     
00002DE0                          2873  OP_ERROR  
00002DE0  14FC 0044               2874          MOVE.B  #'D',(A2)+
00002DE4  14FC 0041               2875          MOVE.B  #'A',(A2)+
00002DE8  14FC 0054               2876          MOVE.B  #'T',(A2)+
00002DEC  14FC 0041               2877          MOVE.B  #'A',(A2)+
00002DF0  14FC 0020               2878          MOVE.B  #' ',(A2)+
00002DF4  14FC 0020               2879          MOVE.B  #' ',(A2)+
00002DF8  14FC 0020               2880          MOVE.B  #' ',(A2)+
00002DFC  14FC 0020               2881          MOVE.B  #' ',(A2)+
00002E00  14FC 0020               2882          MOVE.B  #' ',(A2)+
00002E04  14FC 0024               2883          MOVE.B  #'$',(A2)+
00002E08  3A00                    2884          MOVE.W  D0,D5
00002E0A  4EB8 1218               2885          JSR     ITOA_WORD_ERROR
00002E0E  4EF8 13CC               2886          JMP     OP_FINISH
00002E12                          2887          
00002E12                          2888  EA_ERROR
00002E12  45F9 00005009           2889          LEA     error_buffer,A2
00002E18  7637                    2890          MOVE.L  #55,D3 
00002E1A                          2891         
00002E1A                          2892  EA_ERROR_LOOP
00002E1A  14FC 0000               2893          MOVE.B  #0,(A2)+
00002E1E  5343                    2894          SUBI    #1,D3
00002E20  6EF8                    2895          BGT     EA_ERROR_LOOP
00002E22  45F9 00005009           2896          LEA     error_buffer,A2
00002E28  14FC 0044               2897          MOVE.B  #'D',(A2)+
00002E2C  14FC 0041               2898          MOVE.B  #'A',(A2)+
00002E30  14FC 0054               2899          MOVE.B  #'T',(A2)+
00002E34  14FC 0041               2900          MOVE.B  #'A',(A2)+
00002E38  14FC 0020               2901          MOVE.B  #' ',(A2)+
00002E3C  14FC 0020               2902          MOVE.B  #' ',(A2)+
00002E40  14FC 0020               2903          MOVE.B  #' ',(A2)+
00002E44  14FC 0020               2904          MOVE.B  #' ',(A2)+
00002E48  14FC 0020               2905          MOVE.B  #' ',(A2)+
00002E4C  14FC 0024               2906          MOVE.B  #'$',(A2)+
00002E50  3A00                    2907          MOVE.W  D0,D5
00002E52  4EB8 1218               2908          JSR     ITOA_WORD_ERROR
00002E56  4EF8 1E10               2909          JMP     EA_FINISH
00002E5A                          2910          
00002E5A  FFFF FFFF               2911  DONE    SIMHALT             ; halt simulator
00002E5E                          2912  
00002E5E                          2913  * Put variables and constants here
00002E5E                          2914      
00002E5E  =00000040               2915  buffer_size         EQU         64 
00002E5E  =00005000               2916  decoded_buffer      EQU         $5000  
00002E5E  =00005009               2917  error_buffer        EQU         $5009
00002E5E  =0000000D               2918  CR                  EQU         $0D
00002E5E  =0000000A               2919  LF                  EQU         $0A
00002E5E  =0000A000               2920  stack               EQU         $0000A000
00002E5E  =0000001E               2921  lines_p_screen      EQU         30
00002E5E  =00000003               2922  right3              EQU         3
00002E5E  =00000004               2923  right4              EQU         4
00002E5E  =00000006               2924  right6              EQU         6
00002E5E  =00000008               2925  right8              EQU         8
00002E5E  =00000009               2926  right9              EQU         9
00002E5E  =0000000C               2927  right12             EQU         12
00002E5E  =00000010               2928  right16             EQU         16
00002E5E  =00000018               2929  right24             EQU         24
00002E5E= 20                      2930  ascii_y_n           DC.B        32
00002E5F  =00000059               2931  y_uppercase         EQU         $59         
00002E5F  =00000079               2932  y_lowercase         EQU         $79
00002E5F  =0000004E               2933  n_uppercase         EQU         $4E
00002E5F  =0000006E               2934  n_lowercase         EQU         $6E
00002E5F  =00000002               2935  task2               EQU         $02
00002E5F  =00000005               2936  task5               EQU         $05
00002E5F  =00000009               2937  task9               EQU         $09
00002E5F  =0000000D               2938  task13              EQU         $0D
00002E5F  =0000000E               2939  task14              EQU         $0E
00002E5F  =0000F000               2940  first_nibble        EQU         $F000
00002E5F  =00000F00               2941  second_nibble       EQU         $0F00   
00002E5F  =000000F0               2942  third_nibble        EQU         $00F0
00002E5F  =0000000F               2943  fourth_nibble       EQU         $000F
00002E5F  =000000FF               2944  second_half         EQU         $00FF
00002E5F  =000001C0               2945  dst_mode            EQU         $01C0
00002E5F  =00000E00               2946  dst_reg             EQU         $0E00
00002E5F  =00000038               2947  src_mode            EQU         $0038
00002E5F  =00000007               2948  src_reg             EQU         $0007
00002E5F  =00000100               2949  bit8                EQU         $0100
00002E5F                          2950  
00002E5F  =00000000               2951  ea_type_immediate   EQU     0       ; EA Type = immediate
00002E5F  =00000001               2952  ea_type_move        EQU     1       ; EA Type = move
00002E5F  =00000002               2953  ea_type_movea       EQU     2       ; EA Type = movea
00002E5F  =00000003               2954  ea_type_lea         EQU     3       ; EA Type = lea
00002E5F  =00000004               2955  ea_type_dstonly     EQU     4       ; EA Type = clr, neg, not, jsr, jmp
00002E5F  =00000005               2956  ea_type_ext         EQU     5       ; EA Type = ext, add, adda
00002E5F  =00000006               2957  ea_type_movem       EQU     6       ; EA Type = movem
00002E5F  =00000007               2958  ea_type_shifts      EQU     7       ; EA Type = ASL/ASR/LSL/LSR/ROL/ROR
00002E5F  =00000008               2959  ea_type_quick       EQU     8       ; EA Type = addq, subq
00002E5F  =00000009               2960  ea_type_branch      EQU     9       ; EA Type = bra, bsr, bcc
00002E5F                          2961             
00002E5F= 57 65 6C 63 6F 6D ...   2962  WELCOME             DC.B        'Welcome to the 68k Disassembler of Avery and Alan',CR,LF,CR,LF,0
00002E95                          2963  
00002E95= 50 6C 65 61 73 65 ...   2964  USER_INST           DC.B        'Please follow the proper input instructions below: ',CR,LF
00002ECA= 2D 20 53 74 61 72 ...   2965                      DC.B        '- Starting address must be lower than ending address.',CR,LF
00002F01= 2D 20 54 68 65 20 ...   2966                      DC.B        '- The values for the starting and ending address must be an even value.',CR,LF
00002F4A= 2D 20 53 74 61 72 ...   2967                      DC.B        '- Starting and ending address must be inputted as hexadecimal value.',CR,LF
00002F90= 2D 20 44 6F 20 6E ...   2968                      DC.B        '- Do not put spaces in between input characters.',CR,LF
00002FC2= 2D 20 56 61 6C 69 ...   2969                      DC.B        '- Valid characters include: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F',CR,LF,0
0000300F                          2970                  
0000300F= 50 72 65 73 73 20 ...   2971  ENTER_PROMPT        DC.B        'Press enter to continue...',CR,LF,0
0000302C= 50 72 65 73 73 20 ...   2972  PROMPT_AGAIN        DC.B        'Press Y to continue / N to exit.',CR,LF,0
0000304F= 50 72 6F 67 72 61 ...   2973  EXIT_PROMPT         DC.B        'Program has execution has stopped.',CR,LF,0
00003074= 45 6E 74 65 72 20 ...   2974  PROMPT_V_END        DC.B        'Enter a valid ending address: ',CR,LF,0
00003095= 45 52 52 4F 52 3A ...   2975  ERROR_MESSAGE       DC.B        'ERROR: The input is invalid.',CR,LF,0  
000030B4= 45 52 52 4F 52 3A ...   2976  ODD_ERROR_MESSAGE   DC.B        'ERROR: The last digit of the address is odd, which is invalid.',CR,LF,0
000030F5                          2977        
000030F5= 45 6E 74 65 72 20 ...   2978  START_IN            DC.B        'Enter a starting address: ',CR,LF,0 
00003112= 45 6E 74 65 72 20 ...   2979  END_IN              DC.B        'Enter an ending address: ',CR,LF,0 
0000312E                          2980  START_ADDRESS       DS.B        32     
0000314E                          2981  END_ADDRESS         DS.B        32 
0000316E                          2982       
0000316E                          2983      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_LONG       2D72
ABSOLUTE_WORD       2D66
ADDQ_EA_CALC        2BA2
ADD_PARENTHESIS     2AB8
AND_OR_CHECK        22D4
AN_CHECK            2DB8
AN_FINISH           29FC
ASCII_TO_HEX_LETTER  109A
ASCII_Y_N           2E5E
ATOI                1074
BACK_PARENTHESIS    2AC2
BIT8                100
BRANCH_WORD_CHECK   2C9E
BUFFER_SIZE         40
CHANGE_TO_001       20D6
CHANGE_TO_EIGHT     2BE4
CHECK1_BIT_0        26A0
CHECK1_BIT_1        2678
CHECK1_BIT_10       24E6
CHECK1_BIT_11       24B8
CHECK1_BIT_12       248A
CHECK1_BIT_13       245C
CHECK1_BIT_14       242E
CHECK1_BIT_2        2650
CHECK1_BIT_3        2628
CHECK1_BIT_4        25FA
CHECK1_BIT_5        25CC
CHECK1_BIT_6        259E
CHECK1_BIT_7        2570
CHECK1_BIT_8        2542
CHECK1_BIT_9        2514
CHECK_BIT_0         29B6
CHECK_BIT_1         298E
CHECK_BIT_10        27FE
CHECK_BIT_11        27D0
CHECK_BIT_12        27A2
CHECK_BIT_13        2774
CHECK_BIT_14        2746
CHECK_BIT_2         2966
CHECK_BIT_3         293E
CHECK_BIT_4         2910
CHECK_BIT_5         28E2
CHECK_BIT_6         28B4
CHECK_BIT_7         2886
CHECK_BIT_8         2858
CHECK_BIT_9         282C
CHECK_IF_ZERO       2B48
CODE0000            1448
CODE0001            1462
CODE0010            1466
CODE0011            147E
CODE0100            1496
CODE0101            14B0
CODE0110            14B4
CODE0111            1540
CODE1000            1544
CODE1001            1564
CODE1010            1568
CODE1011            156C
CODE1100            1570
CODE1101            158A
CODE1110            15A4
CODE1111            1622
COMPLETE_END        10FC
COMPLETE_START      10F4
CONTINUE_OR_END     131E
CR                  D
D4_AN_SETONE_0      258C
D4_AN_SETONE_1      25BA
D4_AN_SETONE_2      25E8
D4_AN_SETONE_3      2616
D4_AN_SETONE_4      263E
D4_AN_SETONE_5      2666
D4_AN_SETONE_6      268E
D4_AN_SETONE_7      26B6
D4_AN_SET_0         2874
D4_AN_SET_1         2848
D4_AN_SET_2         281A
D4_AN_SET_3         27EC
D4_AN_SET_4         27BE
D4_AN_SET_5         2790
D4_AN_SET_6         2762
D4_AN_SET_7         2734
D4_DN_SETONE_0      241C
D4_DN_SETONE_1      244A
D4_DN_SETONE_2      2478
D4_DN_SETONE_3      24A6
D4_DN_SETONE_4      24D4
D4_DN_SETONE_5      2502
D4_DN_SETONE_6      2530
D4_DN_SETONE_7      255E
D4_DN_SET_0         29CC
D4_DN_SET_1         29A4
D4_DN_SET_2         297C
D4_DN_SET_3         2954
D4_DN_SET_4         292C
D4_DN_SET_5         28FE
D4_DN_SET_6         28D0
D4_DN_SET_7         28A2
DECODED_BUFFER      5000
DECODE_MEMORY       1396
DECODE_PAUSE        130A
DECODING_ITERATION  12E6
DISP_UI             100C
DISP_W              1000
DN_CHECK            2DC2
DN_DST              224A
DN_SRC              2288
DONE                2E5A
DONT_CHANGE         2BE8
DO_ITOA_MOVE        2DAC
DO_ITOA_OPMODE      2DB2
DST_MODE            1C0
DST_REG             E00
EA_ABSOLUTE_AND_IMMEDIATE  2D4A
EA_ADDA             2364
EA_AN               2CF6
EA_AND              22E6
EA_AN_INDIRECT      2D02
EA_AN_INDIRECT_DEC  2D2E
EA_AN_INDIRECT_INC  2D16
EA_BRANCH           2C54
EA_CLEAR            2110
EA_DN               2CEA
EA_DSTONLY          20F0
EA_ERROR            2E12
EA_ERROR_LOOP       2E1A
EA_EXT              21B6
EA_EXT_TABLE        21D2
EA_FINISH           1E10
EA_GEN_SRC          2CAC
EA_GEN_TABLE_SRC    2CBA
EA_IMMEDIATE        1F34
EA_JSR              215E
EA_LEA              206C
EA_MEMORY_SHIFTS    2A5A
EA_MOVE             1F90
EA_MOVEA            2000
EA_MOVEM            23AC
EA_MULS_MULU_DIV    230E
EA_OPMODE_012456    2202
EA_OPMODE_37        22F6
EA_OR               22EC
EA_QUICK            2B92
EA_REGISTER_SHIFTS  2AD0
EA_SHIFTS           2A10
EA_SHIFTS_TABLE     2A2A
EA_SIZE_ADDA        1EEA
EA_SIZE_B           1F12
EA_SIZE_DONE        1F32
EA_SIZE_GENERAL     1E56
EA_SIZE_L           1F28
EA_SIZE_MEMORY_SHIFTS  1EFE
EA_SIZE_MOVE        1E72
EA_SIZE_MOVEA       1E8E
EA_SIZE_MOVEM       1EA2
EA_SIZE_OPMODE_012456  1EB6
EA_SIZE_W           1F1C
EA_SIZE_W_MEMORY    1F26
EA_START            1DFE
EA_TYPE_BRANCH      9
EA_TYPE_DSTONLY     4
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_SHIFTS      7
EA_TYPE_TABLE       1E16
EA_UNSUPPORTED      2D46
END_ADDRESS         314E
END_IN              3112
ENTER_PROMPT        300F
ERROR_BUFFER        5009
ERROR_MESSAGE       3095
EXIT                1386
EXIT_PROMPT         304F
FINISH_MOVEM_MEM_TO_REG  29DE
FINISH_REG_TO_MEM   26C8
FIRST_NIBBLE        F000
FOURTH_NIBBLE       F
FOURTH_NIBBLE_CHECK  2C88
FRONT_FORMAT        2AAA
IMMEDIATE           2D7E
IMMEDIATE_CHECK     2DCC
IMMEDIATE_EIGHT     2B52
IMMEDIATE_REGISTER_CHECK  2DD6
IMMEDIATE_SRC       2B04
INPUT_INVALID       10BC
ITOA                1132
ITOA_BYTE           11BA
ITOA_BYTE_BRANCH    11C8
ITOA_BYTE_CONVERT   12A2
ITOA_CONVERT_A_TO_F  12D2
ITOA_DONE           12DE
ITOA_LONG           1238
ITOA_LONGADDRESS    126A
ITOA_MOVE           1154
ITOA_NIBBLE_CONVERT  12C2
ITOA_OPMODE         1176
ITOA_WORD           11DA
ITOA_WORD_BRANCH    11F6
ITOA_WORD_ERROR     1218
JSR_ABSOLUTE_CHECK  21A6
JSR_AN_VALID        219C
JSR_NOP_RTS         186C
LAST_DIGIT_CHECK    10DA
LAST_DIGIT_ODD      1116
LEA_SRC_VALID       20AA
LF                  A
LINES_P_SCREEN      1E
MEMORY_1110_LEFT    15DA
MEMORY_1110_RIGHT   15FE
MEM_TO_REG          26EE
MEM_TO_REG_CONTINUE  2716
MOVEA_DST_VALID     2062
MOVEQ_EA_CALC       2C12
NOP_CHECK           189A
NOP_CHECK_THREE     18CA
NOP_CHECK_TWO       18B2
NORMAL_FINISH       2A0A
N_LOWERCASE         6E
N_UPPERCASE         4E
ODD_ERROR_MESSAGE   30B4
OP_0000_TABLE       1626
OP_0100_TABLE       1686
OP_1100_TABLE       16E6
OP_1101_TABLE       1746
OP_1110_TABLE_REGISTER  17A6
OP_ADD              1D1A
OP_ADDA             1D36
OP_ADDI             194E
OP_ADDQ             1A4A
OP_AND              1CFE
OP_ASL              1D72
OP_ASR              1D56
OP_AS_CHECK         1806
OP_BCC              1ADA
OP_BCS              1AF6
OP_BEQ              1B2E
OP_BGE              1BBA
OP_BGT              1BF2
OP_BHI              1AA2
OP_BLE              1C0E
OP_BLS              1ABE
OP_BLT              1BD6
OP_BMI              1B9E
OP_BNE              1B12
OP_BPL              1B82
OP_BRA              1A6A
OP_BSR              1A86
OP_BVC              1B4A
OP_BVS              1B66
OP_CLEAR_DATA       13D2
OP_CLEAR_DATA_LOOP  13DE
OP_CLR              19B2
OP_CMP              1CA2
OP_DIVU             1C4E
OP_ERROR            2DE0
OP_FINISH           13CC
OP_JSR              19EE
OP_LEA              1A2E
OP_LSL              1DAA
OP_LSR              1D8E
OP_LS_CHECK         1828
OP_MOVE             1992
OP_MOVEA            196E
OP_MOVEM            1A0A
OP_MOVEQ            1C2A
OP_MULS             1CDE
OP_MULU             1CBE
OP_NOP              19CE
OP_OR               1C6E
OP_ROL              1DE2
OP_ROR              1DC6
OP_RO_CHECK         184A
OP_RTS              19DE
OP_SUB              1C86
OP_SUBI             192E
OP_TABLE            13E8
OP_UNSUPPORTED      192A
PRINT1_A0           2594
PRINT1_A1           25C2
PRINT1_A2           25F0
PRINT1_A3           261E
PRINT1_A4           2646
PRINT1_A5           266E
PRINT1_A6           2696
PRINT1_A7           26BE
PRINT1_D0           2424
PRINT1_D1           2452
PRINT1_D2           2480
PRINT1_D3           24AE
PRINT1_D4           24DC
PRINT1_D5           250A
PRINT1_D6           2538
PRINT1_D7           2566
PRINT_A0            287C
PRINT_A1            284E
PRINT_A2            2822
PRINT_A3            27F4
PRINT_A4            27C6
PRINT_A5            2798
PRINT_A6            276A
PRINT_A7            273C
PRINT_D0            29D4
PRINT_D1            29AC
PRINT_D2            2984
PRINT_D3            295C
PRINT_D4            2934
PRINT_D5            2906
PRINT_D6            28D8
PRINT_D7            28AA
PROMPT_AGAIN        302C
PROMPT_END          1040
PROMPT_START        1018
PROMPT_VA_END       1052
PROMPT_V_END        3074
READ_END            1060
READ_START          102C
REGISTER_SRC        2B58
REG_TO_MEM          23FE
RIGHT12             C
RIGHT16             10
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT6              6
RIGHT8              8
RIGHT9              9
RTS_CHECK           18E2
RTS_CHECK_THREE     1912
RTS_CHECK_TWO       18FA
SECOND_HALF         FF
SECOND_NIBBLE       F00
SRC_MODE            38
SRC_REG             7
STACK               A000
START               1000
START_ADDRESS       312E
START_DECODING      12E4
START_IN            30F5
TASK13              D
TASK14              E
TASK2               2
TASK5               5
TASK9               9
THIRD_NIBBLE        F0
USER_INST           2E95
VALIDATE_END        1070
VALIDATE_START      103C
WELCOME             2E5F
Y_LOWERCASE         79
Y_UPPERCASE         59
