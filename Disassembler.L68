00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/9/2020 9:42:13 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler for the Motorola MC68000 Microprocessor
00000000                             3  * Written by :  Avery Mortenson & Alan Luu
00000000                             4  * Date       :  2/12/2020
00000000                             5  * Description:  An inverse assembler (disassembler) that will 
00000000                             6  * convert a memory image of instructions and data back 
00000000                             7  * to the MC68000 assembly code and that will output the 
00000000                             8  * disassembled code to the display.
00000000                             9  *-----------------------------------------------------------
00001000                            10      ORG    $1000
00001000                            11  START:            
00001000                            12  *------------------------------------------------------------*
00001000                            13  * D0: used for the tasks
00001000                            14  * D1: used to hold the size of the input obtained. 
00001000                            15  * D5: used to store the starting and ending address 
00001000                            16  * temporarily before moving them to A4 and A6 correspondingly. 
00001000                            17  * D6: used to check the last digit to see if the input 
00001000                            18  * for the starting and ending address causes a bus error. 
00001000                            19  * A1: a pointer to the message to print out. 
00001000                            20  *------------------------------------------------------------*
00001000  103C 000E                 21  DISP_W      MOVE.B  #14,D0                  ; Display Welcome Message. 
00001004  43F9 00002FE6             22              LEA     WELCOME,A1
0000100A  4E4F                      23              TRAP    #15
0000100C                            24  
0000100C                            25  * Put program code here
0000100C                            26  
0000100C  103C 000E                 27  DISP_UI         MOVE.B  #14,D0              ; Display User Instructions. 
00001010  43F9 0000301C             28                  LEA     USER_INST,A1
00001016  4E4F                      29                  TRAP    #15    
00001018                            30  
00001018  4285                      31  PROMPT_START    CLR.L   D5
0000101A  4FF9 0000A000             32                  LEA     stack, SP           ; SP = stack ($A0000)
00001020  43F9 0000321C             33                  LEA     START_IN,A1         ; Display starting address message
00001026  103C 000E                 34                  MOVE.B  #14,D0
0000102A  4E4F                      35                  TRAP    #15       
0000102C                            36       
0000102C  43F9 00003255             37  READ_START      LEA     START_ADDRESS,A1    ; Store user's starting address input
00001032  103C 0002                 38                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001036  4E4F                      39                  TRAP    #15
00001038  1C3C 0000                 40                  MOVE.B  #0,D6               ; Used to indicate we are at start address
0000103C                            41  
0000103C  6000 0036                 42  VALIDATE_START  BRA     ATOI
00001040                            43  
00001040  4285                      44  PROMPT_END      CLR.L   D5
00001042  43F9 00003239             45                  LEA     END_IN,A1           ; Display ending address message
00001048  103C 000E                 46                  MOVE.B  #14,D0
0000104C  4E4F                      47                  TRAP    #15
0000104E  6000 0010                 48                  BRA     READ_END
00001052                            49  
00001052  4285                      50  PROMPT_VA_END   CLR.L   D5                  ; prompt a valid ending address
00001054  43F9 000031FB             51                  LEA     PROMPT_V_END,A1     ; Display ending address message
0000105A  103C 000E                 52                  MOVE.B  #14,D0
0000105E  4E4F                      53                  TRAP    #15
00001060                            54              
00001060  43F9 00003275             55  READ_END        LEA     END_ADDRESS,A1      ; Store user's starting address input
00001066  103C 0002                 56                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
0000106A  4E4F                      57                  TRAP    #15
0000106C  1C3C 0001                 58                  MOVE.B  #1,D6               ; Used to indicate we are at end address
00001070                            59  
00001070  6000 0002                 60  VALIDATE_END    BRA     ATOI
00001074                            61                 
00001074                            62  * D0 stores the value to pushed from A1.
00001074                            63  
00001074  1019                      64  ATOI            MOVE.B  (A1)+,D0    ; Move to next character in A1 and store in D0          
00001076  B03C 0030                 65                  CMP.B   #$30,D0
0000107A  6D00 0040                 66                  BLT     INPUT_INVALID
0000107E  B03C 0039                 67                  CMP.B   #$39,D0
00001082  6E00 0016                 68                  BGT     ASCII_TO_HEX_LETTER
00001086  0400 0030                 69                  SUB.B   #$30,D0     ; Subtract by 30 to get the numbers 0-9
0000108A  DA80                      70                  ADD.L   D0,D5
0000108C  5341                      71                  SUBI    #1,D1       ; Decrement input's length to move to next character          
0000108E  B23C 0000                 72                  CMP.B   #0,D1       ; Compare to see if we're at the last digit
00001092  6700 0046                 73                  BEQ     LAST_DIGIT_CHECK
00001096  E98D                      74                  LSL.L   #4,D5
00001098  60DA                      75                  BRA     ATOI
0000109A                            76  
0000109A                            77    
0000109A  B03C 0041                 78  ASCII_TO_HEX_LETTER     CMP.B   #$41,D0
0000109E  6D00 001C                 79                          BLT     INPUT_INVALID
000010A2  B03C 0046                 80                          CMP.B   #$46, D0
000010A6  6E00 0014                 81                          BGT     INPUT_INVALID 
000010AA  0400 0031                 82                          SUB.B   #$31,D0     ; Subtract by 31 to get the numbers A-F
000010AE  5D00                      83                          SUB.B   #6,D0
000010B0  DA80                      84                          ADD.L   D0,D5
000010B2  5341                      85                          SUBI    #1,D1
000010B4  6700 0024                 86                          BEQ     LAST_DIGIT_CHECK
000010B8  E98D                      87                          LSL.L   #4,D5
000010BA  60B8                      88                          BRA     ATOI     
000010BC                            89  
000010BC                            90                      
000010BC  43F9 00002F88             91  INPUT_INVALID   LEA     ERROR_MESSAGE, A1   ; Display error message
000010C2  103C 000E                 92                  MOVE.B  #14, D0
000010C6  4E4F                      93                  TRAP    #15
000010C8  4206                      94                  CLR.B   D6
000010CA                            95                  
000010CA  BC3C 0000                 96                  CMP.B   #0,D6           ; When D6 is 0
000010CE  6700 FF48                 97                  BEQ     PROMPT_START    ; Go back to start prompt
000010D2  BC3C 0001                 98                  CMP.B   #1,D6           ; When D6 is 1
000010D6  6700 FF68                 99                  BEQ     PROMPT_END      ; Go back to end prompt
000010DA                           100  
000010DA                           101                            
000010DA  2E05                     102  LAST_DIGIT_CHECK    MOVE.L  D5, D7          ; D7 used as temporary storage
000010DC  E20F                     103                      LSR.B   #1, D7          ; Check for carry bit to see if last digit is odd
000010DE  6500 0036                104                      BCS     LAST_DIGIT_ODD  ; branch when there is a carry; this indicates odd last digit 
000010E2  4287                     105                      CLR.L   D7
000010E4  BC3C 0000                106                      CMP.B   #0,D6
000010E8  6700 000A                107                      BEQ     COMPLETE_START  
000010EC  BC3C 0001                108                      CMP.B   #1,D6
000010F0  6700 000A                109                      BEQ     COMPLETE_END
000010F4                           110  
000010F4  2845                     111  COMPLETE_START      MOVEA.L D5, A4  ; A4 holds the starting address
000010F6  4285                     112                      CLR.L   D5 
000010F8  6000 FF46                113                      BRA PROMPT_END
000010FC                           114  
000010FC  2C45                     115  COMPLETE_END        MOVEA.L D5, A6  ; A6 holds the ending address
000010FE                           116  
000010FE  3A0C                     117                      MOVE.W  A4, D5          ; move starting address to D5
00001100  BA4E                     118                      CMP.W   A6, D5          ; check if the ending address is less than starting address. 
00001102  6E00 FF4E                119                      BGT     PROMPT_VA_END   ; branch to prompt new ending address if so. 
00001106                           120              
00001106  2A4C                     121                      MOVEA.L A4, A5  ; Store starting address into current address
00001108                           122                      
00001108                           123                      *Clear the data and address registers used to obtain the starting and ending address 
00001108  4280                     124                      CLR.L   D0
0000110A  4285                     125                      CLR.L   D5
0000110C  4286                     126                      CLR.L   D6
0000110E  327C 0000                127                      MOVEA   #0, A1
00001112  6000 01D0                128                      BRA     START_DECODING  ; All inputs are valid, go to the decode process
00001116                           129                      
00001116  43F9 00002FA6            130  LAST_DIGIT_ODD      LEA     ODD_ERROR_MESSAGE, A1 
0000111C  103C 000E                131                      MOVE.B  #14, D0
00001120  4E4F                     132                      TRAP    #15
00001122                           133                      
00001122  BC3C 0000                134                      CMP.B   #0,D6           ; When D6 is 0
00001126  6700 FEF0                135                      BEQ     PROMPT_START    ; Go back to start prompt
0000112A  BC3C 0001                136                      CMP.B   #1,D6           ; When D6 is 1
0000112E  6700 FF10                137                      BEQ     PROMPT_END      ; Go back to end prompt
00001132                           138  *--------------------------------------------------------------------------------------
00001132                           139  * param D2 data size to convert into ASCII
00001132                           140  * param A2 a pointer to decode_buf
00001132                           141  * param A5 the current address
00001132                           142  * itoa (D2, A2, A5) {
00001132                           143  * D0 byte data in ACII
00001132                           144  * D1 #sfhit
00001132                           145  * D7 long data to convert into ASCII
00001132                           146  * }
00001132                           147          
00001132                           148  ITOA                                ; convert integer to ASCII  
00001132  48E7 C000                149          MOVEM.L D0-D1,-(SP) 
00001136  B43C 0000                150          CMP.B   #%00, D2            ; byte
0000113A  6700 007E                151          BEQ     ITOA_BYTE
0000113E  B43C 0001                152          CMP.B   #%01, D2            ; word
00001142  6700 0096                153          BEQ     ITOA_WORD
00001146  B43C 0002                154          CMP.B   #%10, D2            ; long
0000114A  6700 00EC                155          BEQ     ITOA_LONG
0000114E  4EF9 0000126A            156          JMP     ITOA_LONGADDRESS    ; long address
00001154                           157          
00001154                           158  ITOA_MOVE                           ; convert integer to ASCII
00001154  48E7 C000                159          MOVEM.L D0-D1,-(SP) 
00001158  B43C 0001                160          CMP.B   #%01, D2            ; byte
0000115C  6700 005C                161          BEQ     ITOA_BYTE
00001160  B43C 0003                162          CMP.B   #%11, D2            ; word
00001164  6700 0074                163          BEQ     ITOA_WORD
00001168  B43C 0002                164          CMP.B   #%10,D2             ; long
0000116C  6700 00CA                165          BEQ     ITOA_LONG
00001170  4EF9 0000126A            166          JMP     ITOA_LONGADDRESS    ; long address
00001176                           167          
00001176                           168  ITOA_OPMODE                         ; convert integer to ASCII
00001176  48E7 C000                169          MOVEM.L D0-D1,-(SP) 
0000117A  B43C 0000                170          CMP.B   #%000,D2            ; When 0 then byte
0000117E  6700 003A                171          BEQ     ITOA_BYTE
00001182  B43C 0004                172          CMP.B   #%100,D2            ; When 4 then byte
00001186  6700 0032                173          BEQ     ITOA_BYTE 
0000118A  B43C 0001                174          CMP.B   #%001,D2            ; When 1 then word
0000118E  6700 004A                175          BEQ     ITOA_WORD
00001192  B43C 0003                176          CMP.B   #%011,D2            ; When 3 then word
00001196  6700 0042                177          BEQ     ITOA_WORD
0000119A  B43C 0005                178          CMP.B   #%101,D2            ; When 5 then word
0000119E  6700 003A                179          BEQ     ITOA_WORD 
000011A2  B43C 0002                180          CMP.B   #%010,D2            ; When 2 then long
000011A6  6700 0090                181          BEQ     ITOA_LONG
000011AA  B43C 0006                182          CMP.B   #%110,D2            ; When 6 then long
000011AE  6700 0088                183          BEQ     ITOA_LONG
000011B2  B43C 0007                184          CMP.B   #%111,D2            ; When 7 then long
000011B6  6700 0080                185          BEQ     ITOA_LONG
000011BA                           186          
000011BA                           187  ITOA_BYTE
000011BA  3E1D                     188          MOVE.W  (A5)+,D7
000011BC  4EB9 000012A2            189          JSR     ITOA_BYTE_CONVERT
000011C2  4EF9 000012DE            190          JMP     ITOA_DONE
000011C8                           191  
000011C8                           192  ITOA_BYTE_BRANCH
000011C8  48E7 C000                193          MOVEM.L D0-D1,-(SP)
000011CC  3E05                     194          MOVE.W  D5,D7
000011CE  4EB9 000012A2            195          JSR     ITOA_BYTE_CONVERT
000011D4  4EF9 000012DE            196          JMP     ITOA_DONE
000011DA                           197          
000011DA                           198  ITOA_WORD
000011DA  3E15                     199          MOVE.W  (A5),D7
000011DC  123C 0008                200          MOVE.B  #right8, D1
000011E0  E26F                     201          LSR.W   D1,D7
000011E2  4EB9 000012A2            202          JSR     ITOA_BYTE_CONVERT
000011E8  3E1D                     203          MOVE.W  (A5)+, D7
000011EA  4EB9 000012A2            204          JSR     ITOA_BYTE_CONVERT
000011F0  4EF9 000012DE            205          JMP     ITOA_DONE
000011F6                           206          
000011F6                           207  ITOA_WORD_BRANCH
000011F6  48E7 C000                208          MOVEM.L D0-D1,-(SP) 
000011FA  3E05                     209          MOVE.W  D5,D7
000011FC  123C 0008                210          MOVE.B  #right8, D1
00001200  E26F                     211          LSR.W   D1,D7
00001202  4EB9 000012A2            212          JSR     ITOA_BYTE_CONVERT
00001208  3E05                     213          MOVE.W  D5, D7
0000120A  361D                     214          MOVE.W  (A5)+,D3
0000120C  4EB9 000012A2            215          JSR     ITOA_BYTE_CONVERT
00001212  4EF9 000012DE            216          JMP     ITOA_DONE
00001218                           217          
00001218                           218  ITOA_WORD_ERROR
00001218  48E7 C000                219          MOVEM.L D0-D1,-(SP) 
0000121C  3E05                     220          MOVE.W  D5,D7
0000121E  123C 0008                221          MOVE.B  #right8, D1
00001222  E26F                     222          LSR.W   D1,D7
00001224  4EB9 000012A2            223          JSR     ITOA_BYTE_CONVERT
0000122A  3E05                     224          MOVE.W  D5,D7
0000122C  4EB9 000012A2            225          JSR     ITOA_BYTE_CONVERT
00001232  4EF9 000012DE            226          JMP     ITOA_DONE
00001238                           227          
00001238                           228  ITOA_LONG
00001238  3E15                     229          MOVE.W  (A5),D7
0000123A  123C 0008                230          MOVE.B  #right8, D1
0000123E  E26F                     231          LSR.W   D1, D7
00001240  4EB9 000012A2            232          JSR     ITOA_BYTE_CONVERT
00001246  3E1D                     233          MOVE.W  (A5)+, D7
00001248  4EB9 000012A2            234          JSR     ITOA_BYTE_CONVERT
0000124E                           235          
0000124E  3E15                     236          MOVE.W  (A5),D7
00001250  123C 0008                237          MOVE.B  #right8, D1
00001254  E26F                     238          LSR.W   D1, D7
00001256  4EB9 000012A2            239          JSR     ITOA_BYTE_CONVERT
0000125C  3E1D                     240          MOVE.W  (A5)+, D7
0000125E  4EB9 000012A2            241          JSR     ITOA_BYTE_CONVERT
00001264  4EF9 000012DE            242          JMP     ITOA_DONE
0000126A                           243  
0000126A                           244  ITOA_LONGADDRESS
0000126A  3E0D                     245          MOVE.W  A5,D7
0000126C  123C 0018                246          MOVE.B  #right24,D1
00001270  E26F                     247          LSR.W   D1,D7
00001272  4EB9 000012A2            248          JSR     ITOA_BYTE_CONVERT
00001278  3E0D                     249          MOVE.W  A5,D7
0000127A  123C 0010                250          MOVE.B  #right16,D1
0000127E  E26F                     251          LSR.W   D1,D7
00001280  4EB9 000012A2            252          JSR     ITOA_BYTE_CONVERT
00001286  3E0D                     253          MOVE.W  A5,D7
00001288  123C 0008                254          MOVE.B  #right8,D1
0000128C  E26F                     255          LSR.W   D1,D7
0000128E  4EB9 000012A2            256          JSR     ITOA_BYTE_CONVERT
00001294  3E0D                     257          MOVE.W  A5,D7
00001296  4EB9 000012A2            258          JSR     ITOA_BYTE_CONVERT   
0000129C  4EF9 000012DE            259          JMP     ITOA_DONE   
000012A2                           260  
000012A2                           261  ITOA_BYTE_CONVERT
000012A2  3007                     262          MOVE.W  D7, D0 
000012A4  0240 00F0                263          ANDI.W  #$F0, D0
000012A8  123C 0004                264          MOVE.B  #right4, D1
000012AC  E268                     265          LSR.W   D1, D0
000012AE  4EB9 000012C2            266          JSR     ITOA_NIBBLE_CONVERT
000012B4                           267          
000012B4  3007                     268          MOVE.W  D7, D0
000012B6  0240 000F                269          ANDI.W  #$0F, D0
000012BA  4EB9 000012C2            270          JSR     ITOA_NIBBLE_CONVERT
000012C0  4E75                     271          RTS
000012C2                           272          
000012C2                           273  ITOA_NIBBLE_CONVERT
000012C2  B03C 0009                274          CMP.B   #9, D0
000012C6  6E00 000A                275          BGT     ITOA_CONVERT_A_TO_F
000012CA  0600 0030                276          ADD.B   #$30, D0
000012CE  14C0                     277          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
000012D0  4E75                     278          RTS
000012D2                           279          
000012D2                           280  ITOA_CONVERT_A_TO_F
000012D2  0400 000A                281          SUBI.B  #10, D0
000012D6  0600 0041                282          ADDI.B  #$41, D0
000012DA  14C0                     283          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
000012DC  4E75                     284          RTS
000012DE                           285  
000012DE                           286  ITOA_DONE
000012DE  4CDF 0003                287          MOVEM.L (SP)+, D0-D1
000012E2  4E75                     288          RTS
000012E4                           289  *-------------------------------------------------------------------------------*
000012E4                           290  START_DECODING
000012E4  4282                     291          CLR.L   D2
000012E6                           292          
000012E6                           293  DECODING_ITERATION
000012E6                           294          ;decoding the current address
000012E6  4EB9 00001396            295          JSR     DECODE_MEMORY
000012EC  103C 000D                296          MOVE.B  #task13, D0
000012F0  43F9 00005000            297          LEA     decoded_buffer, A1
000012F6  4E4F                     298          TRAP    #15
000012F8                           299          
000012F8                           300          ;check if decoding has finished or if the screen is filled 
000012F8  BDCD                     301          CMP.L   A5, A6
000012FA  6F00 0022                302          BLE     CONTINUE_OR_END     ; If A6-A5 <= 0, go to CONTINUE_OR_END 
000012FE                           303          
000012FE                           304          ;have yet to reach the ending address
000012FE  5202                     305          ADDQ.B  #1, D2              ; D2 (screen_line_counter)++
00001300  B43C 001E                306          CMP.B   #lines_p_screen, D2
00001304  6C00 0004                307          BGE     DECODE_PAUSE
00001308                           308          ;not yet reached the maximum lines per screen. 
00001308  60DC                     309          BRA     DECODING_ITERATION
0000130A                           310  
0000130A                           311  DECODE_PAUSE
0000130A  103C 000E                312          MOVE.B  #task14, D0
0000130E  43F9 00003196            313          LEA     ENTER_PROMPT, A1
00001314  4E4F                     314          TRAP    #15
00001316  103C 0005                315          MOVE.B  #task5, D0
0000131A  4E4F                     316          TRAP    #15
0000131C  60C6                     317          BRA     START_DECODING
0000131E                           318  
0000131E                           319  CONTINUE_OR_END
0000131E  4280                     320          CLR.L   D0
00001320  4281                     321          CLR.L   D1
00001322  4282                     322          CLR.L   D2
00001324  4283                     323          CLR.L   D3
00001326  4284                     324          CLR.L   D4
00001328  4285                     325          CLR.L   D5
0000132A  4286                     326          CLR.L   D6
0000132C  4287                     327          CLR.L   D7
0000132E  327C 0000                328          MOVEA   #0,A1
00001332  347C 0000                329          MOVEA   #0,A2
00001336  367C 0000                330          MOVEA   #0,A3
0000133A  387C 0000                331          MOVEA   #0,A4
0000133E  3A7C 0000                332          MOVEA   #0,A5
00001342  3C7C 0000                333          MOVEA   #0,A6
00001346                           334  
00001346  103C 000E                335          MOVE.B  #task14, D0
0000134A  43F9 000031B3            336          LEA     PROMPT_AGAIN, A1
00001350  4E4F                     337          TRAP    #15
00001352                           338          
00001352  103C 0002                339          MOVE.B  #task2, D0
00001356  43F9 00002E80            340          LEA     ascii_y_n, A1
0000135C  4E4F                     341          TRAP    #15
0000135E                           342          
0000135E  1639 00002E80            343          MOVE.B  ascii_y_n, D3
00001364  0C03 0059                344          CMPI.B  #y_uppercase, D3
00001368  6700 FCAE                345          BEQ     PROMPT_START
0000136C  0C03 0079                346          CMPI.B  #y_lowercase, D3
00001370  6700 FCA6                347          BEQ     PROMPT_START
00001374  0C03 004E                348          CMPI.B  #n_uppercase, D3
00001378  6700 000C                349          BEQ     EXIT
0000137C  0C03 006E                350          CMPI.B  #n_lowercase, D3
00001380  6700 0004                351          BEQ     EXIT
00001384  6098                     352          BRA     CONTINUE_OR_END 
00001386                           353          
00001386                           354  EXIT
00001386  103C 000E                355          MOVE.B  #task14, D0
0000138A  43F9 000031D6            356          LEA     EXIT_PROMPT, A1
00001390  4E4F                     357          TRAP    #15  
00001392  6000 1AE8                358          BRA     DONE             
00001396                           359  *---------------------------------------------------------------------------------*
00001396                           360  * D0: the current instruction. 
00001396                           361  * D1: used as temp storage
00001396                           362  * D2: data size 
00001396                           363  * D3: loop counter for the amount of lines per screen. 
00001396                           364  * D4: 
00001396                           365  * D5: #shifts
00001396                           366  * D6: store first nibble
00001396                           367  * D7: 
00001396                           368  * A0: 
00001396                           369  * A1: A pointer to the message to print out. 
00001396                           370  * A2: A pointer to the decode_buffer. 
00001396                           371  * A3: 
00001396                           372  * A4: Store the starting address and increment to the ending address. 
00001396                           373  * A5: The current address. 
00001396                           374  * A6: Store the ending address. 
00001396                           375  * A7: Stack pointer. 
00001396                           376  *---------------------------------------------------------------------------------*                             
00001396                           377  DECODE_MEMORY       
00001396  48E7 2002                378          MOVEM.L D2/A6, -(SP)
0000139A                           379                  
0000139A                           380          ;zero clear the decode_buffer
0000139A  4EB9 000013D2            381          JSR     OP_CLEAR_DATA
000013A0  45F9 00005000            382          LEA     decoded_buffer, A2  Load decode buffer into A2
000013A6                           383                  
000013A6                           384          ;print out the current address
000013A6  7403                     385          MOVE.L  #$0003, D2
000013A8  4EB8 1132                386          JSR      ITOA
000013AC                           387          
000013AC  14FC 0009                388          MOVE.B  #$9, (A2)+  ; Add space after long address
000013B0                           389                  
000013B0                           390          ;load the next instruction and jump to the opcode table entry
000013B0  41F9 000013E8            391          LEA     OP_TABLE, A0
000013B6  4280                     392          CLR.L   D0
000013B8  301D                     393          MOVE.W  (A5)+, D0       ; Store A5's value into D0, then increment A5
000013BA  2200                     394          MOVE.L  D0, D1          ; Store A5's value from D0 into D1
000013BC  1A3C 000C                395          MOVE.B  #right12, D5    ; Store 12 into D5
000013C0  EA69                     396          LSR.W   D5, D1          ; Shift first nibble into LSB position
000013C2  2C01                     397          MOVE.L  D1, D6          ; Store first nibble into D6
000013C4  C2FC 0006                398          MULU    #6, D1          ; Multiply 6 to D1
000013C8  4EF0 1000                399          JMP     0(A0, D1)       ; Go to displacement (A0 + D1 * 6)      
000013CC                           400  OP_FINISH
000013CC  4CDF 4004                401          MOVEM.L (SP)+, D2/A6,
000013D0  4E75                     402          RTS
000013D2                           403  *------------------------------------------------------------------------------------*
000013D2                           404  *Clear the 32 bits within the decoded_buffer       
000013D2                           405  OP_CLEAR_DATA
000013D2  4283                     406          CLR.L   D3
000013D4  163C 0040                407          MOVE.B  #buffer_size, D3
000013D8  45F9 00005000            408          LEA     decoded_buffer, A2
000013DE                           409          
000013DE                           410  OP_CLEAR_DATA_LOOP
000013DE  14FC 0000                411          MOVE.B  #0, (A2)+
000013E2  5343                     412          SUBI    #1, D3
000013E4  6EF8                     413          BGT     OP_CLEAR_DATA_LOOP
000013E6  4E75                     414          RTS
000013E8                           415  
000013E8                           416  *------------------------------------------------------------------------------------*
000013E8                           417  OP_TABLE
000013E8  4EF9 00001448            418          JMP     code0000    ; ADDI.bwl/ ANDI.bwl / CMPI.bwl / EORI.bwl / ORI.bwl / SUBI.bwl 
000013EE  4EF9 00001462            419          JMP     code0001    ; MOVE.b
000013F4  4EF9 00001466            420          JMP     code0010    ; MOVE.l / MOVEA.l
000013FA  4EF9 0000147E            421          JMP     code0011    ; MOVE.w / MOVEA.w
00001400  4EF9 00001496            422          JMP     code0100    ; CLR.bwl / JMP / JSR / LEA / MOVEM.wl / NOP / NOT.bwl / RTS / STOP / TRAP
00001406  4EF9 000014B0            423          JMP     code0101    ; ADDQ.bwl / SUBQ.bwl / Scc / Dbcc
0000140C  4EF9 000014B4            424          JMP     code0110    ; BRA.bw / BSR.bw / Bcc.bw
00001412  4EF9 00001540            425          JMP     code0111    ; MOVEQ
00001418  4EF9 00001544            426          JMP     code1000    ; DIVS / DIVU / CR.bwl
0000141E  4EF9 00001564            427          JMP     code1001    ; SUB.bwl / SUBA.wl
00001424  4EF9 00001568            428          JMP     code1010    ;   [unassigned]
0000142A  4EF9 0000156C            429          JMP     code1011    ; CMP.bwl / CMPA.wl / EOR.bwl
00001430  4EF9 00001570            430          JMP     code1100    ; MULS / MULU / AND.bwl
00001436  4EF9 0000158A            431          JMP     code1101    ; ADD.bwl / ADDA.wl / ADDX.bwl
0000143C  4EF9 000015A4            432          JMP     code1110    ; ASL.bwl / ASR.bwl / LSL.bwl / LSR.bwl / ROR.bwl / ROL.bwl
00001442  4EF9 00001622            433          JMP     code1111    ;   [unassigned]
00001448                           434          
00001448                           435  code0000                            ; Opcodes ADDI and SUBI
00001448  2200                     436          MOVE.L  D0,D1               ; D0 is current instruction word
0000144A  0241 0F00                437          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
0000144E  1A3C 0008                438          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001452  EA69                     439          LSR.W   D5,D1               ; Shift nibble into LSB position
00001454  C2FC 0006                440          MULU    #6, D1              ; Set displacement 
00001458  41F9 00001626            441          LEA     OP_0000_TABLE,A0    ; Load table into A0
0000145E  4EF0 1000                442          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00001462                           443  
00001462                           444  code0001                            ; Opcode MOVE.B
00001462  6000 052E                445          BRA     OP_MOVE             ; Go to opcode MOVE
00001466                           446  
00001466                           447  code0010                            ; Opcodes MOVE.L and MOVEA.L 
00001466  2200                     448          MOVE.L  D0,D1               ; D0 is current instruction word
00001468  0241 01C0                449          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000146C  1A3C 0006                450          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001470  EA69                     451          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001472  B23C 0001                452          CMP.B   #1, D1              ; When 001 in destination mode
00001476  6700 04F6                453          BEQ     OP_MOVEA            ; Go to opcode MOVEA
0000147A  6000 0516                454          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
0000147E                           455  
0000147E                           456  code0011                            ; Opcodes MOVE.W and MOVEA.W 
0000147E  2200                     457          MOVE.L  D0,D1               ; D0 is current instruction word
00001480  0241 01C0                458          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001484  1A3C 0006                459          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001488  EA69                     460          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000148A  B23C 0001                461          CMP.B   #1, D1              ; When 001 in destination mode
0000148E  6700 04DE                462          BEQ     OP_MOVEA            ; Go to opcode MOVEA
00001492  6000 04FE                463          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001496                           464  
00001496                           465  code0100                            ; Opcodes CLR, JSR, LEA, MOVEM, NOP, RTS
00001496  2200                     466          MOVE.L  D0,D1               ; D0 is current instruction word
00001498  0241 0F00                467          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
0000149C  1A3C 0008                468          MOVE.B  #right8,D5          ; Used to shift 8 times to right
000014A0  EA69                     469          LSR.W   D5,D1               ; Shift nibble into LSB position
000014A2  C2FC 0006                470          MULU    #6, D1              ; Set displacement 
000014A6  41F9 00001686            471          LEA     OP_0100_TABLE,A0    ; Load table into A0
000014AC  4EF0 1000                472          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000014B0                           473  
000014B0                           474  code0101                            ; Opcode ADDQ.B/W/L
000014B0  6000 0598                475          BRA     OP_ADDQ             ; Go to opcode ADDQ
000014B4                           476  
000014B4                           477  code0110                            ; Opcodes BRA / BSR / BHI
000014B4  2200                     478          MOVE.L  D0,D1               ; D0 is current instruction word
000014B6  0241 0F00                479          ANDI.W  #second_nibble,D1   ; Extract 2nd 4 bits from instruction word
000014BA  1A3C 0008                480          MOVE.B  #right8,D5          ; Used to shift 8 times to right
000014BE  EA69                     481          LSR.W   D5,D1               ; Shift nibble into LSB position
000014C0  B23C 0000                482          CMP.B   #0, D1              ; When 0000 in second nibble 
000014C4  6700 05A4                483          BEQ     OP_BRA              ; Go to opcode BRA
000014C8  B23C 0001                484          CMP.B   #1, D1              ; When 0001 in second nibble 
000014CC  6700 05B8                485          BEQ     OP_BSR              ; Go to opcode BSR
000014D0  B23C 0002                486          CMP.B   #2, D1              ; When 0010 in second nibble 
000014D4  6700 05CC                487          BEQ     OP_BHI              ; Go to opcode BHI
000014D8  B23C 0003                488          CMP.B   #3, D1              ; When 0011 in second nibble
000014DC  6700 05E0                489          BEQ     OP_BLS              ; Go to opcode BLS
000014E0  B23C 0004                490          CMP.B   #4, D1              ; When 0100 in second nibble
000014E4  6700 05F4                491          BEQ     OP_BCC              ; Go to opcode BCC
000014E8  B23C 0005                492          CMP.B   #5, D1              ; When 0101 in second nibble
000014EC  6700 0608                493          BEQ     OP_BCS              ; Go to opcode BCS
000014F0  B23C 0006                494          CMP.B   #6, D1              ; When 0110 in second nibble
000014F4  6700 061C                495          BEQ     OP_BNE              ; Go to opcode BNE
000014F8  B23C 0007                496          CMP.B   #7, D1              ; When 0111 in second nibble
000014FC  6700 0630                497          BEQ     OP_BEQ              ; Go to opcode BEQ
00001500  B23C 0008                498          CMP.B   #8, D1              ; When 1000 in second nibble
00001504  6700 0644                499          BEQ     OP_BVC              ; Go to opcode BVC
00001508  B23C 0009                500          CMP.B   #9, D1              ; When 1001 in second nibble
0000150C  6700 0658                501          BEQ     OP_BVS              ; Go to opcode BVS
00001510  B23C 000A                502          CMP.B   #10, D1             ; When 1010 in second nibble
00001514  6700 066C                503          BEQ     OP_BPL              ; Go to opcode BPL
00001518  B23C 000B                504          CMP.B   #11, D1             ; When 1011 in second nibble
0000151C  6700 0680                505          BEQ     OP_BMI              ; Go to opcode BMI
00001520  B23C 000C                506          CMP.B   #12, D1             ; When 1100 in second nibble
00001524  6700 0694                507          BEQ     OP_BGE              ; Go to opcode BGE
00001528  B23C 000D                508          CMP.B   #13, D1             ; When 1101 in second nibble
0000152C  6700 06A8                509          BEQ     OP_BLT              ; Go to opcode BLT
00001530  B23C 000E                510          CMP.B   #14, D1             ; When 1110 in second nibble
00001534  6700 06BC                511          BEQ     OP_BGT              ; Go to opcode BGT
00001538  B23C 000F                512          CMP.B   #15, D1             ; When 1111 in second nibble
0000153C  6700 06D0                513          BEQ     OP_BLE              ; Go to opcode BLE
00001540                           514  
00001540                           515  code0111                            ; Opcode MOVEQ
00001540  6000 06E8                516          BRA     OP_MOVEQ            ; Go to opcode MOVEQ
00001544                           517  
00001544                           518  code1000                            ; Opcodes DIVU word and OR.B/W/L
00001544  2200                     519          MOVE.L  D0,D1               ; D0 is current instruction word
00001546  0241 01C0                520          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000154A  1A3C 0006                521          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000154E  EA69                     522          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001550  B23C 0003                523          CMP.B   #3,D1               ; When 011 in destination mode
00001554  6700 06F8                524          BEQ     OP_DIVU             ; Go to opcode DIVU word
00001558  B23C 0007                525          CMP.B   #7,D1               ; When 111
0000155C  6700 03CC                526          BEQ     OP_UNSUPPORTED      ; Go to opcode unsupported
00001560  6000 070C                527          BRA     OP_OR               ; Otherwise, go to opcode OR
00001564                           528  
00001564                           529  code1001                            ; Opcode SUB.B/W/L
00001564  6000 0720                530          BRA     OP_SUB              ; Go to opcode SUB   
00001568                           531          
00001568                           532  code1010                            ; Opcode not supported 
00001568  6000 03C0                533          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
0000156C                           534       
0000156C                           535  code1011                            ; Opcode CMP.B/W/L
0000156C  6000 0734                536          BRA     OP_CMP              ; Go to opcode CMP
00001570                           537  
00001570                           538  code1100                            ; Opcodes MULS, MULU, AND.B/W/L
00001570  2200                     539          MOVE.L  D0,D1               ; D0 is current instruction word
00001572  0241 01C0                540          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001576  1A3C 0006                541          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000157A  EA69                     542          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000157C  C2FC 0006                543          MULU    #6, D1              ; Set displacement 
00001580  41F9 000016E6            544          LEA     OP_1100_TABLE,A0    ; Load table into A0
00001586  4EF0 1000                545          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
0000158A                           546  
0000158A                           547  code1101                            ; Opcodes ADD.B/W/L, ADDA.B/W/L
0000158A  2200                     548          MOVE.L  D0,D1               ; D0 is current instruction word
0000158C  0241 01C0                549          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001590  1A3C 0006                550          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001594  EA69                     551          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001596  C2FC 0006                552          MULU    #6, D1              ; Set displacement 
0000159A  41F9 00001746            553          LEA     OP_1101_TABLE,A0    ; Load table into A0
000015A0  4EF0 1000                554          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
000015A4                           555  
000015A4                           556  code1110                            ; Opcodes ASL.B/W/L, ASR.B/W/L, LSL.B/W/L, LSR.B/W/L, ROL.B/W/L, ROR.B/W/L   
000015A4  2200                     557          MOVE.L  D0,D1               ; D0 is current instruction word
000015A6  0241 01C0                558          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000015AA  1A3C 0006                559          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000015AE  EA69                     560          LSR.W   D5,D1               ; Shift dst mode into LSB position
000015B0                           561     
000015B0                           562          ; Check Memory Shifts
000015B0  B23C 0007                563          CMP.B   #7, D1              ; When 111
000015B4  6700 0024                564          BEQ     MEMORY_1110_LEFT    ; Go to Memory Shift Left Side
000015B8                           565      
000015B8  B23C 0003                566          CMP.B   #3, D1              ; When 011
000015BC  6700 0040                567          BEQ     MEMORY_1110_RIGHT   ; Go Memory Shift Right Side
000015C0                           568      
000015C0                           569          ; Check Register Shifts
000015C0  2200                     570          MOVE.L  D0,D1                       ; D0 is current instruction word
000015C2  0241 0038                571          ANDI.W  #src_mode,D1                ; Extract 5-3 bits from instruction word
000015C6  1A3C 0003                572          MOVE.B  #right3,D5                  ; Used to shift 3 times to right
000015CA  EA69                     573          LSR.W   D5,D1                       ; Shift 5-3 bits into LSB position
000015CC  C2FC 0006                574          MULU    #6,D1                       ; Set displacement 
000015D0  41F9 000017A6            575          LEA     OP_1110_TABLE_REGISTER,A0   ; Load table into A0
000015D6  4EF0 1000                576          JMP     0(A0,D1)                    ; go to displacement (A0 + D1 * 6)
000015DA                           577  
000015DA                           578  MEMORY_1110_LEFT    
000015DA  2200                     579          MOVE.L  D0,D1               ; D0 is current instruction word
000015DC  0241 0E00                580          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
000015E0  1A3C 0009                581          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000015E4  EA69                     582          LSR.W   D5,D1               ; Shift dst reg into LSB position
000015E6  B23C 0000                583          CMP.B   #0,D1               ; When D1 is 0
000015EA  6700 0786                584          BEQ     OP_ASL              ; Go to opcode ASL
000015EE  B23C 0001                585          CMP.B   #1, D1              ; when D1 is 1
000015F2  6700 07B6                586          BEQ     OP_LSL              ; Go to opcode LSL
000015F6  B23C 0003                587          CMP.B   #3, D1              ; When D1 is 3
000015FA  6700 07E6                588          BEQ     OP_ROL              ; Go to opcode ROL
000015FE                           589  
000015FE                           590  MEMORY_1110_RIGHT
000015FE  2200                     591          MOVE.L  D0,D1               ; D0 is current instruction word
00001600  0241 0E00                592          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
00001604  1A3C 0009                593          MOVE.B  #right9,D5          ; Used to shift 9 times to right
00001608  EA69                     594          LSR.W   D5,D1               ; Shift dst reg into LSB position
0000160A  B23C 0000                595          CMP.B   #0,D1               ; When D1 is 0
0000160E  6700 0746                596          BEQ     OP_ASR              ; Go to opcode ASR
00001612  B23C 0001                597          CMP.B   #1, D1              ; when D1 is 1
00001616  6700 0776                598          BEQ     OP_LSR              ; Go to opcode LSR
0000161A  B23C 0003                599          CMP.B   #3, D1              ; When D1 is 3
0000161E  6700 07A6                600          BEQ     OP_ROR              ; Go to opcode ROR
00001622                           601  
00001622                           602  code1111                            ; Opcode not supported 
00001622  6000 0306                603          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
00001626                           604           
00001626                           605  OP_0000_TABLE
00001626  4EF9 0000192A            606          JMP     OP_UNSUPPORTED  ; 0 Go to opcode unsupported  
0000162C  4EF9 0000192A            607          JMP     OP_UNSUPPORTED  ; 1 Go to opcode unsupported  
00001632  4EF9 0000192A            608          JMP     OP_UNSUPPORTED  ; 2 Go to opcode unsupported  
00001638  4EF9 0000192A            609          JMP     OP_UNSUPPORTED  ; 3 Go to opcode unsupported  
0000163E  4EF9 0000192E            610          JMP     OP_SUBI         ; 4 Go to opcode SUBI
00001644  4EF9 0000192A            611          JMP     OP_UNSUPPORTED  ; 5 Go to opcode unsupported  
0000164A  4EF9 0000194E            612          JMP     OP_ADDI         ; 6 Go to opcode ADDI
00001650  4EF9 0000192A            613          JMP     OP_UNSUPPORTED  ; 7 Go to opcode unsupported  
00001656  4EF9 0000192A            614          JMP     OP_UNSUPPORTED  ; 8 Go to opcode unsupported  
0000165C  4EF9 0000192A            615          JMP     OP_UNSUPPORTED  ; 9 Go to opcode unsupported  
00001662  4EF9 0000192A            616          JMP     OP_UNSUPPORTED  ; A Go to opcode unsupported  
00001668  4EF9 0000192A            617          JMP     OP_UNSUPPORTED  ; B Go to opcode unsupported  
0000166E  4EF9 0000192A            618          JMP     OP_UNSUPPORTED  ; C Go to opcode unsupported  
00001674  4EF9 0000192A            619          JMP     OP_UNSUPPORTED  ; D Go to opcode unsupported  
0000167A  4EF9 0000192A            620          JMP     OP_UNSUPPORTED  ; E Go to opcode unsupported  
00001680  4EF9 0000192A            621          JMP     OP_UNSUPPORTED  ; F Go to opcode unsupported  
00001686                           622      
00001686                           623  OP_0100_TABLE
00001686  4EF9 0000192A            624          JMP     OP_UNSUPPORTED      ; 0 Go to opcode unsupported  
0000168C  4EF9 00001A2E            625          JMP     OP_LEA              ; 1 Go to opcode LEA
00001692  4EF9 000019B2            626          JMP     OP_CLR              ; 2 Go to opcode CLR
00001698  4EF9 00001A2E            627          JMP     OP_LEA              ; 3 Go to opcode LEA
0000169E  4EF9 0000192A            628          JMP     OP_UNSUPPORTED      ; 4 Go to opcode unsupported  
000016A4  4EF9 00001A2E            629          JMP     OP_LEA              ; 5 Go to opcode LEA
000016AA  4EF9 0000194E            630          JMP     OP_ADDI             ; 6 Go to opcode ADDI
000016B0  4EF9 00001A2E            631          JMP     OP_LEA              ; 7 Go to opcode LEA
000016B6  4EF9 00001A0A            632          JMP     OP_MOVEM            ; 8 Go to opcode MOVEM
000016BC  4EF9 00001A2E            633          JMP     OP_LEA              ; 9 Go to opcode LEA
000016C2  4EF9 0000192A            634          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000016C8  4EF9 00001A2E            635          JMP     OP_LEA              ; B Go to opcode LEA
000016CE  4EF9 00001A0A            636          JMP     OP_MOVEM            ; C Go to opcode MOVEM
000016D4  4EF9 00001A2E            637          JMP     OP_LEA              ; D Go to opcode LEA
000016DA  4EF9 0000186C            638          JMP     JSR_NOP_RTS         ; E Go to opcode JSR, NOP, or RTS
000016E0  4EF9 0000192A            639          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000016E6                           640      
000016E6                           641  OP_1100_TABLE
000016E6  4EF9 00001CFE            642          JMP     OP_AND              ; 0 Go to opcode AND 
000016EC  4EF9 00001CFE            643          JMP     OP_AND              ; 1 Go to opcode AND
000016F2  4EF9 00001CFE            644          JMP     OP_AND              ; 2 Go to opcode AND
000016F8  4EF9 00001CBE            645          JMP     OP_MULU             ; 3 Go to opcode MULU
000016FE  4EF9 00001CFE            646          JMP     OP_AND              ; 4 Go to opcode AND 
00001704  4EF9 00001CFE            647          JMP     OP_AND              ; 5 Go to opcode AND
0000170A  4EF9 00001CFE            648          JMP     OP_AND              ; 6 Go to opcode AND
00001710  4EF9 00001CDE            649          JMP     OP_MULS             ; 7 Go to opcode MULS
00001716  4EF9 0000192A            650          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000171C  4EF9 0000192A            651          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001722  4EF9 0000192A            652          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
00001728  4EF9 0000192A            653          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
0000172E  4EF9 0000192A            654          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001734  4EF9 0000192A            655          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000173A  4EF9 0000192A            656          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001740  4EF9 0000192A            657          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001746                           658      
00001746                           659  OP_1101_TABLE
00001746  4EF9 00001D1A            660          JMP     OP_ADD              ; 0 Go to opcode ADD 
0000174C  4EF9 00001D1A            661          JMP     OP_ADD              ; 1 Go to opcode ADD
00001752  4EF9 00001D1A            662          JMP     OP_ADD              ; 2 Go to opcode ADD
00001758  4EF9 00001D36            663          JMP     OP_ADDA             ; 3 Go to opcode ADDA
0000175E  4EF9 00001D1A            664          JMP     OP_ADD              ; 4 Go to opcode ADD 
00001764  4EF9 00001D1A            665          JMP     OP_ADD              ; 5 Go to opcode ADD
0000176A  4EF9 00001D1A            666          JMP     OP_ADD              ; 6 Go to opcode ADD
00001770  4EF9 00001D36            667          JMP     OP_ADDA             ; 7 Go to opcode ADDA
00001776  4EF9 0000192A            668          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000177C  4EF9 0000192A            669          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001782  4EF9 0000192A            670          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
00001788  4EF9 0000192A            671          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
0000178E  4EF9 0000192A            672          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001794  4EF9 0000192A            673          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000179A  4EF9 0000192A            674          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
000017A0  4EF9 0000192A            675          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000017A6                           676      
000017A6                           677  OP_1110_TABLE_REGISTER
000017A6  4EF9 00001806            678          JMP     OP_AS_CHECK         ; 0 Check if AS is left or right
000017AC  4EF9 00001828            679          JMP     OP_LS_CHECK         ; 1 Check if LS is left or right
000017B2  4EF9 0000192A            680          JMP     OP_UNSUPPORTED      ; 2 Go to opcode unsupported  
000017B8  4EF9 0000184A            681          JMP     OP_RO_CHECK         ; 3 Check if RO is left or right
000017BE  4EF9 00001806            682          JMP     OP_AS_CHECK         ; 4 Check if AS is left or right
000017C4  4EF9 00001828            683          JMP     OP_LS_CHECK         ; 5 Check if LS is left or right
000017CA  4EF9 0000192A            684          JMP     OP_UNSUPPORTED      ; 6 Go to opcode unsupported 
000017D0  4EF9 0000184A            685          JMP     OP_RO_CHECK         ; 7 Check if RO is left or right
000017D6  4EF9 0000192A            686          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
000017DC  4EF9 0000192A            687          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
000017E2  4EF9 0000192A            688          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000017E8  4EF9 0000192A            689          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
000017EE  4EF9 0000192A            690          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
000017F4  4EF9 0000192A            691          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
000017FA  4EF9 0000192A            692          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001800  4EF9 0000192A            693          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001806                           694  
00001806                           695  OP_AS_CHECK
00001806  2200                     696          MOVE.L  D0,D1               ; D0 is current instruction word
00001808  0241 01C0                697          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
0000180C  1A3C 0006                698          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001810  EA69                     699          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001812  0201 0004                700          ANDI.B  #4,D1               ; Get only bit 8 (dr)
00001816  E449                     701          LSR.W   #2,D1
00001818                           702  
00001818  B23C 0001                703          CMP.B   #1,D1               ; Go left
0000181C  6700 0554                704          BEQ     OP_ASL              ; 1 Go to opcode ASL
00001820  B23C 0000                705          CMP.B   #0,D1               ; Go right
00001824  6700 0530                706          BEQ     OP_ASR              ; 0 Go to opcode ASR
00001828                           707          
00001828                           708  OP_LS_CHECK
00001828  2200                     709          MOVE.L  D0,D1               ; D0 is current instruction word
0000182A  0241 01C0                710          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
0000182E  1A3C 0006                711          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001832  EA69                     712          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001834  0201 0004                713          ANDI.B  #4,D1               ; Get only bit 8 (dr)
00001838  E449                     714          LSR.W   #2,D1
0000183A                           715  
0000183A  B23C 0001                716          CMP.B   #1,D1               ; Go left
0000183E  6700 056A                717          BEQ     OP_LSL              ; 1 Go to opcode LSL
00001842  B23C 0000                718          CMP.B   #0,D1               ; Go right
00001846  6700 0546                719          BEQ     OP_LSR              ; 0 Go to opcode LSR
0000184A                           720          
0000184A                           721  OP_RO_CHECK
0000184A  2200                     722          MOVE.L  D0,D1               ; D0 is current instruction word
0000184C  0241 01C0                723          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00001850  1A3C 0006                724          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001854  EA69                     725          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001856  0201 0004                726          ANDI.B  #4,D1               ; Get only bit 8 (dr)
0000185A  E449                     727          LSR.W   #2,D1
0000185C                           728  
0000185C  B23C 0001                729          CMP.B   #1,D1               ; Go left
00001860  6700 0580                730          BEQ     OP_ROL              ; 1 Go to opcode ROL
00001864  B23C 0000                731          CMP.B   #0,D1               ; Go right
00001868  6700 055C                732          BEQ     OP_ROR              ; 0 Go to opcode ROR
0000186C                           733          
0000186C                           734  JSR_NOP_RTS
0000186C  2200                     735          MOVE.L  D0,D1               ; D0 is current instruction word
0000186E  0241 01C0                736          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001872  1A3C 0006                737          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001876  EA69                     738          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001878  B23C 0002                739          CMP.B   #2, D1              ; When 010 in destination mode
0000187C  6700 0170                740          BEQ     OP_JSR              ; Go to opcode JSR
00001880                           741          
00001880  2200                     742          MOVE.L  D0,D1               ; D0 is current instruction word
00001882  0241 000F                743          ANDI.W  #fourth_nibble,D1   ; Extract dst mode position from instruction word
00001886  B23C 0001                744          CMP.B   #1, D1  
0000188A  6700 000E                745          BEQ     NOP_CHECK
0000188E  B23C 0005                746          CMP.B   #5, D1  
00001892  6700 004E                747          BEQ     RTS_CHECK
00001896  6000 0092                748          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000189A                           749          
0000189A                           750  NOP_CHECK
0000189A  2200                     751          MOVE.L  D0,D1               ; D0 is current instruction word
0000189C  0241 F000                752          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
000018A0  1A3C 000C                753          MOVE.B  #right12,D5         ; Used to shift 6 times to right
000018A4  EA69                     754          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018A6  B23C 0004                755          CMP.B   #4, D1              
000018AA  6700 0006                756          BEQ     NOP_CHECK_TWO
000018AE  6000 007A                757          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018B2                           758          
000018B2                           759  NOP_CHECK_TWO
000018B2  2200                     760          MOVE.L  D0,D1               ; D0 is current instruction word
000018B4  0241 0F00                761          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
000018B8  1A3C 0008                762          MOVE.B  #right8,D5          ; Used to shift 6 times to right
000018BC  EA69                     763          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018BE  B23C 000E                764          CMP.B   #14, D1            
000018C2  6700 0006                765          BEQ     NOP_CHECK_THREE
000018C6  6000 0062                766          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018CA                           767  
000018CA                           768  NOP_CHECK_THREE
000018CA  2200                     769          MOVE.L  D0,D1               ; D0 is current instruction word
000018CC  0241 00F0                770          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
000018D0  1A3C 0004                771          MOVE.B  #right4,D5          ; Used to shift 6 times to right
000018D4  EA69                     772          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018D6  B23C 0007                773          CMP.B   #7, D1              
000018DA  6700 00F2                774          BEQ     OP_NOP
000018DE  6000 004A                775          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018E2                           776       
000018E2                           777  RTS_CHECK
000018E2  2200                     778          MOVE.L  D0,D1               ; D0 is current instruction word
000018E4  0241 F000                779          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
000018E8  1A3C 000C                780          MOVE.B  #right12,D5         ; Used to shift 6 times to right
000018EC  EA69                     781          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018EE  B23C 0004                782          CMP.B   #4, D1              
000018F2  6700 0006                783          BEQ     RTS_CHECK_TWO
000018F6  6000 0032                784          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018FA                           785          
000018FA                           786  RTS_CHECK_TWO
000018FA  2200                     787          MOVE.L  D0,D1               ; D0 is current instruction word
000018FC  0241 0F00                788          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
00001900  1A3C 0008                789          MOVE.B  #right8,D5          ; Used to shift 6 times to right
00001904  EA69                     790          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001906  B23C 000E                791          CMP.B   #14, D1             
0000190A  6700 0006                792          BEQ     RTS_CHECK_THREE
0000190E  6000 001A                793          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
00001912                           794  
00001912                           795  RTS_CHECK_THREE
00001912  2200                     796          MOVE.L  D0,D1               ; D0 is current instruction word
00001914  0241 00F0                797          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
00001918  1A3C 0004                798          MOVE.B  #right4,D5          ; Used to shift 6 times to right
0000191C  EA69                     799          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000191E  B23C 0007                800          CMP.B   #7, D1             
00001922  6700 00BA                801          BEQ     OP_RTS
00001926  6000 0002                802          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000192A                           803  
0000192A                           804  OP_UNSUPPORTED
0000192A  6000 14D6                805       BRA OP_ERROR       
0000192E                           806  *----------------------------------------------------------------------------------------------*
0000192E                           807  * param D0 the current instruction in word
0000192E                           808  * param D1 the EA type
0000192E                           809  * param A2 a pointer to the decode_buffer
0000192E                           810  * param A5 current address
0000192E                           811  * ea_start(D0, D1, A2, A5){
0000192E                           812  * D2: size
0000192E                           813  * D3: src mode, dst mode
0000192E                           814  * D4: src regs, dst regs
0000192E                           815  * D5: #shifts
0000192E                           816  * D7: immediate data
0000192E                           817  * A0: EA_TYPE_TABLE
0000192E                           818  *       0 = ea_immediate
0000192E                           819  * }
0000192E                           820  
0000192E                           821  *----------------------------------------------------------------------------------------------*
0000192E                           822  * First 4 bits: 0000
0000192E                           823  OP_SUBI
0000192E  14FC 0053                824          MOVE.B  #'S',(A2)+
00001932  14FC 0055                825          MOVE.B  #'U',(A2)+
00001936  14FC 0042                826          MOVE.B  #'B',(A2)+
0000193A  14FC 0049                827          MOVE.B  #'I',(A2)+
0000193E  223C 00000000            828          MOVE.L  #ea_type_immediate,D1
00001944  4EB9 00001DFE            829          JSR     EA_START
0000194A  4EF8 13CC                830          JMP     OP_FINISH
0000194E                           831          
0000194E                           832  OP_ADDI
0000194E  14FC 0041                833          MOVE.B  #'A',(A2)+
00001952  14FC 0044                834          MOVE.B  #'D',(A2)+
00001956  14FC 0044                835          MOVE.B  #'D',(A2)+
0000195A  14FC 0049                836          MOVE.B  #'I',(A2)+
0000195E  223C 00000000            837          MOVE.L  #ea_type_immediate,D1
00001964  4EB9 00001DFE            838          JSR     EA_START
0000196A  4EF8 13CC                839          JMP     OP_FINISH
0000196E                           840  
0000196E                           841  *-----------------------------------------------------------------------------------------------*
0000196E                           842  * First 4 bits: 0001
0000196E                           843  OP_MOVEA
0000196E  14FC 004D                844          MOVE.B  #'M',(A2)+
00001972  14FC 004F                845          MOVE.B  #'O',(A2)+
00001976  14FC 0056                846          MOVE.B  #'V',(A2)+
0000197A  14FC 0045                847          MOVE.B  #'E',(A2)+
0000197E  14FC 0041                848          MOVE.B  #'A',(A2)+
00001982  223C 00000002            849          MOVE.L  #ea_type_movea,D1
00001988  4EB9 00001DFE            850          JSR     EA_START
0000198E  4EF8 13CC                851          JMP     OP_FINISH
00001992                           852  
00001992                           853  *------------------------------------------------------------------------------------------------*
00001992                           854  * First 4 bits: 0011
00001992                           855  OP_MOVE
00001992  14FC 004D                856          MOVE.B  #'M',(A2)+
00001996  14FC 004F                857          MOVE.B  #'O',(A2)+
0000199A  14FC 0056                858          MOVE.B  #'V',(A2)+
0000199E  14FC 0045                859          MOVE.B  #'E',(A2)+
000019A2  223C 00000001            860          MOVE.L  #ea_type_move,D1
000019A8  4EB9 00001DFE            861          JSR     EA_START
000019AE  4EF8 13CC                862          JMP     OP_FINISH
000019B2                           863  
000019B2                           864  *------------------------------------------------------------------------------------------------*
000019B2                           865  * First 4 bits: 0100
000019B2                           866  OP_CLR
000019B2  14FC 0043                867          MOVE.B  #'C',(A2)+
000019B6  14FC 004C                868          MOVE.B  #'L',(A2)+
000019BA  14FC 0052                869          MOVE.B  #'R',(A2)+
000019BE  223C 00000004            870          MOVE.L  #ea_type_dstonly,D1
000019C4  4EB9 00001DFE            871          JSR     EA_START
000019CA  4EF8 13CC                872          JMP     OP_FINISH
000019CE                           873          
000019CE                           874  OP_NOP
000019CE  14FC 004E                875          MOVE.B  #'N',(A2)+
000019D2  14FC 004F                876          MOVE.B  #'O',(A2)+
000019D6  14FC 0050                877          MOVE.B  #'P',(A2)+
000019DA  4EF8 13CC                878          JMP     OP_FINISH
000019DE                           879          
000019DE                           880  OP_RTS
000019DE  14FC 0052                881          MOVE.B  #'R',(A2)+
000019E2  14FC 0054                882          MOVE.B  #'T',(A2)+
000019E6  14FC 0053                883          MOVE.B  #'S',(A2)+
000019EA  4EF8 13CC                884          JMP     OP_FINISH
000019EE                           885          
000019EE                           886  OP_JSR
000019EE  14FC 004A                887          MOVE.B  #'J',(A2)+
000019F2  14FC 0053                888          MOVE.B  #'S',(A2)+
000019F6  14FC 0052                889          MOVE.B  #'R',(A2)+
000019FA  223C 00000004            890          MOVE.L  #ea_type_dstonly,D1
00001A00  4EB9 00001DFE            891          JSR     EA_START
00001A06  4EF8 13CC                892          JMP     OP_FINISH
00001A0A                           893  
00001A0A                           894  OP_MOVEM
00001A0A  14FC 004D                895          MOVE.B  #'M',(A2)+
00001A0E  14FC 004F                896          MOVE.B  #'O',(A2)+
00001A12  14FC 0056                897          MOVE.B  #'V',(A2)+
00001A16  14FC 0045                898          MOVE.B  #'E',(A2)+
00001A1A  14FC 004D                899          MOVE.B  #'M',(A2)+
00001A1E  223C 00000006            900          MOVE.L  #ea_type_movem,D1
00001A24  4EB9 00001DFE            901          JSR     EA_START
00001A2A  4EF8 13CC                902          JMP     OP_FINISH
00001A2E                           903          
00001A2E                           904  OP_LEA
00001A2E  14FC 004C                905          MOVE.B  #'L',(A2)+
00001A32  14FC 0045                906          MOVE.B  #'E',(A2)+
00001A36  14FC 0041                907          MOVE.B  #'A',(A2)+
00001A3A  223C 00000003            908          MOVE.L  #ea_type_lea,D1
00001A40  4EB9 00001DFE            909          JSR     EA_START
00001A46  4EF8 13CC                910          JMP     OP_FINISH
00001A4A                           911  
00001A4A                           912  *------------------------------------------------------------------------------------------------*
00001A4A                           913  * First 4 bits: 0101
00001A4A                           914  OP_ADDQ
00001A4A  14FC 0041                915          MOVE.B  #'A',(A2)+
00001A4E  14FC 0044                916          MOVE.B  #'D',(A2)+
00001A52  14FC 0044                917          MOVE.B  #'D',(A2)+
00001A56  14FC 0051                918          MOVE.B  #'Q',(A2)+
00001A5A  223C 00000008            919          MOVE.L  #ea_type_quick,D1
00001A60  4EB9 00001DFE            920          JSR     EA_START
00001A66  4EF8 13CC                921          JMP     OP_FINISH
00001A6A                           922          
00001A6A                           923  *------------------------------------------------------------------------------------------------*
00001A6A                           924  * First 4 bits: 0110
00001A6A                           925  OP_BRA
00001A6A  14FC 0042                926          MOVE.B  #'B',(A2)+
00001A6E  14FC 0052                927          MOVE.B  #'R',(A2)+
00001A72  14FC 0041                928          MOVE.B  #'A',(A2)+
00001A76  223C 00000009            929          MOVE.L  #ea_type_branch,D1
00001A7C  4EB9 00001DFE            930          JSR     EA_START
00001A82  4EF8 13CC                931          JMP     OP_FINISH
00001A86                           932  
00001A86                           933  OP_BSR
00001A86  14FC 0042                934          MOVE.B  #'B',(A2)+
00001A8A  14FC 0053                935          MOVE.B  #'S',(A2)+
00001A8E  14FC 0052                936          MOVE.B  #'R',(A2)+
00001A92  223C 00000009            937          MOVE.L  #ea_type_branch,D1
00001A98  4EB9 00001DFE            938          JSR     EA_START
00001A9E  4EF8 13CC                939          JMP     OP_FINISH
00001AA2                           940          
00001AA2                           941  OP_BHI
00001AA2  14FC 0042                942          MOVE.B  #'B',(A2)+
00001AA6  14FC 0048                943          MOVE.B  #'H',(A2)+
00001AAA  14FC 0049                944          MOVE.B  #'I',(A2)+
00001AAE  223C 00000009            945          MOVE.L  #ea_type_branch,D1
00001AB4  4EB9 00001DFE            946          JSR     EA_START
00001ABA  4EF8 13CC                947          JMP     OP_FINISH
00001ABE                           948  
00001ABE                           949  OP_BLS
00001ABE  14FC 0042                950          MOVE.B  #'B',(A2)+
00001AC2  14FC 004C                951          MOVE.B  #'L',(A2)+
00001AC6  14FC 0053                952          MOVE.B  #'S',(A2)+
00001ACA  223C 00000009            953          MOVE.L  #ea_type_branch,D1
00001AD0  4EB9 00001DFE            954          JSR     EA_START
00001AD6  4EF8 13CC                955          JMP     OP_FINISH
00001ADA                           956  
00001ADA                           957  OP_BCC
00001ADA  14FC 0042                958          MOVE.B  #'B',(A2)+
00001ADE  14FC 0043                959          MOVE.B  #'C',(A2)+
00001AE2  14FC 0043                960          MOVE.B  #'C',(A2)+
00001AE6  223C 00000009            961          MOVE.L  #ea_type_branch,D1
00001AEC  4EB9 00001DFE            962          JSR     EA_START
00001AF2  4EF8 13CC                963          JMP     OP_FINISH
00001AF6                           964          
00001AF6                           965  OP_BCS
00001AF6  14FC 0042                966          MOVE.B  #'B',(A2)+
00001AFA  14FC 0043                967          MOVE.B  #'C',(A2)+
00001AFE  14FC 0053                968          MOVE.B  #'S',(A2)+
00001B02  223C 00000009            969          MOVE.L  #ea_type_branch,D1
00001B08  4EB9 00001DFE            970          JSR     EA_START
00001B0E  4EF8 13CC                971          JMP     OP_FINISH
00001B12                           972  
00001B12                           973  OP_BNE
00001B12  14FC 0042                974          MOVE.B  #'B',(A2)+
00001B16  14FC 004E                975          MOVE.B  #'N',(A2)+
00001B1A  14FC 0045                976          MOVE.B  #'E',(A2)+
00001B1E  223C 00000009            977          MOVE.L  #ea_type_branch,D1
00001B24  4EB9 00001DFE            978          JSR     EA_START
00001B2A  4EF8 13CC                979          JMP     OP_FINISH
00001B2E                           980  
00001B2E                           981  OP_BEQ
00001B2E  14FC 0042                982          MOVE.B  #'B',(A2)+
00001B32  14FC 0045                983          MOVE.B  #'E',(A2)+
00001B36  14FC 0051                984          MOVE.B  #'Q',(A2)+
00001B3A  223C 00000009            985          MOVE.L  #ea_type_branch,D1
00001B40  4EB9 00001DFE            986          JSR     EA_START
00001B46  4EF8 13CC                987          JMP     OP_FINISH
00001B4A                           988  
00001B4A                           989  OP_BVC
00001B4A  14FC 0042                990          MOVE.B  #'B',(A2)+
00001B4E  14FC 0056                991          MOVE.B  #'V',(A2)+
00001B52  14FC 0043                992          MOVE.B  #'C',(A2)+
00001B56  223C 00000009            993          MOVE.L  #ea_type_branch,D1
00001B5C  4EB9 00001DFE            994          JSR     EA_START
00001B62  4EF8 13CC                995          JMP     OP_FINISH
00001B66                           996  
00001B66                           997  OP_BVS
00001B66  14FC 0042                998          MOVE.B  #'B',(A2)+
00001B6A  14FC 0056                999          MOVE.B  #'V',(A2)+
00001B6E  14FC 0053               1000          MOVE.B  #'S',(A2)+
00001B72  223C 00000009           1001          MOVE.L  #ea_type_branch,D1
00001B78  4EB9 00001DFE           1002          JSR     EA_START
00001B7E  4EF8 13CC               1003          JMP     OP_FINISH
00001B82                          1004  
00001B82                          1005  OP_BPL
00001B82  14FC 0042               1006          MOVE.B  #'B',(A2)+
00001B86  14FC 0050               1007          MOVE.B  #'P',(A2)+
00001B8A  14FC 004C               1008          MOVE.B  #'L',(A2)+
00001B8E  223C 00000009           1009          MOVE.L  #ea_type_branch,D1
00001B94  4EB9 00001DFE           1010          JSR     EA_START
00001B9A  4EF8 13CC               1011          JMP     OP_FINISH
00001B9E                          1012  
00001B9E                          1013  OP_BMI
00001B9E  14FC 0042               1014          MOVE.B  #'B',(A2)+
00001BA2  14FC 004D               1015          MOVE.B  #'M',(A2)+
00001BA6  14FC 0049               1016          MOVE.B  #'I',(A2)+
00001BAA  223C 00000009           1017          MOVE.L  #ea_type_branch,D1
00001BB0  4EB9 00001DFE           1018          JSR     EA_START
00001BB6  4EF8 13CC               1019          JMP     OP_FINISH
00001BBA                          1020  
00001BBA                          1021  OP_BGE
00001BBA  14FC 0042               1022          MOVE.B  #'B',(A2)+
00001BBE  14FC 0047               1023          MOVE.B  #'G',(A2)+
00001BC2  14FC 0045               1024          MOVE.B  #'E',(A2)+
00001BC6  223C 00000009           1025          MOVE.L  #ea_type_branch,D1
00001BCC  4EB9 00001DFE           1026          JSR     EA_START
00001BD2  4EF8 13CC               1027          JMP     OP_FINISH
00001BD6                          1028  
00001BD6                          1029  OP_BLT
00001BD6  14FC 0042               1030          MOVE.B  #'B',(A2)+
00001BDA  14FC 004C               1031          MOVE.B  #'L',(A2)+
00001BDE  14FC 0054               1032          MOVE.B  #'T',(A2)+
00001BE2  223C 00000009           1033          MOVE.L  #ea_type_branch,D1
00001BE8  4EB9 00001DFE           1034          JSR     EA_START
00001BEE  4EF8 13CC               1035          JMP     OP_FINISH
00001BF2                          1036  
00001BF2                          1037  OP_BGT
00001BF2  14FC 0042               1038          MOVE.B  #'B',(A2)+
00001BF6  14FC 0047               1039          MOVE.B  #'G',(A2)+
00001BFA  14FC 0054               1040          MOVE.B  #'T',(A2)+
00001BFE  223C 00000009           1041          MOVE.L  #ea_type_branch,D1
00001C04  4EB9 00001DFE           1042          JSR     EA_START
00001C0A  4EF8 13CC               1043          JMP     OP_FINISH
00001C0E                          1044  
00001C0E                          1045  OP_BLE
00001C0E  14FC 0042               1046          MOVE.B  #'B',(A2)+
00001C12  14FC 004C               1047          MOVE.B  #'L',(A2)+
00001C16  14FC 0045               1048          MOVE.B  #'E',(A2)+
00001C1A  223C 00000009           1049          MOVE.L  #ea_type_branch,D1
00001C20  4EB9 00001DFE           1050          JSR     EA_START
00001C26  4EF8 13CC               1051          JMP     OP_FINISH
00001C2A                          1052  *------------------------------------------------------------------------------------------------*
00001C2A                          1053  * First 4 bits: 0111
00001C2A                          1054  OP_MOVEQ
00001C2A  14FC 004D               1055          MOVE.B  #'M',(A2)+
00001C2E  14FC 004F               1056          MOVE.B  #'O',(A2)+
00001C32  14FC 0056               1057          MOVE.B  #'V',(A2)+
00001C36  14FC 0045               1058          MOVE.B  #'E',(A2)+
00001C3A  14FC 0051               1059          MOVE.B  #'Q',(A2)+
00001C3E  223C 00000008           1060          MOVE.L  #ea_type_quick,D1
00001C44  4EB9 00001DFE           1061          JSR     EA_START
00001C4A  4EF8 13CC               1062          JMP     OP_FINISH
00001C4E                          1063          
00001C4E                          1064  *------------------------------------------------------------------------------------------------*
00001C4E                          1065  * First 4 bits: 1000
00001C4E                          1066  OP_DIVU
00001C4E  14FC 0044               1067          MOVE.B  #'D',(A2)+
00001C52  14FC 0049               1068          MOVE.B  #'I',(A2)+
00001C56  14FC 0056               1069          MOVE.B  #'V',(A2)+
00001C5A  14FC 0055               1070          MOVE.B  #'U',(A2)+
00001C5E  223C 00000005           1071          MOVE.L  #ea_type_ext,D1
00001C64  4EB9 00001DFE           1072          JSR     EA_START
00001C6A  4EF8 13CC               1073          JMP     OP_FINISH
00001C6E                          1074    
00001C6E                          1075  OP_OR
00001C6E  14FC 004F               1076          MOVE.B  #'O',(A2)+
00001C72  14FC 0052               1077          MOVE.B  #'R',(A2)+
00001C76  223C 00000005           1078          MOVE.L  #ea_type_ext,D1
00001C7C  4EB9 00001DFE           1079          JSR     EA_START
00001C82  4EF8 13CC               1080          JMP     OP_FINISH
00001C86                          1081  
00001C86                          1082  *------------------------------------------------------------------------------------------------*
00001C86                          1083  * First 4 bits: 1001
00001C86                          1084  OP_SUB
00001C86  14FC 0053               1085          MOVE.B  #'S',(A2)+
00001C8A  14FC 0055               1086          MOVE.B  #'U',(A2)+
00001C8E  14FC 0042               1087          MOVE.B  #'B',(A2)+
00001C92  223C 00000005           1088          MOVE.L  #ea_type_ext,D1
00001C98  4EB9 00001DFE           1089          JSR     EA_START
00001C9E  4EF8 13CC               1090          JMP     OP_FINISH
00001CA2                          1091          
00001CA2                          1092  *------------------------------------------------------------------------------------------------*
00001CA2                          1093  * First 4 bits: 1011
00001CA2                          1094  OP_CMP
00001CA2  14FC 0043               1095          MOVE.B  #'C',(A2)+
00001CA6  14FC 004D               1096          MOVE.B  #'M',(A2)+
00001CAA  14FC 0050               1097          MOVE.B  #'P',(A2)+
00001CAE  223C 00000005           1098          MOVE.L  #ea_type_ext,D1
00001CB4  4EB9 00001DFE           1099          JSR     EA_START
00001CBA  4EF8 13CC               1100          JMP     OP_FINISH
00001CBE                          1101          
00001CBE                          1102  *------------------------------------------------------------------------------------------------*
00001CBE                          1103  * First 4 bits: 1100
00001CBE                          1104  OP_MULU
00001CBE  14FC 004D               1105          MOVE.B  #'M',(A2)+
00001CC2  14FC 0055               1106          MOVE.B  #'U',(A2)+
00001CC6  14FC 004C               1107          MOVE.B  #'L',(A2)+
00001CCA  14FC 0055               1108          MOVE.B  #'U',(A2)+
00001CCE  223C 00000005           1109          MOVE.L  #ea_type_ext,D1
00001CD4  4EB9 00001DFE           1110          JSR     EA_START
00001CDA  4EF8 13CC               1111          JMP     OP_FINISH
00001CDE                          1112          
00001CDE                          1113  OP_MULS
00001CDE  14FC 004D               1114          MOVE.B  #'M',(A2)+
00001CE2  14FC 0055               1115          MOVE.B  #'U',(A2)+
00001CE6  14FC 004C               1116          MOVE.B  #'L',(A2)+
00001CEA  14FC 0053               1117          MOVE.B  #'S',(A2)+
00001CEE  223C 00000005           1118          MOVE.L  #ea_type_ext,D1
00001CF4  4EB9 00001DFE           1119          JSR     EA_START
00001CFA  4EF8 13CC               1120          JMP     OP_FINISH
00001CFE                          1121          
00001CFE                          1122  OP_AND
00001CFE  14FC 0041               1123          MOVE.B  #'A',(A2)+
00001D02  14FC 004E               1124          MOVE.B  #'N',(A2)+
00001D06  14FC 0044               1125          MOVE.B  #'D',(A2)+
00001D0A  223C 00000005           1126          MOVE.L  #ea_type_ext,D1
00001D10  4EB9 00001DFE           1127          JSR     EA_START
00001D16  4EF8 13CC               1128          JMP     OP_FINISH
00001D1A                          1129          
00001D1A                          1130  *------------------------------------------------------------------------------------------------*
00001D1A                          1131  * First 4 bits: 1101
00001D1A                          1132  OP_ADD
00001D1A  14FC 0041               1133          MOVE.B  #'A',(A2)+
00001D1E  14FC 0044               1134          MOVE.B  #'D',(A2)+
00001D22  14FC 0044               1135          MOVE.B  #'D',(A2)+
00001D26  223C 00000005           1136          MOVE.L  #ea_type_ext,D1
00001D2C  4EB9 00001DFE           1137          JSR     EA_START
00001D32  4EF8 13CC               1138          JMP     OP_FINISH
00001D36                          1139  
00001D36                          1140  OP_ADDA
00001D36  14FC 0041               1141          MOVE.B  #'A',(A2)+
00001D3A  14FC 0044               1142          MOVE.B  #'D',(A2)+
00001D3E  14FC 0044               1143          MOVE.B  #'D',(A2)+
00001D42  14FC 0041               1144          MOVE.B  #'A',(A2)+
00001D46  223C 00000005           1145          MOVE.L  #ea_type_ext,D1
00001D4C  4EB9 00001DFE           1146          JSR     EA_START
00001D52  4EF8 13CC               1147          JMP     OP_FINISH
00001D56                          1148          
00001D56                          1149  *------------------------------------------------------------------------------------------------*
00001D56                          1150  * First 4 bits: 1110
00001D56                          1151  OP_ASR
00001D56  14FC 0041               1152          MOVE.B  #'A',(A2)+
00001D5A  14FC 0053               1153          MOVE.B  #'S',(A2)+
00001D5E  14FC 0052               1154          MOVE.B  #'R',(A2)+
00001D62  223C 00000007           1155          MOVE.L  #ea_type_shifts,D1
00001D68  4EB9 00001DFE           1156          JSR     EA_START
00001D6E  4EF8 13CC               1157          JMP     OP_FINISH
00001D72                          1158  OP_ASL
00001D72  14FC 0041               1159          MOVE.B  #'A',(A2)+
00001D76  14FC 0053               1160          MOVE.B  #'S',(A2)+
00001D7A  14FC 004C               1161          MOVE.B  #'L',(A2)+
00001D7E  223C 00000007           1162          MOVE.L  #ea_type_shifts,D1
00001D84  4EB9 00001DFE           1163          JSR     EA_START
00001D8A  4EF8 13CC               1164          JMP     OP_FINISH
00001D8E                          1165          
00001D8E                          1166  OP_LSR
00001D8E  14FC 004C               1167          MOVE.B  #'L',(A2)+
00001D92  14FC 0053               1168          MOVE.B  #'S',(A2)+
00001D96  14FC 0052               1169          MOVE.B  #'R',(A2)+
00001D9A  223C 00000007           1170          MOVE.L  #ea_type_shifts,D1
00001DA0  4EB9 00001DFE           1171          JSR     EA_START
00001DA6  4EF8 13CC               1172          JMP     OP_FINISH
00001DAA                          1173         
00001DAA                          1174  OP_LSL
00001DAA  14FC 004C               1175          MOVE.B  #'L',(A2)+
00001DAE  14FC 0053               1176          MOVE.B  #'S',(A2)+
00001DB2  14FC 004C               1177          MOVE.B  #'L',(A2)+
00001DB6  223C 00000007           1178          MOVE.L  #ea_type_shifts,D1
00001DBC  4EB9 00001DFE           1179          JSR     EA_START
00001DC2  4EF8 13CC               1180          JMP     OP_FINISH
00001DC6                          1181          
00001DC6                          1182  OP_ROR
00001DC6  14FC 0052               1183          MOVE.B  #'R',(A2)+
00001DCA  14FC 004F               1184          MOVE.B  #'O',(A2)+
00001DCE  14FC 0052               1185          MOVE.B  #'R',(A2)+
00001DD2  223C 00000007           1186          MOVE.L  #ea_type_shifts,D1
00001DD8  4EB9 00001DFE           1187          JSR     EA_START
00001DDE  4EF8 13CC               1188          JMP     OP_FINISH
00001DE2                          1189          
00001DE2                          1190  OP_ROL
00001DE2  14FC 0052               1191          MOVE.B  #'R',(A2)+
00001DE6  14FC 004F               1192          MOVE.B  #'O',(A2)+
00001DEA  14FC 004C               1193          MOVE.B  #'L',(A2)+
00001DEE  223C 00000007           1194          MOVE.L  #ea_type_shifts,D1
00001DF4  4EB9 00001DFE           1195          JSR     EA_START
00001DFA  4EF8 13CC               1196          JMP     OP_FINISH
00001DFE                          1197          
00001DFE                          1198  *------------------------------------------------------------------------------------------------*
00001DFE                          1199  EA_START
00001DFE  48E7 38C0               1200          MOVEM.L D2-D4/A0-A1, -(SP)
00001E02                          1201          
00001E02  41F9 00001E16           1202          LEA     EA_TYPE_TABLE, A0
00001E08  C2FC 0006               1203          MULU    #6, D1
00001E0C  4EF0 1000               1204          JMP     0(A0, D1)
00001E10                          1205          
00001E10                          1206  EA_FINISH
00001E10  4CDF 031C               1207          MOVEM.L (SP)+, D2-D4/A0-A1
00001E14  4E75                    1208          RTS
00001E16                          1209          
00001E16                          1210  EA_TYPE_TABLE
00001E16  4EF9 00001F34           1211          JMP     EA_IMMEDIATE        ; 0: ea_immediate
00001E1C  4EF9 00001F8C           1212          JMP     EA_MOVE             ; 1: ea_move
00001E22  4EF9 00001FF8           1213          JMP     EA_MOVEA            ; 2: ea_movea
00001E28  4EF9 00002064           1214          JMP     EA_LEA              ; 3: ea_lea
00001E2E  4EF9 000020E2           1215          JMP     EA_DSTONLY          ; 4: ea_dstonly
00001E34  4EF9 00002194           1216          JMP     EA_EXT              ; 5: ea_ext
00001E3A  4EF9 00002384           1217          JMP     EA_MOVEM            ; 6: ea_movem
00001E40  4EF9 000029E8           1218          JMP     EA_SHIFTS           ; 7: ea_shifts
00001E46  4EF9 00002B6A           1219          JMP     EA_QUICK            ; 8: ea_quick
00001E4C  4EF9 00002C2C           1220          JMP     EA_branch           ; 9: ea_branch
00001E52  4EF8 1E10               1221          JMP     EA_FINISH
00001E56                          1222          
00001E56                          1223  EA_SIZE_GENERAL
00001E56  B43C 0000               1224          CMP.B   #%00,D2             ; .b
00001E5A  6700 00B6               1225          BEQ     EA_SIZE_B       
00001E5E  B43C 0001               1226          CMP.B   #%01,D2             ; .w
00001E62  6700 00B8               1227          BEQ     EA_SIZE_W       
00001E66  B43C 0002               1228          CMP.B   #%10,D2             ; .l
00001E6A  6700 00BC               1229          BEQ     EA_SIZE_L
00001E6E  6000 0FC4               1230          BRA     EA_ERROR          ; wrong size
00001E72                          1231  
00001E72                          1232  EA_SIZE_MOVE
00001E72  B43C 0001               1233          CMP.B   #%01,D2             ; .b
00001E76  6700 009A               1234          BEQ     EA_SIZE_B       
00001E7A  B43C 0003               1235          CMP.B   #%11,D2             ; .w
00001E7E  6700 009C               1236          BEQ     EA_SIZE_W       
00001E82  B43C 0002               1237          CMP.B   #%10,D2             ; .l
00001E86  6700 00A0               1238          BEQ     EA_SIZE_L
00001E8A  6000 0FA8               1239          BRA     EA_ERROR            ; wrong size
00001E8E                          1240  
00001E8E                          1241  EA_SIZE_MOVEA     
00001E8E  B43C 0003               1242          CMP.B   #%11,D2             ; .w
00001E92  6700 0088               1243          BEQ     EA_SIZE_W       
00001E96  B43C 0002               1244          CMP.B   #%10,D2             ; .l
00001E9A  6700 008C               1245          BEQ     EA_SIZE_L
00001E9E  6000 0F94               1246          BRA     EA_ERROR            ; wrong size
00001EA2                          1247          
00001EA2                          1248  EA_SIZE_MOVEM     
00001EA2  B43C 0000               1249          CMP.B   #%0000,D2           ; .w
00001EA6  6700 0074               1250          BEQ     EA_SIZE_W       
00001EAA  B43C 0004               1251          CMP.B   #%0100,D2           ; .l
00001EAE  6700 0078               1252          BEQ     EA_SIZE_L
00001EB2  6000 0F80               1253          BRA     EA_ERROR            ; wrong size
00001EB6                          1254  
00001EB6                          1255  EA_SIZE_OPMODE_012456               ; Check opmode field for size
00001EB6  B43C 0000               1256          CMP.B   #%000,D2            ; When 0 then .b
00001EBA  6700 0056               1257          BEQ     EA_SIZE_B
00001EBE  B43C 0004               1258          CMP.B   #%100,D2            ; When 4 then .b
00001EC2  6700 004E               1259          BEQ     EA_SIZE_B  
00001EC6  B43C 0001               1260          CMP.B   #%001,D2            ; When 1 then .w
00001ECA  6700 0050               1261          BEQ     EA_SIZE_W
00001ECE  B43C 0005               1262          CMP.B   #%101,D2            ; When 5 then .w
00001ED2  6700 0048               1263          BEQ     EA_SIZE_W 
00001ED6  B43C 0002               1264          CMP.B   #%010,D2            ; When 2 then .l
00001EDA  6700 004C               1265          BEQ     EA_SIZE_L
00001EDE  B43C 0006               1266          CMP.B   #%110,D2            ; When 6 then .l
00001EE2  6700 0044               1267          BEQ     EA_SIZE_L
00001EE6  6000 0F4C               1268          BRA     EA_ERROR            ; wrong size
00001EEA                          1269  
00001EEA                          1270  EA_SIZE_ADDA                        ; Check opmode field for size
00001EEA  B43C 0003               1271          CMP.B   #%011,D2            ; When 3 then .w
00001EEE  6700 002C               1272          BEQ     EA_SIZE_W       
00001EF2  B43C 0007               1273          CMP.B   #%111,D2            ; When 7 then .l
00001EF6  6700 0030               1274          BEQ     EA_SIZE_L
00001EFA  6000 0F38               1275          BRA     EA_ERROR            ; wrong size
00001EFE                          1276                  
00001EFE                          1277  EA_SIZE_MEMORY_SHIFTS
00001EFE  B43C 0000               1278          CMP.B   #%00,D2             ; .w
00001F02  6700 0022               1279          BEQ     EA_SIZE_W_MEMORY      
00001F06  B43C 0001               1280          CMP.B   #%01,D2             ; .l
00001F0A  6700 001C               1281          BEQ     EA_SIZE_L      
00001F0E  6000 0F24               1282          BRA     EA_ERROR            ; wrong size
00001F12                          1283  
00001F12                          1284  EA_SIZE_B
00001F12  14FC 002E               1285          MOVE.B  #'.',(A2)+
00001F16  14FC 0042               1286          MOVE.B  #'B',(A2)+
00001F1A  4E75                    1287          RTS
00001F1C                          1288  EA_SIZE_W
00001F1C  14FC 002E               1289          MOVE.B  #'.',(A2)+
00001F20  14FC 0057               1290          MOVE.B  #'W',(A2)+
00001F24  4E75                    1291          RTS     
00001F26                          1292  EA_SIZE_W_MEMORY
00001F26  4E75                    1293          RTS        
00001F28                          1294  EA_SIZE_L
00001F28  14FC 002E               1295          MOVE.B  #'.',(A2)+
00001F2C  14FC 004C               1296          MOVE.B  #'L',(A2)+
00001F30  4E75                    1297          RTS
00001F32                          1298  EA_SIZE_DONE
00001F32  4E75                    1299          RTS
00001F34                          1300  *------------------------------------------------------------------------------------------------*     
00001F34                          1301  EA_IMMEDIATE                        ; 0 ea_immediate
00001F34  2200                    1302          MOVE.L  D0,D1
00001F36  0241 01C0               1303          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00001F3A  1A3C 0006               1304          MOVE.B  #right6,D5          ; Store 6 into D5
00001F3E  EA69                    1305          LSR.W   D5,D1               ; Shift D1 six times to LSB position
00001F40  0201 0003               1306          ANDI.B  #3,D1               ; Remove the front bit from D1
00001F44  1401                    1307          MOVE.B  D1,D2               ; Store D1 into D2 (used to check size)
00001F46  4EB8 1E56               1308          JSR     EA_SIZE_GENERAL     ; Get size 
00001F4A                          1309          
00001F4A  14FC 0020               1310          MOVE.B  #$20,(A2)+          ; Add space after size
00001F4E  14FC 0020               1311          MOVE.B  #$20,(A2)+          ; Add space 
00001F52  14FC 0020               1312          MOVE.B  #$20,(A2)+          ; Add space
00001F56                          1313  
00001F56                          1314          ; Get source and store into decode buffer
00001F56  7804                    1315          MOVE.L  #4,D4               ; Store 100 into D4 (jump to immed)
00001F58  7607                    1316          MOVE.L  #7,D3               ; Store 111 into D3 (Go abs and immed)
00001F5A  4EB9 00002C84           1317          JSR     EA_GEN_SRC          ; Get EA src print 
00001F60                          1318  
00001F60  14FC 002C               1319          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001F64  14FC 0020               1320          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F68                          1321  
00001F68                          1322          ; Get desination and store into decode buffer
00001F68  2800                    1323          MOVE.L  D0,D4               ; Store the current address into D4 
00001F6A  0244 0007               1324          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00001F6E                          1325          
00001F6E  2600                    1326          MOVE.L  D0,D3               ; Store the current address into D3 
00001F70  0243 0038               1327          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00001F74  1A3C 0003               1328          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00001F78  EA6B                    1329          LSR.W   D5,D3               ; do the actual shift 
00001F7A  B63C 0001               1330          CMP.B   #1,D3               ; If dest mode is 001: An
00001F7E  6700 0EB4               1331          BEQ     EA_ERROR            ; Go to invalid message 
00001F82  4EB9 00002C84           1332          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00001F88                          1333  
00001F88  4EF8 1E10               1334          JMP     EA_FINISH           ; Opcode is finish
00001F8C                          1335  *------------------------------------------------------------------------------------------------*
00001F8C                          1336  EA_MOVE                             ; 1: ea_move
00001F8C  2200                    1337          MOVE.L  D0,D1
00001F8E  0241 F000               1338          ANDI.W  #first_nibble,D1
00001F92  1A3C 000C               1339          MOVE.B  #right12,D5 
00001F96  EA69                    1340          LSR.W   D5,D1
00001F98  0201 0003               1341          ANDI.B  #3,D1
00001F9C  1401                    1342          MOVE.B  D1,D2
00001F9E  4EB8 1E72               1343          JSR     EA_SIZE_MOVE
00001FA2                          1344          
00001FA2  14FC 0020               1345          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001FA6  14FC 0020               1346          MOVE.B  #$20,(A2)+          ; Print out a space
00001FAA  14FC 0020               1347          MOVE.B  #$20,(A2)+          ; Print out a space
00001FAE                          1348          
00001FAE                          1349          ; Get source and store into decode buffer
00001FAE  2800                    1350          MOVE.L  D0,D4               ; Store the src reg in D4
00001FB0  0244 0007               1351          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001FB4                          1352          
00001FB4  2600                    1353          MOVE.L  D0,D3               ; Store the src mode in D3
00001FB6  0243 0038               1354          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001FBA  1A3C 0003               1355          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001FBE  EA6B                    1356          LSR.W   D5,D3               ; Do the actual shift 
00001FC0  4EB9 00002C84           1357          JSR     EA_GEN_SRC
00001FC6                          1358          
00001FC6  14FC 002C               1359          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001FCA  14FC 0020               1360          MOVE.B  #$20,(A2)+          ; Add space after comma
00001FCE                          1361          
00001FCE                          1362          ; Get desination and store into decode buffer
00001FCE  2800                    1363          MOVE.L  D0,D4               ; Store the dest reg in D4
00001FD0  0244 0E00               1364          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001FD4  1A3C 0009               1365          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001FD8  EA6C                    1366          LSR.W   D5,D4               ; Do the actual shift
00001FDA                          1367          
00001FDA  2600                    1368          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001FDC  0243 01C0               1369          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001FE0  1A3C 0006               1370          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001FE4  EA6B                    1371          LSR.W   D5,D3               ; Do the actual shift 
00001FE6  B63C 0001               1372          CMP.B   #1,D3               ; If dest mode is 001: An
00001FEA  6700 0E48               1373          BEQ     EA_ERROR            ; Go to invalid message 
00001FEE  4EB9 00002C84           1374          JSR     EA_GEN_SRC          ; Get EA print
00001FF4                          1375          
00001FF4  4EF8 1E10               1376          JMP     EA_FINISH           ; Opcode is finish
00001FF8                          1377  *------------------------------------------------------------------------------------------------*          
00001FF8                          1378  EA_MOVEA                            ; 2: ea_movea
00001FF8  2200                    1379          MOVE.L  D0,D1
00001FFA  0241 F000               1380          ANDI.W  #first_nibble,D1
00001FFE  1A3C 000C               1381          MOVE.B  #right12,D5 
00002002  EA69                    1382          LSR.W   D5,D1
00002004  0201 0003               1383          ANDI.B  #3,D1
00002008  1401                    1384          MOVE.B  D1,D2
0000200A  4EB8 1E8E               1385          JSR     EA_SIZE_MOVEA 
0000200E                          1386          
0000200E  14FC 0020               1387          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002012  14FC 0020               1388          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002016                          1389          
00002016                          1390          ; Get source and store into decode buffer
00002016  2800                    1391          MOVE.L  D0,D4               ; Store the src reg in D4
00002018  0244 0007               1392          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000201C                          1393          
0000201C  2600                    1394          MOVE.L  D0,D3               ; Store the src mode in D3
0000201E  0243 0038               1395          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002022  1A3C 0003               1396          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002026  EA6B                    1397          LSR.W   D5,D3               ; Do the actual shift 
00002028  4EB9 00002C84           1398          JSR     EA_GEN_SRC
0000202E                          1399          
0000202E  14FC 002C               1400          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002032  14FC 0020               1401          MOVE.B  #$20,(A2)+          ; Add space after comma
00002036                          1402          
00002036                          1403          ; Get desination and store into decode buffer
00002036  2800                    1404          MOVE.L  D0,D4               ; Store the dest reg in D4
00002038  0244 0E00               1405          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000203C  1A3C 0009               1406          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002040  EA6C                    1407          LSR.W   D5,D4               ; Do the actual shift
00002042                          1408          
00002042  2600                    1409          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00002044  0243 01C0               1410          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00002048  1A3C 0006               1411          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
0000204C  EA6B                    1412          LSR.W   D5,D3               ; Do the actual shift 
0000204E  B63C 0001               1413          CMP.B   #1,D3               ; If dst mode is 001: An 
00002052  6700 0006               1414          BEQ     MOVEA_DST_VALID     ; dst is valid, so branch 
00002056  6000 0DDC               1415          BRA     EA_ERROR            ; Otherwise, go to invalid message 
0000205A                          1416          
0000205A                          1417  MOVEA_DST_VALID
0000205A  4EB9 00002C84           1418          JSR     EA_GEN_SRC          ; Get EA print
00002060  4EF8 1E10               1419          JMP     EA_FINISH           ; Opcode is finish
00002064                          1420  *------------------------------------------------------------------------------------------------*
00002064                          1421  EA_LEA                              ; 3: ea_lea
00002064  14FC 0020               1422          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002068  14FC 0020               1423          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000206C  14FC 0020               1424          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002070  14FC 0020               1425          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002074  14FC 0020               1426          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002078  14FC 0020               1427          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000207C                          1428  
0000207C  2800                    1429          MOVE.L  D0,D4               ; Store the src reg in D4
0000207E  0244 0007               1430          ANDI.W  #src_reg,D4         ; get the bits at 2-0
00002082                          1431          
00002082  2600                    1432          MOVE.L  D0,D3               ; Store the src mode in D3
00002084  0243 0038               1433          ANDI.W  #src_mode,D3        ; get bits 5-3
00002088  1A3C 0003               1434          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB
0000208C  EA6B                    1435          LSR.W   D5,D3               ; do the actual shift 
0000208E  B67C 0002               1436          CMP     #2,D3               ; If D3 (src mode) is 010 (An)
00002092  6700 000E               1437          BEQ     LEA_SRC_VALID
00002096  B67C 0007               1438          CMP     #7,D3               ; If D3 (src mode) is 111 (W or L)
0000209A  6700 0006               1439          BEQ     LEA_SRC_VALID
0000209E  6000 0D94               1440          BRA     EA_ERROR            ; when src mode is not 010 or 111, branch to error message
000020A2                          1441          
000020A2                          1442  LEA_SRC_VALID        
000020A2  4EB9 00002C84           1443          JSR     EA_GEN_SRC          ; Go to function 
000020A8                          1444   
000020A8  14FC 002C               1445          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000020AC  14FC 0020               1446          MOVE.B  #$20,(A2)+          ; Add space after comma
000020B0                          1447  
000020B0  2600                    1448          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
000020B2  0243 01C0               1449          ANDI.W  #dst_mode,D3        ; Get bits 8-6
000020B6  1A3C 0006               1450          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
000020BA  EA6B                    1451          LSR.W   D5,D3               ; Do the actual shift
000020BC  B63C 0007               1452          CMP.B   #7,D3               ; Check if D3 is 111
000020C0  6700 0006               1453          BEQ     CHANGE_TO_001       ; change the D3 bits to 001 
000020C4  6000 0D6E               1454          BRA     EA_ERROR            ; Print out an error message if bits 8-6 (dst mode) are not 111
000020C8                          1455    
000020C8                          1456  CHANGE_TO_001
000020C8  163C 0001               1457          MOVE.B  #%001,D3            ; set D3 to 001 to ensure the print out A 
000020CC                          1458          
000020CC  2800                    1459          MOVE.L  D0,D4               ; Store the dest reg in D4 to get the Address register number
000020CE  0244 0E00               1460          ANDI.W  #dst_reg,D4         ; get the bits at 11-9
000020D2  1A3C 0009               1461          MOVE.B  #right9,D5          ; shift the bits 11-9 to the LSB
000020D6  EA6C                    1462          LSR.W   D5,D4               ; do the actual shift
000020D8  4EB9 00002C84           1463          JSR     EA_GEN_SRC          ; Print out the address register
000020DE  4EF8 1E10               1464          JMP     EA_FINISH           ; Opcode is finish
000020E2                          1465  *------------------------------------------------------------------------------------------------*
000020E2                          1466  EA_DSTONLY                          ; 4: ea_dstonly
000020E2  2200                    1467          MOVE.L  D0,D1
000020E4  0241 0F00               1468          ANDI.W  #second_nibble,D1   ; get second nibble from D1
000020E8  1A3C 0008               1469          MOVE.B  #right8,D5 
000020EC  EA69                    1470          LSR.W   D5,D1     
000020EE  B23C 0002               1471          CMP.B   #2, D1              ; When 0010 for second nibble
000020F2  6700 000E               1472          BEQ     EA_CLEAR            ; Then do EA_CLEAR
000020F6  B23C 000E               1473          CMP.B   #$E, D1             ; When 1110 for second nibble
000020FA  6700 0050               1474          BEQ     EA_JSR              ; Then do EA_JSR
000020FE  6000 0D34               1475          BRA     EA_ERROR     
00002102                          1476          
00002102                          1477  EA_CLEAR
00002102  2200                    1478          MOVE.L  D0,D1
00002104  0241 01C0               1479          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00002108  1A3C 0006               1480          MOVE.B  #right6,D5          ; Store 6 into D5
0000210C  EA69                    1481          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
0000210E  0201 0003               1482          ANDI.B  #3,D1               ; Remove the front bit from D1
00002112  1401                    1483          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002114  4EB8 1E56               1484          JSR     EA_SIZE_GENERAL     ; Get size 
00002118                          1485          
00002118  14FC 0020               1486          MOVE.B  #$20,(A2)+          ; Add space after size
0000211C  14FC 0020               1487          MOVE.B  #$20,(A2)+          ; Add space 
00002120  14FC 0020               1488          MOVE.B  #$20,(A2)+          ; Add space 
00002124  14FC 0020               1489          MOVE.B  #$20,(A2)+          ; Add space
00002128                          1490          
00002128                          1491          ; Get desination and store into decode buffer
00002128  2800                    1492          MOVE.L  D0,D4               ; Store the current address into D4 
0000212A  0244 0007               1493          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
0000212E                          1494          
0000212E  2600                    1495          MOVE.L  D0,D3               ; Store the current address into D3 
00002130  0243 0038               1496          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002134  1A3C 0003               1497          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002138  EA6B                    1498          LSR.W   D5,D3               ; do the actual shift 
0000213A  B63C 0001               1499          CMP.B   #1,D3               ; If dest mode is 001: An
0000213E  6700 0CF4               1500          BEQ     EA_ERROR            ; Go to invalid message 
00002142  4EB9 00002C84           1501          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00002148  4EF8 1E10               1502          JMP     EA_FINISH           ; Opcode is finish
0000214C                          1503          
0000214C  14FC 0020               1504  EA_JSR  MOVE.B  #$20,(A2)+          ; Add space 
00002150  14FC 0020               1505          MOVE.B  #$20,(A2)+          ; Add space 
00002154  14FC 0020               1506          MOVE.B  #$20,(A2)+          ; Add space 
00002158  14FC 0020               1507          MOVE.B  #$20,(A2)+          ; Add space 
0000215C  14FC 0020               1508          MOVE.B  #$20,(A2)+          ; Add space 
00002160  14FC 0020               1509          MOVE.B  #$20,(A2)+          ; Add space
00002164                          1510  
00002164                          1511          ; Get EA and store into decode buffer   
00002164  2800                    1512          MOVE.L  D0,D4               ; Store the current address into D4 
00002166  0244 0007               1513          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
0000216A                          1514          
0000216A  2600                    1515          MOVE.L  D0,D3               ; Store the current address into D3 
0000216C  0243 0038               1516          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002170  1A3C 0003               1517          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002174  EA6B                    1518          LSR.W   D5,D3               ; do the actual shift 
00002176  B67C 0002               1519          CMP     #2,D3               ; If D3 (src mode) is 010: (An)
0000217A  6700 000E               1520          BEQ     JSR_EA_VALID
0000217E  B67C 0007               1521          CMP     #7,D3               ; If D3 (src mode) is 111: (W or L)
00002182  6700 0006               1522          BEQ     JSR_EA_VALID
00002186  6000 0CAC               1523          BRA     EA_ERROR            ; Otherwise, branch to invalid message
0000218A                          1524          
0000218A                          1525  JSR_EA_VALID
0000218A  4EB9 00002C84           1526          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00002190  4EF8 1E10               1527          JMP     EA_FINISH           ; Opcode is finish
00002194                          1528  *------------------------------------------------------------------------------------------------*
00002194                          1529  EA_EXT                              ; 5: ea_ext
00002194  2200                    1530          MOVE.L  D0,D1
00002196  0241 01C0               1531          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1 (get opmode)
0000219A  1A3C 0006               1532          MOVE.B  #right6,D5          ; Store 6 into D5
0000219E  EA69                    1533          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
000021A0  1401                    1534          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
000021A2  C2FC 0006               1535          MULU    #6, D1              ; Multiply 6 to D1 
000021A6  41F9 000021B0           1536          LEA     EA_EXT_TABLE,A0     ; Load table into A0
000021AC  4EF0 1000               1537          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000021B0                          1538  
000021B0                          1539  EA_EXT_TABLE
000021B0  4EF9 000021E0           1540          JMP     EA_OPMODE_012456    ; 000: ADD/SUB/CMP/OR/AND
000021B6  4EF9 000021E0           1541          JMP     EA_OPMODE_012456    ; 001: ADD/SUB/CMP/OR/AND
000021BC  4EF9 000021E0           1542          JMP     EA_OPMODE_012456    ; 010: ADD/SUB/CMP/OR/AND
000021C2  4EF9 000022CE           1543          JMP     EA_OPMODE_37        ; 011: ADDA/MULS/MULU/DIVU
000021C8  4EF9 000021E0           1544          JMP     EA_OPMODE_012456    ; 100: ADD/SUB/CMP/OR/AND
000021CE  4EF9 000021E0           1545          JMP     EA_OPMODE_012456    ; 101: ADD/SUB/CMP/OR/AND
000021D4  4EF9 000021E0           1546          JMP     EA_OPMODE_012456    ; 110: ADD/SUB/CMP/OR/AND
000021DA  4EF9 000022CE           1547          JMP     EA_OPMODE_37        ; 111: ADDA/MULS/MULU/DIVU
000021E0                          1548  
000021E0                          1549  EA_OPMODE_012456
000021E0  4EB8 1EB6               1550          JSR     EA_SIZE_OPMODE_012456    
000021E4                          1551          
000021E4  14FC 0020               1552          MOVE.B  #$20,(A2)+          ; Print out a space after the size
000021E8  14FC 0020               1553          MOVE.B  #$20,(A2)+          ; Print out a space 
000021EC  14FC 0020               1554          MOVE.B  #$20,(A2)+          ; Print out a space
000021F0  14FC 0020               1555          MOVE.B  #$20,(A2)+          ; Add space
000021F4                          1556          
000021F4                          1557          ; Operation: <ea> + Dn -> Dn
000021F4  B43C 0000               1558          CMP.B   #%000,D2            ; When 0 then Dn is destination
000021F8  6700 002E               1559          BEQ     Dn_DST
000021FC  B43C 0001               1560          CMP.B   #%001,D2            ; When 1 then Dn is destination
00002200  6700 0026               1561          BEQ     Dn_DST
00002204  B43C 0002               1562          CMP.B   #%010,D2            ; When 2 then Dn is destination
00002208  6700 001E               1563          BEQ     Dn_DST
0000220C                          1564          
0000220C                          1565          ; Operation: Dn + <ea> -> <ea>
0000220C  B43C 0004               1566          CMP.B   #%100,D2            ; When 4 then Dn is source
00002210  6700 0054               1567          BEQ     Dn_SRC  
00002214  B43C 0005               1568          CMP.B   #%101,D2            ; When 5 then Dn is source
00002218  6700 004C               1569          BEQ     Dn_SRC 
0000221C  B43C 0006               1570          CMP.B   #%110,D2            ; When 6 then Dn is source
00002220  6700 0044               1571          BEQ     Dn_SRC 
00002224                          1572          
00002224  6000 0C0E               1573          BRA     EA_ERROR
00002228                          1574  
00002228                          1575  Dn_DST
00002228                          1576          ; Get source and store into decode buffer
00002228  2800                    1577          MOVE.L  D0,D4               ; Store the src reg in D4
0000222A  0244 0007               1578          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000222E                          1579          
0000222E  2600                    1580          MOVE.L  D0,D3               ; Store the src mode in D3
00002230  0243 0038               1581          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002234  1A3C 0003               1582          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002238  EA6B                    1583          LSR.W   D5,D3               ; Do the actual shift 
0000223A  4EB9 000022AC           1584          JSR     AND_OR_CHECK 
00002240  4EB9 00002C84           1585          JSR     EA_GEN_SRC          ; Get EA print
00002246                          1586          
00002246  14FC 002C               1587          MOVE.B  #$2C,(A2)+          ; Add comma after size print
0000224A  14FC 0020               1588          MOVE.B  #$20,(A2)+          ; Add space after comma
0000224E                          1589          
0000224E                          1590          ; Get desination and store into decode buffer
0000224E  2800                    1591          MOVE.L  D0,D4               ; Store the dest reg in D4
00002250  0244 0E00               1592          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002254  1A3C 0009               1593          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002258  EA6C                    1594          LSR.W   D5,D4               ; Do the actual shift
0000225A                          1595          
0000225A  7600                    1596          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000225C  4EB9 00002C84           1597          JSR     EA_GEN_SRC          ; Get the Dn print
00002262  4EF8 1E10               1598          JMP     EA_FINISH           ; Opcode is finish
00002266                          1599            
00002266                          1600  Dn_SRC  
00002266  BC3C 000B               1601          CMP.B   #11,D6              ; If first nibble is 1011 (indicates CMP opcode)
0000226A  6700 0BC8               1602          BEQ     EA_ERROR            ; Then branch to error message
0000226E                          1603       
0000226E                          1604          ; Get source and store into decode buffer
0000226E  2800                    1605          MOVE.L  D0,D4               ; Store the src reg in D4
00002270  0244 0E00               1606          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002274  1A3C 0009               1607          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002278  EA6C                    1608          LSR.W   D5,D4               ; Do the actual shift
0000227A                          1609          
0000227A  7600                    1610          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000227C  4EB9 00002C84           1611          JSR     EA_GEN_SRC          ; Get the Dn print
00002282                          1612          
00002282  14FC 002C               1613          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002286  14FC 0020               1614          MOVE.B  #$20,(A2)+          ; Add space after comma
0000228A                          1615  
0000228A                          1616          ; Get destination and store into decode buffer
0000228A  2800                    1617          MOVE.L  D0,D4               ; Store the dst reg in D4
0000228C  0244 0007               1618          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002290                          1619          
00002290  2600                    1620          MOVE.L  D0,D3               ; Store the dest mode in D3
00002292  0243 0038               1621          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002296  1A3C 0003               1622          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000229A  EA6B                    1623          LSR.W   D5,D3               ; Do the actual shift
0000229C  4EB9 00002D9A           1624          JSR     An_CHECK            ; Check if mode is An
000022A2                          1625         
000022A2  4EB9 00002C84           1626          JSR     EA_GEN_SRC          ; Get EA print
000022A8  4EF8 1E10               1627          JMP     EA_FINISH           ; Opcode is finish
000022AC                          1628  
000022AC                          1629  AND_OR_CHECK
000022AC  BC3C 000C               1630          CMP.B   #12,D6              ; If first nibble is 1100 (indicates AND opcode)
000022B0  6700 000C               1631          BEQ     EA_AND              
000022B4  BC3C 0008               1632          CMP.B   #8,D6               ; If first nibble is 1000 (indicates OR opcode)
000022B8  6700 000A               1633          BEQ     EA_OR 
000022BC  4E75                    1634          RTS
000022BE                          1635  EA_AND
000022BE  4EF9 00002D9A           1636          JMP     An_CHECK            ; Go check if mode is An 
000022C4                          1637      
000022C4                          1638  EA_OR
000022C4  14FC 0020               1639          MOVE.B  #$20,(A2)+          ; Add space
000022C8  4EF9 00002D9A           1640          JMP     An_CHECK            ; Check if mode is An
000022CE                          1641          
000022CE                          1642  EA_OPMODE_37
000022CE  BC3C 0008               1643          CMP.B   #8,D6               ; If first nibble 1000: DIVU
000022D2  6700 0012               1644          BEQ     EA_MULS_MULU_DIV
000022D6  BC3C 000C               1645          CMP.B   #12,D6              ; If first nibble 1100: MULS/MULU
000022DA  6700 000A               1646          BEQ     EA_MULS_MULU_DIV
000022DE  BC3C 000D               1647          CMP.B   #13,D6              ; If first nibble 1101: ADDA
000022E2  6700 0058               1648          BEQ     EA_ADDA                
000022E6                          1649  
000022E6                          1650  EA_MULS_MULU_DIV
000022E6  143C 0001               1651          MOVE.B  #1,D2               ; Set D2 to 1, since we know size is word   
000022EA                          1652  
000022EA  14FC 0020               1653          MOVE.B  #$20,(A2)+          ; Print out a space
000022EE  14FC 0020               1654          MOVE.B  #$20,(A2)+          ; Print out a space
000022F2  14FC 0020               1655          MOVE.B  #$20,(A2)+          ; Print out a space
000022F6  14FC 0020               1656          MOVE.B  #$20,(A2)+          ; Add space
000022FA  14FC 0020               1657          MOVE.B  #$20,(A2)+          ; Add space
000022FE                          1658  
000022FE                          1659          ; Get source and store into decode buffer
000022FE  2800                    1660          MOVE.L  D0,D4               ; Store the src reg in D4
00002300  0244 0007               1661          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002304                          1662          
00002304  2600                    1663          MOVE.L  D0,D3               ; Store the src mode in D3
00002306  0243 0038               1664          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000230A  1A3C 0003               1665          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000230E  EA6B                    1666          LSR.W   D5,D3               ; Do the actual shift
00002310  4EB9 00002D9A           1667          JSR     An_CHECK            ; Check if mode is An 
00002316  4EB9 00002C84           1668          JSR     EA_GEN_SRC          ; Go get EA print
0000231C                          1669          
0000231C  14FC 002C               1670          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002320  14FC 0020               1671          MOVE.B  #$20,(A2)+          ; Add space after comma
00002324                          1672          
00002324                          1673          ; Get desination and store into decode buffer
00002324  2800                    1674          MOVE.L  D0,D4               ; Store the dest reg in D4
00002326  0244 0E00               1675          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000232A  1A3C 0009               1676          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000232E  EA6C                    1677          LSR.W   D5,D4               ; Do the actual shift
00002330                          1678          
00002330  7600                    1679          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
00002332  4EB9 00002C84           1680          JSR     EA_GEN_SRC          ; Go get EA print
00002338  4EF8 1E10               1681          JMP     EA_FINISH           ; Opcode is finish
0000233C                          1682  
0000233C                          1683  EA_ADDA
0000233C  4EB8 1EEA               1684          JSR     EA_SIZE_ADDA        ; Get size    
00002340                          1685  
00002340  14FC 0020               1686          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002344  14FC 0020               1687          MOVE.B  #$20,(A2)+          ; Print out a space
00002348  14FC 0020               1688          MOVE.B  #$20,(A2)+          ; Add space        
0000234C                          1689          
0000234C                          1690          
0000234C                          1691          ; Get source and store into decode buffer
0000234C  2800                    1692          MOVE.L  D0,D4               ; Store the src reg in D4
0000234E  0244 0007               1693          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002352                          1694          
00002352  2600                    1695          MOVE.L  D0,D3               ; Store the src mode in D3
00002354  0243 0038               1696          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002358  1A3C 0003               1697          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000235C  EA6B                    1698          LSR.W   D5,D3               ; Do the actual shift 
0000235E  4EB9 00002C84           1699          JSR     EA_GEN_SRC
00002364                          1700          
00002364  14FC 002C               1701          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002368  14FC 0020               1702          MOVE.B  #$20,(A2)+          ; Add space after comma
0000236C                          1703          
0000236C                          1704          ; Get desination and store into decode buffer
0000236C  2800                    1705          MOVE.L  D0,D4               ; Store the dest reg in D4
0000236E  0244 0E00               1706          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002372  1A3C 0009               1707          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002376  EA6C                    1708          LSR.W   D5,D4               ; Do the actual shift
00002378                          1709          
00002378  7601                    1710          MOVE.L  #1,D3               ; Store 001 into D3, so it can jump to An 
0000237A  4EB9 00002C84           1711          JSR     EA_GEN_SRC          ; Go get EA print
00002380  4EF8 1E10               1712          JMP     EA_FINISH           ; Opcode is finish
00002384                          1713  *------------------------------------------------------------------------------------------------*
00002384                          1714  EA_MOVEM        ; 6: ea_movem
00002384  2200                    1715          MOVE.L  D0, D1
00002386  0241 00F0               1716          ANDI.W  #third_nibble,D1
0000238A  1A3C 0004               1717          MOVE.B  #right4,D5 
0000238E  EA69                    1718          LSR.W   D5,D1
00002390  0201 0004               1719          ANDI.B  #4,D1
00002394  1401                    1720          MOVE.B  D1,D2
00002396  4EB8 1EA2               1721          JSR     EA_SIZE_MOVEM       ; get the size of the MOVEM as .W or .L 
0000239A                          1722  
0000239A  14FC 0020               1723          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000239E  14FC 0020               1724          MOVE.B  #$20,(A2)+          ; Print out a space
000023A2                          1725          
000023A2                          1726  *-----------------------------------------------------------------------------------*
000023A2                          1727  * HANDLE the case where src mode is 010. 
000023A2  2600                    1728          MOVE.L  D0,D3               ; Store the src mode in D3
000023A4  0243 0038               1729          ANDI.W  #src_mode,D3        ; Get bits 5-3
000023A8  1A3C 0003               1730          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000023AC  EA6B                    1731          LSR.W   D5,D3 
000023AE                          1732  
000023AE  B63C 0002               1733          CMP.B   #2, D3
000023B2  6700 0312               1734          BEQ     MEM_TO_REG        
000023B6                          1735  
000023B6                          1736  *-----------------------------------------------------------------------------------*
000023B6                          1737  
000023B6  2200                    1738          MOVE.L  D0, D1
000023B8  0241 0F00               1739          ANDI.W  #second_nibble,D1
000023BC  1A3C 0008               1740          MOVE.B  #right8,D5 
000023C0  EA69                    1741          LSR.W   D5,D1
000023C2  0201 0006               1742          ANDI.B  #6, D1              ; Get the Dr field
000023C6                          1743          
000023C6  B23C 0000               1744          CMP.B   #0, D1              ; check if Dr field is 0. 
000023CA  6700 000A               1745          BEQ     REG_TO_MEM
000023CE                          1746  
000023CE  B23C 0004               1747          CMP.B   #4, D1              ; check if Dr field is 1. 
000023D2  6700 02F2               1748          BEQ     MEM_TO_REG
000023D6                          1749  
000023D6                          1750  REG_TO_MEM                          ; pre-decrement - D7-D0,A7-A0
000023D6  3C15                    1751          MOVE.W  (A5), D6            ; store the register list mask field for REG to MEM
000023D8                          1752          
000023D8                          1753  * Print out the proper data and address registers. 
000023D8                          1754  * FIRST NIBBLE CHECK D0 - D3
000023D8                          1755  *-----------------------------------------------------------------------------------*
000023D8                          1756  * Print out D0 if mask field states to. 
000023D8                          1757  
000023D8  3606                    1758          MOVE.W  D6, D3
000023DA  0243 F000               1759          ANDI.W  #first_nibble,D3
000023DE  1A3C 000C               1760          MOVE.B  #right12,D5 
000023E2  EA6B                    1761          LSR.W   D5,D3
000023E4  0203 0008               1762          ANDI.B  #8,D3
000023E8  B63C 0008               1763          CMP.B   #8,D3
000023EC  6700 0006               1764          BEQ     D4_Dn_SETONE_0      ; SETONE refers to the set for reg to mem branch. 
000023F0  6000 0014               1765          BRA     CHECK1_BIT_14
000023F4                          1766  D4_Dn_SETONE_0
000023F4  183C 0000               1767          MOVE.B  #$0, D4
000023F8                          1768          
000023F8  6000 0002               1769          BRA     PRINT1_D0
000023FC                          1770          
000023FC                          1771  PRINT1_D0
000023FC  4EB9 00002CC2           1772          JSR     EA_Dn
00002402  14FC 002F               1773          MOVE.B  #$2F,(A2)+
00002406                          1774          
00002406                          1775  *-----------------------------------------------------------------------------------*
00002406                          1776  * Print out D1 if mask field states to. 
00002406                          1777  
00002406                          1778  CHECK1_BIT_14
00002406  3606                    1779          MOVE.W  D6, D3
00002408  0243 F000               1780          ANDI.W  #first_nibble,D3
0000240C  1A3C 000C               1781          MOVE.B  #right12,D5 
00002410  EA6B                    1782          LSR.W   D5,D3
00002412  0203 0004               1783          ANDI.B  #4,D3
00002416  B63C 0004               1784          CMP.B   #4,D3
0000241A  6700 0006               1785          BEQ     D4_Dn_SETONE_1      ; SETONE refers to the set for reg to mem branch. 
0000241E  6000 0014               1786          BRA     CHECK1_BIT_13
00002422                          1787  D4_Dn_SETONE_1
00002422  183C 0001               1788          MOVE.B  #$1, D4
00002426                          1789          
00002426  6000 0002               1790          BRA     PRINT1_D1
0000242A                          1791          
0000242A                          1792  PRINT1_D1
0000242A  4EB9 00002CC2           1793          JSR     EA_Dn
00002430  14FC 002F               1794          MOVE.B  #$2F,(A2)+
00002434                          1795  
00002434                          1796  *-----------------------------------------------------------------------------------*
00002434                          1797  * Print out D2 if mask field states to. 
00002434                          1798  
00002434                          1799  CHECK1_BIT_13
00002434  3606                    1800          MOVE.W  D6, D3
00002436  0243 F000               1801          ANDI.W  #first_nibble,D3
0000243A  1A3C 000C               1802          MOVE.B  #right12,D5 
0000243E  EA6B                    1803          LSR.W   D5,D3
00002440  0203 0002               1804          ANDI.B  #2,D3
00002444  B63C 0002               1805          CMP.B   #2,D3
00002448  6700 0006               1806          BEQ     D4_Dn_SETONE_2      ; SETONE refers to the set for reg to mem branch. 
0000244C  6000 0014               1807          BRA     CHECK1_BIT_12
00002450                          1808  D4_Dn_SETONE_2
00002450  183C 0002               1809          MOVE.B  #$2, D4
00002454                          1810          
00002454  6000 0002               1811          BRA     PRINT1_D2
00002458                          1812          
00002458                          1813  PRINT1_D2
00002458  4EB9 00002CC2           1814          JSR     EA_Dn
0000245E  14FC 002F               1815          MOVE.B  #$2F,(A2)+       
00002462                          1816  
00002462                          1817  *-----------------------------------------------------------------------------------*
00002462                          1818  * Print out D3 if mask field states to. 
00002462                          1819  
00002462                          1820  CHECK1_BIT_12
00002462  3606                    1821          MOVE.W  D6, D3
00002464  0243 F000               1822          ANDI.W  #first_nibble,D3
00002468  1A3C 000C               1823          MOVE.B  #right12,D5 
0000246C  EA6B                    1824          LSR.W   D5,D3
0000246E  0203 0001               1825          ANDI.B  #1,D3
00002472  B63C 0001               1826          CMP.B   #1,D3
00002476  6700 0006               1827          BEQ     D4_Dn_SETONE_3      ; SETONE refers to the set for reg to mem branch. 
0000247A  6000 0014               1828          BRA     CHECK1_BIT_11
0000247E                          1829  D4_Dn_SETONE_3
0000247E  183C 0003               1830          MOVE.B  #$3, D4
00002482                          1831          
00002482  6000 0002               1832          BRA     PRINT1_D3
00002486                          1833          
00002486                          1834  PRINT1_D3
00002486  4EB9 00002CC2           1835          JSR     EA_Dn
0000248C  14FC 002F               1836          MOVE.B  #$2F,(A2)+ 
00002490                          1837          
00002490                          1838  * SECOND NIBBLE CHECK D4 - D7
00002490                          1839  *-----------------------------------------------------------------------------------*
00002490                          1840  * Print out D4 if mask field states to. 
00002490                          1841  
00002490                          1842  
00002490                          1843  CHECK1_BIT_11
00002490  3606                    1844          MOVE.W  D6, D3
00002492  0243 0F00               1845          ANDI.W  #second_nibble,D3
00002496  1A3C 0008               1846          MOVE.B  #right8,D5 
0000249A  EA6B                    1847          LSR.W   D5,D3
0000249C  0203 0008               1848          ANDI.B  #8,D3
000024A0  B63C 0008               1849          CMP.B   #8,D3
000024A4  6700 0006               1850          BEQ     D4_Dn_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
000024A8  6000 0014               1851          BRA     CHECK1_BIT_10
000024AC                          1852  D4_Dn_SETONE_4
000024AC  183C 0004               1853          MOVE.B  #$4, D4
000024B0                          1854          
000024B0  6000 0002               1855          BRA     PRINT1_D4
000024B4                          1856          
000024B4                          1857  PRINT1_D4
000024B4  4EB9 00002CC2           1858          JSR     EA_Dn
000024BA  14FC 002F               1859          MOVE.B  #$2F,(A2)+ 
000024BE                          1860  
000024BE                          1861  *-----------------------------------------------------------------------------------*
000024BE                          1862  * Print out D5 if mask field states to. 
000024BE                          1863  
000024BE                          1864  CHECK1_BIT_10
000024BE  3606                    1865          MOVE.W  D6, D3
000024C0  0243 0F00               1866          ANDI.W  #second_nibble,D3
000024C4  1A3C 0008               1867          MOVE.B  #right8,D5 
000024C8  EA6B                    1868          LSR.W   D5,D3
000024CA  0203 0004               1869          ANDI.B  #4,D3
000024CE  B63C 0004               1870          CMP.B   #4,D3
000024D2  6700 0006               1871          BEQ     D4_Dn_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
000024D6  6000 0014               1872          BRA     CHECK1_BIT_9
000024DA                          1873  D4_Dn_SETONE_5
000024DA  183C 0005               1874          MOVE.B  #$5, D4
000024DE                          1875          
000024DE  6000 0002               1876          BRA     PRINT1_D5
000024E2                          1877          
000024E2                          1878  PRINT1_D5
000024E2  4EB9 00002CC2           1879          JSR     EA_Dn
000024E8  14FC 002F               1880          MOVE.B  #$2F,(A2)+ 
000024EC                          1881  
000024EC                          1882  *-----------------------------------------------------------------------------------*
000024EC                          1883  * Print out D6 if mask field states to. 
000024EC                          1884  
000024EC                          1885  CHECK1_BIT_9
000024EC  3606                    1886          MOVE.W  D6, D3
000024EE  0243 0F00               1887          ANDI.W  #second_nibble,D3
000024F2  1A3C 0008               1888          MOVE.B  #right8,D5 
000024F6  EA6B                    1889          LSR.W   D5,D3
000024F8  0203 0002               1890          ANDI.B  #2,D3
000024FC  B63C 0002               1891          CMP.B   #2,D3
00002500  6700 0006               1892          BEQ     D4_Dn_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
00002504  6000 0014               1893          BRA     CHECK1_BIT_8
00002508                          1894  D4_Dn_SETONE_6
00002508  183C 0006               1895          MOVE.B  #$6, D4
0000250C                          1896          
0000250C  6000 0002               1897          BRA     PRINT1_D6
00002510                          1898          
00002510                          1899  PRINT1_D6
00002510  4EB9 00002CC2           1900          JSR     EA_Dn
00002516  14FC 002F               1901          MOVE.B  #$2F,(A2)+ 
0000251A                          1902          
0000251A                          1903  *-----------------------------------------------------------------------------------*
0000251A                          1904  * Print out D7 if mask field states to. 
0000251A                          1905  
0000251A                          1906  CHECK1_BIT_8
0000251A  3606                    1907          MOVE.W  D6, D3
0000251C  0243 0F00               1908          ANDI.W  #second_nibble,D3
00002520  1A3C 0008               1909          MOVE.B  #right8,D5 
00002524  EA6B                    1910          LSR.W   D5,D3
00002526  0203 0001               1911          ANDI.B  #1,D3
0000252A  B63C 0001               1912          CMP.B   #1,D3
0000252E  6700 0006               1913          BEQ     D4_Dn_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
00002532  6000 0014               1914          BRA     CHECK1_BIT_7
00002536                          1915  D4_Dn_SETONE_7
00002536  183C 0007               1916          MOVE.B  #$7, D4
0000253A                          1917          
0000253A  6000 0002               1918          BRA     PRINT1_D7
0000253E                          1919          
0000253E                          1920  PRINT1_D7
0000253E  4EB9 00002CC2           1921          JSR     EA_Dn
00002544  14FC 002F               1922          MOVE.B  #$2F,(A2)+ 
00002548                          1923  
00002548                          1924  * THIRD NIBBLE CHECK - A0 / A3
00002548                          1925  *-----------------------------------------------------------------------------------*
00002548                          1926  * Print out A0 if mask field states to. 
00002548                          1927  
00002548                          1928  CHECK1_BIT_7
00002548  3606                    1929          MOVE.W  D6, D3
0000254A  0243 00F0               1930          ANDI.W  #third_nibble,D3
0000254E  1A3C 0004               1931          MOVE.B  #right4,D5 
00002552  EA6B                    1932          LSR.W   D5,D3
00002554  0203 0008               1933          ANDI.B  #8,D3
00002558  B63C 0008               1934          CMP.B   #8,D3
0000255C  6700 0006               1935          BEQ     D4_An_SETONE_0       ; SETONE refers to the set for reg to mem branch. 
00002560  6000 0014               1936          BRA     CHECK1_BIT_6
00002564                          1937  D4_An_SETONE_0
00002564  183C 0000               1938          MOVE.B  #$0, D4
00002568                          1939          
00002568  6000 0002               1940          BRA     PRINT1_A0
0000256C                          1941          
0000256C                          1942  PRINT1_A0
0000256C  4EB9 00002CCE           1943          JSR     EA_An
00002572  14FC 002F               1944          MOVE.B  #$2F,(A2)+ 
00002576                          1945          
00002576                          1946  *-----------------------------------------------------------------------------------*
00002576                          1947  * Print out A1 if mask field states to. 
00002576                          1948  
00002576                          1949  CHECK1_BIT_6
00002576  3606                    1950          MOVE.W  D6, D3
00002578  0243 00F0               1951          ANDI.W  #third_nibble,D3
0000257C  1A3C 0004               1952          MOVE.B  #right4,D5 
00002580  EA6B                    1953          LSR.W   D5,D3
00002582  0203 0004               1954          ANDI.B  #4,D3
00002586  B63C 0004               1955          CMP.B   #4,D3
0000258A  6700 0006               1956          BEQ     D4_An_SETONE_1       ; SETONE refers to the set for reg to mem branch. 
0000258E  6000 0014               1957          BRA     CHECK1_BIT_5
00002592                          1958  D4_An_SETONE_1
00002592  183C 0001               1959          MOVE.B  #$1, D4
00002596                          1960          
00002596  6000 0002               1961          BRA     PRINT1_A1
0000259A                          1962          
0000259A                          1963  PRINT1_A1
0000259A  4EB9 00002CCE           1964          JSR     EA_An
000025A0  14FC 002F               1965          MOVE.B  #$2F,(A2)+ 
000025A4                          1966  
000025A4                          1967  *-----------------------------------------------------------------------------------*
000025A4                          1968  * Print out A2 if mask field states to. 
000025A4                          1969  
000025A4                          1970  CHECK1_BIT_5
000025A4  3606                    1971          MOVE.W  D6, D3
000025A6  0243 00F0               1972          ANDI.W  #third_nibble,D3
000025AA  1A3C 0004               1973          MOVE.B  #right4,D5 
000025AE  EA6B                    1974          LSR.W   D5,D3
000025B0  0203 0002               1975          ANDI.B  #2,D3
000025B4  B63C 0002               1976          CMP.B   #2,D3
000025B8  6700 0006               1977          BEQ     D4_An_SETONE_2       ; SETONE refers to the set for reg to mem branch. 
000025BC  6000 0014               1978          BRA     CHECK1_BIT_4
000025C0                          1979  D4_An_SETONE_2
000025C0  183C 0002               1980          MOVE.B  #$2, D4
000025C4                          1981          
000025C4  6000 0002               1982          BRA     PRINT1_A2
000025C8                          1983          
000025C8                          1984  PRINT1_A2
000025C8  4EB9 00002CCE           1985          JSR     EA_An
000025CE  14FC 002F               1986          MOVE.B  #$2F,(A2)+ 
000025D2                          1987  
000025D2                          1988  *-----------------------------------------------------------------------------------*
000025D2                          1989  * Print out A3 if mask field states to. 
000025D2                          1990  
000025D2                          1991  CHECK1_BIT_4
000025D2  3606                    1992          MOVE.W  D6, D3
000025D4  0243 00F0               1993          ANDI.W  #third_nibble,D3
000025D8  1A3C 0004               1994          MOVE.B  #right4,D5 
000025DC  EA6B                    1995          LSR.W   D5,D3
000025DE  0203 0001               1996          ANDI.B  #1,D3
000025E2  B63C 0001               1997          CMP.B   #1,D3
000025E6  6700 0006               1998          BEQ     D4_An_SETONE_3       ; SETONE refers to the set for reg to mem branch. 
000025EA  6000 0014               1999          BRA     CHECK1_BIT_3
000025EE                          2000  D4_An_SETONE_3
000025EE  183C 0003               2001          MOVE.B  #$3, D4
000025F2                          2002          
000025F2  6000 0002               2003          BRA     PRINT1_A3
000025F6                          2004          
000025F6                          2005  PRINT1_A3
000025F6  4EB9 00002CCE           2006          JSR     EA_An
000025FC  14FC 002F               2007          MOVE.B  #$2F,(A2)+ 
00002600                          2008  
00002600                          2009  * FOURTH NIBBLE CHECK A4 - A7 
00002600                          2010  *-----------------------------------------------------------------------------------*
00002600                          2011  * Print out A4 if mask field states to. 
00002600                          2012  
00002600                          2013  CHECK1_BIT_3
00002600  3606                    2014          MOVE.W  D6, D3
00002602  0243 000F               2015          ANDI.W  #fourth_nibble,D3
00002606  0203 0008               2016          ANDI.B  #8,D3
0000260A  B63C 0008               2017          CMP.B   #8,D3
0000260E  6700 0006               2018          BEQ     D4_An_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
00002612  6000 0014               2019          BRA     CHECK1_BIT_2
00002616                          2020  D4_An_SETONE_4
00002616  183C 0004               2021          MOVE.B  #$4, D4
0000261A                          2022          
0000261A  6000 0002               2023          BRA     PRINT1_A4
0000261E                          2024          
0000261E                          2025  PRINT1_A4
0000261E  4EB9 00002CCE           2026          JSR     EA_An
00002624  14FC 002F               2027          MOVE.B  #$2F,(A2)+ 
00002628                          2028  
00002628                          2029  *-----------------------------------------------------------------------------------*
00002628                          2030  * Print out A5 if mask field states to. 
00002628                          2031  
00002628                          2032  CHECK1_BIT_2
00002628  3606                    2033          MOVE.W  D6, D3
0000262A  0243 000F               2034          ANDI.W  #fourth_nibble,D3
0000262E  0203 0004               2035          ANDI.B  #4,D3
00002632  B63C 0004               2036          CMP.B   #4,D3
00002636  6700 0006               2037          BEQ     D4_An_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
0000263A  6000 0014               2038          BRA     CHECK1_BIT_1
0000263E                          2039  D4_An_SETONE_5
0000263E  183C 0005               2040          MOVE.B  #$5, D4
00002642                          2041          
00002642  6000 0002               2042          BRA     PRINT1_A5
00002646                          2043          
00002646                          2044  PRINT1_A5
00002646  4EB9 00002CCE           2045          JSR     EA_An
0000264C  14FC 002F               2046          MOVE.B  #$2F,(A2)+ 
00002650                          2047  
00002650                          2048  *-----------------------------------------------------------------------------------*
00002650                          2049  * Print out A6 if mask field states to. 
00002650                          2050  
00002650                          2051  CHECK1_BIT_1
00002650  3606                    2052          MOVE.W  D6, D3
00002652  0243 000F               2053          ANDI.W  #fourth_nibble,D3
00002656  0203 0002               2054          ANDI.B  #2,D3
0000265A  B63C 0002               2055          CMP.B   #2,D3
0000265E  6700 0006               2056          BEQ     D4_An_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
00002662  6000 0014               2057          BRA     CHECK1_BIT_0
00002666                          2058  D4_An_SETONE_6
00002666  183C 0006               2059          MOVE.B  #$6, D4
0000266A                          2060          
0000266A  6000 0002               2061          BRA     PRINT1_A6
0000266E                          2062          
0000266E                          2063  PRINT1_A6
0000266E  4EB9 00002CCE           2064          JSR     EA_An
00002674  14FC 002F               2065          MOVE.B  #$2F,(A2)+ 
00002678                          2066  
00002678                          2067  *-----------------------------------------------------------------------------------*
00002678                          2068  * Print out A7 if mask field states to. 
00002678                          2069  
00002678                          2070  CHECK1_BIT_0
00002678  3606                    2071          MOVE.W  D6, D3
0000267A  0243 000F               2072          ANDI.W  #fourth_nibble,D3
0000267E  0203 0001               2073          ANDI.B  #1,D3
00002682  B63C 0001               2074          CMP.B   #1,D3
00002686  6700 0006               2075          BEQ     D4_An_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
0000268A  6000 0014               2076          BRA     FINISH_REG_TO_MEM
0000268E                          2077  D4_An_SETONE_7
0000268E  183C 0007               2078          MOVE.B  #$7, D4
00002692                          2079          
00002692  6000 0002               2080          BRA     PRINT1_A7
00002696                          2081          
00002696                          2082  PRINT1_A7
00002696  4EB9 00002CCE           2083          JSR     EA_An
0000269C  14FC 002F               2084          MOVE.B  #$2F,(A2)+ 
000026A0                          2085  
000026A0                          2086  FINISH_REG_TO_MEM
000026A0  14FC 002C               2087          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000026A4  14FC 0020               2088          MOVE.B  #$20,(A2)+          ; Add space after comma
000026A8                          2089  
000026A8  2800                    2090          MOVE.L  D0,D4               ; Store the src reg in D4
000026AA  0244 0007               2091          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000026AE                          2092          
000026AE  2600                    2093          MOVE.L  D0,D3               ; Store the src mode in D3
000026B0  0243 0038               2094          ANDI.W  #src_mode,D3        ; Get bits 5-3
000026B4  1A3C 0003               2095          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000026B8  EA6B                    2096          LSR.W   D5,D3               ; Do the actual shift 
000026BA  4EB9 00002C84           2097          JSR     EA_GEN_SRC
000026C0                          2098          
000026C0  301D                    2099          MOVE.W  (A5)+, D0 
000026C2                          2100  
000026C2  4EF8 1E10               2101          JMP     EA_FINISH
000026C6                          2102  
000026C6                          2103  MEM_TO_REG                          ; post-increment + A7-A0,D7-D0
000026C6                          2104  
000026C6  B63C 0002               2105          CMP.B   #2, D3              ; check if the destination is (An)
000026CA  6700 0022               2106          BEQ     MEM_TO_REG_CONTINUE ; branch to print out the address and data registers. 
000026CE                          2107          
000026CE  2800                    2108          MOVE.L  D0,D4               ; Store the src reg in D4
000026D0  0244 0007               2109          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000026D4                          2110          
000026D4  2600                    2111          MOVE.L  D0,D3               ; Store the src mode in D3
000026D6  0243 0038               2112          ANDI.W  #src_mode,D3        ; Get bits 5-3
000026DA  1A3C 0003               2113          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000026DE  EA6B                    2114          LSR.W   D5,D3               ; Do the actual shift 
000026E0  4EB9 00002C84           2115          JSR     EA_GEN_SRC
000026E6                          2116          
000026E6  14FC 002C               2117          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000026EA  14FC 0020               2118          MOVE.B  #$20,(A2)+          ; Add space after comma
000026EE                          2119  
000026EE                          2120          
000026EE                          2121  * Print out the proper data and address registers. 
000026EE                          2122  * FIRST NIBBLE CHECK A7 - A4
000026EE                          2123  *-----------------------------------------------------------------------------------*
000026EE                          2124  * Print out A7 if mask field states to. 
000026EE                          2125  MEM_TO_REG_CONTINUE
000026EE  3C15                    2126          MOVE.W  (A5), D6            ; store the register list mask field for MEM to REG
000026F0                          2127          
000026F0  3606                    2128          MOVE.W  D6, D3
000026F2  0243 F000               2129          ANDI.W  #first_nibble,D3
000026F6  1A3C 000C               2130          MOVE.B  #right12,D5 
000026FA  EA6B                    2131          LSR.W   D5,D3
000026FC  0203 0008               2132          ANDI.B  #8,D3
00002700  B63C 0008               2133          CMP.B   #8,D3
00002704  6700 0006               2134          BEQ     D4_An_SET_7
00002708  6000 0014               2135          BRA     CHECK_BIT_14
0000270C                          2136  D4_An_SET_7
0000270C  183C 0007               2137          MOVE.B  #$7, D4
00002710                          2138          
00002710  6000 0002               2139          BRA     PRINT_A7
00002714                          2140          
00002714                          2141  PRINT_A7
00002714  4EB9 00002CCE           2142          JSR     EA_An
0000271A  14FC 002F               2143          MOVE.B  #$2F,(A2)+
0000271E                          2144          
0000271E                          2145  *-----------------------------------------------------------------------------------*
0000271E                          2146  * Print out A6 if mask field states to. 
0000271E                          2147  
0000271E                          2148  CHECK_BIT_14
0000271E  3606                    2149          MOVE.W  D6, D3
00002720  0243 F000               2150          ANDI.W  #first_nibble,D3
00002724  1A3C 000C               2151          MOVE.B  #right12,D5 
00002728  EA6B                    2152          LSR.W   D5,D3
0000272A  0203 0004               2153          ANDI.B  #4,D3
0000272E  B63C 0004               2154          CMP.B   #4,D3
00002732  6700 0006               2155          BEQ     D4_An_SET_6
00002736  6000 0014               2156          BRA     CHECK_BIT_13
0000273A                          2157  D4_An_SET_6
0000273A  183C 0006               2158          MOVE.B  #$6, D4
0000273E                          2159          
0000273E  6000 0002               2160          BRA     PRINT_A6
00002742                          2161          
00002742                          2162  PRINT_A6
00002742  4EB9 00002CCE           2163          JSR     EA_An
00002748  14FC 002F               2164          MOVE.B  #$2F,(A2)+
0000274C                          2165  
0000274C                          2166  *-----------------------------------------------------------------------------------*
0000274C                          2167  * Print out A5 if mask field states to. 
0000274C                          2168  
0000274C                          2169  CHECK_BIT_13
0000274C  3606                    2170          MOVE.W  D6, D3
0000274E  0243 F000               2171          ANDI.W  #first_nibble,D3
00002752  1A3C 000C               2172          MOVE.B  #right12,D5 
00002756  EA6B                    2173          LSR.W   D5,D3
00002758  0203 0002               2174          ANDI.B  #2,D3
0000275C  B63C 0002               2175          CMP.B   #2,D3
00002760  6700 0006               2176          BEQ     D4_An_SET_5
00002764  6000 0014               2177          BRA     CHECK_BIT_12
00002768                          2178  D4_An_SET_5
00002768  183C 0005               2179          MOVE.B  #$5, D4
0000276C                          2180          
0000276C  6000 0002               2181          BRA     PRINT_A5
00002770                          2182          
00002770                          2183  PRINT_A5
00002770  4EB9 00002CCE           2184          JSR     EA_An
00002776  14FC 002F               2185          MOVE.B  #$2F,(A2)+
0000277A                          2186  
0000277A                          2187  *-----------------------------------------------------------------------------------*
0000277A                          2188  * Print out A4 if mask field states to. 
0000277A                          2189          
0000277A                          2190  CHECK_BIT_12
0000277A  3606                    2191          MOVE.W  D6, D3
0000277C  0243 F000               2192          ANDI.W  #first_nibble,D3
00002780  1A3C 000C               2193          MOVE.B  #right12,D5 
00002784  EA6B                    2194          LSR.W   D5,D3
00002786  0203 0001               2195          ANDI.B  #1,D3
0000278A  B63C 0001               2196          CMP.B   #1,D3
0000278E  6700 0006               2197          BEQ     D4_An_SET_4
00002792  6000 0014               2198          BRA     CHECK_BIT_11
00002796                          2199  D4_An_SET_4
00002796  183C 0004               2200          MOVE.B  #$4, D4
0000279A                          2201          
0000279A  6000 0002               2202          BRA     PRINT_A4
0000279E                          2203          
0000279E                          2204  PRINT_A4
0000279E  4EB9 00002CCE           2205          JSR     EA_An
000027A4  14FC 002F               2206          MOVE.B  #$2F,(A2)+
000027A8                          2207  
000027A8                          2208  *-----------------------------------------------------------------------------------*
000027A8                          2209  * Print out A3 if mask field states to. 
000027A8                          2210  * SECOND NIBBLE CHECK A7 - A4
000027A8                          2211    
000027A8                          2212  CHECK_BIT_11
000027A8  3606                    2213          MOVE.W  D6, D3
000027AA  0243 0F00               2214          ANDI.W  #second_nibble,D3
000027AE  1A3C 0008               2215          MOVE.B  #right8,D5 
000027B2  EA6B                    2216          LSR.W   D5,D3
000027B4  0203 0008               2217          ANDI.B  #8,D3
000027B8  B63C 0008               2218          CMP.B   #8,D3
000027BC  6700 0006               2219          BEQ     D4_An_SET_3
000027C0  6000 0014               2220          BRA     CHECK_BIT_10
000027C4                          2221  D4_An_SET_3
000027C4  183C 0003               2222          MOVE.B  #$3, D4
000027C8                          2223          
000027C8  6000 0002               2224          BRA     PRINT_A3
000027CC                          2225          
000027CC                          2226  PRINT_A3
000027CC  4EB9 00002CCE           2227          JSR     EA_An
000027D2  14FC 002F               2228          MOVE.B  #$2F,(A2)+     
000027D6                          2229  
000027D6                          2230  *-----------------------------------------------------------------------------------*
000027D6                          2231  * Print out A2 if mask field states to. 
000027D6                          2232    
000027D6                          2233  CHECK_BIT_10
000027D6  3606                    2234          MOVE.W  D6, D3
000027D8  0243 0F00               2235          ANDI.W  #second_nibble,D3
000027DC  1A3C 0008               2236          MOVE.B  #right8,D5 
000027E0  EA6B                    2237          LSR.W   D5,D3
000027E2  0203 0004               2238          ANDI.B  #4,D3
000027E6  B63C 0004               2239          CMP.B   #4,D3
000027EA  6700 0006               2240          BEQ     D4_An_SET_2
000027EE  6000 0014               2241          BRA     CHECK_BIT_9
000027F2                          2242  D4_An_SET_2
000027F2  183C 0002               2243          MOVE.B  #$2, D4
000027F6                          2244          
000027F6  6000 0002               2245          BRA     PRINT_A2
000027FA                          2246          
000027FA                          2247  PRINT_A2
000027FA  4EB9 00002CCE           2248          JSR     EA_An
00002800  14FC 002F               2249          MOVE.B  #$2F,(A2)+  
00002804                          2250  
00002804                          2251  *-----------------------------------------------------------------------------------*
00002804                          2252  * Print out A1 if mask field states to. 
00002804                          2253    
00002804                          2254  CHECK_BIT_9
00002804  3606                    2255          MOVE.W  D6, D3
00002806  0243 0F00               2256          ANDI.W  #second_nibble,D3
0000280A  1A3C 0008               2257          MOVE.B  #right8,D5 
0000280E  EA6B                    2258          LSR.W   D5,D3
00002810  0203 0002               2259          ANDI.B  #2,D3
00002814  B63C 0002               2260          CMP.B   #2,D3
00002818  6700 0006               2261          BEQ     D4_An_SET_1
0000281C  6000 0012               2262          BRA     CHECK_BIT_8
00002820                          2263  D4_An_SET_1
00002820  183C 0001               2264          MOVE.B  #$1, D4
00002824                          2265          
00002824  60D4                    2266          BRA     PRINT_A2
00002826                          2267          
00002826                          2268  PRINT_A1
00002826  4EB9 00002CCE           2269          JSR     EA_An
0000282C  14FC 002F               2270          MOVE.B  #$2F,(A2)+ 
00002830                          2271  
00002830                          2272  *-----------------------------------------------------------------------------------*
00002830                          2273  * Print out A0 if mask field states to. 
00002830                          2274    
00002830                          2275  CHECK_BIT_8
00002830  3606                    2276          MOVE.W  D6, D3
00002832  0243 0F00               2277          ANDI.W  #second_nibble,D3
00002836  1A3C 0008               2278          MOVE.B  #right8,D5 
0000283A  EA6B                    2279          LSR.W   D5,D3
0000283C  0203 0001               2280          ANDI.B  #1,D3
00002840  B63C 0001               2281          CMP.B   #1,D3
00002844  6700 0006               2282          BEQ     D4_An_SET_0
00002848  6000 0014               2283          BRA     CHECK_BIT_7
0000284C                          2284  D4_An_SET_0
0000284C  183C 0000               2285          MOVE.B  #$0, D4
00002850                          2286          
00002850  6000 0002               2287          BRA     PRINT_A0
00002854                          2288          
00002854                          2289  PRINT_A0
00002854  4EB9 00002CCE           2290          JSR     EA_An
0000285A  14FC 002F               2291          MOVE.B  #$2F,(A2)+        
0000285E                          2292  
0000285E                          2293  *-----------------------------------------------------------------------------------*
0000285E                          2294  * Print out D7 if mask field states to. 
0000285E                          2295  * THIRD NIBBLE CHECK D7-D0
0000285E                          2296  
0000285E                          2297  CHECK_BIT_7
0000285E  3606                    2298          MOVE.W  D6, D3
00002860  0243 00F0               2299          ANDI.W  #third_nibble,D3
00002864  1A3C 0004               2300          MOVE.B  #right4,D5 
00002868  EA6B                    2301          LSR.W   D5,D3
0000286A  0203 0008               2302          ANDI.B  #8,D3
0000286E  B63C 0008               2303          CMP.B   #8,D3
00002872  6700 0006               2304          BEQ     D4_Dn_SET_7
00002876  6000 0014               2305          BRA     CHECK_BIT_6
0000287A                          2306  D4_Dn_SET_7
0000287A  183C 0007               2307          MOVE.B  #$7, D4
0000287E                          2308          
0000287E  6000 0002               2309          BRA     PRINT_D7
00002882                          2310          
00002882                          2311  PRINT_D7
00002882  4EB9 00002CC2           2312          JSR     EA_Dn
00002888  14FC 002F               2313          MOVE.B  #$2F,(A2)+
0000288C                          2314  
0000288C                          2315  *-----------------------------------------------------------------------------------*
0000288C                          2316  * Print out D6 if mask field states to. 
0000288C                          2317  
0000288C                          2318  CHECK_BIT_6
0000288C  3606                    2319          MOVE.W  D6, D3
0000288E  0243 00F0               2320          ANDI.W  #third_nibble,D3
00002892  1A3C 0004               2321          MOVE.B  #right4,D5 
00002896  EA6B                    2322          LSR.W   D5,D3
00002898  0203 0004               2323          ANDI.B  #4,D3
0000289C  B63C 0004               2324          CMP.B   #4,D3
000028A0  6700 0006               2325          BEQ     D4_Dn_SET_6
000028A4  6000 0014               2326          BRA     CHECK_BIT_5
000028A8                          2327  D4_Dn_SET_6
000028A8  183C 0006               2328          MOVE.B  #$6, D4
000028AC                          2329          
000028AC  6000 0002               2330          BRA     PRINT_D6
000028B0                          2331          
000028B0                          2332  PRINT_D6
000028B0  4EB9 00002CC2           2333          JSR     EA_Dn
000028B6  14FC 002F               2334          MOVE.B  #$2F,(A2)+
000028BA                          2335  
000028BA                          2336  *-----------------------------------------------------------------------------------*
000028BA                          2337  * Print out D5 if mask field states to. 
000028BA                          2338  
000028BA                          2339  CHECK_BIT_5
000028BA  3606                    2340          MOVE.W  D6, D3
000028BC  0243 00F0               2341          ANDI.W  #third_nibble,D3
000028C0  1A3C 0004               2342          MOVE.B  #right4,D5 
000028C4  EA6B                    2343          LSR.W   D5,D3
000028C6  0203 0002               2344          ANDI.B  #2,D3
000028CA  B63C 0002               2345          CMP.B   #2,D3
000028CE  6700 0006               2346          BEQ     D4_Dn_SET_5
000028D2  6000 0014               2347          BRA     CHECK_BIT_4
000028D6                          2348  D4_Dn_SET_5
000028D6  183C 0005               2349          MOVE.B  #$5, D4
000028DA                          2350          
000028DA  6000 0002               2351          BRA     PRINT_D5
000028DE                          2352          
000028DE                          2353  PRINT_D5
000028DE  4EB9 00002CC2           2354          JSR     EA_Dn
000028E4  14FC 002F               2355          MOVE.B  #$2F,(A2)+
000028E8                          2356  
000028E8                          2357  *-----------------------------------------------------------------------------------*
000028E8                          2358  * Print out D4 if mask field states to. 
000028E8                          2359  
000028E8                          2360  CHECK_BIT_4
000028E8  3606                    2361          MOVE.W  D6, D3
000028EA  0243 00F0               2362          ANDI.W  #third_nibble,D3
000028EE  1A3C 0004               2363          MOVE.B  #right4,D5 
000028F2  EA6B                    2364          LSR.W   D5,D3
000028F4  0203 0001               2365          ANDI.B  #1,D3
000028F8  B63C 0001               2366          CMP.B   #1,D3
000028FC  6700 0006               2367          BEQ     D4_Dn_SET_4
00002900  6000 0014               2368          BRA     CHECK_BIT_3
00002904                          2369  D4_Dn_SET_4
00002904  183C 0004               2370          MOVE.B  #$4, D4
00002908                          2371          
00002908  6000 0002               2372          BRA     PRINT_D4
0000290C                          2373          
0000290C                          2374  PRINT_D4
0000290C  4EB9 00002CC2           2375          JSR     EA_Dn
00002912  14FC 002F               2376          MOVE.B  #$2F,(A2)+
00002916                          2377  
00002916                          2378  *-----------------------------------------------------------------------------------*
00002916                          2379  * Print out D3 if mask field states to. 
00002916                          2380  * FOURTH NIBBLE CHECK / D3 - D0
00002916                          2381  
00002916                          2382  CHECK_BIT_3
00002916  3606                    2383          MOVE.W  D6, D3
00002918  0243 000F               2384          ANDI.W  #fourth_nibble,D3
0000291C  0203 0008               2385          ANDI.B  #8,D3
00002920  B63C 0008               2386          CMP.B   #8,D3
00002924  6700 0006               2387          BEQ     D4_Dn_SET_3
00002928  6000 0014               2388          BRA     CHECK_BIT_2
0000292C                          2389  D4_Dn_SET_3
0000292C  183C 0003               2390          MOVE.B  #$3, D4
00002930                          2391          
00002930  6000 0002               2392          BRA     PRINT_D3
00002934                          2393          
00002934                          2394  PRINT_D3
00002934  4EB9 00002CC2           2395          JSR     EA_Dn
0000293A  14FC 002F               2396          MOVE.B  #$2F,(A2)+
0000293E                          2397  
0000293E                          2398  *-----------------------------------------------------------------------------------*
0000293E                          2399  * Print out D2 if mask field states to. 
0000293E                          2400  
0000293E                          2401  CHECK_BIT_2
0000293E  3606                    2402          MOVE.W  D6, D3
00002940  0243 000F               2403          ANDI.W  #fourth_nibble,D3
00002944  0203 0004               2404          ANDI.B  #4,D3
00002948  B63C 0004               2405          CMP.B   #4,D3
0000294C  6700 0006               2406          BEQ     D4_Dn_SET_2
00002950  6000 0014               2407          BRA     CHECK_BIT_1
00002954                          2408  D4_Dn_SET_2
00002954  183C 0002               2409          MOVE.B  #$2, D4
00002958                          2410          
00002958  6000 0002               2411          BRA     PRINT_D2
0000295C                          2412          
0000295C                          2413  PRINT_D2
0000295C  4EB9 00002CC2           2414          JSR     EA_Dn
00002962  14FC 002F               2415          MOVE.B  #$2F,(A2)+
00002966                          2416  
00002966                          2417  *-----------------------------------------------------------------------------------*
00002966                          2418  * Print out D1 if mask field states to. 
00002966                          2419  
00002966                          2420  CHECK_BIT_1
00002966  3606                    2421          MOVE.W  D6, D3
00002968  0243 000F               2422          ANDI.W  #fourth_nibble,D3
0000296C  0203 0002               2423          ANDI.B  #2,D3
00002970  B63C 0002               2424          CMP.B   #2,D3
00002974  6700 0006               2425          BEQ     D4_Dn_SET_1
00002978  6000 0014               2426          BRA     CHECK_BIT_0
0000297C                          2427  D4_Dn_SET_1
0000297C  183C 0001               2428          MOVE.B  #$1, D4
00002980                          2429          
00002980  6000 0002               2430          BRA     PRINT_D1
00002984                          2431          
00002984                          2432  PRINT_D1
00002984  4EB9 00002CC2           2433          JSR     EA_Dn
0000298A  14FC 002F               2434          MOVE.B  #$2F,(A2)+
0000298E                          2435  
0000298E                          2436  *-----------------------------------------------------------------------------------*
0000298E                          2437  * Print out D0 if mask field states to. 
0000298E                          2438  
0000298E                          2439  CHECK_BIT_0
0000298E  3606                    2440          MOVE.W  D6, D3
00002990  0243 000F               2441          ANDI.W  #fourth_nibble,D3
00002994  0203 0001               2442          ANDI.B  #1,D3
00002998  B63C 0001               2443          CMP.B   #1,D3
0000299C  6700 0006               2444          BEQ     D4_Dn_SET_0
000029A0  6000 0014               2445          BRA     FINISH_MOVEM_MEM_TO_REG
000029A4                          2446  D4_Dn_SET_0
000029A4  183C 0000               2447          MOVE.B  #$0, D4
000029A8                          2448          
000029A8  6000 0002               2449          BRA     PRINT_D0
000029AC                          2450          
000029AC                          2451  PRINT_D0
000029AC  4EB9 00002CC2           2452          JSR     EA_Dn
000029B2  14FC 002F               2453          MOVE.B  #$2F,(A2)+
000029B6                          2454  
000029B6                          2455  FINISH_MOVEM_MEM_TO_REG
000029B6                          2456          
000029B6  2600                    2457          MOVE.L  D0,D3               ; Store the src mode in D3
000029B8  0243 0038               2458          ANDI.W  #src_mode,D3        ; Get bits 5-3
000029BC  1A3C 0003               2459          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000029C0  EA6B                    2460          LSR.W   D5,D3               ; Do the actual shift
000029C2                          2461  
000029C2  2800                    2462          MOVE.L  D0,D4               ; Store the dst reg in D4
000029C4  0244 0007               2463          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000029C8                          2464   
000029C8  B63C 0002               2465          CMP.B   #2, D3
000029CC  6700 0006               2466          BEQ     An_FINISH           ; branch to print out (An) 
000029D0  6000 0010               2467          BRA     NORMAL_FINISH       ; branch to the normal finish
000029D4                          2468  
000029D4                          2469  An_FINISH
000029D4  14FC 002C               2470          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000029D8  14FC 0020               2471          MOVE.B  #$20,(A2)+          ; Add space after comma
000029DC                          2472          
000029DC                          2473                      
000029DC  4EB9 00002C84           2474          JSR     EA_GEN_SRC
000029E2                          2475  
000029E2                          2476  NORMAL_FINISH
000029E2  301D                    2477          MOVE.W  (A5)+, D0
000029E4                          2478          
000029E4  4EF8 1E10               2479          JMP     EA_FINISH
000029E8                          2480  *------------------------------------------------------------------------------------------------*
000029E8                          2481  EA_SHIFTS       ; 7: ea_shifts
000029E8  2200                    2482          MOVE.L  D0,D1               ; D0 is current instruction word
000029EA  0241 01C0               2483          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000029EE  1A3C 0006               2484          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000029F2  EA69                    2485          LSR.W   D5,D1               ; Shift dst mode into LSB position
000029F4  C2FC 0006               2486          MULU    #6, D1              ; Set displacement 
000029F8  41F9 00002A02           2487          LEA     EA_SHIFTS_TABLE,A0  ; Load table into A0
000029FE  4EF0 1000               2488          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00002A02                          2489  
00002A02                          2490  EA_SHIFTS_TABLE
00002A02  4EF9 00002AA8           2491          JMP     EA_REGISTER_SHIFTS  ; 000 Register
00002A08  4EF9 00002AA8           2492          JMP     EA_REGISTER_SHIFTS  ; 001 Register
00002A0E  4EF9 00002AA8           2493          JMP     EA_REGISTER_SHIFTS  ; 010 Register
00002A14  4EF9 00002A32           2494          JMP     EA_MEMORY_SHIFTS    ; 011 Memory
00002A1A  4EF9 00002AA8           2495          JMP     EA_REGISTER_SHIFTS  ; 100 Register
00002A20  4EF9 00002AA8           2496          JMP     EA_REGISTER_SHIFTS  ; 101 Register
00002A26  4EF9 00002AA8           2497          JMP     EA_REGISTER_SHIFTS  ; 110 Register
00002A2C  4EF9 00002A32           2498          JMP     EA_MEMORY_SHIFTS    ; 111 Memory
00002A32                          2499          
00002A32                          2500  EA_MEMORY_SHIFTS
00002A32                          2501          ; Get EA and store into decode buffer
00002A32  2800                    2502          MOVE.L  D0,D4               ; Store the EA reg in D4
00002A34  0244 0007               2503          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002A38                          2504          
00002A38  2600                    2505          MOVE.L  D0,D3               ; Store the EA mode in D3
00002A3A  0243 0038               2506          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002A3E  1A3C 0003               2507          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002A42  EA6B                    2508          LSR.W   D5,D3               ; Do the actual shift
00002A44  4EB9 00002D9A           2509          JSR     An_CHECK            ; Check if mode is An 
00002A4A  4EB9 00002DA4           2510          JSR     Dn_CHECK            ; Check if mode is Dn
00002A50  4EB9 00002DAE           2511          JSR     IMMEDIATE_CHECK     ; Check if mode is immediate
00002A56                          2512          
00002A56  14FC 0020               2513          MOVE.B  #$20,(A2)+          ; Print out a space 
00002A5A  14FC 0020               2514          MOVE.B  #$20,(A2)+          ; Print out a space
00002A5E  14FC 0020               2515          MOVE.B  #$20,(A2)+          ; Print out a space
00002A62  14FC 0020               2516          MOVE.B  #$20,(A2)+          ; Print out a space
00002A66  14FC 0020               2517          MOVE.B  #$20,(A2)+          ; Add space
00002A6A                          2518          
00002A6A  4EB9 00002A82           2519          JSR     FRONT_FORMAT
00002A70  4EB9 00002C84           2520          JSR     EA_GEN_SRC          ; Go get EA print
00002A76  B63C 002A               2521          CMP.B   #$2A,D3             ; When mode is 111 * 6 (2A)
00002A7A  6700 001E               2522          BEQ     BACK_PARENTHESIS  
00002A7E  4EF8 1E10               2523          JMP     EA_FINISH           ; Opcode is finish
00002A82                          2524  
00002A82                          2525  FRONT_FORMAT
00002A82  B63C 0007               2526          CMP.B   #7,D3               ; When mode is 111
00002A86  6700 0008               2527          BEQ     ADD_PARENTHESIS
00002A8A  14FC 0020               2528          MOVE.B  #$20,(A2)+          ; Print out a space
00002A8E  4E75                    2529          RTS
00002A90                          2530          
00002A90                          2531  ADD_PARENTHESIS
00002A90  14FC 0020               2532          MOVE.B  #$20,(A2)+          ; Print out a space
00002A94  14FC 0028               2533          MOVE.B  #'(',(A2)+
00002A98  4E75                    2534          RTS
00002A9A                          2535          
00002A9A                          2536  BACK_PARENTHESIS            
00002A9A  14FC 0029               2537          MOVE.B  #')',(A2)+
00002A9E  1404                    2538          MOVE.B  D4,D2
00002AA0  4EB8 1EFE               2539          JSR     EA_SIZE_MEMORY_SHIFTS
00002AA4  4EF8 1E10               2540          JMP     EA_FINISH           ; Opcode is finish
00002AA8                          2541      
00002AA8                          2542  EA_REGISTER_SHIFTS
00002AA8  2200                    2543          MOVE.L  D0,D1
00002AAA  0241 01C0               2544          ANDI.W  #dst_mode,D1
00002AAE  1A3C 0006               2545          MOVE.B  #right6,D5 
00002AB2  EA69                    2546          LSR.W   D5,D1
00002AB4  0201 0003               2547          ANDI.B  #3,D1               ; Remove bit 8 and get bits 7-6
00002AB8  1401                    2548          MOVE.B  D1,D2
00002ABA  4EB8 1E56               2549          JSR     EA_SIZE_GENERAL
00002ABE                          2550          
00002ABE  2600                    2551          MOVE.L  D0,D3               ; Store the instruction in D3
00002AC0  0243 0038               2552          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002AC4  1A3C 0003               2553          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002AC8  EA6B                    2554          LSR.W   D5,D3               ; Do the actual shift 
00002ACA  0203 0004               2555          ANDI.B  #4,D3               ; Get bit 5(ir) from bits 5-3
00002ACE  E44B                    2556          LSR.W   #2,D3
00002AD0                          2557  
00002AD0  B63C 0000               2558          CMP.B   #0,D3               ; When D1 is 0 (immediate)
00002AD4  6700 0006               2559          BEQ     IMMEDIATE_SRC
00002AD8  6000 0056               2560          BRA     REGISTER_SRC        ; When D1 is 1 (register)
00002ADC                          2561          
00002ADC                          2562  IMMEDIATE_SRC
00002ADC  14FC 0020               2563          MOVE.B  #$20,(A2)+          ; Add space
00002AE0  14FC 0020               2564          MOVE.B  #$20,(A2)+          ; Add space
00002AE4  14FC 0020               2565          MOVE.B  #$20,(A2)+          ; Add space
00002AE8  14FC 0020               2566          MOVE.B  #$20,(A2)+          ; Add space
00002AEC                          2567          
00002AEC                          2568          ; Get source and store into decode buffer
00002AEC  2800                    2569          MOVE.L  D0,D4               ; Store the src reg in D4
00002AEE  0244 0E00               2570          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002AF2  1A3C 0009               2571          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002AF6  EA6C                    2572          LSR.W   D5,D4               ; Do the actual shift
00002AF8  4EB9 00002B20           2573          JSR     CHECK_IF_ZERO       ; Check if register is 0
00002AFE                          2574          
00002AFE  14FC 0023               2575          MOVE.B  #$23,(A2)+          ; Add # symbol
00002B02  0604 0030               2576          ADDI.B  #$30,D4             ; Convert hex to ASCII
00002B06  14C4                    2577          MOVE.B  D4,(A2)+            ; Store into buffer
00002B08                          2578          
00002B08  14FC 002C               2579          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B0C  14FC 0020               2580          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B10                          2581  
00002B10                          2582          ; Get destination and store into decode buffer
00002B10  2800                    2583          MOVE.L  D0,D4               ; Store the src reg in D4
00002B12  0244 0007               2584          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002B16  4EB9 00002CC2           2585          JSR     EA_Dn               ; store Dn into decode buffer
00002B1C  4EF8 1E10               2586          JMP     EA_FINISH           ; Opcode is finish
00002B20                          2587                
00002B20                          2588  CHECK_IF_ZERO
00002B20  B83C 0000               2589          CMP.B   #0,D4               ; When D4 is 0 
00002B24  6700 0004               2590          BEQ     IMMEDIATE_EIGHT     ; Branch
00002B28  4E75                    2591          RTS
00002B2A                          2592  
00002B2A                          2593  IMMEDIATE_EIGHT
00002B2A  183C 0008               2594          MOVE.B  #8,D4               ; Store 8 into D4 
00002B2E  4E75                    2595          RTS
00002B30                          2596  
00002B30                          2597  REGISTER_SRC        
00002B30  14FC 0020               2598          MOVE.B  #$20,(A2)+          ; Add space
00002B34  14FC 0020               2599          MOVE.B  #$20,(A2)+          ; Add space
00002B38  14FC 0020               2600          MOVE.B  #$20,(A2)+          ; Add space
00002B3C  14FC 0020               2601          MOVE.B  #$20,(A2)+          ; Add space
00002B40                          2602  
00002B40                          2603          ; Get source and store into decode buffer
00002B40  2800                    2604          MOVE.L  D0,D4               ; Store the src reg in D4
00002B42  0244 0E00               2605          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B46  1A3C 0009               2606          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B4A  EA6C                    2607          LSR.W   D5,D4               ; Do the actual shift
00002B4C  4EB9 00002CC2           2608          JSR     EA_Dn               ; store Dn into decode buffer
00002B52                          2609          
00002B52  14FC 002C               2610          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B56  14FC 0020               2611          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B5A                          2612  
00002B5A                          2613          ; Get destination and store into decode buffer
00002B5A  2800                    2614          MOVE.L  D0,D4               ; Store the src reg in D4
00002B5C  0244 0007               2615          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002B60  4EB9 00002CC2           2616          JSR     EA_Dn               ; store Dn into decode buffer
00002B66  4EF8 1E10               2617          JMP     EA_FINISH           ; Opcode is finish
00002B6A                          2618  *------------------------------------------------------------------------------------------------*
00002B6A                          2619  EA_QUICK        ; 8: ea_quick
00002B6A  BC3C 0005               2620          CMP.B   #5, D6              ; check if the first nibble is 5 for ADDQ
00002B6E  6700 000A               2621          BEQ     ADDQ_EA_CALC
00002B72                          2622          
00002B72  BC3C 0007               2623          CMP.B   #7, D6              ; check if the first nibble is 7 for MOVEQ
00002B76  6700 0072               2624          BEQ     MOVEQ_EA_CALC
00002B7A                          2625          
00002B7A                          2626  ADDQ_EA_CALC
00002B7A  2200                    2627          MOVE.L  D0,D1
00002B7C  0241 01C0               2628          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00002B80  1A3C 0006               2629          MOVE.B  #right6,D5          ; Store 6 into D5
00002B84  EA69                    2630          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002B86  0201 0003               2631          ANDI.B  #3,D1               ; Remove the front bit from D1
00002B8A  1401                    2632          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002B8C  4EB8 1E56               2633          JSR     EA_SIZE_GENERAL     ; Get size and print size.
00002B90                          2634          
00002B90  14FC 0020               2635          MOVE.B  #$20,(A2)+          ; Add space after size
00002B94  14FC 0020               2636          MOVE.B  #$20,(A2)+          ; Add space
00002B98  14FC 0020               2637          MOVE.B  #$20,(A2)+          ; Add space
00002B9C                          2638          
00002B9C  14FC 0023               2639          MOVE.B  #$23,(A2)+          ; Add # symbol
00002BA0  14FC 0024               2640          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002BA4                          2641          
00002BA4  2800                    2642          MOVE.L  D0,D4               ; Store the data in D4
00002BA6  0244 0E00               2643          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002BAA  1A3C 0009               2644          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002BAE  EA6C                    2645          LSR.W   D5,D4               ; Do the actual shift
00002BB0                          2646          
00002BB0  B83C 0000               2647          CMP.B   #0, D4
00002BB4  6700 0006               2648          BEQ     CHANGE_TO_EIGHT
00002BB8                          2649          
00002BB8  6000 0006               2650          BRA     DONT_CHANGE
00002BBC                          2651  
00002BBC                          2652  CHANGE_TO_EIGHT
00002BBC  183C 0008               2653          MOVE.B  #8, D4
00002BC0                          2654  
00002BC0                          2655  DONT_CHANGE        
00002BC0  0604 0030               2656          ADDI.B  #$30, D4
00002BC4  14C4                    2657          MOVE.B  D4, (A2)+      
00002BC6                          2658          
00002BC6  14FC 002C               2659          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002BCA  14FC 0020               2660          MOVE.B  #$20,(A2)+          ; Add space after comma
00002BCE                          2661          
00002BCE  2800                    2662          MOVE.L  D0,D4               ; Store the src reg in D4
00002BD0  0244 0007               2663          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002BD4                          2664          
00002BD4  2600                    2665          MOVE.L  D0,D3               ; Store the src mode in D3
00002BD6  0243 0038               2666          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002BDA  1A3C 0003               2667          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002BDE  EA6B                    2668          LSR.W   D5,D3               ; Do the actual shift 
00002BE0  4EB9 00002C84           2669          JSR     EA_GEN_SRC
00002BE6                          2670          
00002BE6  4EF8 1E10               2671          JMP     EA_FINISH
00002BEA                          2672  
00002BEA                          2673  MOVEQ_EA_CALC
00002BEA  14FC 0020               2674          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002BEE  14FC 0020               2675          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002BF2  14FC 0020               2676          MOVE.B  #$20,(A2)+          ; Add space
00002BF6  14FC 0020               2677          MOVE.B  #$20,(A2)+          ; Add space
00002BFA                          2678  
00002BFA  14FC 0023               2679          MOVE.B  #$23,(A2)+          ; Add # symbol
00002BFE  14FC 0024               2680          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C02                          2681          
00002C02  2200                    2682          MOVE.L  D0, D1              ; move D0 to D1
00002C04  0241 00FF               2683          ANDI.W  #second_half, D1    ; get the second 8 bits of D1
00002C08  1A01                    2684          MOVE.B  D1, D5              ; move D1 to D5 to convert it to ASCII
00002C0A                          2685          
00002C0A  4EB8 11C8               2686          JSR     ITOA_BYTE_BRANCH    ; print out the bit of data
00002C0E                          2687          
00002C0E  14FC 002C               2688          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002C12  14FC 0020               2689          MOVE.B  #$20,(A2)+          ; Add space after comma
00002C16                          2690          
00002C16  2800                    2691          MOVE.L  D0,D4               ; Store the data in D4
00002C18  0244 0E00               2692          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002C1C  1A3C 0009               2693          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002C20  EA6C                    2694          LSR.W   D5,D4               ; Do the actual shift
00002C22  4EB9 00002C84           2695          JSR     EA_GEN_SRC
00002C28                          2696          
00002C28  4EF8 1E10               2697          JMP     EA_FINISH
00002C2C                          2698  *------------------------------------------------------------------------------------------------*
00002C2C                          2699  EA_BRANCH       ; 9: ea_branch
00002C2C  14FC 0020               2700          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C30  14FC 0020               2701          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C34  14FC 0020               2702          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C38  14FC 0020               2703          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C3C  14FC 0020               2704          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C40  14FC 0020               2705          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C44                          2706  
00002C44  2600                    2707          MOVE.L  D0,D3               ; D0 is current instruction word
00002C46  0243 00F0               2708          ANDI.W  #third_nibble,D3   ; Extract 3rd nibble from instruction word
00002C4A  1A3C 0004               2709          MOVE.B  #right4,D5
00002C4E                          2710          
00002C4E  2800                    2711          MOVE.L  D0,D4               ; D0 is current instruction word
00002C50  0244 000F               2712          ANDI.W  #fourth_nibble,D4   ; Extract 4th nibble from instruction word
00002C54                          2713           
00002C54  B63C 0000               2714          CMP.B   #0,D3               ; check if 3rd nibble is 0. 
00002C58  6700 0006               2715          BEQ     FOURTH_NIBBLE_CHECK
00002C5C                          2716          
00002C5C  6000 0018               2717          BRA     BRANCH_WORD_CHECK
00002C60                          2718          
00002C60                          2719  FOURTH_NIBBLE_CHECK                 
00002C60  B83C 0000               2720          CMP.B   #0,D4               ; check if the 4th nibble is 0. 
00002C64                          2721          
00002C64  3A15                    2722          MOVE.W  (A5),D5            ; store the 16-bit displacement into D5
00002C66                          2723          
00002C66  260D                    2724          MOVE.L  A5,D3              ; Store A5 address into D3
00002C68                          2725          
00002C68  DA43                    2726          ADD.W   D3,D5              ; Add the address to D5 to get the displacement. 
00002C6A                          2727          
00002C6A  14FC 0024               2728          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C6E                          2729          
00002C6E  4EB8 11F6               2730          JSR     ITOA_WORD_BRANCH    ; Print. 
00002C72                          2731  
00002C72  4EF8 1E10               2732          JMP     EA_FINISH
00002C76                          2733  
00002C76                          2734  BRANCH_WORD_CHECK
00002C76  4245                    2735          CLR     D5                  ; handles 8-bit displacement. 
00002C78  DA03                    2736          ADD.B   D3,D5               ; add d3 and d4 to d5
00002C7A  DA04                    2737          ADD.B   D4,D5
00002C7C                          2738          
00002C7C  4EB8 11C8               2739          JSR     ITOA_BYTE_BRANCH    ; Print. 
00002C80                          2740  
00002C80  4EF8 1E10               2741          JMP     EA_FINISH
00002C84                          2742  
00002C84                          2743  EA_GEN_SRC
00002C84  41F9 00002C92           2744          LEA     EA_GEN_TABLE_SRC, A0
00002C8A  C6FC 0006               2745          MULU    #6, D3              ; use D3 to jump to the proper src mode and dst mode. 
00002C8E  4EF0 3000               2746          JMP     0(A0,D3)            ; jump to each ea src generation table entry 
00002C92                          2747  
00002C92                          2748  EA_GEN_TABLE_SRC
00002C92  4EF9 00002CC2           2749          JMP     EA_Dn                       ; 000: Dn
00002C98  4EF9 00002CCE           2750          JMP     EA_An                       ; 001: An
00002C9E  4EF9 00002CDA           2751          JMP     EA_An_Indirect              ; 010: (An)
00002CA4  4EF9 00002CEE           2752          JMP     EA_An_Indirect_Inc          ; 011: (An)+
00002CAA  4EF9 00002D06           2753          JMP     EA_An_Indirect_Dec          ; 100: -(An)
00002CB0  4EF9 00002D1E           2754          JMP     EA_UNSUPPORTED              ; 101: Unsupported EA
00002CB6  4EF9 00002D1E           2755          JMP     EA_UNSUPPORTED              ; 110: Unsupported EA
00002CBC  4EF9 00002D2C           2756          JMP     EA_Absolute_And_Immediate   ; 111: (xxx).W,(xxx).L, or #<data>
00002CC2                          2757  
00002CC2                          2758  EA_Dn               ; 000: Dn
00002CC2  14FC 0044               2759          MOVE.B  #'D',(A2)+
00002CC6  0604 0030               2760          ADDI.B  #$30,D4
00002CCA  14C4                    2761          MOVE.B  D4,(A2)+
00002CCC  4E75                    2762          RTS
00002CCE                          2763  
00002CCE                          2764  EA_An               ; 001: An
00002CCE  14FC 0041               2765          MOVE.B  #'A',(A2)+
00002CD2  0604 0030               2766          ADDI.B  #$30,D4
00002CD6  14C4                    2767          MOVE.B  D4,(A2)+
00002CD8  4E75                    2768          RTS
00002CDA                          2769  
00002CDA                          2770  EA_An_Indirect      ; 010: (An)
00002CDA  14FC 0028               2771          MOVE.B  #'(',(A2)+
00002CDE  14FC 0041               2772          MOVE.B  #'A',(A2)+
00002CE2  0604 0030               2773          ADDI.B  #$30,D4
00002CE6  14C4                    2774          MOVE.B  D4,(A2)+
00002CE8  14FC 0029               2775          MOVE.B  #')',(A2)+
00002CEC  4E75                    2776          RTS
00002CEE                          2777          
00002CEE                          2778  EA_An_Indirect_Inc  ; 011: (An)+
00002CEE  14FC 0028               2779          MOVE.B  #'(',(A2)+
00002CF2  14FC 0041               2780          MOVE.B  #'A',(A2)+
00002CF6  0604 0030               2781          ADDI.B  #$30, D4
00002CFA  14C4                    2782          MOVE.B  D4,(A2)+
00002CFC  14FC 0029               2783          MOVE.B  #')',(A2)+
00002D00  14FC 002B               2784          MOVE.B  #'+',(A2)+
00002D04  4E75                    2785          RTS
00002D06                          2786          
00002D06                          2787  EA_An_Indirect_Dec  ; 100: -(An)
00002D06  14FC 002D               2788          MOVE.B  #'-',(A2)+
00002D0A  14FC 0028               2789          MOVE.B  #'(',(A2)+
00002D0E  14FC 0041               2790          MOVE.B  #'A',(A2)+
00002D12  0604 0030               2791          ADDI.B  #$30,D4
00002D16  14C4                    2792          MOVE.B  D4,(A2)+
00002D18  14FC 0029               2793          MOVE.B  #')',(A2)+
00002D1C  4E75                    2794          RTS
00002D1E                          2795  
00002D1E                          2796  EA_UNSUPPORTED
00002D1E  43F9 00002ECB           2797          LEA     EA_TYPE_ERROR,A1
00002D24  103C 000E               2798          MOVE.B  #14,D0
00002D28  4E4F                    2799          TRAP    #15  
00002D2A  4E75                    2800          RTS 
00002D2C                          2801          
00002D2C                          2802  EA_Absolute_And_Immediate           ; 111: (xxx).W,(xxx).L, or #<data>
00002D2C  B83C 0000               2803          CMP.B   #0,D4               ; If D4 is (xxx).W
00002D30  6700 0016               2804          BEQ     ABSOLUTE_WORD
00002D34                          2805          
00002D34  B83C 0001               2806          CMP.B   #1,D4               ; If D4 is (xxx).L
00002D38  6700 001A               2807          BEQ     ABSOLUTE_LONG
00002D3C                          2808          
00002D3C  B83C 0004               2809          CMP.B   #4,D4               ; If D4 is #<data>  
00002D40  6700 001E               2810          BEQ     IMMEDIATE
00002D44                          2811          
00002D44  6000 00EE               2812          BRA     EA_ERROR    
00002D48                          2813  
00002D48                          2814  ABSOLUTE_WORD
00002D48  14FC 0024               2815          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D4C  7401                    2816          MOVE.L  #1,D2               ; Insert 1 to D2 
00002D4E  4EB8 1132               2817          JSR     ITOA                ; Convert word hex values to ITOA
00002D52  4E75                    2818          RTS
00002D54                          2819          
00002D54                          2820  ABSOLUTE_LONG
00002D54  14FC 0024               2821          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D58  7402                    2822          MOVE.L  #2,D2               ; Insert 2 to D2
00002D5A  4EB8 1132               2823          JSR     ITOA                ; Convert long hex values to ITOA
00002D5E  4E75                    2824          RTS
00002D60                          2825     
00002D60                          2826  IMMEDIATE
00002D60  14FC 0023               2827          MOVE.B  #$23,(A2)+          ; Add # symbol
00002D64  14FC 0024               2828          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D68                          2829  
00002D68  BC3C 0001               2830          CMP.B   #1,D6               ; If MOVE.b (code0001)
00002D6C  6700 0020               2831          BEQ     DO_ITOA_MOVE
00002D70  BC3C 0002               2832          CMP.B   #2, D6              ; If MOVE.l / MOVEA.l (code0010)
00002D74  6700 0018               2833          BEQ     DO_ITOA_MOVE
00002D78  BC3C 0003               2834          CMP.B   #3, D6              ; If MOVE.w / MOVEA.w (code0011)
00002D7C  6700 0010               2835          BEQ     DO_ITOA_MOVE        
00002D80  BC3C 000D               2836          CMP.B   #13, D6             ; If ADD / ADDA (code1101)
00002D84  6700 000E               2837          BEQ     DO_ITOA_OPMODE
00002D88                          2838          
00002D88  4EB8 1132               2839          JSR     ITOA                ; Go to ITOA when not a move instruction
00002D8C  4E75                    2840          RTS
00002D8E                          2841          
00002D8E                          2842  DO_ITOA_MOVE
00002D8E  4EB8 1154               2843          JSR ITOA_MOVE
00002D92  4E75                    2844          RTS
00002D94                          2845                
00002D94                          2846  DO_ITOA_OPMODE
00002D94  4EB8 1176               2847          JSR ITOA_OPMODE
00002D98  4E75                    2848          RTS
00002D9A                          2849  
00002D9A                          2850  An_CHECK 
00002D9A  B63C 0001               2851          CMP.B   #1,D3               ; If mode is An     
00002D9E  6700 0094               2852          BEQ     EA_ERROR            ; Then branch to error message
00002DA2  4E75                    2853          RTS   
00002DA4                          2854        
00002DA4                          2855  Dn_CHECK 
00002DA4  B63C 0000               2856          CMP.B   #0,D3               ; If mode is Dn     
00002DA8  6700 008A               2857          BEQ     EA_ERROR            ; Then branch to error message
00002DAC  4E75                    2858          RTS    
00002DAE                          2859       
00002DAE                          2860  IMMEDIATE_CHECK
00002DAE  B63C 0007               2861          CMP.B   #7,D3
00002DB2  6700 0004               2862          BEQ     REGISTER_CHECK
00002DB6  4E75                    2863          RTS
00002DB8                          2864          
00002DB8                          2865  REGISTER_CHECK
00002DB8  B83C 0004               2866          CMP.B   #4,D4               ; If 100 in register
00002DBC  6700 0076               2867          BEQ     EA_ERROR            ; Branch to invalid
00002DC0  4E75                    2868          RTS   
00002DC2                          2869                
00002DC2                          2870  EA_WRONG_SIZE 
00002DC2  43F9 00002E81           2871          LEA     WRONG_SIZE_MESSAGE, A1 
00002DC8  103C 000E               2872          MOVE.B  #14, D0
00002DCC  4E4F                    2873          TRAP    #15
00002DCE  4EF8 1E10               2874          JMP     EA_FINISH
00002DD2                          2875          
00002DD2                          2876  ABSOLUTE_IMMEDIATE_ERROR  
00002DD2  43F9 00002E8F           2877          LEA     ABSOLUTE_WRONGREG, A1 
00002DD8  103C 000E               2878          MOVE.B  #14, D0
00002DDC  4E4F                    2879          TRAP    #15
00002DDE  4EF8 1E10               2880          JMP     EA_FINISH
00002DE2                          2881          
00002DE2                          2882  DST_INVALID
00002DE2  43F9 00002EED           2883          LEA     DST_INVALID_MSG, A1 
00002DE8  103C 000E               2884          MOVE.B  #14, D0
00002DEC  4E4F                    2885          TRAP    #15
00002DEE  4EF8 1E10               2886          JMP     EA_FINISH
00002DF2                          2887          
00002DF2                          2888  SRC_INVALID 
00002DF2  43F9 00002F1F           2889          LEA     SRC_INVALID_MSG, A1 
00002DF8  103C 000E               2890          MOVE.B  #14, D0
00002DFC  4E4F                    2891          TRAP    #15
00002DFE  4EF8 1E10               2892          JMP     EA_FINISH
00002E02                          2893          
00002E02                          2894  OP_ERROR  
00002E02  14FC 0044               2895          MOVE.B  #'D',(A2)+
00002E06  14FC 0041               2896          MOVE.B  #'A',(A2)+
00002E0A  14FC 0054               2897          MOVE.B  #'T',(A2)+
00002E0E  14FC 0041               2898          MOVE.B  #'A',(A2)+
00002E12  14FC 0020               2899          MOVE.B  #' ',(A2)+
00002E16  14FC 0020               2900          MOVE.B  #' ',(A2)+
00002E1A  14FC 0020               2901          MOVE.B  #' ',(A2)+
00002E1E  14FC 0020               2902          MOVE.B  #' ',(A2)+
00002E22  14FC 0020               2903          MOVE.B  #' ',(A2)+
00002E26  14FC 0024               2904          MOVE.B  #'$',(A2)+
00002E2A  3A00                    2905          MOVE.W  D0,D5
00002E2C  4EB8 1218               2906          JSR     ITOA_WORD_ERROR
00002E30  4EF8 13CC               2907          JMP     OP_FINISH
00002E34                          2908          
00002E34                          2909  EA_ERROR
00002E34  45F9 00005009           2910          LEA     error_buffer,A2
00002E3A  7637                    2911          MOVE.L  #55,D3 
00002E3C                          2912         
00002E3C                          2913  EA_ERROR_LOOP
00002E3C  14FC 0000               2914          MOVE.B  #0,(A2)+
00002E40  5343                    2915          SUBI    #1,D3
00002E42  6EF8                    2916          BGT     EA_ERROR_LOOP
00002E44  45F9 00005009           2917          LEA     error_buffer,A2
00002E4A  14FC 0044               2918          MOVE.B  #'D',(A2)+
00002E4E  14FC 0041               2919          MOVE.B  #'A',(A2)+
00002E52  14FC 0054               2920          MOVE.B  #'T',(A2)+
00002E56  14FC 0041               2921          MOVE.B  #'A',(A2)+
00002E5A  14FC 0020               2922          MOVE.B  #' ',(A2)+
00002E5E  14FC 0020               2923          MOVE.B  #' ',(A2)+
00002E62  14FC 0020               2924          MOVE.B  #' ',(A2)+
00002E66  14FC 0020               2925          MOVE.B  #' ',(A2)+
00002E6A  14FC 0020               2926          MOVE.B  #' ',(A2)+
00002E6E  14FC 0024               2927          MOVE.B  #'$',(A2)+
00002E72  3A00                    2928          MOVE.W  D0,D5
00002E74  4EB8 1218               2929          JSR     ITOA_WORD_ERROR
00002E78  4EF8 1E10               2930          JMP     EA_FINISH
00002E7C                          2931  
00002E7C                          2932             
00002E7C  FFFF FFFF               2933  DONE    SIMHALT             ; halt simulator
00002E80                          2934  
00002E80                          2935  * Put variables and constants here
00002E80                          2936      
00002E80  =00000040               2937  buffer_size         EQU         64 
00002E80  =00005000               2938  decoded_buffer      EQU         $5000  
00002E80  =00005009               2939  error_buffer        EQU         $5009
00002E80  =0000000D               2940  CR                  EQU         $0D
00002E80  =0000000A               2941  LF                  EQU         $0A
00002E80  =0000A000               2942  stack               EQU         $0000A000
00002E80  =0000001E               2943  lines_p_screen      EQU         30
00002E80  =00000003               2944  right3              EQU         3
00002E80  =00000004               2945  right4              EQU         4
00002E80  =00000006               2946  right6              EQU         6
00002E80  =00000008               2947  right8              EQU         8
00002E80  =00000009               2948  right9              EQU         9
00002E80  =0000000C               2949  right12             EQU         12
00002E80  =00000010               2950  right16             EQU         16
00002E80  =00000018               2951  right24             EQU         24
00002E80= 20                      2952  ascii_y_n           DC.B        32
00002E81  =00000059               2953  y_uppercase         EQU         $59         
00002E81  =00000079               2954  y_lowercase         EQU         $79
00002E81  =0000004E               2955  n_uppercase         EQU         $4E
00002E81  =0000006E               2956  n_lowercase         EQU         $6E
00002E81  =00000002               2957  task2               EQU         $02
00002E81  =00000005               2958  task5               EQU         $05
00002E81  =00000009               2959  task9               EQU         $09
00002E81  =0000000D               2960  task13              EQU         $0D
00002E81  =0000000E               2961  task14              EQU         $0E
00002E81  =0000F000               2962  first_nibble        EQU         $F000
00002E81  =00000F00               2963  second_nibble       EQU         $0F00   
00002E81  =000000F0               2964  third_nibble        EQU         $00F0
00002E81  =0000000F               2965  fourth_nibble       EQU         $000F
00002E81  =000000FF               2966  second_half         EQU         $00FF
00002E81  =000001C0               2967  dst_mode            EQU         $01C0
00002E81  =00000E00               2968  dst_reg             EQU         $0E00
00002E81  =00000038               2969  src_mode            EQU         $0038
00002E81  =00000007               2970  src_reg             EQU         $0007
00002E81  =00000100               2971  bit8                EQU         $0100
00002E81                          2972  
00002E81  =00000000               2973  ea_type_immediate   EQU     0       ; EA Type = immediate
00002E81  =00000001               2974  ea_type_move        EQU     1       ; EA Type = move
00002E81  =00000002               2975  ea_type_movea       EQU     2       ; EA Type = movea
00002E81  =0000000C               2976  ea_type_movea6      EQU     12      ; EA Type = movea * 6
00002E81  =00000003               2977  ea_type_lea         EQU     3       ; EA Type = lea
00002E81  =00000004               2978  ea_type_dstonly     EQU     4       ; EA Type = clr, neg, not, jsr, jmp
00002E81  =00000005               2979  ea_type_ext         EQU     5       ; EA Type = ext, add, adda
00002E81  =00000006               2980  ea_type_movem       EQU     6       ; EA Type = movem
00002E81  =00000007               2981  ea_type_shifts      EQU     7       ; EA Type = ASL/ASR/LSL/LSR/ROL/ROR
00002E81  =00000008               2982  ea_type_quick       EQU     8       ; EA Type = addq, subq
00002E81  =00000009               2983  ea_type_branch      EQU     9       ; EA Type = bra, bsr, bcc
00002E81  =00000000               2984  ea_bcc_flag         EQU     0       ; EA Type = branch, flag = bcc
00002E81  =00000001               2985  ea_dbcc_flag        EQU     1       ; EA Type = branch, flag = dbcc
00002E81  =00000002               2986  ea_scc_flag         EQU     2       ; EA Type = branch, flag = scc
00002E81                          2987  
00002E81= 57 72 6F 6E 67 20 ...   2988  WRONG_SIZE_MESSAGE  DC.B    'Wrong size.',CR,LF,0
00002E8F= 45 52 52 4F 52 3A ...   2989  ABSOLUTE_WRONGREG   DC.B    'ERROR: Register does not exist for Absolute and immediate',CR,LF,0
00002ECB= 45 52 52 4F 52 3A ...   2990  EA_TYPE_ERROR       DC.B    'ERROR: EA type is not supported',CR,LF,0
00002EED= 45 52 52 4F 52 3A ...   2991  DST_INVALID_MSG     DC.B    'ERROR: Destination effective address is invalid',CR,LF,0
00002F1F= 45 52 52 4F 52 3A ...   2992  SRC_INVALID_MSG     DC.B    'ERROR: Source effective address is invalid',CR,LF,0
00002F4C= 45 52 52 4F 52 3A ...   2993  EA_INVALID_MSG      DC.B    'ERROR: Invalid addressing mode',CR,LF,0
00002F6D= 45 52 52 4F 52 3A ...   2994  OPCODE_INVALID      DC.B    'ERROR: Opcode is invalid',CR,LF,0
00002F88= 45 52 52 4F 52 3A ...   2995  ERROR_MESSAGE       DC.B    'ERROR: The input is invalid',CR,LF,0  
00002FA6= 45 52 52 4F 52 3A ...   2996  ODD_ERROR_MESSAGE   DC.B    'ERROR: The last digit of the address is odd, which is invalid',CR,LF,0  
00002FE6                          2997               
00002FE6= 57 65 6C 63 6F 6D ...   2998  WELCOME             DC.B        'Welcome to the 68k Disassembler of Avery and Alan',CR,LF,CR,LF,0
0000301C                          2999  
0000301C= 50 6C 65 61 73 65 ...   3000  USER_INST           DC.B        'Please follow the proper input instructions below: ',CR,LF
00003051= 2D 20 53 74 61 72 ...   3001                      DC.B        '- Starting address must be lower than ending address.',CR,LF
00003088= 2D 20 54 68 65 20 ...   3002                      DC.B        '- The values for the starting and ending address must be an even value.',CR,LF
000030D1= 2D 20 53 74 61 72 ...   3003                      DC.B        '- Starting and ending address must be inputted as hexadecimal value.',CR,LF
00003117= 2D 20 44 6F 20 6E ...   3004                      DC.B        '- Do not put spaces in between input characters.',CR,LF
00003149= 2D 20 56 61 6C 69 ...   3005                      DC.B        '- Valid characters include: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F',CR,LF,0
00003196                          3006                  
00003196= 50 72 65 73 73 20 ...   3007  ENTER_PROMPT        DC.B        'Press enter to continue...',CR,LF,0
000031B3= 50 72 65 73 73 20 ...   3008  PROMPT_AGAIN        DC.B        'Press Y to continue / N to exit.',CR,LF,0
000031D6= 50 72 6F 67 72 61 ...   3009  EXIT_PROMPT         DC.B        'Program has execution has stopped.',CR,LF,0
000031FB= 45 6E 74 65 72 20 ...   3010  PROMPT_V_END        DC.B        'Enter a valid ending address: ',CR,LF,0
0000321C                          3011        
0000321C= 45 6E 74 65 72 20 ...   3012  START_IN            DC.B        'Enter a starting address: ',CR,LF,0 
00003239= 45 6E 74 65 72 20 ...   3013  END_IN              DC.B        'Enter an ending address: ',CR,LF,0 
00003255                          3014  START_ADDRESS       DS.B        32     
00003275                          3015  END_ADDRESS         DS.B        32 
00003295                          3016       
00003295                          3017      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_IMMEDIATE_ERROR  2DD2
ABSOLUTE_LONG       2D54
ABSOLUTE_WORD       2D48
ABSOLUTE_WRONGREG   2E8F
ADDQ_EA_CALC        2B7A
ADD_PARENTHESIS     2A90
AND_OR_CHECK        22AC
AN_CHECK            2D9A
AN_FINISH           29D4
ASCII_TO_HEX_LETTER  109A
ASCII_Y_N           2E80
ATOI                1074
BACK_PARENTHESIS    2A9A
BIT8                100
BRANCH_WORD_CHECK   2C76
BUFFER_SIZE         40
CHANGE_TO_001       20C8
CHANGE_TO_EIGHT     2BBC
CHECK1_BIT_0        2678
CHECK1_BIT_1        2650
CHECK1_BIT_10       24BE
CHECK1_BIT_11       2490
CHECK1_BIT_12       2462
CHECK1_BIT_13       2434
CHECK1_BIT_14       2406
CHECK1_BIT_2        2628
CHECK1_BIT_3        2600
CHECK1_BIT_4        25D2
CHECK1_BIT_5        25A4
CHECK1_BIT_6        2576
CHECK1_BIT_7        2548
CHECK1_BIT_8        251A
CHECK1_BIT_9        24EC
CHECK_BIT_0         298E
CHECK_BIT_1         2966
CHECK_BIT_10        27D6
CHECK_BIT_11        27A8
CHECK_BIT_12        277A
CHECK_BIT_13        274C
CHECK_BIT_14        271E
CHECK_BIT_2         293E
CHECK_BIT_3         2916
CHECK_BIT_4         28E8
CHECK_BIT_5         28BA
CHECK_BIT_6         288C
CHECK_BIT_7         285E
CHECK_BIT_8         2830
CHECK_BIT_9         2804
CHECK_IF_ZERO       2B20
CODE0000            1448
CODE0001            1462
CODE0010            1466
CODE0011            147E
CODE0100            1496
CODE0101            14B0
CODE0110            14B4
CODE0111            1540
CODE1000            1544
CODE1001            1564
CODE1010            1568
CODE1011            156C
CODE1100            1570
CODE1101            158A
CODE1110            15A4
CODE1111            1622
COMPLETE_END        10FC
COMPLETE_START      10F4
CONTINUE_OR_END     131E
CR                  D
D4_AN_SETONE_0      2564
D4_AN_SETONE_1      2592
D4_AN_SETONE_2      25C0
D4_AN_SETONE_3      25EE
D4_AN_SETONE_4      2616
D4_AN_SETONE_5      263E
D4_AN_SETONE_6      2666
D4_AN_SETONE_7      268E
D4_AN_SET_0         284C
D4_AN_SET_1         2820
D4_AN_SET_2         27F2
D4_AN_SET_3         27C4
D4_AN_SET_4         2796
D4_AN_SET_5         2768
D4_AN_SET_6         273A
D4_AN_SET_7         270C
D4_DN_SETONE_0      23F4
D4_DN_SETONE_1      2422
D4_DN_SETONE_2      2450
D4_DN_SETONE_3      247E
D4_DN_SETONE_4      24AC
D4_DN_SETONE_5      24DA
D4_DN_SETONE_6      2508
D4_DN_SETONE_7      2536
D4_DN_SET_0         29A4
D4_DN_SET_1         297C
D4_DN_SET_2         2954
D4_DN_SET_3         292C
D4_DN_SET_4         2904
D4_DN_SET_5         28D6
D4_DN_SET_6         28A8
D4_DN_SET_7         287A
DECODED_BUFFER      5000
DECODE_MEMORY       1396
DECODE_PAUSE        130A
DECODING_ITERATION  12E6
DISP_UI             100C
DISP_W              1000
DN_CHECK            2DA4
DN_DST              2228
DN_SRC              2266
DONE                2E7C
DONT_CHANGE         2BC0
DO_ITOA_MOVE        2D8E
DO_ITOA_OPMODE      2D94
DST_INVALID         2DE2
DST_INVALID_MSG     2EED
DST_MODE            1C0
DST_REG             E00
EA_ABSOLUTE_AND_IMMEDIATE  2D2C
EA_ADDA             233C
EA_AN               2CCE
EA_AND              22BE
EA_AN_INDIRECT      2CDA
EA_AN_INDIRECT_DEC  2D06
EA_AN_INDIRECT_INC  2CEE
EA_BCC_FLAG         0
EA_BRANCH           2C2C
EA_CLEAR            2102
EA_DBCC_FLAG        1
EA_DN               2CC2
EA_DSTONLY          20E2
EA_ERROR            2E34
EA_ERROR_LOOP       2E3C
EA_EXT              2194
EA_EXT_TABLE        21B0
EA_FINISH           1E10
EA_GEN_SRC          2C84
EA_GEN_TABLE_SRC    2C92
EA_IMMEDIATE        1F34
EA_INVALID_MSG      2F4C
EA_JSR              214C
EA_LEA              2064
EA_MEMORY_SHIFTS    2A32
EA_MOVE             1F8C
EA_MOVEA            1FF8
EA_MOVEM            2384
EA_MULS_MULU_DIV    22E6
EA_OPMODE_012456    21E0
EA_OPMODE_37        22CE
EA_OR               22C4
EA_QUICK            2B6A
EA_REGISTER_SHIFTS  2AA8
EA_SCC_FLAG         2
EA_SHIFTS           29E8
EA_SHIFTS_TABLE     2A02
EA_SIZE_ADDA        1EEA
EA_SIZE_B           1F12
EA_SIZE_DONE        1F32
EA_SIZE_GENERAL     1E56
EA_SIZE_L           1F28
EA_SIZE_MEMORY_SHIFTS  1EFE
EA_SIZE_MOVE        1E72
EA_SIZE_MOVEA       1E8E
EA_SIZE_MOVEM       1EA2
EA_SIZE_OPMODE_012456  1EB6
EA_SIZE_W           1F1C
EA_SIZE_W_MEMORY    1F26
EA_START            1DFE
EA_TYPE_BRANCH      9
EA_TYPE_DSTONLY     4
EA_TYPE_ERROR       2ECB
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_SHIFTS      7
EA_TYPE_TABLE       1E16
EA_UNSUPPORTED      2D1E
EA_WRONG_SIZE       2DC2
END_ADDRESS         3275
END_IN              3239
ENTER_PROMPT        3196
ERROR_BUFFER        5009
ERROR_MESSAGE       2F88
EXIT                1386
EXIT_PROMPT         31D6
FINISH_MOVEM_MEM_TO_REG  29B6
FINISH_REG_TO_MEM   26A0
FIRST_NIBBLE        F000
FOURTH_NIBBLE       F
FOURTH_NIBBLE_CHECK  2C60
FRONT_FORMAT        2A82
IMMEDIATE           2D60
IMMEDIATE_CHECK     2DAE
IMMEDIATE_EIGHT     2B2A
IMMEDIATE_SRC       2ADC
INPUT_INVALID       10BC
ITOA                1132
ITOA_BYTE           11BA
ITOA_BYTE_BRANCH    11C8
ITOA_BYTE_CONVERT   12A2
ITOA_CONVERT_A_TO_F  12D2
ITOA_DONE           12DE
ITOA_LONG           1238
ITOA_LONGADDRESS    126A
ITOA_MOVE           1154
ITOA_NIBBLE_CONVERT  12C2
ITOA_OPMODE         1176
ITOA_WORD           11DA
ITOA_WORD_BRANCH    11F6
ITOA_WORD_ERROR     1218
JSR_EA_VALID        218A
JSR_NOP_RTS         186C
LAST_DIGIT_CHECK    10DA
LAST_DIGIT_ODD      1116
LEA_SRC_VALID       20A2
LF                  A
LINES_P_SCREEN      1E
MEMORY_1110_LEFT    15DA
MEMORY_1110_RIGHT   15FE
MEM_TO_REG          26C6
MEM_TO_REG_CONTINUE  26EE
MOVEA_DST_VALID     205A
MOVEQ_EA_CALC       2BEA
NOP_CHECK           189A
NOP_CHECK_THREE     18CA
NOP_CHECK_TWO       18B2
NORMAL_FINISH       29E2
N_LOWERCASE         6E
N_UPPERCASE         4E
ODD_ERROR_MESSAGE   2FA6
OPCODE_INVALID      2F6D
OP_0000_TABLE       1626
OP_0100_TABLE       1686
OP_1100_TABLE       16E6
OP_1101_TABLE       1746
OP_1110_TABLE_REGISTER  17A6
OP_ADD              1D1A
OP_ADDA             1D36
OP_ADDI             194E
OP_ADDQ             1A4A
OP_AND              1CFE
OP_ASL              1D72
OP_ASR              1D56
OP_AS_CHECK         1806
OP_BCC              1ADA
OP_BCS              1AF6
OP_BEQ              1B2E
OP_BGE              1BBA
OP_BGT              1BF2
OP_BHI              1AA2
OP_BLE              1C0E
OP_BLS              1ABE
OP_BLT              1BD6
OP_BMI              1B9E
OP_BNE              1B12
OP_BPL              1B82
OP_BRA              1A6A
OP_BSR              1A86
OP_BVC              1B4A
OP_BVS              1B66
OP_CLEAR_DATA       13D2
OP_CLEAR_DATA_LOOP  13DE
OP_CLR              19B2
OP_CMP              1CA2
OP_DIVU             1C4E
OP_ERROR            2E02
OP_FINISH           13CC
OP_JSR              19EE
OP_LEA              1A2E
OP_LSL              1DAA
OP_LSR              1D8E
OP_LS_CHECK         1828
OP_MOVE             1992
OP_MOVEA            196E
OP_MOVEM            1A0A
OP_MOVEQ            1C2A
OP_MULS             1CDE
OP_MULU             1CBE
OP_NOP              19CE
OP_OR               1C6E
OP_ROL              1DE2
OP_ROR              1DC6
OP_RO_CHECK         184A
OP_RTS              19DE
OP_SUB              1C86
OP_SUBI             192E
OP_TABLE            13E8
OP_UNSUPPORTED      192A
PRINT1_A0           256C
PRINT1_A1           259A
PRINT1_A2           25C8
PRINT1_A3           25F6
PRINT1_A4           261E
PRINT1_A5           2646
PRINT1_A6           266E
PRINT1_A7           2696
PRINT1_D0           23FC
PRINT1_D1           242A
PRINT1_D2           2458
PRINT1_D3           2486
PRINT1_D4           24B4
PRINT1_D5           24E2
PRINT1_D6           2510
PRINT1_D7           253E
PRINT_A0            2854
PRINT_A1            2826
PRINT_A2            27FA
PRINT_A3            27CC
PRINT_A4            279E
PRINT_A5            2770
PRINT_A6            2742
PRINT_A7            2714
PRINT_D0            29AC
PRINT_D1            2984
PRINT_D2            295C
PRINT_D3            2934
PRINT_D4            290C
PRINT_D5            28DE
PRINT_D6            28B0
PRINT_D7            2882
PROMPT_AGAIN        31B3
PROMPT_END          1040
PROMPT_START        1018
PROMPT_VA_END       1052
PROMPT_V_END        31FB
READ_END            1060
READ_START          102C
REGISTER_CHECK      2DB8
REGISTER_SRC        2B30
REG_TO_MEM          23D6
RIGHT12             C
RIGHT16             10
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT6              6
RIGHT8              8
RIGHT9              9
RTS_CHECK           18E2
RTS_CHECK_THREE     1912
RTS_CHECK_TWO       18FA
SECOND_HALF         FF
SECOND_NIBBLE       F00
SRC_INVALID         2DF2
SRC_INVALID_MSG     2F1F
SRC_MODE            38
SRC_REG             7
STACK               A000
START               1000
START_ADDRESS       3255
START_DECODING      12E4
START_IN            321C
TASK13              D
TASK14              E
TASK2               2
TASK5               5
TASK9               9
THIRD_NIBBLE        F0
USER_INST           301C
VALIDATE_END        1070
VALIDATE_START      103C
WELCOME             2FE6
WRONG_SIZE_MESSAGE  2E81
Y_LOWERCASE         79
Y_UPPERCASE         59
