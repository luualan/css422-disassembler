00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/10/2020 1:59:41 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler for the Motorola MC68000 Microprocessor
00000000                             3  * Written by :  Avery Mortenson & Alan Luu
00000000                             4  * Date       :  2/12/2020
00000000                             5  * Description:  An inverse assembler (disassembler) that will 
00000000                             6  * convert a memory image of instructions and data back 
00000000                             7  * to the MC68000 assembly code and that will output the 
00000000                             8  * disassembled code to the display.
00000000                             9  *-----------------------------------------------------------
00001000                            10      ORG    $1000
00001000                            11  START:            
00001000                            12  *------------------------------------------------------------*
00001000                            13  * D0: used for the tasks
00001000                            14  * D1: used to hold the size of the input obtained. 
00001000                            15  * D5: used to store the starting and ending address 
00001000                            16  * temporarily before moving them to A4 and A6 correspondingly. 
00001000                            17  * D6: used to check the last digit to see if the input 
00001000                            18  * for the starting and ending address causes a bus error. 
00001000                            19  * A1: a pointer to the message to print out. 
00001000                            20  *------------------------------------------------------------*
00001000  103C 000E                 21  DISP_W      MOVE.B  #14,D0                  ; Display Welcome Message. 
00001004  43F9 00002E97             22              LEA     WELCOME,A1
0000100A  4E4F                      23              TRAP    #15
0000100C                            24  
0000100C                            25  * Put program code here
0000100C                            26  
0000100C  103C 000E                 27  DISP_UI         MOVE.B  #14,D0              ; Display User Instructions. 
00001010  43F9 00002ECD             28                  LEA     USER_INST,A1
00001016  4E4F                      29                  TRAP    #15    
00001018                            30  
00001018  4285                      31  PROMPT_START    CLR.L   D5
0000101A  4FF9 0000A000             32                  LEA     stack, SP           ; SP = stack ($A0000)
00001020  43F9 0000312D             33                  LEA     START_IN,A1         ; Display starting address message
00001026  103C 000E                 34                  MOVE.B  #14,D0
0000102A  4E4F                      35                  TRAP    #15       
0000102C                            36       
0000102C  43F9 00003166             37  READ_START      LEA     START_ADDRESS,A1    ; Store user's starting address input
00001032  103C 0002                 38                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001036  4E4F                      39                  TRAP    #15
00001038  1C3C 0000                 40                  MOVE.B  #0,D6               ; Used to indicate we are at start address
0000103C                            41  
0000103C  6000 0036                 42  VALIDATE_START  BRA     ATOI
00001040                            43  
00001040  4285                      44  PROMPT_END      CLR.L   D5
00001042  43F9 0000314A             45                  LEA     END_IN,A1           ; Display ending address message
00001048  103C 000E                 46                  MOVE.B  #14,D0
0000104C  4E4F                      47                  TRAP    #15
0000104E  6000 0010                 48                  BRA     READ_END
00001052                            49  
00001052  4285                      50  PROMPT_VA_END   CLR.L   D5                  ; prompt a valid ending address
00001054  43F9 000030AC             51                  LEA     PROMPT_V_END,A1     ; Display ending address message
0000105A  103C 000E                 52                  MOVE.B  #14,D0
0000105E  4E4F                      53                  TRAP    #15
00001060                            54              
00001060  43F9 00003186             55  READ_END        LEA     END_ADDRESS,A1      ; Store user's starting address input
00001066  103C 0002                 56                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
0000106A  4E4F                      57                  TRAP    #15
0000106C  1C3C 0001                 58                  MOVE.B  #1,D6               ; Used to indicate we are at end address
00001070                            59  
00001070  6000 0002                 60  VALIDATE_END    BRA     ATOI
00001074                            61                 
00001074                            62  * D0 stores the value to pushed from A1.
00001074                            63  
00001074  1019                      64  ATOI            MOVE.B  (A1)+,D0    ; Move to next character in A1 and store in D0          
00001076  B03C 0030                 65                  CMP.B   #$30,D0
0000107A  6D00 0040                 66                  BLT     INPUT_INVALID
0000107E  B03C 0039                 67                  CMP.B   #$39,D0
00001082  6E00 0016                 68                  BGT     ASCII_TO_HEX_LETTER
00001086  0400 0030                 69                  SUB.B   #$30,D0     ; Subtract by 30 to get the numbers 0-9
0000108A  DA80                      70                  ADD.L   D0,D5
0000108C  5341                      71                  SUBI    #1,D1       ; Decrement input's length to move to next character          
0000108E  B23C 0000                 72                  CMP.B   #0,D1       ; Compare to see if we're at the last digit
00001092  6700 0046                 73                  BEQ     LAST_DIGIT_CHECK
00001096  E98D                      74                  LSL.L   #4,D5
00001098  60DA                      75                  BRA     ATOI
0000109A                            76  
0000109A                            77    
0000109A  B03C 0041                 78  ASCII_TO_HEX_LETTER     CMP.B   #$41,D0
0000109E  6D00 001C                 79                          BLT     INPUT_INVALID
000010A2  B03C 0046                 80                          CMP.B   #$46, D0
000010A6  6E00 0014                 81                          BGT     INPUT_INVALID 
000010AA  0400 0031                 82                          SUB.B   #$31,D0     ; Subtract by 31 to get the numbers A-F
000010AE  5D00                      83                          SUB.B   #6,D0
000010B0  DA80                      84                          ADD.L   D0,D5
000010B2  5341                      85                          SUBI    #1,D1
000010B4  6700 0024                 86                          BEQ     LAST_DIGIT_CHECK
000010B8  E98D                      87                          LSL.L   #4,D5
000010BA  60B8                      88                          BRA     ATOI     
000010BC                            89  
000010BC                            90                      
000010BC  43F9 000030CD             91  INPUT_INVALID   LEA     ERROR_MESSAGE, A1   ; Display error message
000010C2  103C 000E                 92                  MOVE.B  #14, D0
000010C6  4E4F                      93                  TRAP    #15
000010C8  4206                      94                  CLR.B   D6
000010CA                            95                  
000010CA  BC3C 0000                 96                  CMP.B   #0,D6           ; When D6 is 0
000010CE  6700 FF48                 97                  BEQ     PROMPT_START    ; Go back to start prompt
000010D2  BC3C 0001                 98                  CMP.B   #1,D6           ; When D6 is 1
000010D6  6700 FF68                 99                  BEQ     PROMPT_END      ; Go back to end prompt
000010DA                           100  
000010DA                           101                            
000010DA  2E05                     102  LAST_DIGIT_CHECK    MOVE.L  D5, D7          ; D7 used as temporary storage
000010DC  E20F                     103                      LSR.B   #1, D7          ; Check for carry bit to see if last digit is odd
000010DE  6500 0036                104                      BCS     LAST_DIGIT_ODD  ; branch when there is a carry; this indicates odd last digit 
000010E2  4287                     105                      CLR.L   D7
000010E4  BC3C 0000                106                      CMP.B   #0,D6
000010E8  6700 000A                107                      BEQ     COMPLETE_START  
000010EC  BC3C 0001                108                      CMP.B   #1,D6
000010F0  6700 000A                109                      BEQ     COMPLETE_END
000010F4                           110  
000010F4  2845                     111  COMPLETE_START      MOVEA.L D5, A4  ; A4 holds the starting address
000010F6  4285                     112                      CLR.L   D5 
000010F8  6000 FF46                113                      BRA PROMPT_END
000010FC                           114  
000010FC  2C45                     115  COMPLETE_END        MOVEA.L D5, A6  ; A6 holds the ending address
000010FE                           116  
000010FE  3A0C                     117                      MOVE.W  A4, D5          ; move starting address to D5
00001100  BA4E                     118                      CMP.W   A6, D5          ; check if the ending address is less than starting address. 
00001102  6E00 FF4E                119                      BGT     PROMPT_VA_END   ; branch to prompt new ending address if so. 
00001106                           120              
00001106  2A4C                     121                      MOVEA.L A4, A5  ; Store starting address into current address
00001108                           122                      
00001108                           123                      *Clear the data and address registers used to obtain the starting and ending address 
00001108  4280                     124                      CLR.L   D0
0000110A  4285                     125                      CLR.L   D5
0000110C  4286                     126                      CLR.L   D6
0000110E  327C 0000                127                      MOVEA   #0, A1
00001112  6000 01D0                128                      BRA     START_DECODING  ; All inputs are valid, go to the decode process
00001116                           129                      
00001116  43F9 000030EC            130  LAST_DIGIT_ODD      LEA     ODD_ERROR_MESSAGE, A1 
0000111C  103C 000E                131                      MOVE.B  #14, D0
00001120  4E4F                     132                      TRAP    #15
00001122                           133                      
00001122  BC3C 0000                134                      CMP.B   #0,D6           ; When D6 is 0
00001126  6700 FEF0                135                      BEQ     PROMPT_START    ; Go back to start prompt
0000112A  BC3C 0001                136                      CMP.B   #1,D6           ; When D6 is 1
0000112E  6700 FF10                137                      BEQ     PROMPT_END      ; Go back to end prompt
00001132                           138  *--------------------------------------------------------------------------------------
00001132                           139  * param D2 data size to convert into ASCII
00001132                           140  * param A2 a pointer to decode_buf
00001132                           141  * param A5 the current address
00001132                           142  * itoa (D2, A2, A5) {
00001132                           143  * D0 byte data in ACII
00001132                           144  * D1 #sfhit
00001132                           145  * D7 long data to convert into ASCII
00001132                           146  * }
00001132                           147          
00001132                           148  ITOA                                ; convert integer to ASCII  
00001132  48E7 C000                149          MOVEM.L D0-D1,-(SP) 
00001136  B43C 0000                150          CMP.B   #%00, D2            ; byte
0000113A  6700 007E                151          BEQ     ITOA_BYTE
0000113E  B43C 0001                152          CMP.B   #%01, D2            ; word
00001142  6700 0096                153          BEQ     ITOA_WORD
00001146  B43C 0002                154          CMP.B   #%10, D2            ; long
0000114A  6700 00EC                155          BEQ     ITOA_LONG
0000114E  4EF9 0000126A            156          JMP     ITOA_LONGADDRESS    ; long address
00001154                           157          
00001154                           158  ITOA_MOVE                           ; convert integer to ASCII
00001154  48E7 C000                159          MOVEM.L D0-D1,-(SP) 
00001158  B43C 0001                160          CMP.B   #%01, D2            ; byte
0000115C  6700 005C                161          BEQ     ITOA_BYTE
00001160  B43C 0003                162          CMP.B   #%11, D2            ; word
00001164  6700 0074                163          BEQ     ITOA_WORD
00001168  B43C 0002                164          CMP.B   #%10,D2             ; long
0000116C  6700 00CA                165          BEQ     ITOA_LONG
00001170  4EF9 0000126A            166          JMP     ITOA_LONGADDRESS    ; long address
00001176                           167          
00001176                           168  ITOA_OPMODE                         ; convert integer to ASCII
00001176  48E7 C000                169          MOVEM.L D0-D1,-(SP) 
0000117A  B43C 0000                170          CMP.B   #%000,D2            ; When 0 then byte
0000117E  6700 003A                171          BEQ     ITOA_BYTE
00001182  B43C 0004                172          CMP.B   #%100,D2            ; When 4 then byte
00001186  6700 0032                173          BEQ     ITOA_BYTE 
0000118A  B43C 0001                174          CMP.B   #%001,D2            ; When 1 then word
0000118E  6700 004A                175          BEQ     ITOA_WORD
00001192  B43C 0003                176          CMP.B   #%011,D2            ; When 3 then word
00001196  6700 0042                177          BEQ     ITOA_WORD
0000119A  B43C 0005                178          CMP.B   #%101,D2            ; When 5 then word
0000119E  6700 003A                179          BEQ     ITOA_WORD 
000011A2  B43C 0002                180          CMP.B   #%010,D2            ; When 2 then long
000011A6  6700 0090                181          BEQ     ITOA_LONG
000011AA  B43C 0006                182          CMP.B   #%110,D2            ; When 6 then long
000011AE  6700 0088                183          BEQ     ITOA_LONG
000011B2  B43C 0007                184          CMP.B   #%111,D2            ; When 7 then long
000011B6  6700 0080                185          BEQ     ITOA_LONG
000011BA                           186          
000011BA                           187  ITOA_BYTE
000011BA  3E1D                     188          MOVE.W  (A5)+,D7
000011BC  4EB9 000012A2            189          JSR     ITOA_BYTE_CONVERT
000011C2  4EF9 000012DE            190          JMP     ITOA_DONE
000011C8                           191  
000011C8                           192  ITOA_BYTE_BRANCH
000011C8  48E7 C000                193          MOVEM.L D0-D1,-(SP)
000011CC  3E05                     194          MOVE.W  D5,D7
000011CE  4EB9 000012A2            195          JSR     ITOA_BYTE_CONVERT
000011D4  4EF9 000012DE            196          JMP     ITOA_DONE
000011DA                           197          
000011DA                           198  ITOA_WORD
000011DA  3E15                     199          MOVE.W  (A5),D7
000011DC  123C 0008                200          MOVE.B  #right8, D1
000011E0  E26F                     201          LSR.W   D1,D7
000011E2  4EB9 000012A2            202          JSR     ITOA_BYTE_CONVERT
000011E8  3E1D                     203          MOVE.W  (A5)+, D7
000011EA  4EB9 000012A2            204          JSR     ITOA_BYTE_CONVERT
000011F0  4EF9 000012DE            205          JMP     ITOA_DONE
000011F6                           206          
000011F6                           207  ITOA_WORD_BRANCH
000011F6  48E7 C000                208          MOVEM.L D0-D1,-(SP) 
000011FA  3E05                     209          MOVE.W  D5,D7
000011FC  123C 0008                210          MOVE.B  #right8, D1
00001200  E26F                     211          LSR.W   D1,D7
00001202  4EB9 000012A2            212          JSR     ITOA_BYTE_CONVERT
00001208  3E05                     213          MOVE.W  D5, D7
0000120A  361D                     214          MOVE.W  (A5)+,D3
0000120C  4EB9 000012A2            215          JSR     ITOA_BYTE_CONVERT
00001212  4EF9 000012DE            216          JMP     ITOA_DONE
00001218                           217          
00001218                           218  ITOA_WORD_ERROR
00001218  48E7 C000                219          MOVEM.L D0-D1,-(SP) 
0000121C  3E05                     220          MOVE.W  D5,D7
0000121E  123C 0008                221          MOVE.B  #right8, D1
00001222  E26F                     222          LSR.W   D1,D7
00001224  4EB9 000012A2            223          JSR     ITOA_BYTE_CONVERT
0000122A  3E05                     224          MOVE.W  D5,D7
0000122C  4EB9 000012A2            225          JSR     ITOA_BYTE_CONVERT
00001232  4EF9 000012DE            226          JMP     ITOA_DONE
00001238                           227          
00001238                           228  ITOA_LONG
00001238  3E15                     229          MOVE.W  (A5),D7
0000123A  123C 0008                230          MOVE.B  #right8, D1
0000123E  E26F                     231          LSR.W   D1, D7
00001240  4EB9 000012A2            232          JSR     ITOA_BYTE_CONVERT
00001246  3E1D                     233          MOVE.W  (A5)+, D7
00001248  4EB9 000012A2            234          JSR     ITOA_BYTE_CONVERT
0000124E                           235          
0000124E  3E15                     236          MOVE.W  (A5),D7
00001250  123C 0008                237          MOVE.B  #right8, D1
00001254  E26F                     238          LSR.W   D1, D7
00001256  4EB9 000012A2            239          JSR     ITOA_BYTE_CONVERT
0000125C  3E1D                     240          MOVE.W  (A5)+, D7
0000125E  4EB9 000012A2            241          JSR     ITOA_BYTE_CONVERT
00001264  4EF9 000012DE            242          JMP     ITOA_DONE
0000126A                           243  
0000126A                           244  ITOA_LONGADDRESS
0000126A  3E0D                     245          MOVE.W  A5,D7
0000126C  123C 0018                246          MOVE.B  #right24,D1
00001270  E26F                     247          LSR.W   D1,D7
00001272  4EB9 000012A2            248          JSR     ITOA_BYTE_CONVERT
00001278  3E0D                     249          MOVE.W  A5,D7
0000127A  123C 0010                250          MOVE.B  #right16,D1
0000127E  E26F                     251          LSR.W   D1,D7
00001280  4EB9 000012A2            252          JSR     ITOA_BYTE_CONVERT
00001286  3E0D                     253          MOVE.W  A5,D7
00001288  123C 0008                254          MOVE.B  #right8,D1
0000128C  E26F                     255          LSR.W   D1,D7
0000128E  4EB9 000012A2            256          JSR     ITOA_BYTE_CONVERT
00001294  3E0D                     257          MOVE.W  A5,D7
00001296  4EB9 000012A2            258          JSR     ITOA_BYTE_CONVERT   
0000129C  4EF9 000012DE            259          JMP     ITOA_DONE   
000012A2                           260  
000012A2                           261  ITOA_BYTE_CONVERT
000012A2  3007                     262          MOVE.W  D7, D0 
000012A4  0240 00F0                263          ANDI.W  #$F0, D0
000012A8  123C 0004                264          MOVE.B  #right4, D1
000012AC  E268                     265          LSR.W   D1, D0
000012AE  4EB9 000012C2            266          JSR     ITOA_NIBBLE_CONVERT
000012B4                           267          
000012B4  3007                     268          MOVE.W  D7, D0
000012B6  0240 000F                269          ANDI.W  #$0F, D0
000012BA  4EB9 000012C2            270          JSR     ITOA_NIBBLE_CONVERT
000012C0  4E75                     271          RTS
000012C2                           272          
000012C2                           273  ITOA_NIBBLE_CONVERT
000012C2  B03C 0009                274          CMP.B   #9, D0
000012C6  6E00 000A                275          BGT     ITOA_CONVERT_A_TO_F
000012CA  0600 0030                276          ADD.B   #$30, D0
000012CE  14C0                     277          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
000012D0  4E75                     278          RTS
000012D2                           279          
000012D2                           280  ITOA_CONVERT_A_TO_F
000012D2  0400 000A                281          SUBI.B  #10, D0
000012D6  0600 0041                282          ADDI.B  #$41, D0
000012DA  14C0                     283          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
000012DC  4E75                     284          RTS
000012DE                           285  
000012DE                           286  ITOA_DONE
000012DE  4CDF 0003                287          MOVEM.L (SP)+, D0-D1
000012E2  4E75                     288          RTS
000012E4                           289  *-------------------------------------------------------------------------------*
000012E4                           290  START_DECODING
000012E4  4282                     291          CLR.L   D2
000012E6                           292          
000012E6                           293  DECODING_ITERATION
000012E6                           294          ;decoding the current address
000012E6  4EB9 00001396            295          JSR     DECODE_MEMORY
000012EC  103C 000D                296          MOVE.B  #task13, D0
000012F0  43F9 00005000            297          LEA     decoded_buffer, A1
000012F6  4E4F                     298          TRAP    #15
000012F8                           299          
000012F8                           300          ;check if decoding has finished or if the screen is filled 
000012F8  BDCD                     301          CMP.L   A5, A6
000012FA  6F00 0022                302          BLE     CONTINUE_OR_END     ; If A6-A5 <= 0, go to CONTINUE_OR_END 
000012FE                           303          
000012FE                           304          ;have yet to reach the ending address
000012FE  5202                     305          ADDQ.B  #1, D2              ; D2 (screen_line_counter)++
00001300  B43C 001E                306          CMP.B   #lines_p_screen, D2
00001304  6C00 0004                307          BGE     DECODE_PAUSE
00001308                           308          ;not yet reached the maximum lines per screen. 
00001308  60DC                     309          BRA     DECODING_ITERATION
0000130A                           310  
0000130A                           311  DECODE_PAUSE
0000130A  103C 000E                312          MOVE.B  #task14, D0
0000130E  43F9 00003047            313          LEA     ENTER_PROMPT, A1
00001314  4E4F                     314          TRAP    #15
00001316  103C 0005                315          MOVE.B  #task5, D0
0000131A  4E4F                     316          TRAP    #15
0000131C  60C6                     317          BRA     START_DECODING
0000131E                           318  
0000131E                           319  CONTINUE_OR_END
0000131E  4280                     320          CLR.L   D0
00001320  4281                     321          CLR.L   D1
00001322  4282                     322          CLR.L   D2
00001324  4283                     323          CLR.L   D3
00001326  4284                     324          CLR.L   D4
00001328  4285                     325          CLR.L   D5
0000132A  4286                     326          CLR.L   D6
0000132C  4287                     327          CLR.L   D7
0000132E  327C 0000                328          MOVEA   #0,A1
00001332  347C 0000                329          MOVEA   #0,A2
00001336  367C 0000                330          MOVEA   #0,A3
0000133A  387C 0000                331          MOVEA   #0,A4
0000133E  3A7C 0000                332          MOVEA   #0,A5
00001342  3C7C 0000                333          MOVEA   #0,A6
00001346                           334  
00001346  103C 000E                335          MOVE.B  #task14, D0
0000134A  43F9 00003064            336          LEA     PROMPT_AGAIN, A1
00001350  4E4F                     337          TRAP    #15
00001352                           338          
00001352  103C 0002                339          MOVE.B  #task2, D0
00001356  43F9 00002E96            340          LEA     ascii_y_n, A1
0000135C  4E4F                     341          TRAP    #15
0000135E                           342          
0000135E  1639 00002E96            343          MOVE.B  ascii_y_n, D3
00001364  0C03 0059                344          CMPI.B  #y_uppercase, D3
00001368  6700 FCAE                345          BEQ     PROMPT_START
0000136C  0C03 0079                346          CMPI.B  #y_lowercase, D3
00001370  6700 FCA6                347          BEQ     PROMPT_START
00001374  0C03 004E                348          CMPI.B  #n_uppercase, D3
00001378  6700 000C                349          BEQ     EXIT
0000137C  0C03 006E                350          CMPI.B  #n_lowercase, D3
00001380  6700 0004                351          BEQ     EXIT
00001384  6098                     352          BRA     CONTINUE_OR_END 
00001386                           353          
00001386                           354  EXIT
00001386  103C 000E                355          MOVE.B  #task14, D0
0000138A  43F9 00003087            356          LEA     EXIT_PROMPT, A1
00001390  4E4F                     357          TRAP    #15  
00001392  6000 1AFE                358          BRA     DONE             
00001396                           359  *---------------------------------------------------------------------------------*
00001396                           360  * D0: the current instruction. 
00001396                           361  * D1: used as temp storage
00001396                           362  * D2: data size 
00001396                           363  * D3: loop counter for the amount of lines per screen. 
00001396                           364  * D4: 
00001396                           365  * D5: #shifts
00001396                           366  * D6: store first nibble
00001396                           367  * D7: 
00001396                           368  * A0: 
00001396                           369  * A1: A pointer to the message to print out. 
00001396                           370  * A2: A pointer to the decode_buffer. 
00001396                           371  * A3: 
00001396                           372  * A4: Store the starting address and increment to the ending address. 
00001396                           373  * A5: The current address. 
00001396                           374  * A6: Store the ending address. 
00001396                           375  * A7: Stack pointer. 
00001396                           376  *---------------------------------------------------------------------------------*                             
00001396                           377  DECODE_MEMORY       
00001396  48E7 2002                378          MOVEM.L D2/A6, -(SP)
0000139A                           379                  
0000139A                           380          ;zero clear the decode_buffer
0000139A  4EB9 000013D2            381          JSR     OP_CLEAR_DATA
000013A0  45F9 00005000            382          LEA     decoded_buffer, A2  Load decode buffer into A2
000013A6                           383                  
000013A6                           384          ;print out the current address
000013A6  7403                     385          MOVE.L  #$0003, D2
000013A8  4EB8 1132                386          JSR      ITOA
000013AC                           387          
000013AC  14FC 0009                388          MOVE.B  #$9, (A2)+  ; Add space after long address
000013B0                           389                  
000013B0                           390          ;load the next instruction and jump to the opcode table entry
000013B0  41F9 000013E8            391          LEA     OP_TABLE, A0
000013B6  4280                     392          CLR.L   D0
000013B8  301D                     393          MOVE.W  (A5)+, D0       ; Store A5's value into D0, then increment A5
000013BA  2200                     394          MOVE.L  D0, D1          ; Store A5's value from D0 into D1
000013BC  1A3C 000C                395          MOVE.B  #right12, D5    ; Store 12 into D5
000013C0  EA69                     396          LSR.W   D5, D1          ; Shift first nibble into LSB position
000013C2  2C01                     397          MOVE.L  D1, D6          ; Store first nibble into D6
000013C4  C2FC 0006                398          MULU    #6, D1          ; Multiply 6 to D1
000013C8  4EF0 1000                399          JMP     0(A0, D1)       ; Go to displacement (A0 + D1 * 6)      
000013CC                           400  OP_FINISH
000013CC  4CDF 4004                401          MOVEM.L (SP)+, D2/A6,
000013D0  4E75                     402          RTS
000013D2                           403  *------------------------------------------------------------------------------------*
000013D2                           404  *Clear the 32 bits within the decoded_buffer       
000013D2                           405  OP_CLEAR_DATA
000013D2  4283                     406          CLR.L   D3
000013D4  163C 0040                407          MOVE.B  #buffer_size, D3
000013D8  45F9 00005000            408          LEA     decoded_buffer, A2
000013DE                           409          
000013DE                           410  OP_CLEAR_DATA_LOOP
000013DE  14FC 0000                411          MOVE.B  #0, (A2)+
000013E2  5343                     412          SUBI    #1, D3
000013E4  6EF8                     413          BGT     OP_CLEAR_DATA_LOOP
000013E6  4E75                     414          RTS
000013E8                           415  
000013E8                           416  *------------------------------------------------------------------------------------*
000013E8                           417  OP_TABLE
000013E8  4EF9 00001448            418          JMP     code0000    ; ADDI.bwl/ ANDI.bwl / CMPI.bwl / EORI.bwl / ORI.bwl / SUBI.bwl 
000013EE  4EF9 00001462            419          JMP     code0001    ; MOVE.b
000013F4  4EF9 00001466            420          JMP     code0010    ; MOVE.l / MOVEA.l
000013FA  4EF9 0000147E            421          JMP     code0011    ; MOVE.w / MOVEA.w
00001400  4EF9 00001496            422          JMP     code0100    ; CLR.bwl / JMP / JSR / LEA / MOVEM.wl / NOP / NOT.bwl / RTS / STOP / TRAP
00001406  4EF9 000014B0            423          JMP     code0101    ; ADDQ.bwl / SUBQ.bwl / Scc / Dbcc
0000140C  4EF9 000014B4            424          JMP     code0110    ; BRA.bw / BSR.bw / Bcc.bw
00001412  4EF9 00001540            425          JMP     code0111    ; MOVEQ
00001418  4EF9 00001544            426          JMP     code1000    ; DIVS / DIVU / CR.bwl
0000141E  4EF9 00001564            427          JMP     code1001    ; SUB.bwl / SUBA.wl
00001424  4EF9 00001568            428          JMP     code1010    ;   [unassigned]
0000142A  4EF9 0000156C            429          JMP     code1011    ; CMP.bwl / CMPA.wl / EOR.bwl
00001430  4EF9 00001570            430          JMP     code1100    ; MULS / MULU / AND.bwl
00001436  4EF9 0000158A            431          JMP     code1101    ; ADD.bwl / ADDA.wl / ADDX.bwl
0000143C  4EF9 000015A4            432          JMP     code1110    ; ASL.bwl / ASR.bwl / LSL.bwl / LSR.bwl / ROR.bwl / ROL.bwl
00001442  4EF9 00001622            433          JMP     code1111    ;   [unassigned]
00001448                           434          
00001448                           435  code0000                            ; Opcodes ADDI and SUBI
00001448  2200                     436          MOVE.L  D0,D1               ; D0 is current instruction word
0000144A  0241 0F00                437          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
0000144E  1A3C 0008                438          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001452  EA69                     439          LSR.W   D5,D1               ; Shift nibble into LSB position
00001454  C2FC 0006                440          MULU    #6, D1              ; Set displacement 
00001458  41F9 00001626            441          LEA     OP_0000_TABLE,A0    ; Load table into A0
0000145E  4EF0 1000                442          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00001462                           443  
00001462                           444  code0001                            ; Opcode MOVE.B
00001462  6000 052E                445          BRA     OP_MOVE             ; Go to opcode MOVE
00001466                           446  
00001466                           447  code0010                            ; Opcodes MOVE.L and MOVEA.L 
00001466  2200                     448          MOVE.L  D0,D1               ; D0 is current instruction word
00001468  0241 01C0                449          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000146C  1A3C 0006                450          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001470  EA69                     451          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001472  B23C 0001                452          CMP.B   #1,D1               ; When 001 in destination mode
00001476  6700 04F6                453          BEQ     OP_MOVEA            ; Go to opcode MOVEA
0000147A  6000 0516                454          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
0000147E                           455  
0000147E                           456  code0011                            ; Opcodes MOVE.W and MOVEA.W 
0000147E  2200                     457          MOVE.L  D0,D1               ; D0 is current instruction word
00001480  0241 01C0                458          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001484  1A3C 0006                459          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001488  EA69                     460          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000148A  B23C 0001                461          CMP.B   #1,D1               ; When 001 in destination mode
0000148E  6700 04DE                462          BEQ     OP_MOVEA            ; Go to opcode MOVEA
00001492  6000 04FE                463          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001496                           464  
00001496                           465  code0100                            ; Opcodes CLR, JSR, LEA, MOVEM, NOP, RTS
00001496  2200                     466          MOVE.L  D0,D1               ; D0 is current instruction word
00001498  0241 0F00                467          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
0000149C  1A3C 0008                468          MOVE.B  #right8,D5          ; Used to shift 8 times to right
000014A0  EA69                     469          LSR.W   D5,D1               ; Shift nibble into LSB position
000014A2  C2FC 0006                470          MULU    #6, D1              ; Set displacement 
000014A6  41F9 00001686            471          LEA     OP_0100_TABLE,A0    ; Load table into A0
000014AC  4EF0 1000                472          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000014B0                           473  
000014B0                           474  code0101                            ; Opcode ADDQ.B/W/L
000014B0  6000 0598                475          BRA     OP_ADDQ             ; Go to opcode ADDQ
000014B4                           476  
000014B4                           477  code0110                            ; Opcodes BRA / BSR / BHI
000014B4  2200                     478          MOVE.L  D0,D1               ; D0 is current instruction word
000014B6  0241 0F00                479          ANDI.W  #second_nibble,D1   ; Extract 2nd 4 bits from instruction word
000014BA  1A3C 0008                480          MOVE.B  #right8,D5          ; Used to shift 8 times to right
000014BE  EA69                     481          LSR.W   D5,D1               ; Shift nibble into LSB position
000014C0  B23C 0000                482          CMP.B   #0, D1              ; When 0000 in second nibble 
000014C4  6700 05A4                483          BEQ     OP_BRA              ; Go to opcode BRA
000014C8  B23C 0001                484          CMP.B   #1, D1              ; When 0001 in second nibble 
000014CC  6700 05B8                485          BEQ     OP_BSR              ; Go to opcode BSR
000014D0  B23C 0002                486          CMP.B   #2, D1              ; When 0010 in second nibble 
000014D4  6700 05CC                487          BEQ     OP_BHI              ; Go to opcode BHI
000014D8  B23C 0003                488          CMP.B   #3, D1              ; When 0011 in second nibble
000014DC  6700 05E0                489          BEQ     OP_BLS              ; Go to opcode BLS
000014E0  B23C 0004                490          CMP.B   #4, D1              ; When 0100 in second nibble
000014E4  6700 05F4                491          BEQ     OP_BCC              ; Go to opcode BCC
000014E8  B23C 0005                492          CMP.B   #5, D1              ; When 0101 in second nibble
000014EC  6700 0608                493          BEQ     OP_BCS              ; Go to opcode BCS
000014F0  B23C 0006                494          CMP.B   #6, D1              ; When 0110 in second nibble
000014F4  6700 061C                495          BEQ     OP_BNE              ; Go to opcode BNE
000014F8  B23C 0007                496          CMP.B   #7, D1              ; When 0111 in second nibble
000014FC  6700 0630                497          BEQ     OP_BEQ              ; Go to opcode BEQ
00001500  B23C 0008                498          CMP.B   #8, D1              ; When 1000 in second nibble
00001504  6700 0644                499          BEQ     OP_BVC              ; Go to opcode BVC
00001508  B23C 0009                500          CMP.B   #9, D1              ; When 1001 in second nibble
0000150C  6700 0658                501          BEQ     OP_BVS              ; Go to opcode BVS
00001510  B23C 000A                502          CMP.B   #10, D1             ; When 1010 in second nibble
00001514  6700 066C                503          BEQ     OP_BPL              ; Go to opcode BPL
00001518  B23C 000B                504          CMP.B   #11, D1             ; When 1011 in second nibble
0000151C  6700 0680                505          BEQ     OP_BMI              ; Go to opcode BMI
00001520  B23C 000C                506          CMP.B   #12, D1             ; When 1100 in second nibble
00001524  6700 0694                507          BEQ     OP_BGE              ; Go to opcode BGE
00001528  B23C 000D                508          CMP.B   #13, D1             ; When 1101 in second nibble
0000152C  6700 06A8                509          BEQ     OP_BLT              ; Go to opcode BLT
00001530  B23C 000E                510          CMP.B   #14, D1             ; When 1110 in second nibble
00001534  6700 06BC                511          BEQ     OP_BGT              ; Go to opcode BGT
00001538  B23C 000F                512          CMP.B   #15, D1             ; When 1111 in second nibble
0000153C  6700 06D0                513          BEQ     OP_BLE              ; Go to opcode BLE
00001540                           514  
00001540                           515  code0111                            ; Opcode MOVEQ
00001540  6000 06E8                516          BRA     OP_MOVEQ            ; Go to opcode MOVEQ
00001544                           517  
00001544                           518  code1000                            ; Opcodes DIVU word and OR.B/W/L
00001544  2200                     519          MOVE.L  D0,D1               ; D0 is current instruction word
00001546  0241 01C0                520          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000154A  1A3C 0006                521          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000154E  EA69                     522          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001550  B23C 0003                523          CMP.B   #3,D1               ; When 011 in destination mode
00001554  6700 06F8                524          BEQ     OP_DIVU             ; Go to opcode DIVU word
00001558  B23C 0007                525          CMP.B   #7,D1               ; When 111
0000155C  6700 03CC                526          BEQ     OP_UNSUPPORTED      ; Go to opcode unsupported
00001560  6000 070C                527          BRA     OP_OR               ; Otherwise, go to opcode OR
00001564                           528  
00001564                           529  code1001                            ; Opcode SUB.B/W/L
00001564  6000 0720                530          BRA     OP_SUB              ; Go to opcode SUB   
00001568                           531          
00001568                           532  code1010                            ; Opcode not supported 
00001568  6000 03C0                533          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
0000156C                           534       
0000156C                           535  code1011                            ; Opcode CMP.B/W/L
0000156C  6000 0734                536          BRA     OP_CMP              ; Go to opcode CMP
00001570                           537  
00001570                           538  code1100                            ; Opcodes MULS, MULU, AND.B/W/L
00001570  2200                     539          MOVE.L  D0,D1               ; D0 is current instruction word
00001572  0241 01C0                540          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001576  1A3C 0006                541          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000157A  EA69                     542          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000157C  C2FC 0006                543          MULU    #6, D1              ; Set displacement 
00001580  41F9 000016E6            544          LEA     OP_1100_TABLE,A0    ; Load table into A0
00001586  4EF0 1000                545          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
0000158A                           546  
0000158A                           547  code1101                            ; Opcodes ADD.B/W/L, ADDA.B/W/L
0000158A  2200                     548          MOVE.L  D0,D1               ; D0 is current instruction word
0000158C  0241 01C0                549          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001590  1A3C 0006                550          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001594  EA69                     551          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001596  C2FC 0006                552          MULU    #6, D1              ; Set displacement 
0000159A  41F9 00001746            553          LEA     OP_1101_TABLE,A0    ; Load table into A0
000015A0  4EF0 1000                554          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
000015A4                           555  
000015A4                           556  code1110                            ; Opcodes ASL.B/W/L, ASR.B/W/L, LSL.B/W/L, LSR.B/W/L, ROL.B/W/L, ROR.B/W/L   
000015A4  2200                     557          MOVE.L  D0,D1               ; D0 is current instruction word
000015A6  0241 01C0                558          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000015AA  1A3C 0006                559          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000015AE  EA69                     560          LSR.W   D5,D1               ; Shift dst mode into LSB position
000015B0                           561     
000015B0                           562          ; Check Memory Shifts
000015B0  B23C 0007                563          CMP.B   #7, D1              ; When 111
000015B4  6700 0024                564          BEQ     MEMORY_1110_LEFT    ; Go to Memory Shift Left Side
000015B8                           565      
000015B8  B23C 0003                566          CMP.B   #3, D1              ; When 011
000015BC  6700 0040                567          BEQ     MEMORY_1110_RIGHT   ; Go Memory Shift Right Side
000015C0                           568      
000015C0                           569          ; Check Register Shifts
000015C0  2200                     570          MOVE.L  D0,D1                       ; D0 is current instruction word
000015C2  0241 0038                571          ANDI.W  #src_mode,D1                ; Extract 5-3 bits from instruction word
000015C6  1A3C 0003                572          MOVE.B  #right3,D5                  ; Used to shift 3 times to right
000015CA  EA69                     573          LSR.W   D5,D1                       ; Shift 5-3 bits into LSB position
000015CC  C2FC 0006                574          MULU    #6,D1                       ; Set displacement 
000015D0  41F9 000017A6            575          LEA     OP_1110_TABLE_REGISTER,A0   ; Load table into A0
000015D6  4EF0 1000                576          JMP     0(A0,D1)                    ; go to displacement (A0 + D1 * 6)
000015DA                           577  
000015DA                           578  MEMORY_1110_LEFT    
000015DA  2200                     579          MOVE.L  D0,D1               ; D0 is current instruction word
000015DC  0241 0E00                580          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
000015E0  1A3C 0009                581          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000015E4  EA69                     582          LSR.W   D5,D1               ; Shift dst reg into LSB position
000015E6  B23C 0000                583          CMP.B   #0,D1               ; When D1 is 0
000015EA  6700 0786                584          BEQ     OP_ASL              ; Go to opcode ASL
000015EE  B23C 0001                585          CMP.B   #1, D1              ; when D1 is 1
000015F2  6700 07B6                586          BEQ     OP_LSL              ; Go to opcode LSL
000015F6  B23C 0003                587          CMP.B   #3, D1              ; When D1 is 3
000015FA  6700 07E6                588          BEQ     OP_ROL              ; Go to opcode ROL
000015FE                           589  
000015FE                           590  MEMORY_1110_RIGHT
000015FE  2200                     591          MOVE.L  D0,D1               ; D0 is current instruction word
00001600  0241 0E00                592          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
00001604  1A3C 0009                593          MOVE.B  #right9,D5          ; Used to shift 9 times to right
00001608  EA69                     594          LSR.W   D5,D1               ; Shift dst reg into LSB position
0000160A  B23C 0000                595          CMP.B   #0,D1               ; When D1 is 0
0000160E  6700 0746                596          BEQ     OP_ASR              ; Go to opcode ASR
00001612  B23C 0001                597          CMP.B   #1, D1              ; when D1 is 1
00001616  6700 0776                598          BEQ     OP_LSR              ; Go to opcode LSR
0000161A  B23C 0003                599          CMP.B   #3, D1              ; When D1 is 3
0000161E  6700 07A6                600          BEQ     OP_ROR              ; Go to opcode ROR
00001622                           601  
00001622                           602  code1111                            ; Opcode not supported 
00001622  6000 0306                603          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
00001626                           604           
00001626                           605  OP_0000_TABLE
00001626  4EF9 0000192A            606          JMP     OP_UNSUPPORTED  ; 0 Go to opcode unsupported  
0000162C  4EF9 0000192A            607          JMP     OP_UNSUPPORTED  ; 1 Go to opcode unsupported  
00001632  4EF9 0000192A            608          JMP     OP_UNSUPPORTED  ; 2 Go to opcode unsupported  
00001638  4EF9 0000192A            609          JMP     OP_UNSUPPORTED  ; 3 Go to opcode unsupported  
0000163E  4EF9 0000192E            610          JMP     OP_SUBI         ; 4 Go to opcode SUBI
00001644  4EF9 0000192A            611          JMP     OP_UNSUPPORTED  ; 5 Go to opcode unsupported  
0000164A  4EF9 0000194E            612          JMP     OP_ADDI         ; 6 Go to opcode ADDI
00001650  4EF9 0000192A            613          JMP     OP_UNSUPPORTED  ; 7 Go to opcode unsupported  
00001656  4EF9 0000192A            614          JMP     OP_UNSUPPORTED  ; 8 Go to opcode unsupported  
0000165C  4EF9 0000192A            615          JMP     OP_UNSUPPORTED  ; 9 Go to opcode unsupported  
00001662  4EF9 0000192A            616          JMP     OP_UNSUPPORTED  ; A Go to opcode unsupported  
00001668  4EF9 0000192A            617          JMP     OP_UNSUPPORTED  ; B Go to opcode unsupported  
0000166E  4EF9 0000192A            618          JMP     OP_UNSUPPORTED  ; C Go to opcode unsupported  
00001674  4EF9 0000192A            619          JMP     OP_UNSUPPORTED  ; D Go to opcode unsupported  
0000167A  4EF9 0000192A            620          JMP     OP_UNSUPPORTED  ; E Go to opcode unsupported  
00001680  4EF9 0000192A            621          JMP     OP_UNSUPPORTED  ; F Go to opcode unsupported  
00001686                           622      
00001686                           623  OP_0100_TABLE
00001686  4EF9 0000192A            624          JMP     OP_UNSUPPORTED      ; 0 Go to opcode unsupported  
0000168C  4EF9 00001A2E            625          JMP     OP_LEA              ; 1 Go to opcode LEA
00001692  4EF9 000019B2            626          JMP     OP_CLR              ; 2 Go to opcode CLR
00001698  4EF9 00001A2E            627          JMP     OP_LEA              ; 3 Go to opcode LEA
0000169E  4EF9 0000192A            628          JMP     OP_UNSUPPORTED      ; 4 Go to opcode unsupported  
000016A4  4EF9 00001A2E            629          JMP     OP_LEA              ; 5 Go to opcode LEA
000016AA  4EF9 0000192A            630          JMP     OP_UNSUPPORTED      ; 6 Go to opcode unsupported
000016B0  4EF9 00001A2E            631          JMP     OP_LEA              ; 7 Go to opcode LEA
000016B6  4EF9 00001A0A            632          JMP     OP_MOVEM            ; 8 Go to opcode MOVEM
000016BC  4EF9 00001A2E            633          JMP     OP_LEA              ; 9 Go to opcode LEA
000016C2  4EF9 0000192A            634          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000016C8  4EF9 00001A2E            635          JMP     OP_LEA              ; B Go to opcode LEA
000016CE  4EF9 00001A0A            636          JMP     OP_MOVEM            ; C Go to opcode MOVEM
000016D4  4EF9 00001A2E            637          JMP     OP_LEA              ; D Go to opcode LEA
000016DA  4EF9 0000186C            638          JMP     JSR_NOP_RTS         ; E Go to opcode JSR, NOP, or RTS
000016E0  4EF9 0000192A            639          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000016E6                           640      
000016E6                           641  OP_1100_TABLE
000016E6  4EF9 00001CFE            642          JMP     OP_AND              ; 0 Go to opcode AND 
000016EC  4EF9 00001CFE            643          JMP     OP_AND              ; 1 Go to opcode AND
000016F2  4EF9 00001CFE            644          JMP     OP_AND              ; 2 Go to opcode AND
000016F8  4EF9 00001CBE            645          JMP     OP_MULU             ; 3 Go to opcode MULU
000016FE  4EF9 00001CFE            646          JMP     OP_AND              ; 4 Go to opcode AND 
00001704  4EF9 00001CFE            647          JMP     OP_AND              ; 5 Go to opcode AND
0000170A  4EF9 00001CFE            648          JMP     OP_AND              ; 6 Go to opcode AND
00001710  4EF9 00001CDE            649          JMP     OP_MULS             ; 7 Go to opcode MULS
00001716  4EF9 0000192A            650          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000171C  4EF9 0000192A            651          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001722  4EF9 0000192A            652          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
00001728  4EF9 0000192A            653          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
0000172E  4EF9 0000192A            654          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001734  4EF9 0000192A            655          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000173A  4EF9 0000192A            656          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001740  4EF9 0000192A            657          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001746                           658      
00001746                           659  OP_1101_TABLE
00001746  4EF9 00001D1A            660          JMP     OP_ADD              ; 0 Go to opcode ADD 
0000174C  4EF9 00001D1A            661          JMP     OP_ADD              ; 1 Go to opcode ADD
00001752  4EF9 00001D1A            662          JMP     OP_ADD              ; 2 Go to opcode ADD
00001758  4EF9 00001D36            663          JMP     OP_ADDA             ; 3 Go to opcode ADDA
0000175E  4EF9 00001D1A            664          JMP     OP_ADD              ; 4 Go to opcode ADD 
00001764  4EF9 00001D1A            665          JMP     OP_ADD              ; 5 Go to opcode ADD
0000176A  4EF9 00001D1A            666          JMP     OP_ADD              ; 6 Go to opcode ADD
00001770  4EF9 00001D36            667          JMP     OP_ADDA             ; 7 Go to opcode ADDA
00001776  4EF9 0000192A            668          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000177C  4EF9 0000192A            669          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001782  4EF9 0000192A            670          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
00001788  4EF9 0000192A            671          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
0000178E  4EF9 0000192A            672          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001794  4EF9 0000192A            673          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000179A  4EF9 0000192A            674          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
000017A0  4EF9 0000192A            675          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000017A6                           676      
000017A6                           677  OP_1110_TABLE_REGISTER
000017A6  4EF9 00001806            678          JMP     OP_AS_CHECK         ; 0 Check if AS is left or right
000017AC  4EF9 00001828            679          JMP     OP_LS_CHECK         ; 1 Check if LS is left or right
000017B2  4EF9 0000192A            680          JMP     OP_UNSUPPORTED      ; 2 Go to opcode unsupported  
000017B8  4EF9 0000184A            681          JMP     OP_RO_CHECK         ; 3 Check if RO is left or right
000017BE  4EF9 00001806            682          JMP     OP_AS_CHECK         ; 4 Check if AS is left or right
000017C4  4EF9 00001828            683          JMP     OP_LS_CHECK         ; 5 Check if LS is left or right
000017CA  4EF9 0000192A            684          JMP     OP_UNSUPPORTED      ; 6 Go to opcode unsupported 
000017D0  4EF9 0000184A            685          JMP     OP_RO_CHECK         ; 7 Check if RO is left or right
000017D6  4EF9 0000192A            686          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
000017DC  4EF9 0000192A            687          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
000017E2  4EF9 0000192A            688          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000017E8  4EF9 0000192A            689          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
000017EE  4EF9 0000192A            690          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
000017F4  4EF9 0000192A            691          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
000017FA  4EF9 0000192A            692          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001800  4EF9 0000192A            693          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001806                           694  
00001806                           695  OP_AS_CHECK
00001806  2200                     696          MOVE.L  D0,D1               ; D0 is current instruction word
00001808  0241 01C0                697          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
0000180C  1A3C 0006                698          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001810  EA69                     699          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001812  0201 0004                700          ANDI.B  #4,D1               ; Get only bit 8 (dr)
00001816  E449                     701          LSR.W   #2,D1
00001818                           702  
00001818  B23C 0001                703          CMP.B   #1,D1               ; Go left
0000181C  6700 0554                704          BEQ     OP_ASL              ; 1 Go to opcode ASL
00001820  B23C 0000                705          CMP.B   #0,D1               ; Go right
00001824  6700 0530                706          BEQ     OP_ASR              ; 0 Go to opcode ASR
00001828                           707          
00001828                           708  OP_LS_CHECK
00001828  2200                     709          MOVE.L  D0,D1               ; D0 is current instruction word
0000182A  0241 01C0                710          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
0000182E  1A3C 0006                711          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001832  EA69                     712          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001834  0201 0004                713          ANDI.B  #4,D1               ; Get only bit 8 (dr)
00001838  E449                     714          LSR.W   #2,D1
0000183A                           715  
0000183A  B23C 0001                716          CMP.B   #1,D1               ; Go left
0000183E  6700 056A                717          BEQ     OP_LSL              ; 1 Go to opcode LSL
00001842  B23C 0000                718          CMP.B   #0,D1               ; Go right
00001846  6700 0546                719          BEQ     OP_LSR              ; 0 Go to opcode LSR
0000184A                           720          
0000184A                           721  OP_RO_CHECK
0000184A  2200                     722          MOVE.L  D0,D1               ; D0 is current instruction word
0000184C  0241 01C0                723          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00001850  1A3C 0006                724          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001854  EA69                     725          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001856  0201 0004                726          ANDI.B  #4,D1               ; Get only bit 8 (dr)
0000185A  E449                     727          LSR.W   #2,D1
0000185C                           728  
0000185C  B23C 0001                729          CMP.B   #1,D1               ; Go left
00001860  6700 0580                730          BEQ     OP_ROL              ; 1 Go to opcode ROL
00001864  B23C 0000                731          CMP.B   #0,D1               ; Go right
00001868  6700 055C                732          BEQ     OP_ROR              ; 0 Go to opcode ROR
0000186C                           733          
0000186C                           734  JSR_NOP_RTS
0000186C  2200                     735          MOVE.L  D0,D1               ; D0 is current instruction word
0000186E  0241 01C0                736          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001872  1A3C 0006                737          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001876  EA69                     738          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001878  B23C 0002                739          CMP.B   #2, D1              ; When 010 in destination mode
0000187C  6700 0170                740          BEQ     OP_JSR              ; Go to opcode JSR
00001880                           741          
00001880  2200                     742          MOVE.L  D0,D1               ; D0 is current instruction word
00001882  0241 000F                743          ANDI.W  #fourth_nibble,D1   ; Extract dst mode position from instruction word
00001886  B23C 0001                744          CMP.B   #1, D1  
0000188A  6700 000E                745          BEQ     NOP_CHECK
0000188E  B23C 0005                746          CMP.B   #5, D1  
00001892  6700 004E                747          BEQ     RTS_CHECK
00001896  6000 0092                748          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000189A                           749          
0000189A                           750  NOP_CHECK
0000189A  2200                     751          MOVE.L  D0,D1               ; D0 is current instruction word
0000189C  0241 F000                752          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
000018A0  1A3C 000C                753          MOVE.B  #right12,D5         ; Used to shift 6 times to right
000018A4  EA69                     754          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018A6  B23C 0004                755          CMP.B   #4, D1              
000018AA  6700 0006                756          BEQ     NOP_CHECK_TWO
000018AE  6000 007A                757          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018B2                           758          
000018B2                           759  NOP_CHECK_TWO
000018B2  2200                     760          MOVE.L  D0,D1               ; D0 is current instruction word
000018B4  0241 0F00                761          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
000018B8  1A3C 0008                762          MOVE.B  #right8,D5          ; Used to shift 6 times to right
000018BC  EA69                     763          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018BE  B23C 000E                764          CMP.B   #14, D1            
000018C2  6700 0006                765          BEQ     NOP_CHECK_THREE
000018C6  6000 0062                766          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018CA                           767  
000018CA                           768  NOP_CHECK_THREE
000018CA  2200                     769          MOVE.L  D0,D1               ; D0 is current instruction word
000018CC  0241 00F0                770          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
000018D0  1A3C 0004                771          MOVE.B  #right4,D5          ; Used to shift 6 times to right
000018D4  EA69                     772          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018D6  B23C 0007                773          CMP.B   #7, D1              
000018DA  6700 00F2                774          BEQ     OP_NOP
000018DE  6000 004A                775          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018E2                           776       
000018E2                           777  RTS_CHECK
000018E2  2200                     778          MOVE.L  D0,D1               ; D0 is current instruction word
000018E4  0241 F000                779          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
000018E8  1A3C 000C                780          MOVE.B  #right12,D5         ; Used to shift 6 times to right
000018EC  EA69                     781          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018EE  B23C 0004                782          CMP.B   #4, D1              
000018F2  6700 0006                783          BEQ     RTS_CHECK_TWO
000018F6  6000 0032                784          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018FA                           785          
000018FA                           786  RTS_CHECK_TWO
000018FA  2200                     787          MOVE.L  D0,D1               ; D0 is current instruction word
000018FC  0241 0F00                788          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
00001900  1A3C 0008                789          MOVE.B  #right8,D5          ; Used to shift 6 times to right
00001904  EA69                     790          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001906  B23C 000E                791          CMP.B   #14, D1             
0000190A  6700 0006                792          BEQ     RTS_CHECK_THREE
0000190E  6000 001A                793          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
00001912                           794  
00001912                           795  RTS_CHECK_THREE
00001912  2200                     796          MOVE.L  D0,D1               ; D0 is current instruction word
00001914  0241 00F0                797          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
00001918  1A3C 0004                798          MOVE.B  #right4,D5          ; Used to shift 6 times to right
0000191C  EA69                     799          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000191E  B23C 0007                800          CMP.B   #7, D1             
00001922  6700 00BA                801          BEQ     OP_RTS
00001926  6000 0002                802          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000192A                           803  
0000192A                           804  OP_UNSUPPORTED
0000192A  6000 14EC                805       BRA OP_ERROR       
0000192E                           806  *----------------------------------------------------------------------------------------------*
0000192E                           807  * param D0 the current instruction in word
0000192E                           808  * param D1 the EA type
0000192E                           809  * param A2 a pointer to the decode_buffer
0000192E                           810  * param A5 current address
0000192E                           811  * ea_start(D0, D1, A2, A5){
0000192E                           812  * D2: size
0000192E                           813  * D3: src mode, dst mode
0000192E                           814  * D4: src regs, dst regs
0000192E                           815  * D5: #shifts
0000192E                           816  * D7: immediate data
0000192E                           817  * A0: EA_TYPE_TABLE
0000192E                           818  *       0 = ea_immediate
0000192E                           819  * }
0000192E                           820  
0000192E                           821  *----------------------------------------------------------------------------------------------*
0000192E                           822  * First 4 bits: 0000
0000192E                           823  OP_SUBI
0000192E  14FC 0053                824          MOVE.B  #'S',(A2)+
00001932  14FC 0055                825          MOVE.B  #'U',(A2)+
00001936  14FC 0042                826          MOVE.B  #'B',(A2)+
0000193A  14FC 0049                827          MOVE.B  #'I',(A2)+
0000193E  223C 00000000            828          MOVE.L  #ea_type_immediate,D1
00001944  4EB9 00001DFE            829          JSR     EA_START
0000194A  4EF8 13CC                830          JMP     OP_FINISH
0000194E                           831          
0000194E                           832  OP_ADDI
0000194E  14FC 0041                833          MOVE.B  #'A',(A2)+
00001952  14FC 0044                834          MOVE.B  #'D',(A2)+
00001956  14FC 0044                835          MOVE.B  #'D',(A2)+
0000195A  14FC 0049                836          MOVE.B  #'I',(A2)+
0000195E  223C 00000000            837          MOVE.L  #ea_type_immediate,D1
00001964  4EB9 00001DFE            838          JSR     EA_START
0000196A  4EF8 13CC                839          JMP     OP_FINISH
0000196E                           840  
0000196E                           841  *-----------------------------------------------------------------------------------------------*
0000196E                           842  * First 4 bits: 0001
0000196E                           843  OP_MOVEA
0000196E  14FC 004D                844          MOVE.B  #'M',(A2)+
00001972  14FC 004F                845          MOVE.B  #'O',(A2)+
00001976  14FC 0056                846          MOVE.B  #'V',(A2)+
0000197A  14FC 0045                847          MOVE.B  #'E',(A2)+
0000197E  14FC 0041                848          MOVE.B  #'A',(A2)+
00001982  223C 00000002            849          MOVE.L  #ea_type_movea,D1
00001988  4EB9 00001DFE            850          JSR     EA_START
0000198E  4EF8 13CC                851          JMP     OP_FINISH
00001992                           852  
00001992                           853  *------------------------------------------------------------------------------------------------*
00001992                           854  * First 4 bits: 0011
00001992                           855  OP_MOVE
00001992  14FC 004D                856          MOVE.B  #'M',(A2)+
00001996  14FC 004F                857          MOVE.B  #'O',(A2)+
0000199A  14FC 0056                858          MOVE.B  #'V',(A2)+
0000199E  14FC 0045                859          MOVE.B  #'E',(A2)+
000019A2  223C 00000001            860          MOVE.L  #ea_type_move,D1
000019A8  4EB9 00001DFE            861          JSR     EA_START
000019AE  4EF8 13CC                862          JMP     OP_FINISH
000019B2                           863  
000019B2                           864  *------------------------------------------------------------------------------------------------*
000019B2                           865  * First 4 bits: 0100
000019B2                           866  OP_CLR
000019B2  14FC 0043                867          MOVE.B  #'C',(A2)+
000019B6  14FC 004C                868          MOVE.B  #'L',(A2)+
000019BA  14FC 0052                869          MOVE.B  #'R',(A2)+
000019BE  223C 00000004            870          MOVE.L  #ea_type_dstonly,D1
000019C4  4EB9 00001DFE            871          JSR     EA_START
000019CA  4EF8 13CC                872          JMP     OP_FINISH
000019CE                           873          
000019CE                           874  OP_NOP
000019CE  14FC 004E                875          MOVE.B  #'N',(A2)+
000019D2  14FC 004F                876          MOVE.B  #'O',(A2)+
000019D6  14FC 0050                877          MOVE.B  #'P',(A2)+
000019DA  4EF8 13CC                878          JMP     OP_FINISH
000019DE                           879          
000019DE                           880  OP_RTS
000019DE  14FC 0052                881          MOVE.B  #'R',(A2)+
000019E2  14FC 0054                882          MOVE.B  #'T',(A2)+
000019E6  14FC 0053                883          MOVE.B  #'S',(A2)+
000019EA  4EF8 13CC                884          JMP     OP_FINISH
000019EE                           885          
000019EE                           886  OP_JSR
000019EE  14FC 004A                887          MOVE.B  #'J',(A2)+
000019F2  14FC 0053                888          MOVE.B  #'S',(A2)+
000019F6  14FC 0052                889          MOVE.B  #'R',(A2)+
000019FA  223C 00000004            890          MOVE.L  #ea_type_dstonly,D1
00001A00  4EB9 00001DFE            891          JSR     EA_START
00001A06  4EF8 13CC                892          JMP     OP_FINISH
00001A0A                           893  
00001A0A                           894  OP_MOVEM
00001A0A  14FC 004D                895          MOVE.B  #'M',(A2)+
00001A0E  14FC 004F                896          MOVE.B  #'O',(A2)+
00001A12  14FC 0056                897          MOVE.B  #'V',(A2)+
00001A16  14FC 0045                898          MOVE.B  #'E',(A2)+
00001A1A  14FC 004D                899          MOVE.B  #'M',(A2)+
00001A1E  223C 00000006            900          MOVE.L  #ea_type_movem,D1
00001A24  4EB9 00001DFE            901          JSR     EA_START
00001A2A  4EF8 13CC                902          JMP     OP_FINISH
00001A2E                           903          
00001A2E                           904  OP_LEA
00001A2E  14FC 004C                905          MOVE.B  #'L',(A2)+
00001A32  14FC 0045                906          MOVE.B  #'E',(A2)+
00001A36  14FC 0041                907          MOVE.B  #'A',(A2)+
00001A3A  223C 00000003            908          MOVE.L  #ea_type_lea,D1
00001A40  4EB9 00001DFE            909          JSR     EA_START
00001A46  4EF8 13CC                910          JMP     OP_FINISH
00001A4A                           911  
00001A4A                           912  *------------------------------------------------------------------------------------------------*
00001A4A                           913  * First 4 bits: 0101
00001A4A                           914  OP_ADDQ
00001A4A  14FC 0041                915          MOVE.B  #'A',(A2)+
00001A4E  14FC 0044                916          MOVE.B  #'D',(A2)+
00001A52  14FC 0044                917          MOVE.B  #'D',(A2)+
00001A56  14FC 0051                918          MOVE.B  #'Q',(A2)+
00001A5A  223C 00000008            919          MOVE.L  #ea_type_quick,D1
00001A60  4EB9 00001DFE            920          JSR     EA_START
00001A66  4EF8 13CC                921          JMP     OP_FINISH
00001A6A                           922          
00001A6A                           923  *------------------------------------------------------------------------------------------------*
00001A6A                           924  * First 4 bits: 0110
00001A6A                           925  OP_BRA
00001A6A  14FC 0042                926          MOVE.B  #'B',(A2)+
00001A6E  14FC 0052                927          MOVE.B  #'R',(A2)+
00001A72  14FC 0041                928          MOVE.B  #'A',(A2)+
00001A76  223C 00000009            929          MOVE.L  #ea_type_branch,D1
00001A7C  4EB9 00001DFE            930          JSR     EA_START
00001A82  4EF8 13CC                931          JMP     OP_FINISH
00001A86                           932  
00001A86                           933  OP_BSR
00001A86  14FC 0042                934          MOVE.B  #'B',(A2)+
00001A8A  14FC 0053                935          MOVE.B  #'S',(A2)+
00001A8E  14FC 0052                936          MOVE.B  #'R',(A2)+
00001A92  223C 00000009            937          MOVE.L  #ea_type_branch,D1
00001A98  4EB9 00001DFE            938          JSR     EA_START
00001A9E  4EF8 13CC                939          JMP     OP_FINISH
00001AA2                           940          
00001AA2                           941  OP_BHI
00001AA2  14FC 0042                942          MOVE.B  #'B',(A2)+
00001AA6  14FC 0048                943          MOVE.B  #'H',(A2)+
00001AAA  14FC 0049                944          MOVE.B  #'I',(A2)+
00001AAE  223C 00000009            945          MOVE.L  #ea_type_branch,D1
00001AB4  4EB9 00001DFE            946          JSR     EA_START
00001ABA  4EF8 13CC                947          JMP     OP_FINISH
00001ABE                           948  
00001ABE                           949  OP_BLS
00001ABE  14FC 0042                950          MOVE.B  #'B',(A2)+
00001AC2  14FC 004C                951          MOVE.B  #'L',(A2)+
00001AC6  14FC 0053                952          MOVE.B  #'S',(A2)+
00001ACA  223C 00000009            953          MOVE.L  #ea_type_branch,D1
00001AD0  4EB9 00001DFE            954          JSR     EA_START
00001AD6  4EF8 13CC                955          JMP     OP_FINISH
00001ADA                           956  
00001ADA                           957  OP_BCC
00001ADA  14FC 0042                958          MOVE.B  #'B',(A2)+
00001ADE  14FC 0043                959          MOVE.B  #'C',(A2)+
00001AE2  14FC 0043                960          MOVE.B  #'C',(A2)+
00001AE6  223C 00000009            961          MOVE.L  #ea_type_branch,D1
00001AEC  4EB9 00001DFE            962          JSR     EA_START
00001AF2  4EF8 13CC                963          JMP     OP_FINISH
00001AF6                           964          
00001AF6                           965  OP_BCS
00001AF6  14FC 0042                966          MOVE.B  #'B',(A2)+
00001AFA  14FC 0043                967          MOVE.B  #'C',(A2)+
00001AFE  14FC 0053                968          MOVE.B  #'S',(A2)+
00001B02  223C 00000009            969          MOVE.L  #ea_type_branch,D1
00001B08  4EB9 00001DFE            970          JSR     EA_START
00001B0E  4EF8 13CC                971          JMP     OP_FINISH
00001B12                           972  
00001B12                           973  OP_BNE
00001B12  14FC 0042                974          MOVE.B  #'B',(A2)+
00001B16  14FC 004E                975          MOVE.B  #'N',(A2)+
00001B1A  14FC 0045                976          MOVE.B  #'E',(A2)+
00001B1E  223C 00000009            977          MOVE.L  #ea_type_branch,D1
00001B24  4EB9 00001DFE            978          JSR     EA_START
00001B2A  4EF8 13CC                979          JMP     OP_FINISH
00001B2E                           980  
00001B2E                           981  OP_BEQ
00001B2E  14FC 0042                982          MOVE.B  #'B',(A2)+
00001B32  14FC 0045                983          MOVE.B  #'E',(A2)+
00001B36  14FC 0051                984          MOVE.B  #'Q',(A2)+
00001B3A  223C 00000009            985          MOVE.L  #ea_type_branch,D1
00001B40  4EB9 00001DFE            986          JSR     EA_START
00001B46  4EF8 13CC                987          JMP     OP_FINISH
00001B4A                           988  
00001B4A                           989  OP_BVC
00001B4A  14FC 0042                990          MOVE.B  #'B',(A2)+
00001B4E  14FC 0056                991          MOVE.B  #'V',(A2)+
00001B52  14FC 0043                992          MOVE.B  #'C',(A2)+
00001B56  223C 00000009            993          MOVE.L  #ea_type_branch,D1
00001B5C  4EB9 00001DFE            994          JSR     EA_START
00001B62  4EF8 13CC                995          JMP     OP_FINISH
00001B66                           996  
00001B66                           997  OP_BVS
00001B66  14FC 0042                998          MOVE.B  #'B',(A2)+
00001B6A  14FC 0056                999          MOVE.B  #'V',(A2)+
00001B6E  14FC 0053               1000          MOVE.B  #'S',(A2)+
00001B72  223C 00000009           1001          MOVE.L  #ea_type_branch,D1
00001B78  4EB9 00001DFE           1002          JSR     EA_START
00001B7E  4EF8 13CC               1003          JMP     OP_FINISH
00001B82                          1004  
00001B82                          1005  OP_BPL
00001B82  14FC 0042               1006          MOVE.B  #'B',(A2)+
00001B86  14FC 0050               1007          MOVE.B  #'P',(A2)+
00001B8A  14FC 004C               1008          MOVE.B  #'L',(A2)+
00001B8E  223C 00000009           1009          MOVE.L  #ea_type_branch,D1
00001B94  4EB9 00001DFE           1010          JSR     EA_START
00001B9A  4EF8 13CC               1011          JMP     OP_FINISH
00001B9E                          1012  
00001B9E                          1013  OP_BMI
00001B9E  14FC 0042               1014          MOVE.B  #'B',(A2)+
00001BA2  14FC 004D               1015          MOVE.B  #'M',(A2)+
00001BA6  14FC 0049               1016          MOVE.B  #'I',(A2)+
00001BAA  223C 00000009           1017          MOVE.L  #ea_type_branch,D1
00001BB0  4EB9 00001DFE           1018          JSR     EA_START
00001BB6  4EF8 13CC               1019          JMP     OP_FINISH
00001BBA                          1020  
00001BBA                          1021  OP_BGE
00001BBA  14FC 0042               1022          MOVE.B  #'B',(A2)+
00001BBE  14FC 0047               1023          MOVE.B  #'G',(A2)+
00001BC2  14FC 0045               1024          MOVE.B  #'E',(A2)+
00001BC6  223C 00000009           1025          MOVE.L  #ea_type_branch,D1
00001BCC  4EB9 00001DFE           1026          JSR     EA_START
00001BD2  4EF8 13CC               1027          JMP     OP_FINISH
00001BD6                          1028  
00001BD6                          1029  OP_BLT
00001BD6  14FC 0042               1030          MOVE.B  #'B',(A2)+
00001BDA  14FC 004C               1031          MOVE.B  #'L',(A2)+
00001BDE  14FC 0054               1032          MOVE.B  #'T',(A2)+
00001BE2  223C 00000009           1033          MOVE.L  #ea_type_branch,D1
00001BE8  4EB9 00001DFE           1034          JSR     EA_START
00001BEE  4EF8 13CC               1035          JMP     OP_FINISH
00001BF2                          1036  
00001BF2                          1037  OP_BGT
00001BF2  14FC 0042               1038          MOVE.B  #'B',(A2)+
00001BF6  14FC 0047               1039          MOVE.B  #'G',(A2)+
00001BFA  14FC 0054               1040          MOVE.B  #'T',(A2)+
00001BFE  223C 00000009           1041          MOVE.L  #ea_type_branch,D1
00001C04  4EB9 00001DFE           1042          JSR     EA_START
00001C0A  4EF8 13CC               1043          JMP     OP_FINISH
00001C0E                          1044  
00001C0E                          1045  OP_BLE
00001C0E  14FC 0042               1046          MOVE.B  #'B',(A2)+
00001C12  14FC 004C               1047          MOVE.B  #'L',(A2)+
00001C16  14FC 0045               1048          MOVE.B  #'E',(A2)+
00001C1A  223C 00000009           1049          MOVE.L  #ea_type_branch,D1
00001C20  4EB9 00001DFE           1050          JSR     EA_START
00001C26  4EF8 13CC               1051          JMP     OP_FINISH
00001C2A                          1052  *------------------------------------------------------------------------------------------------*
00001C2A                          1053  * First 4 bits: 0111
00001C2A                          1054  OP_MOVEQ
00001C2A  14FC 004D               1055          MOVE.B  #'M',(A2)+
00001C2E  14FC 004F               1056          MOVE.B  #'O',(A2)+
00001C32  14FC 0056               1057          MOVE.B  #'V',(A2)+
00001C36  14FC 0045               1058          MOVE.B  #'E',(A2)+
00001C3A  14FC 0051               1059          MOVE.B  #'Q',(A2)+
00001C3E  223C 00000008           1060          MOVE.L  #ea_type_quick,D1
00001C44  4EB9 00001DFE           1061          JSR     EA_START
00001C4A  4EF8 13CC               1062          JMP     OP_FINISH
00001C4E                          1063          
00001C4E                          1064  *------------------------------------------------------------------------------------------------*
00001C4E                          1065  * First 4 bits: 1000
00001C4E                          1066  OP_DIVU
00001C4E  14FC 0044               1067          MOVE.B  #'D',(A2)+
00001C52  14FC 0049               1068          MOVE.B  #'I',(A2)+
00001C56  14FC 0056               1069          MOVE.B  #'V',(A2)+
00001C5A  14FC 0055               1070          MOVE.B  #'U',(A2)+
00001C5E  223C 00000005           1071          MOVE.L  #ea_type_ext,D1
00001C64  4EB9 00001DFE           1072          JSR     EA_START
00001C6A  4EF8 13CC               1073          JMP     OP_FINISH
00001C6E                          1074    
00001C6E                          1075  OP_OR
00001C6E  14FC 004F               1076          MOVE.B  #'O',(A2)+
00001C72  14FC 0052               1077          MOVE.B  #'R',(A2)+
00001C76  223C 00000005           1078          MOVE.L  #ea_type_ext,D1
00001C7C  4EB9 00001DFE           1079          JSR     EA_START
00001C82  4EF8 13CC               1080          JMP     OP_FINISH
00001C86                          1081  
00001C86                          1082  *------------------------------------------------------------------------------------------------*
00001C86                          1083  * First 4 bits: 1001
00001C86                          1084  OP_SUB
00001C86  14FC 0053               1085          MOVE.B  #'S',(A2)+
00001C8A  14FC 0055               1086          MOVE.B  #'U',(A2)+
00001C8E  14FC 0042               1087          MOVE.B  #'B',(A2)+
00001C92  223C 00000005           1088          MOVE.L  #ea_type_ext,D1
00001C98  4EB9 00001DFE           1089          JSR     EA_START
00001C9E  4EF8 13CC               1090          JMP     OP_FINISH
00001CA2                          1091          
00001CA2                          1092  *------------------------------------------------------------------------------------------------*
00001CA2                          1093  * First 4 bits: 1011
00001CA2                          1094  OP_CMP
00001CA2  14FC 0043               1095          MOVE.B  #'C',(A2)+
00001CA6  14FC 004D               1096          MOVE.B  #'M',(A2)+
00001CAA  14FC 0050               1097          MOVE.B  #'P',(A2)+
00001CAE  223C 00000005           1098          MOVE.L  #ea_type_ext,D1
00001CB4  4EB9 00001DFE           1099          JSR     EA_START
00001CBA  4EF8 13CC               1100          JMP     OP_FINISH
00001CBE                          1101          
00001CBE                          1102  *------------------------------------------------------------------------------------------------*
00001CBE                          1103  * First 4 bits: 1100
00001CBE                          1104  OP_MULU
00001CBE  14FC 004D               1105          MOVE.B  #'M',(A2)+
00001CC2  14FC 0055               1106          MOVE.B  #'U',(A2)+
00001CC6  14FC 004C               1107          MOVE.B  #'L',(A2)+
00001CCA  14FC 0055               1108          MOVE.B  #'U',(A2)+
00001CCE  223C 00000005           1109          MOVE.L  #ea_type_ext,D1
00001CD4  4EB9 00001DFE           1110          JSR     EA_START
00001CDA  4EF8 13CC               1111          JMP     OP_FINISH
00001CDE                          1112          
00001CDE                          1113  OP_MULS
00001CDE  14FC 004D               1114          MOVE.B  #'M',(A2)+
00001CE2  14FC 0055               1115          MOVE.B  #'U',(A2)+
00001CE6  14FC 004C               1116          MOVE.B  #'L',(A2)+
00001CEA  14FC 0053               1117          MOVE.B  #'S',(A2)+
00001CEE  223C 00000005           1118          MOVE.L  #ea_type_ext,D1
00001CF4  4EB9 00001DFE           1119          JSR     EA_START
00001CFA  4EF8 13CC               1120          JMP     OP_FINISH
00001CFE                          1121          
00001CFE                          1122  OP_AND
00001CFE  14FC 0041               1123          MOVE.B  #'A',(A2)+
00001D02  14FC 004E               1124          MOVE.B  #'N',(A2)+
00001D06  14FC 0044               1125          MOVE.B  #'D',(A2)+
00001D0A  223C 00000005           1126          MOVE.L  #ea_type_ext,D1
00001D10  4EB9 00001DFE           1127          JSR     EA_START
00001D16  4EF8 13CC               1128          JMP     OP_FINISH
00001D1A                          1129          
00001D1A                          1130  *------------------------------------------------------------------------------------------------*
00001D1A                          1131  * First 4 bits: 1101
00001D1A                          1132  OP_ADD
00001D1A  14FC 0041               1133          MOVE.B  #'A',(A2)+
00001D1E  14FC 0044               1134          MOVE.B  #'D',(A2)+
00001D22  14FC 0044               1135          MOVE.B  #'D',(A2)+
00001D26  223C 00000005           1136          MOVE.L  #ea_type_ext,D1
00001D2C  4EB9 00001DFE           1137          JSR     EA_START
00001D32  4EF8 13CC               1138          JMP     OP_FINISH
00001D36                          1139  
00001D36                          1140  OP_ADDA
00001D36  14FC 0041               1141          MOVE.B  #'A',(A2)+
00001D3A  14FC 0044               1142          MOVE.B  #'D',(A2)+
00001D3E  14FC 0044               1143          MOVE.B  #'D',(A2)+
00001D42  14FC 0041               1144          MOVE.B  #'A',(A2)+
00001D46  223C 00000005           1145          MOVE.L  #ea_type_ext,D1
00001D4C  4EB9 00001DFE           1146          JSR     EA_START
00001D52  4EF8 13CC               1147          JMP     OP_FINISH
00001D56                          1148          
00001D56                          1149  *------------------------------------------------------------------------------------------------*
00001D56                          1150  * First 4 bits: 1110
00001D56                          1151  OP_ASR
00001D56  14FC 0041               1152          MOVE.B  #'A',(A2)+
00001D5A  14FC 0053               1153          MOVE.B  #'S',(A2)+
00001D5E  14FC 0052               1154          MOVE.B  #'R',(A2)+
00001D62  223C 00000007           1155          MOVE.L  #ea_type_shifts,D1
00001D68  4EB9 00001DFE           1156          JSR     EA_START
00001D6E  4EF8 13CC               1157          JMP     OP_FINISH
00001D72                          1158  OP_ASL
00001D72  14FC 0041               1159          MOVE.B  #'A',(A2)+
00001D76  14FC 0053               1160          MOVE.B  #'S',(A2)+
00001D7A  14FC 004C               1161          MOVE.B  #'L',(A2)+
00001D7E  223C 00000007           1162          MOVE.L  #ea_type_shifts,D1
00001D84  4EB9 00001DFE           1163          JSR     EA_START
00001D8A  4EF8 13CC               1164          JMP     OP_FINISH
00001D8E                          1165          
00001D8E                          1166  OP_LSR
00001D8E  14FC 004C               1167          MOVE.B  #'L',(A2)+
00001D92  14FC 0053               1168          MOVE.B  #'S',(A2)+
00001D96  14FC 0052               1169          MOVE.B  #'R',(A2)+
00001D9A  223C 00000007           1170          MOVE.L  #ea_type_shifts,D1
00001DA0  4EB9 00001DFE           1171          JSR     EA_START
00001DA6  4EF8 13CC               1172          JMP     OP_FINISH
00001DAA                          1173         
00001DAA                          1174  OP_LSL
00001DAA  14FC 004C               1175          MOVE.B  #'L',(A2)+
00001DAE  14FC 0053               1176          MOVE.B  #'S',(A2)+
00001DB2  14FC 004C               1177          MOVE.B  #'L',(A2)+
00001DB6  223C 00000007           1178          MOVE.L  #ea_type_shifts,D1
00001DBC  4EB9 00001DFE           1179          JSR     EA_START
00001DC2  4EF8 13CC               1180          JMP     OP_FINISH
00001DC6                          1181          
00001DC6                          1182  OP_ROR
00001DC6  14FC 0052               1183          MOVE.B  #'R',(A2)+
00001DCA  14FC 004F               1184          MOVE.B  #'O',(A2)+
00001DCE  14FC 0052               1185          MOVE.B  #'R',(A2)+
00001DD2  223C 00000007           1186          MOVE.L  #ea_type_shifts,D1
00001DD8  4EB9 00001DFE           1187          JSR     EA_START
00001DDE  4EF8 13CC               1188          JMP     OP_FINISH
00001DE2                          1189          
00001DE2                          1190  OP_ROL
00001DE2  14FC 0052               1191          MOVE.B  #'R',(A2)+
00001DE6  14FC 004F               1192          MOVE.B  #'O',(A2)+
00001DEA  14FC 004C               1193          MOVE.B  #'L',(A2)+
00001DEE  223C 00000007           1194          MOVE.L  #ea_type_shifts,D1
00001DF4  4EB9 00001DFE           1195          JSR     EA_START
00001DFA  4EF8 13CC               1196          JMP     OP_FINISH
00001DFE                          1197          
00001DFE                          1198  *------------------------------------------------------------------------------------------------*
00001DFE                          1199  EA_START
00001DFE  48E7 38C0               1200          MOVEM.L D2-D4/A0-A1, -(SP)
00001E02                          1201          
00001E02  41F9 00001E16           1202          LEA     EA_TYPE_TABLE, A0
00001E08  C2FC 0006               1203          MULU    #6, D1
00001E0C  4EF0 1000               1204          JMP     0(A0, D1)
00001E10                          1205          
00001E10                          1206  EA_FINISH
00001E10  4CDF 031C               1207          MOVEM.L (SP)+, D2-D4/A0-A1
00001E14  4E75                    1208          RTS
00001E16                          1209          
00001E16                          1210  EA_TYPE_TABLE
00001E16  4EF9 00001F34           1211          JMP     EA_IMMEDIATE        ; 0: ea_immediate
00001E1C  4EF9 00001F90           1212          JMP     EA_MOVE             ; 1: ea_move
00001E22  4EF9 00002000           1213          JMP     EA_MOVEA            ; 2: ea_movea
00001E28  4EF9 0000206C           1214          JMP     EA_LEA              ; 3: ea_lea
00001E2E  4EF9 000020F0           1215          JMP     EA_DSTONLY          ; 4: ea_dstonly
00001E34  4EF9 000021B6           1216          JMP     EA_EXT              ; 5: ea_ext
00001E3A  4EF9 000023AC           1217          JMP     EA_MOVEM            ; 6: ea_movem
00001E40  4EF9 00002A18           1218          JMP     EA_SHIFTS           ; 7: ea_shifts
00001E46  4EF9 00002B9A           1219          JMP     EA_QUICK            ; 8: ea_quick
00001E4C  4EF9 00002C8C           1220          JMP     EA_branch           ; 9: ea_branch
00001E52  4EF8 1E10               1221          JMP     EA_FINISH
00001E56                          1222          
00001E56                          1223  EA_SIZE_GENERAL
00001E56  B43C 0000               1224          CMP.B   #%00,D2             ; .b
00001E5A  6700 00B6               1225          BEQ     EA_SIZE_B       
00001E5E  B43C 0001               1226          CMP.B   #%01,D2             ; .w
00001E62  6700 00B8               1227          BEQ     EA_SIZE_W       
00001E66  B43C 0002               1228          CMP.B   #%10,D2             ; .l
00001E6A  6700 00BC               1229          BEQ     EA_SIZE_L
00001E6E  6000 0FDA               1230          BRA     EA_ERROR          ; wrong size
00001E72                          1231  
00001E72                          1232  EA_SIZE_MOVE
00001E72  B43C 0001               1233          CMP.B   #%01,D2             ; .b
00001E76  6700 009A               1234          BEQ     EA_SIZE_B       
00001E7A  B43C 0003               1235          CMP.B   #%11,D2             ; .w
00001E7E  6700 009C               1236          BEQ     EA_SIZE_W       
00001E82  B43C 0002               1237          CMP.B   #%10,D2             ; .l
00001E86  6700 00A0               1238          BEQ     EA_SIZE_L
00001E8A  6000 0FBE               1239          BRA     EA_ERROR            ; wrong size
00001E8E                          1240  
00001E8E                          1241  EA_SIZE_MOVEA     
00001E8E  B43C 0003               1242          CMP.B   #%11,D2             ; .w
00001E92  6700 0088               1243          BEQ     EA_SIZE_W       
00001E96  B43C 0002               1244          CMP.B   #%10,D2             ; .l
00001E9A  6700 008C               1245          BEQ     EA_SIZE_L
00001E9E  6000 0FAA               1246          BRA     EA_ERROR            ; wrong size
00001EA2                          1247          
00001EA2                          1248  EA_SIZE_MOVEM     
00001EA2  B43C 0000               1249          CMP.B   #%0000,D2           ; .w
00001EA6  6700 0074               1250          BEQ     EA_SIZE_W       
00001EAA  B43C 0004               1251          CMP.B   #%0100,D2           ; .l
00001EAE  6700 0078               1252          BEQ     EA_SIZE_L
00001EB2  6000 0F96               1253          BRA     EA_ERROR            ; wrong size
00001EB6                          1254  
00001EB6                          1255  EA_SIZE_OPMODE_012456               ; Check opmode field for size
00001EB6  B43C 0000               1256          CMP.B   #%000,D2            ; When 0 then .b
00001EBA  6700 0056               1257          BEQ     EA_SIZE_B
00001EBE  B43C 0004               1258          CMP.B   #%100,D2            ; When 4 then .b
00001EC2  6700 004E               1259          BEQ     EA_SIZE_B  
00001EC6  B43C 0001               1260          CMP.B   #%001,D2            ; When 1 then .w
00001ECA  6700 0050               1261          BEQ     EA_SIZE_W
00001ECE  B43C 0005               1262          CMP.B   #%101,D2            ; When 5 then .w
00001ED2  6700 0048               1263          BEQ     EA_SIZE_W 
00001ED6  B43C 0002               1264          CMP.B   #%010,D2            ; When 2 then .l
00001EDA  6700 004C               1265          BEQ     EA_SIZE_L
00001EDE  B43C 0006               1266          CMP.B   #%110,D2            ; When 6 then .l
00001EE2  6700 0044               1267          BEQ     EA_SIZE_L
00001EE6  6000 0F62               1268          BRA     EA_ERROR            ; wrong size
00001EEA                          1269  
00001EEA                          1270  EA_SIZE_ADDA                        ; Check opmode field for size
00001EEA  B43C 0003               1271          CMP.B   #%011,D2            ; When 3 then .w
00001EEE  6700 002C               1272          BEQ     EA_SIZE_W       
00001EF2  B43C 0007               1273          CMP.B   #%111,D2            ; When 7 then .l
00001EF6  6700 0030               1274          BEQ     EA_SIZE_L
00001EFA  6000 0F4E               1275          BRA     EA_ERROR            ; wrong size
00001EFE                          1276                  
00001EFE                          1277  EA_SIZE_MEMORY_SHIFTS
00001EFE  B43C 0000               1278          CMP.B   #%00,D2             ; .w
00001F02  6700 0022               1279          BEQ     EA_SIZE_W_MEMORY      
00001F06  B43C 0001               1280          CMP.B   #%01,D2             ; .l
00001F0A  6700 001C               1281          BEQ     EA_SIZE_L      
00001F0E  6000 0F3A               1282          BRA     EA_ERROR            ; wrong size
00001F12                          1283  
00001F12                          1284  EA_SIZE_B
00001F12  14FC 002E               1285          MOVE.B  #'.',(A2)+
00001F16  14FC 0042               1286          MOVE.B  #'B',(A2)+
00001F1A  4E75                    1287          RTS
00001F1C                          1288  EA_SIZE_W
00001F1C  14FC 002E               1289          MOVE.B  #'.',(A2)+
00001F20  14FC 0057               1290          MOVE.B  #'W',(A2)+
00001F24  4E75                    1291          RTS     
00001F26                          1292  EA_SIZE_W_MEMORY
00001F26  4E75                    1293          RTS        
00001F28                          1294  EA_SIZE_L
00001F28  14FC 002E               1295          MOVE.B  #'.',(A2)+
00001F2C  14FC 004C               1296          MOVE.B  #'L',(A2)+
00001F30  4E75                    1297          RTS
00001F32                          1298  EA_SIZE_DONE
00001F32  4E75                    1299          RTS
00001F34                          1300  *------------------------------------------------------------------------------------------------*     
00001F34                          1301  EA_IMMEDIATE                        ; 0 ea_immediate
00001F34  2200                    1302          MOVE.L  D0,D1
00001F36  0241 01C0               1303          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00001F3A  1A3C 0006               1304          MOVE.B  #right6,D5          ; Store 6 into D5
00001F3E  EA69                    1305          LSR.W   D5,D1               ; Shift D1 six times to LSB position
00001F40  0201 0003               1306          ANDI.B  #3,D1               ; Remove the front bit from D1
00001F44  1401                    1307          MOVE.B  D1,D2               ; Store D1 into D2 (used to check size)
00001F46  4EB8 1E56               1308          JSR     EA_SIZE_GENERAL     ; Get size 
00001F4A                          1309          
00001F4A  14FC 0020               1310          MOVE.B  #$20,(A2)+          ; Add space after size
00001F4E  14FC 0020               1311          MOVE.B  #$20,(A2)+          ; Add space 
00001F52  14FC 0020               1312          MOVE.B  #$20,(A2)+          ; Add space
00001F56                          1313  
00001F56                          1314          ; Get source and store into decode buffer
00001F56  7804                    1315          MOVE.L  #4,D4               ; Store 100 into D4 (jump to immed)
00001F58  7607                    1316          MOVE.L  #7,D3               ; Store 111 into D3 (Go abs and immed)
00001F5A  4EB9 00002CE4           1317          JSR     EA_GEN_SRC          ; Get EA src print 
00001F60                          1318  
00001F60  14FC 002C               1319          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001F64  14FC 0020               1320          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F68                          1321  
00001F68                          1322          ; Get desination and store into decode buffer
00001F68  2800                    1323          MOVE.L  D0,D4               ; Store the current address into D4 
00001F6A  0244 0007               1324          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00001F6E                          1325          
00001F6E  2600                    1326          MOVE.L  D0,D3               ; Store the current address into D3 
00001F70  0243 0038               1327          ANDI.W  #src_mode,D3        ; Get bits 5-3 (D3 stores EA mode)
00001F74  1A3C 0003               1328          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB position
00001F78  EA6B                    1329          LSR.W   D5,D3               ; Do the actual shift 
00001F7A  4EB9 00002DF0           1330          JSR     An_CHECK            ; Check if mode is An
00001F80  4EB9 00002E04           1331          JSR     IMMEDIATE_CHECK     ; Check if mode is Immediate
00001F86  4EB9 00002CE4           1332          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00001F8C  4EF8 1E10               1333          JMP     EA_FINISH           ; Opcode is finish
00001F90                          1334  *------------------------------------------------------------------------------------------------*
00001F90                          1335  EA_MOVE                             ; 1: ea_move
00001F90  2200                    1336          MOVE.L  D0,D1
00001F92  0241 F000               1337          ANDI.W  #first_nibble,D1
00001F96  1A3C 000C               1338          MOVE.B  #right12,D5 
00001F9A  EA69                    1339          LSR.W   D5,D1
00001F9C  0201 0003               1340          ANDI.B  #3,D1
00001FA0  1401                    1341          MOVE.B  D1,D2
00001FA2  4EB8 1E72               1342          JSR     EA_SIZE_MOVE
00001FA6                          1343          
00001FA6  14FC 0020               1344          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001FAA  14FC 0020               1345          MOVE.B  #$20,(A2)+          ; Print out a space
00001FAE  14FC 0020               1346          MOVE.B  #$20,(A2)+          ; Print out a space
00001FB2                          1347          
00001FB2                          1348          ; Get source and store into decode buffer
00001FB2  2800                    1349          MOVE.L  D0,D4               ; Store the src reg in D4
00001FB4  0244 0007               1350          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001FB8                          1351          
00001FB8  2600                    1352          MOVE.L  D0,D3               ; Store the src mode in D3
00001FBA  0243 0038               1353          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001FBE  1A3C 0003               1354          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001FC2  EA6B                    1355          LSR.W   D5,D3               ; Do the actual shift 
00001FC4  4EB9 00002CE4           1356          JSR     EA_GEN_SRC
00001FCA                          1357          
00001FCA  14FC 002C               1358          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001FCE  14FC 0020               1359          MOVE.B  #$20,(A2)+          ; Add space after comma
00001FD2                          1360          
00001FD2                          1361          ; Get desination and store into decode buffer
00001FD2  2800                    1362          MOVE.L  D0,D4               ; Store the dest reg in D4
00001FD4  0244 0E00               1363          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001FD8  1A3C 0009               1364          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001FDC  EA6C                    1365          LSR.W   D5,D4               ; Do the actual shift
00001FDE                          1366          
00001FDE  2600                    1367          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001FE0  0243 01C0               1368          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001FE4  1A3C 0006               1369          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001FE8  EA6B                    1370          LSR.W   D5,D3               ; Do the actual shift 
00001FEA  4EB9 00002DF0           1371          JSR     An_CHECK            ; Check if dest mode is 001: An
00001FF0  4EB9 00002E04           1372          JSR     IMMEDIATE_CHECK     ; Check if immediate 
00001FF6  4EB9 00002CE4           1373          JSR     EA_GEN_SRC          ; Get EA print        
00001FFC  4EF8 1E10               1374          JMP     EA_FINISH           ; Opcode is finish
00002000                          1375  *------------------------------------------------------------------------------------------------*          
00002000                          1376  EA_MOVEA                            ; 2: ea_movea
00002000  2200                    1377          MOVE.L  D0,D1
00002002  0241 F000               1378          ANDI.W  #first_nibble,D1
00002006  1A3C 000C               1379          MOVE.B  #right12,D5 
0000200A  EA69                    1380          LSR.W   D5,D1
0000200C  0201 0003               1381          ANDI.B  #3,D1
00002010  1401                    1382          MOVE.B  D1,D2
00002012  4EB8 1E8E               1383          JSR     EA_SIZE_MOVEA 
00002016                          1384          
00002016  14FC 0020               1385          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000201A  14FC 0020               1386          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000201E                          1387          
0000201E                          1388          ; Get source and store into decode buffer
0000201E  2800                    1389          MOVE.L  D0,D4               ; Store the src reg in D4
00002020  0244 0007               1390          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002024                          1391          
00002024  2600                    1392          MOVE.L  D0,D3               ; Store the src mode in D3
00002026  0243 0038               1393          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000202A  1A3C 0003               1394          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000202E  EA6B                    1395          LSR.W   D5,D3               ; Do the actual shift 
00002030  4EB9 00002CE4           1396          JSR     EA_GEN_SRC
00002036                          1397          
00002036  14FC 002C               1398          MOVE.B  #$2C,(A2)+          ; Add comma after size print
0000203A  14FC 0020               1399          MOVE.B  #$20,(A2)+          ; Add space after comma
0000203E                          1400          
0000203E                          1401          ; Get desination and store into decode buffer
0000203E  2800                    1402          MOVE.L  D0,D4               ; Store the dest reg in D4
00002040  0244 0E00               1403          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002044  1A3C 0009               1404          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002048  EA6C                    1405          LSR.W   D5,D4               ; Do the actual shift
0000204A                          1406          
0000204A  2600                    1407          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
0000204C  0243 01C0               1408          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00002050  1A3C 0006               1409          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00002054  EA6B                    1410          LSR.W   D5,D3               ; Do the actual shift 
00002056  B63C 0001               1411          CMP.B   #1,D3               ; If dst mode is 001: An 
0000205A  6700 0006               1412          BEQ     MOVEA_DST_VALID     ; dst is valid, so branch 
0000205E  6000 0DEA               1413          BRA     EA_ERROR            ; Otherwise, go to invalid message 
00002062                          1414          
00002062                          1415  MOVEA_DST_VALID
00002062  4EB9 00002CE4           1416          JSR     EA_GEN_SRC          ; Get EA print
00002068  4EF8 1E10               1417          JMP     EA_FINISH           ; Opcode is finish
0000206C                          1418  *------------------------------------------------------------------------------------------------*
0000206C                          1419  EA_LEA                              ; 3: ea_lea
0000206C  14FC 0020               1420          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002070  14FC 0020               1421          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002074  14FC 0020               1422          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002078  14FC 0020               1423          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000207C  14FC 0020               1424          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002080  14FC 0020               1425          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002084                          1426  
00002084  2800                    1427          MOVE.L  D0,D4               ; Store the src reg in D4
00002086  0244 0007               1428          ANDI.W  #src_reg,D4         ; get the bits at 2-0
0000208A                          1429          
0000208A  2600                    1430          MOVE.L  D0,D3               ; Store the src mode in D3
0000208C  0243 0038               1431          ANDI.W  #src_mode,D3        ; get bits 5-3
00002090  1A3C 0003               1432          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB
00002094  EA6B                    1433          LSR.W   D5,D3               ; do the actual shift 
00002096  B67C 0002               1434          CMP     #2,D3               ; If D3 (src mode) is 010 (An)
0000209A  6700 000E               1435          BEQ     LEA_SRC_VALID
0000209E  B67C 0007               1436          CMP     #7,D3               ; If D3 (src mode) is 111 (W or L)
000020A2  6700 0006               1437          BEQ     LEA_SRC_VALID
000020A6  6000 0DA2               1438          BRA     EA_ERROR            ; when src mode is not 010 or 111, branch to error message
000020AA                          1439          
000020AA                          1440  LEA_SRC_VALID
000020AA  4EB9 00002E04           1441          JSR     IMMEDIATE_CHECK     ; Check if src is immediate        
000020B0  4EB9 00002CE4           1442          JSR     EA_GEN_SRC          ; Go to function 
000020B6                          1443   
000020B6  14FC 002C               1444          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000020BA  14FC 0020               1445          MOVE.B  #$20,(A2)+          ; Add space after comma
000020BE                          1446  
000020BE  2600                    1447          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
000020C0  0243 01C0               1448          ANDI.W  #dst_mode,D3        ; Get bits 8-6
000020C4  1A3C 0006               1449          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
000020C8  EA6B                    1450          LSR.W   D5,D3               ; Do the actual shift
000020CA  B63C 0007               1451          CMP.B   #7,D3               ; Check if D3 is 111
000020CE  6700 0006               1452          BEQ     CHANGE_TO_001       ; change the D3 bits to 001 
000020D2  6000 0D76               1453          BRA     EA_ERROR            ; Print out an error message if bits 8-6 (dst mode) are not 111
000020D6                          1454    
000020D6                          1455  CHANGE_TO_001
000020D6  163C 0001               1456          MOVE.B  #%001,D3            ; set D3 to 001 to ensure the print out A 
000020DA                          1457          
000020DA  2800                    1458          MOVE.L  D0,D4               ; Store the dest reg in D4 to get the Address register number
000020DC  0244 0E00               1459          ANDI.W  #dst_reg,D4         ; get the bits at 11-9
000020E0  1A3C 0009               1460          MOVE.B  #right9,D5          ; shift the bits 11-9 to the LSB
000020E4  EA6C                    1461          LSR.W   D5,D4               ; do the actual shift
000020E6  4EB9 00002CE4           1462          JSR     EA_GEN_SRC          ; Print out the address register
000020EC  4EF8 1E10               1463          JMP     EA_FINISH           ; Opcode is finish
000020F0                          1464  *------------------------------------------------------------------------------------------------*
000020F0                          1465  EA_DSTONLY                          ; 4: ea_dstonly
000020F0  2200                    1466          MOVE.L  D0,D1
000020F2  0241 0F00               1467          ANDI.W  #second_nibble,D1   ; get second nibble from D1
000020F6  1A3C 0008               1468          MOVE.B  #right8,D5 
000020FA  EA69                    1469          LSR.W   D5,D1     
000020FC  B23C 0002               1470          CMP.B   #2, D1              ; When 0010 for second nibble
00002100  6700 000E               1471          BEQ     EA_CLEAR            ; Then do EA_CLEAR
00002104  B23C 000E               1472          CMP.B   #$E, D1             ; When 1110 for second nibble
00002108  6700 0054               1473          BEQ     EA_JSR              ; Then do EA_JSR
0000210C  6000 0D3C               1474          BRA     EA_ERROR     
00002110                          1475          
00002110                          1476  EA_CLEAR
00002110  2200                    1477          MOVE.L  D0,D1
00002112  0241 01C0               1478          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00002116  1A3C 0006               1479          MOVE.B  #right6,D5          ; Store 6 into D5
0000211A  EA69                    1480          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
0000211C  0201 0003               1481          ANDI.B  #3,D1               ; Remove the front bit from D1
00002120  1401                    1482          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002122  4EB8 1E56               1483          JSR     EA_SIZE_GENERAL     ; Get size 
00002126                          1484          
00002126  14FC 0020               1485          MOVE.B  #$20,(A2)+          ; Add space after size
0000212A  14FC 0020               1486          MOVE.B  #$20,(A2)+          ; Add space 
0000212E  14FC 0020               1487          MOVE.B  #$20,(A2)+          ; Add space 
00002132  14FC 0020               1488          MOVE.B  #$20,(A2)+          ; Add space
00002136                          1489          
00002136                          1490          ; Get desination and store into decode buffer
00002136  2800                    1491          MOVE.L  D0,D4               ; Store the current address into D4 
00002138  0244 0007               1492          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
0000213C                          1493          
0000213C  2600                    1494          MOVE.L  D0,D3               ; Store the current address into D3 
0000213E  0243 0038               1495          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002142  1A3C 0003               1496          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002146  EA6B                    1497          LSR.W   D5,D3               ; do the actual shift 
00002148  4EB9 00002DF0           1498          JSR     An_CHECK            ; Check if dest mode is 001: An
0000214E  4EB9 00002E04           1499          JSR     IMMEDIATE_CHECK     ; Check if immediate
00002154  4EB9 00002CE4           1500          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
0000215A  4EF8 1E10               1501          JMP     EA_FINISH           ; Opcode is finish
0000215E                          1502          
0000215E  14FC 0020               1503  EA_JSR  MOVE.B  #$20,(A2)+          ; Add space 
00002162  14FC 0020               1504          MOVE.B  #$20,(A2)+          ; Add space 
00002166  14FC 0020               1505          MOVE.B  #$20,(A2)+          ; Add space 
0000216A  14FC 0020               1506          MOVE.B  #$20,(A2)+          ; Add space 
0000216E  14FC 0020               1507          MOVE.B  #$20,(A2)+          ; Add space 
00002172  14FC 0020               1508          MOVE.B  #$20,(A2)+          ; Add space
00002176                          1509  
00002176                          1510          ; Get EA and store into decode buffer   
00002176  2800                    1511          MOVE.L  D0,D4               ; Store the current address into D4 
00002178  0244 0007               1512          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
0000217C                          1513          
0000217C  2600                    1514          MOVE.L  D0,D3               ; Store the current address into D3 
0000217E  0243 0038               1515          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002182  1A3C 0003               1516          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002186  EA6B                    1517          LSR.W   D5,D3               ; do the actual shift 
00002188  B67C 0002               1518          CMP     #2,D3               ; If D3 (src mode) is 010: (An)
0000218C  6700 000E               1519          BEQ     JSR_An_VALID
00002190  B67C 0007               1520          CMP     #7,D3               ; If D3 (src mode) is 111: (W or L)
00002194  6700 0010               1521          BEQ     JSR_ABSOLUTE_CHECK
00002198  6000 0CB0               1522          BRA     EA_ERROR            ; Otherwise, branch to invalid message
0000219C                          1523          
0000219C                          1524  JSR_An_VALID
0000219C  4EB9 00002CE4           1525          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
000021A2  4EF8 1E10               1526          JMP     EA_FINISH           ; Opcode is finish
000021A6                          1527          
000021A6                          1528  JSR_ABSOLUTE_CHECK
000021A6  4EB9 00002E04           1529          JSR     IMMEDIATE_CHECK     ; Check if immediate
000021AC  4EB9 00002CE4           1530          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
000021B2  4EF8 1E10               1531          JMP     EA_FINISH           ; Opcode is finish
000021B6                          1532  *------------------------------------------------------------------------------------------------*
000021B6                          1533  EA_EXT                              ; 5: ea_ext
000021B6  2200                    1534          MOVE.L  D0,D1
000021B8  0241 01C0               1535          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1 (get opmode)
000021BC  1A3C 0006               1536          MOVE.B  #right6,D5          ; Store 6 into D5
000021C0  EA69                    1537          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
000021C2  1401                    1538          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
000021C4  C2FC 0006               1539          MULU    #6, D1              ; Multiply 6 to D1 
000021C8  41F9 000021D2           1540          LEA     EA_EXT_TABLE,A0     ; Load table into A0
000021CE  4EF0 1000               1541          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000021D2                          1542  
000021D2                          1543  EA_EXT_TABLE
000021D2  4EF9 00002202           1544          JMP     EA_OPMODE_012456    ; 000: ADD/SUB/CMP/OR/AND
000021D8  4EF9 00002202           1545          JMP     EA_OPMODE_012456    ; 001: ADD/SUB/CMP/OR/AND
000021DE  4EF9 00002202           1546          JMP     EA_OPMODE_012456    ; 010: ADD/SUB/CMP/OR/AND
000021E4  4EF9 000022F6           1547          JMP     EA_OPMODE_37        ; 011: ADDA/MULS/MULU/DIVU
000021EA  4EF9 00002202           1548          JMP     EA_OPMODE_012456    ; 100: ADD/SUB/CMP/OR/AND
000021F0  4EF9 00002202           1549          JMP     EA_OPMODE_012456    ; 101: ADD/SUB/CMP/OR/AND
000021F6  4EF9 00002202           1550          JMP     EA_OPMODE_012456    ; 110: ADD/SUB/CMP/OR/AND
000021FC  4EF9 000022F6           1551          JMP     EA_OPMODE_37        ; 111: ADDA/MULS/MULU/DIVU
00002202                          1552  
00002202                          1553  EA_OPMODE_012456
00002202  4EB8 1EB6               1554          JSR     EA_SIZE_OPMODE_012456    
00002206                          1555          
00002206  14FC 0020               1556          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000220A  14FC 0020               1557          MOVE.B  #$20,(A2)+          ; Print out a space 
0000220E  14FC 0020               1558          MOVE.B  #$20,(A2)+          ; Print out a space
00002212  14FC 0020               1559          MOVE.B  #$20,(A2)+          ; Add space
00002216                          1560          
00002216                          1561          ; Operation: <ea> + Dn -> Dn
00002216  B43C 0000               1562          CMP.B   #%000,D2            ; When 0 then Dn is destination
0000221A  6700 002E               1563          BEQ     Dn_DST
0000221E  B43C 0001               1564          CMP.B   #%001,D2            ; When 1 then Dn is destination
00002222  6700 0026               1565          BEQ     Dn_DST
00002226  B43C 0002               1566          CMP.B   #%010,D2            ; When 2 then Dn is destination
0000222A  6700 001E               1567          BEQ     Dn_DST
0000222E                          1568          
0000222E                          1569          ; Operation: Dn + <ea> -> <ea>
0000222E  B43C 0004               1570          CMP.B   #%100,D2            ; When 4 then Dn is source
00002232  6700 0054               1571          BEQ     Dn_SRC  
00002236  B43C 0005               1572          CMP.B   #%101,D2            ; When 5 then Dn is source
0000223A  6700 004C               1573          BEQ     Dn_SRC 
0000223E  B43C 0006               1574          CMP.B   #%110,D2            ; When 6 then Dn is source
00002242  6700 0044               1575          BEQ     Dn_SRC 
00002246                          1576          
00002246  6000 0C02               1577          BRA     EA_ERROR
0000224A                          1578  
0000224A                          1579  Dn_DST
0000224A                          1580          ; Get source and store into decode buffer
0000224A  2800                    1581          MOVE.L  D0,D4               ; Store the src reg in D4
0000224C  0244 0007               1582          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002250                          1583          
00002250  2600                    1584          MOVE.L  D0,D3               ; Store the src mode in D3
00002252  0243 0038               1585          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002256  1A3C 0003               1586          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000225A  EA6B                    1587          LSR.W   D5,D3               ; Do the actual shift 
0000225C  4EB9 000022D4           1588          JSR     AND_OR_CHECK 
00002262  4EB9 00002CE4           1589          JSR     EA_GEN_SRC          ; Get EA print
00002268                          1590          
00002268  14FC 002C               1591          MOVE.B  #$2C,(A2)+          ; Add comma after size print
0000226C  14FC 0020               1592          MOVE.B  #$20,(A2)+          ; Add space after comma
00002270                          1593          
00002270                          1594          ; Get desination and store into decode buffer
00002270  2800                    1595          MOVE.L  D0,D4               ; Store the dest reg in D4
00002272  0244 0E00               1596          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002276  1A3C 0009               1597          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000227A  EA6C                    1598          LSR.W   D5,D4               ; Do the actual shift
0000227C                          1599          
0000227C  7600                    1600          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000227E  4EB9 00002CE4           1601          JSR     EA_GEN_SRC          ; Get the Dn print
00002284  4EF8 1E10               1602          JMP     EA_FINISH           ; Opcode is finish
00002288                          1603            
00002288                          1604  Dn_SRC  
00002288  BC3C 000B               1605          CMP.B   #11,D6              ; If first nibble is 1011 (indicates CMP opcode)
0000228C  6700 0BBC               1606          BEQ     EA_ERROR            ; Then branch to error message
00002290                          1607       
00002290                          1608          ; Get source and store into decode buffer
00002290  2800                    1609          MOVE.L  D0,D4               ; Store the src reg in D4
00002292  0244 0E00               1610          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002296  1A3C 0009               1611          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000229A  EA6C                    1612          LSR.W   D5,D4               ; Do the actual shift
0000229C                          1613          
0000229C  7600                    1614          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000229E  4EB9 00002CE4           1615          JSR     EA_GEN_SRC          ; Get the Dn print
000022A4                          1616          
000022A4  14FC 002C               1617          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000022A8  14FC 0020               1618          MOVE.B  #$20,(A2)+          ; Add space after comma
000022AC                          1619  
000022AC                          1620          ; Get destination and store into decode buffer
000022AC  2800                    1621          MOVE.L  D0,D4               ; Store the dst reg in D4
000022AE  0244 0007               1622          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000022B2                          1623          
000022B2  2600                    1624          MOVE.L  D0,D3               ; Store the dest mode in D3
000022B4  0243 0038               1625          ANDI.W  #src_mode,D3        ; Get bits 5-3
000022B8  1A3C 0003               1626          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000022BC  EA6B                    1627          LSR.W   D5,D3               ; Do the actual shift
000022BE  4EB9 00002DF0           1628          JSR     An_CHECK            ; Check if mode is An
000022C4  4EB9 00002E04           1629          JSR     IMMEDIATE_CHECK     ; Check if mode is immediate
000022CA                          1630          ; JSR     Dn_CHECK          ; Check if mode is Dn
000022CA                          1631         
000022CA  4EB9 00002CE4           1632          JSR     EA_GEN_SRC          ; Get EA print
000022D0  4EF8 1E10               1633          JMP     EA_FINISH           ; Opcode is finish
000022D4                          1634  
000022D4                          1635  AND_OR_CHECK
000022D4  BC3C 000C               1636          CMP.B   #12,D6              ; If first nibble is 1100 (indicates AND opcode)
000022D8  6700 000C               1637          BEQ     EA_AND              
000022DC  BC3C 0008               1638          CMP.B   #8,D6               ; If first nibble is 1000 (indicates OR opcode)
000022E0  6700 000A               1639          BEQ     EA_OR 
000022E4  4E75                    1640          RTS
000022E6                          1641  EA_AND
000022E6  4EF9 00002DF0           1642          JMP     An_CHECK            ; Go check if mode is An 
000022EC                          1643      
000022EC                          1644  EA_OR
000022EC  14FC 0020               1645          MOVE.B  #$20,(A2)+          ; Add space
000022F0  4EF9 00002DF0           1646          JMP     An_CHECK            ; Check if mode is An
000022F6                          1647          
000022F6                          1648  EA_OPMODE_37
000022F6  BC3C 0008               1649          CMP.B   #8,D6               ; If first nibble 1000: DIVU
000022FA  6700 0012               1650          BEQ     EA_MULS_MULU_DIV
000022FE  BC3C 000C               1651          CMP.B   #12,D6              ; If first nibble 1100: MULS/MULU
00002302  6700 000A               1652          BEQ     EA_MULS_MULU_DIV
00002306  BC3C 000D               1653          CMP.B   #13,D6              ; If first nibble 1101: ADDA
0000230A  6700 0058               1654          BEQ     EA_ADDA                
0000230E                          1655  
0000230E                          1656  EA_MULS_MULU_DIV
0000230E  143C 0001               1657          MOVE.B  #1,D2               ; Set D2 to 1, since we know size is word   
00002312                          1658  
00002312  14FC 0020               1659          MOVE.B  #$20,(A2)+          ; Print out a space
00002316  14FC 0020               1660          MOVE.B  #$20,(A2)+          ; Print out a space
0000231A  14FC 0020               1661          MOVE.B  #$20,(A2)+          ; Print out a space
0000231E  14FC 0020               1662          MOVE.B  #$20,(A2)+          ; Add space
00002322  14FC 0020               1663          MOVE.B  #$20,(A2)+          ; Add space
00002326                          1664  
00002326                          1665          ; Get source and store into decode buffer
00002326  2800                    1666          MOVE.L  D0,D4               ; Store the src reg in D4
00002328  0244 0007               1667          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000232C                          1668          
0000232C  2600                    1669          MOVE.L  D0,D3               ; Store the src mode in D3
0000232E  0243 0038               1670          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002332  1A3C 0003               1671          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002336  EA6B                    1672          LSR.W   D5,D3               ; Do the actual shift
00002338  4EB9 00002DF0           1673          JSR     An_CHECK            ; Check if mode is An 
0000233E  4EB9 00002CE4           1674          JSR     EA_GEN_SRC          ; Go get EA print
00002344                          1675          
00002344  14FC 002C               1676          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002348  14FC 0020               1677          MOVE.B  #$20,(A2)+          ; Add space after comma
0000234C                          1678          
0000234C                          1679          ; Get desination and store into decode buffer
0000234C  2800                    1680          MOVE.L  D0,D4               ; Store the dest reg in D4
0000234E  0244 0E00               1681          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002352  1A3C 0009               1682          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002356  EA6C                    1683          LSR.W   D5,D4               ; Do the actual shift
00002358                          1684          
00002358  7600                    1685          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000235A  4EB9 00002CE4           1686          JSR     EA_GEN_SRC          ; Go get EA print
00002360  4EF8 1E10               1687          JMP     EA_FINISH           ; Opcode is finish
00002364                          1688  
00002364                          1689  EA_ADDA
00002364  4EB8 1EEA               1690          JSR     EA_SIZE_ADDA        ; Get size    
00002368                          1691  
00002368  14FC 0020               1692          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000236C  14FC 0020               1693          MOVE.B  #$20,(A2)+          ; Print out a space
00002370  14FC 0020               1694          MOVE.B  #$20,(A2)+          ; Add space        
00002374                          1695          
00002374                          1696          
00002374                          1697          ; Get source and store into decode buffer
00002374  2800                    1698          MOVE.L  D0,D4               ; Store the src reg in D4
00002376  0244 0007               1699          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000237A                          1700          
0000237A  2600                    1701          MOVE.L  D0,D3               ; Store the src mode in D3
0000237C  0243 0038               1702          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002380  1A3C 0003               1703          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002384  EA6B                    1704          LSR.W   D5,D3               ; Do the actual shift 
00002386  4EB9 00002CE4           1705          JSR     EA_GEN_SRC
0000238C                          1706          
0000238C  14FC 002C               1707          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002390  14FC 0020               1708          MOVE.B  #$20,(A2)+          ; Add space after comma
00002394                          1709          
00002394                          1710          ; Get desination and store into decode buffer
00002394  2800                    1711          MOVE.L  D0,D4               ; Store the dest reg in D4
00002396  0244 0E00               1712          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000239A  1A3C 0009               1713          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000239E  EA6C                    1714          LSR.W   D5,D4               ; Do the actual shift
000023A0                          1715          
000023A0  7601                    1716          MOVE.L  #1,D3               ; Store 001 into D3, so it can jump to An 
000023A2  4EB9 00002CE4           1717          JSR     EA_GEN_SRC          ; Go get EA print
000023A8  4EF8 1E10               1718          JMP     EA_FINISH           ; Opcode is finish
000023AC                          1719  *------------------------------------------------------------------------------------------------*
000023AC                          1720  EA_MOVEM        ; 6: ea_movem
000023AC  2200                    1721          MOVE.L  D0, D1
000023AE  0241 00F0               1722          ANDI.W  #third_nibble,D1
000023B2  1A3C 0004               1723          MOVE.B  #right4,D5 
000023B6  EA69                    1724          LSR.W   D5,D1
000023B8  0201 0004               1725          ANDI.B  #4,D1
000023BC  1401                    1726          MOVE.B  D1,D2
000023BE  4EB8 1EA2               1727          JSR     EA_SIZE_MOVEM       ; get the size of the MOVEM as .W or .L 
000023C2                          1728  
000023C2  14FC 0020               1729          MOVE.B  #$20,(A2)+          ; Print out a space after the size
000023C6  14FC 0020               1730          MOVE.B  #$20,(A2)+          ; Print out a space
000023CA                          1731          
000023CA                          1732  *-----------------------------------------------------------------------------------*
000023CA                          1733  * HANDLE the case where src mode is 010. 
000023CA  2600                    1734          MOVE.L  D0,D3               ; Store the src mode in D3
000023CC  0243 0038               1735          ANDI.W  #src_mode,D3        ; Get bits 5-3
000023D0  1A3C 0003               1736          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000023D4  EA6B                    1737          LSR.W   D5,D3 
000023D6  B63C 0000               1738          CMP.B   #0, D3
000023DA  6700 0A6E               1739          BEQ     EA_ERROR
000023DE  B63C 0002               1740          CMP.B   #2, D3
000023E2  6700 0312               1741          BEQ     MEM_TO_REG 
000023E6                          1742                 
000023E6                          1743  *-----------------------------------------------------------------------------------*
000023E6                          1744  
000023E6  2200                    1745          MOVE.L  D0, D1
000023E8  0241 0F00               1746          ANDI.W  #second_nibble,D1
000023EC  1A3C 0008               1747          MOVE.B  #right8,D5 
000023F0  EA69                    1748          LSR.W   D5,D1
000023F2  0201 0006               1749          ANDI.B  #6, D1              ; Get the Dr field
000023F6                          1750          
000023F6  B23C 0000               1751          CMP.B   #0, D1              ; check if Dr field is 0. 
000023FA  6700 000A               1752          BEQ     REG_TO_MEM
000023FE                          1753  
000023FE  B23C 0004               1754          CMP.B   #4, D1              ; check if Dr field is 1. 
00002402  6700 02F2               1755          BEQ     MEM_TO_REG
00002406                          1756  
00002406                          1757  REG_TO_MEM                          ; pre-decrement - D7-D0,A7-A0
00002406  3C15                    1758          MOVE.W  (A5), D6            ; store the register list mask field for REG to MEM
00002408                          1759          
00002408                          1760  * Print out the proper data and address registers. 
00002408                          1761  * FIRST NIBBLE CHECK D0 - D3
00002408                          1762  *-----------------------------------------------------------------------------------*
00002408                          1763  * Print out D0 if mask field states to. 
00002408                          1764  
00002408  3606                    1765          MOVE.W  D6, D3
0000240A  0243 F000               1766          ANDI.W  #first_nibble,D3
0000240E  1A3C 000C               1767          MOVE.B  #right12,D5 
00002412  EA6B                    1768          LSR.W   D5,D3
00002414  0203 0008               1769          ANDI.B  #8,D3
00002418  B63C 0008               1770          CMP.B   #8,D3
0000241C  6700 0006               1771          BEQ     D4_Dn_SETONE_0      ; SETONE refers to the set for reg to mem branch. 
00002420  6000 0014               1772          BRA     CHECK1_BIT_14
00002424                          1773  D4_Dn_SETONE_0
00002424  183C 0000               1774          MOVE.B  #$0, D4
00002428                          1775          
00002428  6000 0002               1776          BRA     PRINT1_D0
0000242C                          1777          
0000242C                          1778  PRINT1_D0
0000242C  4EB9 00002D22           1779          JSR     EA_Dn
00002432  14FC 002F               1780          MOVE.B  #$2F,(A2)+
00002436                          1781          
00002436                          1782  *-----------------------------------------------------------------------------------*
00002436                          1783  * Print out D1 if mask field states to. 
00002436                          1784  
00002436                          1785  CHECK1_BIT_14
00002436  3606                    1786          MOVE.W  D6, D3
00002438  0243 F000               1787          ANDI.W  #first_nibble,D3
0000243C  1A3C 000C               1788          MOVE.B  #right12,D5 
00002440  EA6B                    1789          LSR.W   D5,D3
00002442  0203 0004               1790          ANDI.B  #4,D3
00002446  B63C 0004               1791          CMP.B   #4,D3
0000244A  6700 0006               1792          BEQ     D4_Dn_SETONE_1      ; SETONE refers to the set for reg to mem branch. 
0000244E  6000 0014               1793          BRA     CHECK1_BIT_13
00002452                          1794  D4_Dn_SETONE_1
00002452  183C 0001               1795          MOVE.B  #$1, D4
00002456                          1796          
00002456  6000 0002               1797          BRA     PRINT1_D1
0000245A                          1798          
0000245A                          1799  PRINT1_D1
0000245A  4EB9 00002D22           1800          JSR     EA_Dn
00002460  14FC 002F               1801          MOVE.B  #$2F,(A2)+
00002464                          1802  
00002464                          1803  *-----------------------------------------------------------------------------------*
00002464                          1804  * Print out D2 if mask field states to. 
00002464                          1805  
00002464                          1806  CHECK1_BIT_13
00002464  3606                    1807          MOVE.W  D6, D3
00002466  0243 F000               1808          ANDI.W  #first_nibble,D3
0000246A  1A3C 000C               1809          MOVE.B  #right12,D5 
0000246E  EA6B                    1810          LSR.W   D5,D3
00002470  0203 0002               1811          ANDI.B  #2,D3
00002474  B63C 0002               1812          CMP.B   #2,D3
00002478  6700 0006               1813          BEQ     D4_Dn_SETONE_2      ; SETONE refers to the set for reg to mem branch. 
0000247C  6000 0014               1814          BRA     CHECK1_BIT_12
00002480                          1815  D4_Dn_SETONE_2
00002480  183C 0002               1816          MOVE.B  #$2, D4
00002484                          1817          
00002484  6000 0002               1818          BRA     PRINT1_D2
00002488                          1819          
00002488                          1820  PRINT1_D2
00002488  4EB9 00002D22           1821          JSR     EA_Dn
0000248E  14FC 002F               1822          MOVE.B  #$2F,(A2)+       
00002492                          1823  
00002492                          1824  *-----------------------------------------------------------------------------------*
00002492                          1825  * Print out D3 if mask field states to. 
00002492                          1826  
00002492                          1827  CHECK1_BIT_12
00002492  3606                    1828          MOVE.W  D6, D3
00002494  0243 F000               1829          ANDI.W  #first_nibble,D3
00002498  1A3C 000C               1830          MOVE.B  #right12,D5 
0000249C  EA6B                    1831          LSR.W   D5,D3
0000249E  0203 0001               1832          ANDI.B  #1,D3
000024A2  B63C 0001               1833          CMP.B   #1,D3
000024A6  6700 0006               1834          BEQ     D4_Dn_SETONE_3      ; SETONE refers to the set for reg to mem branch. 
000024AA  6000 0014               1835          BRA     CHECK1_BIT_11
000024AE                          1836  D4_Dn_SETONE_3
000024AE  183C 0003               1837          MOVE.B  #$3, D4
000024B2                          1838          
000024B2  6000 0002               1839          BRA     PRINT1_D3
000024B6                          1840          
000024B6                          1841  PRINT1_D3
000024B6  4EB9 00002D22           1842          JSR     EA_Dn
000024BC  14FC 002F               1843          MOVE.B  #$2F,(A2)+ 
000024C0                          1844          
000024C0                          1845  * SECOND NIBBLE CHECK D4 - D7
000024C0                          1846  *-----------------------------------------------------------------------------------*
000024C0                          1847  * Print out D4 if mask field states to. 
000024C0                          1848  
000024C0                          1849  
000024C0                          1850  CHECK1_BIT_11
000024C0  3606                    1851          MOVE.W  D6, D3
000024C2  0243 0F00               1852          ANDI.W  #second_nibble,D3
000024C6  1A3C 0008               1853          MOVE.B  #right8,D5 
000024CA  EA6B                    1854          LSR.W   D5,D3
000024CC  0203 0008               1855          ANDI.B  #8,D3
000024D0  B63C 0008               1856          CMP.B   #8,D3
000024D4  6700 0006               1857          BEQ     D4_Dn_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
000024D8  6000 0014               1858          BRA     CHECK1_BIT_10
000024DC                          1859  D4_Dn_SETONE_4
000024DC  183C 0004               1860          MOVE.B  #$4, D4
000024E0                          1861          
000024E0  6000 0002               1862          BRA     PRINT1_D4
000024E4                          1863          
000024E4                          1864  PRINT1_D4
000024E4  4EB9 00002D22           1865          JSR     EA_Dn
000024EA  14FC 002F               1866          MOVE.B  #$2F,(A2)+ 
000024EE                          1867  
000024EE                          1868  *-----------------------------------------------------------------------------------*
000024EE                          1869  * Print out D5 if mask field states to. 
000024EE                          1870  
000024EE                          1871  CHECK1_BIT_10
000024EE  3606                    1872          MOVE.W  D6, D3
000024F0  0243 0F00               1873          ANDI.W  #second_nibble,D3
000024F4  1A3C 0008               1874          MOVE.B  #right8,D5 
000024F8  EA6B                    1875          LSR.W   D5,D3
000024FA  0203 0004               1876          ANDI.B  #4,D3
000024FE  B63C 0004               1877          CMP.B   #4,D3
00002502  6700 0006               1878          BEQ     D4_Dn_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
00002506  6000 0014               1879          BRA     CHECK1_BIT_9
0000250A                          1880  D4_Dn_SETONE_5
0000250A  183C 0005               1881          MOVE.B  #$5, D4
0000250E                          1882          
0000250E  6000 0002               1883          BRA     PRINT1_D5
00002512                          1884          
00002512                          1885  PRINT1_D5
00002512  4EB9 00002D22           1886          JSR     EA_Dn
00002518  14FC 002F               1887          MOVE.B  #$2F,(A2)+ 
0000251C                          1888  
0000251C                          1889  *-----------------------------------------------------------------------------------*
0000251C                          1890  * Print out D6 if mask field states to. 
0000251C                          1891  
0000251C                          1892  CHECK1_BIT_9
0000251C  3606                    1893          MOVE.W  D6, D3
0000251E  0243 0F00               1894          ANDI.W  #second_nibble,D3
00002522  1A3C 0008               1895          MOVE.B  #right8,D5 
00002526  EA6B                    1896          LSR.W   D5,D3
00002528  0203 0002               1897          ANDI.B  #2,D3
0000252C  B63C 0002               1898          CMP.B   #2,D3
00002530  6700 0006               1899          BEQ     D4_Dn_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
00002534  6000 0014               1900          BRA     CHECK1_BIT_8
00002538                          1901  D4_Dn_SETONE_6
00002538  183C 0006               1902          MOVE.B  #$6, D4
0000253C                          1903          
0000253C  6000 0002               1904          BRA     PRINT1_D6
00002540                          1905          
00002540                          1906  PRINT1_D6
00002540  4EB9 00002D22           1907          JSR     EA_Dn
00002546  14FC 002F               1908          MOVE.B  #$2F,(A2)+ 
0000254A                          1909          
0000254A                          1910  *-----------------------------------------------------------------------------------*
0000254A                          1911  * Print out D7 if mask field states to. 
0000254A                          1912  
0000254A                          1913  CHECK1_BIT_8
0000254A  3606                    1914          MOVE.W  D6, D3
0000254C  0243 0F00               1915          ANDI.W  #second_nibble,D3
00002550  1A3C 0008               1916          MOVE.B  #right8,D5 
00002554  EA6B                    1917          LSR.W   D5,D3
00002556  0203 0001               1918          ANDI.B  #1,D3
0000255A  B63C 0001               1919          CMP.B   #1,D3
0000255E  6700 0006               1920          BEQ     D4_Dn_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
00002562  6000 0014               1921          BRA     CHECK1_BIT_7
00002566                          1922  D4_Dn_SETONE_7
00002566  183C 0007               1923          MOVE.B  #$7, D4
0000256A                          1924          
0000256A  6000 0002               1925          BRA     PRINT1_D7
0000256E                          1926          
0000256E                          1927  PRINT1_D7
0000256E  4EB9 00002D22           1928          JSR     EA_Dn
00002574  14FC 002F               1929          MOVE.B  #$2F,(A2)+ 
00002578                          1930  
00002578                          1931  * THIRD NIBBLE CHECK - A0 / A3
00002578                          1932  *-----------------------------------------------------------------------------------*
00002578                          1933  * Print out A0 if mask field states to. 
00002578                          1934  
00002578                          1935  CHECK1_BIT_7
00002578  3606                    1936          MOVE.W  D6, D3
0000257A  0243 00F0               1937          ANDI.W  #third_nibble,D3
0000257E  1A3C 0004               1938          MOVE.B  #right4,D5 
00002582  EA6B                    1939          LSR.W   D5,D3
00002584  0203 0008               1940          ANDI.B  #8,D3
00002588  B63C 0008               1941          CMP.B   #8,D3
0000258C  6700 0006               1942          BEQ     D4_An_SETONE_0       ; SETONE refers to the set for reg to mem branch. 
00002590  6000 0014               1943          BRA     CHECK1_BIT_6
00002594                          1944  D4_An_SETONE_0
00002594  183C 0000               1945          MOVE.B  #$0, D4
00002598                          1946          
00002598  6000 0002               1947          BRA     PRINT1_A0
0000259C                          1948          
0000259C                          1949  PRINT1_A0
0000259C  4EB9 00002D2E           1950          JSR     EA_An
000025A2  14FC 002F               1951          MOVE.B  #$2F,(A2)+ 
000025A6                          1952          
000025A6                          1953  *-----------------------------------------------------------------------------------*
000025A6                          1954  * Print out A1 if mask field states to. 
000025A6                          1955  
000025A6                          1956  CHECK1_BIT_6
000025A6  3606                    1957          MOVE.W  D6, D3
000025A8  0243 00F0               1958          ANDI.W  #third_nibble,D3
000025AC  1A3C 0004               1959          MOVE.B  #right4,D5 
000025B0  EA6B                    1960          LSR.W   D5,D3
000025B2  0203 0004               1961          ANDI.B  #4,D3
000025B6  B63C 0004               1962          CMP.B   #4,D3
000025BA  6700 0006               1963          BEQ     D4_An_SETONE_1       ; SETONE refers to the set for reg to mem branch. 
000025BE  6000 0014               1964          BRA     CHECK1_BIT_5
000025C2                          1965  D4_An_SETONE_1
000025C2  183C 0001               1966          MOVE.B  #$1, D4
000025C6                          1967          
000025C6  6000 0002               1968          BRA     PRINT1_A1
000025CA                          1969          
000025CA                          1970  PRINT1_A1
000025CA  4EB9 00002D2E           1971          JSR     EA_An
000025D0  14FC 002F               1972          MOVE.B  #$2F,(A2)+ 
000025D4                          1973  
000025D4                          1974  *-----------------------------------------------------------------------------------*
000025D4                          1975  * Print out A2 if mask field states to. 
000025D4                          1976  
000025D4                          1977  CHECK1_BIT_5
000025D4  3606                    1978          MOVE.W  D6, D3
000025D6  0243 00F0               1979          ANDI.W  #third_nibble,D3
000025DA  1A3C 0004               1980          MOVE.B  #right4,D5 
000025DE  EA6B                    1981          LSR.W   D5,D3
000025E0  0203 0002               1982          ANDI.B  #2,D3
000025E4  B63C 0002               1983          CMP.B   #2,D3
000025E8  6700 0006               1984          BEQ     D4_An_SETONE_2       ; SETONE refers to the set for reg to mem branch. 
000025EC  6000 0014               1985          BRA     CHECK1_BIT_4
000025F0                          1986  D4_An_SETONE_2
000025F0  183C 0002               1987          MOVE.B  #$2, D4
000025F4                          1988          
000025F4  6000 0002               1989          BRA     PRINT1_A2
000025F8                          1990          
000025F8                          1991  PRINT1_A2
000025F8  4EB9 00002D2E           1992          JSR     EA_An
000025FE  14FC 002F               1993          MOVE.B  #$2F,(A2)+ 
00002602                          1994  
00002602                          1995  *-----------------------------------------------------------------------------------*
00002602                          1996  * Print out A3 if mask field states to. 
00002602                          1997  
00002602                          1998  CHECK1_BIT_4
00002602  3606                    1999          MOVE.W  D6, D3
00002604  0243 00F0               2000          ANDI.W  #third_nibble,D3
00002608  1A3C 0004               2001          MOVE.B  #right4,D5 
0000260C  EA6B                    2002          LSR.W   D5,D3
0000260E  0203 0001               2003          ANDI.B  #1,D3
00002612  B63C 0001               2004          CMP.B   #1,D3
00002616  6700 0006               2005          BEQ     D4_An_SETONE_3       ; SETONE refers to the set for reg to mem branch. 
0000261A  6000 0014               2006          BRA     CHECK1_BIT_3
0000261E                          2007  D4_An_SETONE_3
0000261E  183C 0003               2008          MOVE.B  #$3, D4
00002622                          2009          
00002622  6000 0002               2010          BRA     PRINT1_A3
00002626                          2011          
00002626                          2012  PRINT1_A3
00002626  4EB9 00002D2E           2013          JSR     EA_An
0000262C  14FC 002F               2014          MOVE.B  #$2F,(A2)+ 
00002630                          2015  
00002630                          2016  * FOURTH NIBBLE CHECK A4 - A7 
00002630                          2017  *-----------------------------------------------------------------------------------*
00002630                          2018  * Print out A4 if mask field states to. 
00002630                          2019  
00002630                          2020  CHECK1_BIT_3
00002630  3606                    2021          MOVE.W  D6, D3
00002632  0243 000F               2022          ANDI.W  #fourth_nibble,D3
00002636  0203 0008               2023          ANDI.B  #8,D3
0000263A  B63C 0008               2024          CMP.B   #8,D3
0000263E  6700 0006               2025          BEQ     D4_An_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
00002642  6000 0014               2026          BRA     CHECK1_BIT_2
00002646                          2027  D4_An_SETONE_4
00002646  183C 0004               2028          MOVE.B  #$4, D4
0000264A                          2029          
0000264A  6000 0002               2030          BRA     PRINT1_A4
0000264E                          2031          
0000264E                          2032  PRINT1_A4
0000264E  4EB9 00002D2E           2033          JSR     EA_An
00002654  14FC 002F               2034          MOVE.B  #$2F,(A2)+ 
00002658                          2035  
00002658                          2036  *-----------------------------------------------------------------------------------*
00002658                          2037  * Print out A5 if mask field states to. 
00002658                          2038  
00002658                          2039  CHECK1_BIT_2
00002658  3606                    2040          MOVE.W  D6, D3
0000265A  0243 000F               2041          ANDI.W  #fourth_nibble,D3
0000265E  0203 0004               2042          ANDI.B  #4,D3
00002662  B63C 0004               2043          CMP.B   #4,D3
00002666  6700 0006               2044          BEQ     D4_An_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
0000266A  6000 0014               2045          BRA     CHECK1_BIT_1
0000266E                          2046  D4_An_SETONE_5
0000266E  183C 0005               2047          MOVE.B  #$5, D4
00002672                          2048          
00002672  6000 0002               2049          BRA     PRINT1_A5
00002676                          2050          
00002676                          2051  PRINT1_A5
00002676  4EB9 00002D2E           2052          JSR     EA_An
0000267C  14FC 002F               2053          MOVE.B  #$2F,(A2)+ 
00002680                          2054  
00002680                          2055  *-----------------------------------------------------------------------------------*
00002680                          2056  * Print out A6 if mask field states to. 
00002680                          2057  
00002680                          2058  CHECK1_BIT_1
00002680  3606                    2059          MOVE.W  D6, D3
00002682  0243 000F               2060          ANDI.W  #fourth_nibble,D3
00002686  0203 0002               2061          ANDI.B  #2,D3
0000268A  B63C 0002               2062          CMP.B   #2,D3
0000268E  6700 0006               2063          BEQ     D4_An_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
00002692  6000 0014               2064          BRA     CHECK1_BIT_0
00002696                          2065  D4_An_SETONE_6
00002696  183C 0006               2066          MOVE.B  #$6, D4
0000269A                          2067          
0000269A  6000 0002               2068          BRA     PRINT1_A6
0000269E                          2069          
0000269E                          2070  PRINT1_A6
0000269E  4EB9 00002D2E           2071          JSR     EA_An
000026A4  14FC 002F               2072          MOVE.B  #$2F,(A2)+ 
000026A8                          2073  
000026A8                          2074  *-----------------------------------------------------------------------------------*
000026A8                          2075  * Print out A7 if mask field states to. 
000026A8                          2076  
000026A8                          2077  CHECK1_BIT_0
000026A8  3606                    2078          MOVE.W  D6, D3
000026AA  0243 000F               2079          ANDI.W  #fourth_nibble,D3
000026AE  0203 0001               2080          ANDI.B  #1,D3
000026B2  B63C 0001               2081          CMP.B   #1,D3
000026B6  6700 0006               2082          BEQ     D4_An_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
000026BA  6000 0014               2083          BRA     FINISH_REG_TO_MEM
000026BE                          2084  D4_An_SETONE_7
000026BE  183C 0007               2085          MOVE.B  #$7, D4
000026C2                          2086          
000026C2  6000 0002               2087          BRA     PRINT1_A7
000026C6                          2088          
000026C6                          2089  PRINT1_A7
000026C6  4EB9 00002D2E           2090          JSR     EA_An
000026CC  14FC 002F               2091          MOVE.B  #$2F,(A2)+ 
000026D0                          2092  
000026D0                          2093  FINISH_REG_TO_MEM
000026D0  14FC 002C               2094          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000026D4  14FC 0020               2095          MOVE.B  #$20,(A2)+          ; Add space after comma
000026D8                          2096  
000026D8  2800                    2097          MOVE.L  D0,D4               ; Store the src reg in D4
000026DA  0244 0007               2098          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000026DE                          2099          
000026DE  2600                    2100          MOVE.L  D0,D3               ; Store the src mode in D3
000026E0  0243 0038               2101          ANDI.W  #src_mode,D3        ; Get bits 5-3
000026E4  1A3C 0003               2102          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000026E8  EA6B                    2103          LSR.W   D5,D3               ; Do the actual shift 
000026EA  4EB9 00002CE4           2104          JSR     EA_GEN_SRC
000026F0                          2105          
000026F0  301D                    2106          MOVE.W  (A5)+, D0 
000026F2                          2107  
000026F2  4EF8 1E10               2108          JMP     EA_FINISH
000026F6                          2109  
000026F6                          2110  MEM_TO_REG                          ; post-increment + A7-A0,D7-D0
000026F6                          2111  
000026F6  B63C 0002               2112          CMP.B   #2, D3              ; check if the destination is (An)
000026FA  6700 0022               2113          BEQ     MEM_TO_REG_CONTINUE ; branch to print out the address and data registers. 
000026FE                          2114          
000026FE  2800                    2115          MOVE.L  D0,D4               ; Store the src reg in D4
00002700  0244 0007               2116          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002704                          2117          
00002704  2600                    2118          MOVE.L  D0,D3               ; Store the src mode in D3
00002706  0243 0038               2119          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000270A  1A3C 0003               2120          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000270E  EA6B                    2121          LSR.W   D5,D3               ; Do the actual shift 
00002710  4EB9 00002CE4           2122          JSR     EA_GEN_SRC
00002716                          2123          
00002716  14FC 002C               2124          MOVE.B  #$2C,(A2)+          ; Add comma after size print
0000271A  14FC 0020               2125          MOVE.B  #$20,(A2)+          ; Add space after comma
0000271E                          2126  
0000271E                          2127          
0000271E                          2128  * Print out the proper data and address registers. 
0000271E                          2129  * FIRST NIBBLE CHECK A7 - A4
0000271E                          2130  *-----------------------------------------------------------------------------------*
0000271E                          2131  * Print out A7 if mask field states to. 
0000271E                          2132  MEM_TO_REG_CONTINUE
0000271E  3C15                    2133          MOVE.W  (A5), D6            ; store the register list mask field for MEM to REG
00002720                          2134          
00002720  3606                    2135          MOVE.W  D6, D3
00002722  0243 F000               2136          ANDI.W  #first_nibble,D3
00002726  1A3C 000C               2137          MOVE.B  #right12,D5 
0000272A  EA6B                    2138          LSR.W   D5,D3
0000272C  0203 0008               2139          ANDI.B  #8,D3
00002730  B63C 0008               2140          CMP.B   #8,D3
00002734  6700 0006               2141          BEQ     D4_An_SET_7
00002738  6000 0014               2142          BRA     CHECK_BIT_14
0000273C                          2143  D4_An_SET_7
0000273C  183C 0007               2144          MOVE.B  #$7, D4
00002740                          2145          
00002740  6000 0002               2146          BRA     PRINT_A7
00002744                          2147          
00002744                          2148  PRINT_A7
00002744  4EB9 00002D2E           2149          JSR     EA_An
0000274A  14FC 002F               2150          MOVE.B  #$2F,(A2)+
0000274E                          2151          
0000274E                          2152  *-----------------------------------------------------------------------------------*
0000274E                          2153  * Print out A6 if mask field states to. 
0000274E                          2154  
0000274E                          2155  CHECK_BIT_14
0000274E  3606                    2156          MOVE.W  D6, D3
00002750  0243 F000               2157          ANDI.W  #first_nibble,D3
00002754  1A3C 000C               2158          MOVE.B  #right12,D5 
00002758  EA6B                    2159          LSR.W   D5,D3
0000275A  0203 0004               2160          ANDI.B  #4,D3
0000275E  B63C 0004               2161          CMP.B   #4,D3
00002762  6700 0006               2162          BEQ     D4_An_SET_6
00002766  6000 0014               2163          BRA     CHECK_BIT_13
0000276A                          2164  D4_An_SET_6
0000276A  183C 0006               2165          MOVE.B  #$6, D4
0000276E                          2166          
0000276E  6000 0002               2167          BRA     PRINT_A6
00002772                          2168          
00002772                          2169  PRINT_A6
00002772  4EB9 00002D2E           2170          JSR     EA_An
00002778  14FC 002F               2171          MOVE.B  #$2F,(A2)+
0000277C                          2172  
0000277C                          2173  *-----------------------------------------------------------------------------------*
0000277C                          2174  * Print out A5 if mask field states to. 
0000277C                          2175  
0000277C                          2176  CHECK_BIT_13
0000277C  3606                    2177          MOVE.W  D6, D3
0000277E  0243 F000               2178          ANDI.W  #first_nibble,D3
00002782  1A3C 000C               2179          MOVE.B  #right12,D5 
00002786  EA6B                    2180          LSR.W   D5,D3
00002788  0203 0002               2181          ANDI.B  #2,D3
0000278C  B63C 0002               2182          CMP.B   #2,D3
00002790  6700 0006               2183          BEQ     D4_An_SET_5
00002794  6000 0014               2184          BRA     CHECK_BIT_12
00002798                          2185  D4_An_SET_5
00002798  183C 0005               2186          MOVE.B  #$5, D4
0000279C                          2187          
0000279C  6000 0002               2188          BRA     PRINT_A5
000027A0                          2189          
000027A0                          2190  PRINT_A5
000027A0  4EB9 00002D2E           2191          JSR     EA_An
000027A6  14FC 002F               2192          MOVE.B  #$2F,(A2)+
000027AA                          2193  
000027AA                          2194  *-----------------------------------------------------------------------------------*
000027AA                          2195  * Print out A4 if mask field states to. 
000027AA                          2196          
000027AA                          2197  CHECK_BIT_12
000027AA  3606                    2198          MOVE.W  D6, D3
000027AC  0243 F000               2199          ANDI.W  #first_nibble,D3
000027B0  1A3C 000C               2200          MOVE.B  #right12,D5 
000027B4  EA6B                    2201          LSR.W   D5,D3
000027B6  0203 0001               2202          ANDI.B  #1,D3
000027BA  B63C 0001               2203          CMP.B   #1,D3
000027BE  6700 0006               2204          BEQ     D4_An_SET_4
000027C2  6000 0014               2205          BRA     CHECK_BIT_11
000027C6                          2206  D4_An_SET_4
000027C6  183C 0004               2207          MOVE.B  #$4, D4
000027CA                          2208          
000027CA  6000 0002               2209          BRA     PRINT_A4
000027CE                          2210          
000027CE                          2211  PRINT_A4
000027CE  4EB9 00002D2E           2212          JSR     EA_An
000027D4  14FC 002F               2213          MOVE.B  #$2F,(A2)+
000027D8                          2214  
000027D8                          2215  *-----------------------------------------------------------------------------------*
000027D8                          2216  * Print out A3 if mask field states to. 
000027D8                          2217  * SECOND NIBBLE CHECK A7 - A4
000027D8                          2218    
000027D8                          2219  CHECK_BIT_11
000027D8  3606                    2220          MOVE.W  D6, D3
000027DA  0243 0F00               2221          ANDI.W  #second_nibble,D3
000027DE  1A3C 0008               2222          MOVE.B  #right8,D5 
000027E2  EA6B                    2223          LSR.W   D5,D3
000027E4  0203 0008               2224          ANDI.B  #8,D3
000027E8  B63C 0008               2225          CMP.B   #8,D3
000027EC  6700 0006               2226          BEQ     D4_An_SET_3
000027F0  6000 0014               2227          BRA     CHECK_BIT_10
000027F4                          2228  D4_An_SET_3
000027F4  183C 0003               2229          MOVE.B  #$3, D4
000027F8                          2230          
000027F8  6000 0002               2231          BRA     PRINT_A3
000027FC                          2232          
000027FC                          2233  PRINT_A3
000027FC  4EB9 00002D2E           2234          JSR     EA_An
00002802  14FC 002F               2235          MOVE.B  #$2F,(A2)+     
00002806                          2236  
00002806                          2237  *-----------------------------------------------------------------------------------*
00002806                          2238  * Print out A2 if mask field states to. 
00002806                          2239    
00002806                          2240  CHECK_BIT_10
00002806  3606                    2241          MOVE.W  D6, D3
00002808  0243 0F00               2242          ANDI.W  #second_nibble,D3
0000280C  1A3C 0008               2243          MOVE.B  #right8,D5 
00002810  EA6B                    2244          LSR.W   D5,D3
00002812  0203 0004               2245          ANDI.B  #4,D3
00002816  B63C 0004               2246          CMP.B   #4,D3
0000281A  6700 0006               2247          BEQ     D4_An_SET_2
0000281E  6000 0014               2248          BRA     CHECK_BIT_9
00002822                          2249  D4_An_SET_2
00002822  183C 0002               2250          MOVE.B  #$2, D4
00002826                          2251          
00002826  6000 0002               2252          BRA     PRINT_A2
0000282A                          2253          
0000282A                          2254  PRINT_A2
0000282A  4EB9 00002D2E           2255          JSR     EA_An
00002830  14FC 002F               2256          MOVE.B  #$2F,(A2)+  
00002834                          2257  
00002834                          2258  *-----------------------------------------------------------------------------------*
00002834                          2259  * Print out A1 if mask field states to. 
00002834                          2260    
00002834                          2261  CHECK_BIT_9
00002834  3606                    2262          MOVE.W  D6, D3
00002836  0243 0F00               2263          ANDI.W  #second_nibble,D3
0000283A  1A3C 0008               2264          MOVE.B  #right8,D5 
0000283E  EA6B                    2265          LSR.W   D5,D3
00002840  0203 0002               2266          ANDI.B  #2,D3
00002844  B63C 0002               2267          CMP.B   #2,D3
00002848  6700 0006               2268          BEQ     D4_An_SET_1
0000284C  6000 0012               2269          BRA     CHECK_BIT_8
00002850                          2270  D4_An_SET_1
00002850  183C 0001               2271          MOVE.B  #$1, D4
00002854                          2272          
00002854  60D4                    2273          BRA     PRINT_A2
00002856                          2274          
00002856                          2275  PRINT_A1
00002856  4EB9 00002D2E           2276          JSR     EA_An
0000285C  14FC 002F               2277          MOVE.B  #$2F,(A2)+ 
00002860                          2278  
00002860                          2279  *-----------------------------------------------------------------------------------*
00002860                          2280  * Print out A0 if mask field states to. 
00002860                          2281    
00002860                          2282  CHECK_BIT_8
00002860  3606                    2283          MOVE.W  D6, D3
00002862  0243 0F00               2284          ANDI.W  #second_nibble,D3
00002866  1A3C 0008               2285          MOVE.B  #right8,D5 
0000286A  EA6B                    2286          LSR.W   D5,D3
0000286C  0203 0001               2287          ANDI.B  #1,D3
00002870  B63C 0001               2288          CMP.B   #1,D3
00002874  6700 0006               2289          BEQ     D4_An_SET_0
00002878  6000 0014               2290          BRA     CHECK_BIT_7
0000287C                          2291  D4_An_SET_0
0000287C  183C 0000               2292          MOVE.B  #$0, D4
00002880                          2293          
00002880  6000 0002               2294          BRA     PRINT_A0
00002884                          2295          
00002884                          2296  PRINT_A0
00002884  4EB9 00002D2E           2297          JSR     EA_An
0000288A  14FC 002F               2298          MOVE.B  #$2F,(A2)+        
0000288E                          2299  
0000288E                          2300  *-----------------------------------------------------------------------------------*
0000288E                          2301  * Print out D7 if mask field states to. 
0000288E                          2302  * THIRD NIBBLE CHECK D7-D0
0000288E                          2303  
0000288E                          2304  CHECK_BIT_7
0000288E  3606                    2305          MOVE.W  D6, D3
00002890  0243 00F0               2306          ANDI.W  #third_nibble,D3
00002894  1A3C 0004               2307          MOVE.B  #right4,D5 
00002898  EA6B                    2308          LSR.W   D5,D3
0000289A  0203 0008               2309          ANDI.B  #8,D3
0000289E  B63C 0008               2310          CMP.B   #8,D3
000028A2  6700 0006               2311          BEQ     D4_Dn_SET_7
000028A6  6000 0014               2312          BRA     CHECK_BIT_6
000028AA                          2313  D4_Dn_SET_7
000028AA  183C 0007               2314          MOVE.B  #$7, D4
000028AE                          2315          
000028AE  6000 0002               2316          BRA     PRINT_D7
000028B2                          2317          
000028B2                          2318  PRINT_D7
000028B2  4EB9 00002D22           2319          JSR     EA_Dn
000028B8  14FC 002F               2320          MOVE.B  #$2F,(A2)+
000028BC                          2321  
000028BC                          2322  *-----------------------------------------------------------------------------------*
000028BC                          2323  * Print out D6 if mask field states to. 
000028BC                          2324  
000028BC                          2325  CHECK_BIT_6
000028BC  3606                    2326          MOVE.W  D6, D3
000028BE  0243 00F0               2327          ANDI.W  #third_nibble,D3
000028C2  1A3C 0004               2328          MOVE.B  #right4,D5 
000028C6  EA6B                    2329          LSR.W   D5,D3
000028C8  0203 0004               2330          ANDI.B  #4,D3
000028CC  B63C 0004               2331          CMP.B   #4,D3
000028D0  6700 0006               2332          BEQ     D4_Dn_SET_6
000028D4  6000 0014               2333          BRA     CHECK_BIT_5
000028D8                          2334  D4_Dn_SET_6
000028D8  183C 0006               2335          MOVE.B  #$6, D4
000028DC                          2336          
000028DC  6000 0002               2337          BRA     PRINT_D6
000028E0                          2338          
000028E0                          2339  PRINT_D6
000028E0  4EB9 00002D22           2340          JSR     EA_Dn
000028E6  14FC 002F               2341          MOVE.B  #$2F,(A2)+
000028EA                          2342  
000028EA                          2343  *-----------------------------------------------------------------------------------*
000028EA                          2344  * Print out D5 if mask field states to. 
000028EA                          2345  
000028EA                          2346  CHECK_BIT_5
000028EA  3606                    2347          MOVE.W  D6, D3
000028EC  0243 00F0               2348          ANDI.W  #third_nibble,D3
000028F0  1A3C 0004               2349          MOVE.B  #right4,D5 
000028F4  EA6B                    2350          LSR.W   D5,D3
000028F6  0203 0002               2351          ANDI.B  #2,D3
000028FA  B63C 0002               2352          CMP.B   #2,D3
000028FE  6700 0006               2353          BEQ     D4_Dn_SET_5
00002902  6000 0014               2354          BRA     CHECK_BIT_4
00002906                          2355  D4_Dn_SET_5
00002906  183C 0005               2356          MOVE.B  #$5, D4
0000290A                          2357          
0000290A  6000 0002               2358          BRA     PRINT_D5
0000290E                          2359          
0000290E                          2360  PRINT_D5
0000290E  4EB9 00002D22           2361          JSR     EA_Dn
00002914  14FC 002F               2362          MOVE.B  #$2F,(A2)+
00002918                          2363  
00002918                          2364  *-----------------------------------------------------------------------------------*
00002918                          2365  * Print out D4 if mask field states to. 
00002918                          2366  
00002918                          2367  CHECK_BIT_4
00002918  3606                    2368          MOVE.W  D6, D3
0000291A  0243 00F0               2369          ANDI.W  #third_nibble,D3
0000291E  1A3C 0004               2370          MOVE.B  #right4,D5 
00002922  EA6B                    2371          LSR.W   D5,D3
00002924  0203 0001               2372          ANDI.B  #1,D3
00002928  B63C 0001               2373          CMP.B   #1,D3
0000292C  6700 0006               2374          BEQ     D4_Dn_SET_4
00002930  6000 0014               2375          BRA     CHECK_BIT_3
00002934                          2376  D4_Dn_SET_4
00002934  183C 0004               2377          MOVE.B  #$4, D4
00002938                          2378          
00002938  6000 0002               2379          BRA     PRINT_D4
0000293C                          2380          
0000293C                          2381  PRINT_D4
0000293C  4EB9 00002D22           2382          JSR     EA_Dn
00002942  14FC 002F               2383          MOVE.B  #$2F,(A2)+
00002946                          2384  
00002946                          2385  *-----------------------------------------------------------------------------------*
00002946                          2386  * Print out D3 if mask field states to. 
00002946                          2387  * FOURTH NIBBLE CHECK / D3 - D0
00002946                          2388  
00002946                          2389  CHECK_BIT_3
00002946  3606                    2390          MOVE.W  D6, D3
00002948  0243 000F               2391          ANDI.W  #fourth_nibble,D3
0000294C  0203 0008               2392          ANDI.B  #8,D3
00002950  B63C 0008               2393          CMP.B   #8,D3
00002954  6700 0006               2394          BEQ     D4_Dn_SET_3
00002958  6000 0014               2395          BRA     CHECK_BIT_2
0000295C                          2396  D4_Dn_SET_3
0000295C  183C 0003               2397          MOVE.B  #$3, D4
00002960                          2398          
00002960  6000 0002               2399          BRA     PRINT_D3
00002964                          2400          
00002964                          2401  PRINT_D3
00002964  4EB9 00002D22           2402          JSR     EA_Dn
0000296A  14FC 002F               2403          MOVE.B  #$2F,(A2)+
0000296E                          2404  
0000296E                          2405  *-----------------------------------------------------------------------------------*
0000296E                          2406  * Print out D2 if mask field states to. 
0000296E                          2407  
0000296E                          2408  CHECK_BIT_2
0000296E  3606                    2409          MOVE.W  D6, D3
00002970  0243 000F               2410          ANDI.W  #fourth_nibble,D3
00002974  0203 0004               2411          ANDI.B  #4,D3
00002978  B63C 0004               2412          CMP.B   #4,D3
0000297C  6700 0006               2413          BEQ     D4_Dn_SET_2
00002980  6000 0014               2414          BRA     CHECK_BIT_1
00002984                          2415  D4_Dn_SET_2
00002984  183C 0002               2416          MOVE.B  #$2, D4
00002988                          2417          
00002988  6000 0002               2418          BRA     PRINT_D2
0000298C                          2419          
0000298C                          2420  PRINT_D2
0000298C  4EB9 00002D22           2421          JSR     EA_Dn
00002992  14FC 002F               2422          MOVE.B  #$2F,(A2)+
00002996                          2423  
00002996                          2424  *-----------------------------------------------------------------------------------*
00002996                          2425  * Print out D1 if mask field states to. 
00002996                          2426  
00002996                          2427  CHECK_BIT_1
00002996  3606                    2428          MOVE.W  D6, D3
00002998  0243 000F               2429          ANDI.W  #fourth_nibble,D3
0000299C  0203 0002               2430          ANDI.B  #2,D3
000029A0  B63C 0002               2431          CMP.B   #2,D3
000029A4  6700 0006               2432          BEQ     D4_Dn_SET_1
000029A8  6000 0014               2433          BRA     CHECK_BIT_0
000029AC                          2434  D4_Dn_SET_1
000029AC  183C 0001               2435          MOVE.B  #$1, D4
000029B0                          2436          
000029B0  6000 0002               2437          BRA     PRINT_D1
000029B4                          2438          
000029B4                          2439  PRINT_D1
000029B4  4EB9 00002D22           2440          JSR     EA_Dn
000029BA  14FC 002F               2441          MOVE.B  #$2F,(A2)+
000029BE                          2442  
000029BE                          2443  *-----------------------------------------------------------------------------------*
000029BE                          2444  * Print out D0 if mask field states to. 
000029BE                          2445  
000029BE                          2446  CHECK_BIT_0
000029BE  3606                    2447          MOVE.W  D6, D3
000029C0  0243 000F               2448          ANDI.W  #fourth_nibble,D3
000029C4  0203 0001               2449          ANDI.B  #1,D3
000029C8  B63C 0001               2450          CMP.B   #1,D3
000029CC  6700 0006               2451          BEQ     D4_Dn_SET_0
000029D0  6000 0014               2452          BRA     FINISH_MOVEM_MEM_TO_REG
000029D4                          2453  D4_Dn_SET_0
000029D4  183C 0000               2454          MOVE.B  #$0, D4
000029D8                          2455          
000029D8  6000 0002               2456          BRA     PRINT_D0
000029DC                          2457          
000029DC                          2458  PRINT_D0
000029DC  4EB9 00002D22           2459          JSR     EA_Dn
000029E2  14FC 002F               2460          MOVE.B  #$2F,(A2)+
000029E6                          2461  
000029E6                          2462  FINISH_MOVEM_MEM_TO_REG
000029E6                          2463          
000029E6  2600                    2464          MOVE.L  D0,D3               ; Store the src mode in D3
000029E8  0243 0038               2465          ANDI.W  #src_mode,D3        ; Get bits 5-3
000029EC  1A3C 0003               2466          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000029F0  EA6B                    2467          LSR.W   D5,D3               ; Do the actual shift
000029F2                          2468  
000029F2  2800                    2469          MOVE.L  D0,D4               ; Store the dst reg in D4
000029F4  0244 0007               2470          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000029F8                          2471   
000029F8  B63C 0002               2472          CMP.B   #2, D3
000029FC  6700 0006               2473          BEQ     An_FINISH           ; branch to print out (An) 
00002A00  6000 0010               2474          BRA     NORMAL_FINISH       ; branch to the normal finish
00002A04                          2475  
00002A04                          2476  An_FINISH
00002A04  14FC 002C               2477          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002A08  14FC 0020               2478          MOVE.B  #$20,(A2)+          ; Add space after comma
00002A0C                          2479          
00002A0C                          2480                      
00002A0C  4EB9 00002CE4           2481          JSR     EA_GEN_SRC
00002A12                          2482  
00002A12                          2483  NORMAL_FINISH
00002A12  301D                    2484          MOVE.W  (A5)+, D0
00002A14                          2485          
00002A14  4EF8 1E10               2486          JMP     EA_FINISH
00002A18                          2487  *------------------------------------------------------------------------------------------------*
00002A18                          2488  EA_SHIFTS       ; 7: ea_shifts
00002A18  2200                    2489          MOVE.L  D0,D1               ; D0 is current instruction word
00002A1A  0241 01C0               2490          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00002A1E  1A3C 0006               2491          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00002A22  EA69                    2492          LSR.W   D5,D1               ; Shift dst mode into LSB position
00002A24  C2FC 0006               2493          MULU    #6, D1              ; Set displacement 
00002A28  41F9 00002A32           2494          LEA     EA_SHIFTS_TABLE,A0  ; Load table into A0
00002A2E  4EF0 1000               2495          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00002A32                          2496  
00002A32                          2497  EA_SHIFTS_TABLE
00002A32  4EF9 00002AD8           2498          JMP     EA_REGISTER_SHIFTS  ; 000 Register
00002A38  4EF9 00002AD8           2499          JMP     EA_REGISTER_SHIFTS  ; 001 Register
00002A3E  4EF9 00002AD8           2500          JMP     EA_REGISTER_SHIFTS  ; 010 Register
00002A44  4EF9 00002A62           2501          JMP     EA_MEMORY_SHIFTS    ; 011 Memory
00002A4A  4EF9 00002AD8           2502          JMP     EA_REGISTER_SHIFTS  ; 100 Register
00002A50  4EF9 00002AD8           2503          JMP     EA_REGISTER_SHIFTS  ; 101 Register
00002A56  4EF9 00002AD8           2504          JMP     EA_REGISTER_SHIFTS  ; 110 Register
00002A5C  4EF9 00002A62           2505          JMP     EA_MEMORY_SHIFTS    ; 111 Memory
00002A62                          2506          
00002A62                          2507  EA_MEMORY_SHIFTS
00002A62                          2508          ; Get EA and store into decode buffer
00002A62  2800                    2509          MOVE.L  D0,D4               ; Store the EA reg in D4
00002A64  0244 0007               2510          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002A68                          2511          
00002A68  2600                    2512          MOVE.L  D0,D3               ; Store the EA mode in D3
00002A6A  0243 0038               2513          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002A6E  1A3C 0003               2514          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002A72  EA6B                    2515          LSR.W   D5,D3               ; Do the actual shift
00002A74  4EB9 00002DF0           2516          JSR     An_CHECK            ; Check if mode is An 
00002A7A  4EB9 00002DFA           2517          JSR     Dn_CHECK            ; Check if mode is Dn
00002A80  4EB9 00002E04           2518          JSR     IMMEDIATE_CHECK     ; Check if mode is immediate
00002A86                          2519          
00002A86  14FC 0020               2520          MOVE.B  #$20,(A2)+          ; Print out a space 
00002A8A  14FC 0020               2521          MOVE.B  #$20,(A2)+          ; Print out a space
00002A8E  14FC 0020               2522          MOVE.B  #$20,(A2)+          ; Print out a space
00002A92  14FC 0020               2523          MOVE.B  #$20,(A2)+          ; Print out a space
00002A96  14FC 0020               2524          MOVE.B  #$20,(A2)+          ; Add space
00002A9A                          2525          
00002A9A  4EB9 00002AB2           2526          JSR     FRONT_FORMAT
00002AA0  4EB9 00002CE4           2527          JSR     EA_GEN_SRC          ; Go get EA print
00002AA6  B63C 002A               2528          CMP.B   #$2A,D3             ; When mode is 111 * 6 (2A)
00002AAA  6700 001E               2529          BEQ     BACK_PARENTHESIS  
00002AAE  4EF8 1E10               2530          JMP     EA_FINISH           ; Opcode is finish
00002AB2                          2531  
00002AB2                          2532  FRONT_FORMAT
00002AB2  B63C 0007               2533          CMP.B   #7,D3               ; When mode is 111
00002AB6  6700 0008               2534          BEQ     ADD_PARENTHESIS
00002ABA  14FC 0020               2535          MOVE.B  #$20,(A2)+          ; Print out a space
00002ABE  4E75                    2536          RTS
00002AC0                          2537          
00002AC0                          2538  ADD_PARENTHESIS
00002AC0  14FC 0020               2539          MOVE.B  #$20,(A2)+          ; Print out a space
00002AC4  14FC 0028               2540          MOVE.B  #'(',(A2)+
00002AC8  4E75                    2541          RTS
00002ACA                          2542          
00002ACA                          2543  BACK_PARENTHESIS            
00002ACA  14FC 0029               2544          MOVE.B  #')',(A2)+
00002ACE  1404                    2545          MOVE.B  D4,D2
00002AD0  4EB8 1EFE               2546          JSR     EA_SIZE_MEMORY_SHIFTS
00002AD4  4EF8 1E10               2547          JMP     EA_FINISH           ; Opcode is finish
00002AD8                          2548      
00002AD8                          2549  EA_REGISTER_SHIFTS
00002AD8  2200                    2550          MOVE.L  D0,D1
00002ADA  0241 01C0               2551          ANDI.W  #dst_mode,D1
00002ADE  1A3C 0006               2552          MOVE.B  #right6,D5 
00002AE2  EA69                    2553          LSR.W   D5,D1
00002AE4  0201 0003               2554          ANDI.B  #3,D1               ; Remove bit 8 and get bits 7-6
00002AE8  1401                    2555          MOVE.B  D1,D2
00002AEA  4EB8 1E56               2556          JSR     EA_SIZE_GENERAL
00002AEE                          2557          
00002AEE  2600                    2558          MOVE.L  D0,D3               ; Store the instruction in D3
00002AF0  0243 0038               2559          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002AF4  1A3C 0003               2560          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002AF8  EA6B                    2561          LSR.W   D5,D3               ; Do the actual shift 
00002AFA  0203 0004               2562          ANDI.B  #4,D3               ; Get bit 5(ir) from bits 5-3
00002AFE  E44B                    2563          LSR.W   #2,D3
00002B00                          2564  
00002B00  B63C 0000               2565          CMP.B   #0,D3               ; When D1 is 0 (immediate)
00002B04  6700 0006               2566          BEQ     IMMEDIATE_SRC
00002B08  6000 0056               2567          BRA     REGISTER_SRC        ; When D1 is 1 (register)
00002B0C                          2568          
00002B0C                          2569  IMMEDIATE_SRC
00002B0C  14FC 0020               2570          MOVE.B  #$20,(A2)+          ; Add space
00002B10  14FC 0020               2571          MOVE.B  #$20,(A2)+          ; Add space
00002B14  14FC 0020               2572          MOVE.B  #$20,(A2)+          ; Add space
00002B18  14FC 0020               2573          MOVE.B  #$20,(A2)+          ; Add space
00002B1C                          2574          
00002B1C                          2575          ; Get source and store into decode buffer
00002B1C  2800                    2576          MOVE.L  D0,D4               ; Store the src reg in D4
00002B1E  0244 0E00               2577          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B22  1A3C 0009               2578          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B26  EA6C                    2579          LSR.W   D5,D4               ; Do the actual shift
00002B28  4EB9 00002B50           2580          JSR     CHECK_IF_ZERO       ; Check if register is 0
00002B2E                          2581          
00002B2E  14FC 0023               2582          MOVE.B  #$23,(A2)+          ; Add # symbol
00002B32  0604 0030               2583          ADDI.B  #$30,D4             ; Convert hex to ASCII
00002B36  14C4                    2584          MOVE.B  D4,(A2)+            ; Store into buffer
00002B38                          2585          
00002B38  14FC 002C               2586          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B3C  14FC 0020               2587          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B40                          2588  
00002B40                          2589          ; Get destination and store into decode buffer
00002B40  2800                    2590          MOVE.L  D0,D4               ; Store the src reg in D4
00002B42  0244 0007               2591          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002B46  4EB9 00002D22           2592          JSR     EA_Dn               ; store Dn into decode buffer
00002B4C  4EF8 1E10               2593          JMP     EA_FINISH           ; Opcode is finish
00002B50                          2594                
00002B50                          2595  CHECK_IF_ZERO
00002B50  B83C 0000               2596          CMP.B   #0,D4               ; When D4 is 0 
00002B54  6700 0004               2597          BEQ     IMMEDIATE_EIGHT     ; Branch
00002B58  4E75                    2598          RTS
00002B5A                          2599  
00002B5A                          2600  IMMEDIATE_EIGHT
00002B5A  183C 0008               2601          MOVE.B  #8,D4               ; Store 8 into D4 
00002B5E  4E75                    2602          RTS
00002B60                          2603  
00002B60                          2604  REGISTER_SRC        
00002B60  14FC 0020               2605          MOVE.B  #$20,(A2)+          ; Add space
00002B64  14FC 0020               2606          MOVE.B  #$20,(A2)+          ; Add space
00002B68  14FC 0020               2607          MOVE.B  #$20,(A2)+          ; Add space
00002B6C  14FC 0020               2608          MOVE.B  #$20,(A2)+          ; Add space
00002B70                          2609  
00002B70                          2610          ; Get source and store into decode buffer
00002B70  2800                    2611          MOVE.L  D0,D4               ; Store the src reg in D4
00002B72  0244 0E00               2612          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B76  1A3C 0009               2613          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B7A  EA6C                    2614          LSR.W   D5,D4               ; Do the actual shift
00002B7C  4EB9 00002D22           2615          JSR     EA_Dn               ; store Dn into decode buffer
00002B82                          2616          
00002B82  14FC 002C               2617          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B86  14FC 0020               2618          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B8A                          2619  
00002B8A                          2620          ; Get destination and store into decode buffer
00002B8A  2800                    2621          MOVE.L  D0,D4               ; Store the src reg in D4
00002B8C  0244 0007               2622          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002B90  4EB9 00002D22           2623          JSR     EA_Dn               ; store Dn into decode buffer
00002B96  4EF8 1E10               2624          JMP     EA_FINISH           ; Opcode is finish
00002B9A                          2625  *------------------------------------------------------------------------------------------------*
00002B9A                          2626  EA_QUICK        ; 8: ea_quick
00002B9A  BC3C 0005               2627          CMP.B   #5, D6              ; check if the first nibble is 5 for ADDQ
00002B9E  6700 000A               2628          BEQ     ADDQ_EA_CALC
00002BA2                          2629          
00002BA2  BC3C 0007               2630          CMP.B   #7, D6              ; check if the first nibble is 7 for MOVEQ
00002BA6  6700 008A               2631          BEQ     MOVEQ_EA_CALC
00002BAA                          2632          
00002BAA                          2633  ADDQ_EA_CALC
00002BAA  2200                    2634          MOVE.L  D0,D1               ; error checking to handle SUBQ.
00002BAC  0241 0F00               2635          ANDI.W  #second_nibble,D1   ; Get bits 8-6 from D1
00002BB0  1A3C 0008               2636          MOVE.B  #right8,D5          ; Store 6 into D5
00002BB4  EA69                    2637          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002BB6  0201 0001               2638          ANDI.B  #1,D1               ; Remove the front bit from D1
00002BBA  B23C 0001               2639          CMP.B   #1, D1
00002BBE  6700 028A               2640          BEQ     EA_ERROR
00002BC2                          2641  
00002BC2  2200                    2642          MOVE.L  D0,D1
00002BC4  0241 01C0               2643          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00002BC8  1A3C 0006               2644          MOVE.B  #right6,D5          ; Store 6 into D5
00002BCC  EA69                    2645          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002BCE  0201 0003               2646          ANDI.B  #3,D1               ; Remove the front bit from D1
00002BD2  1401                    2647          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002BD4  4EB8 1E56               2648          JSR     EA_SIZE_GENERAL     ; Get size and print size.
00002BD8                          2649          
00002BD8  14FC 0020               2650          MOVE.B  #$20,(A2)+          ; Add space after size
00002BDC  14FC 0020               2651          MOVE.B  #$20,(A2)+          ; Add space
00002BE0  14FC 0020               2652          MOVE.B  #$20,(A2)+          ; Add space
00002BE4                          2653          
00002BE4  14FC 0023               2654          MOVE.B  #$23,(A2)+          ; Add # symbol
00002BE8  14FC 0024               2655          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002BEC                          2656          
00002BEC  2800                    2657          MOVE.L  D0,D4               ; Store the data in D4
00002BEE  0244 0E00               2658          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002BF2  1A3C 0009               2659          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002BF6  EA6C                    2660          LSR.W   D5,D4               ; Do the actual shift
00002BF8                          2661          
00002BF8  B83C 0000               2662          CMP.B   #0, D4
00002BFC  6700 0006               2663          BEQ     CHANGE_TO_EIGHT
00002C00                          2664          
00002C00  6000 0006               2665          BRA     DONT_CHANGE
00002C04                          2666  
00002C04                          2667  CHANGE_TO_EIGHT
00002C04  183C 0008               2668          MOVE.B  #8, D4
00002C08                          2669  
00002C08                          2670  DONT_CHANGE        
00002C08  0604 0030               2671          ADDI.B  #$30, D4
00002C0C  14C4                    2672          MOVE.B  D4, (A2)+      
00002C0E                          2673          
00002C0E  14FC 002C               2674          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002C12  14FC 0020               2675          MOVE.B  #$20,(A2)+          ; Add space after comma
00002C16                          2676          
00002C16  2800                    2677          MOVE.L  D0,D4               ; Store the src reg in D4
00002C18  0244 0007               2678          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002C1C                          2679          
00002C1C  2600                    2680          MOVE.L  D0,D3               ; Store the src mode in D3
00002C1E  0243 0038               2681          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002C22  1A3C 0003               2682          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002C26  EA6B                    2683          LSR.W   D5,D3               ; Do the actual shift 
00002C28  4EB9 00002CE4           2684          JSR     EA_GEN_SRC
00002C2E                          2685          
00002C2E  4EF8 1E10               2686          JMP     EA_FINISH
00002C32                          2687  
00002C32                          2688  MOVEQ_EA_CALC
00002C32  2200                    2689          MOVE.L  D0,D1               ; error checking to handle brute force.
00002C34  0241 0F00               2690          ANDI.W  #second_nibble,D1   ; Get bits 8-6 from D1
00002C38  1A3C 0008               2691          MOVE.B  #right8,D5          ; Store 6 into D5
00002C3C  EA69                    2692          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002C3E  0201 0001               2693          ANDI.B  #1,D1               ; Remove the front bit from D1
00002C42  B23C 0001               2694          CMP.B   #1, D1
00002C46  6700 0202               2695          BEQ     EA_ERROR
00002C4A                          2696  
00002C4A  14FC 0020               2697          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002C4E  14FC 0020               2698          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002C52  14FC 0020               2699          MOVE.B  #$20,(A2)+          ; Add space
00002C56  14FC 0020               2700          MOVE.B  #$20,(A2)+          ; Add space
00002C5A                          2701  
00002C5A  14FC 0023               2702          MOVE.B  #$23,(A2)+          ; Add # symbol
00002C5E  14FC 0024               2703          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C62                          2704          
00002C62  2200                    2705          MOVE.L  D0, D1              ; move D0 to D1
00002C64  0241 00FF               2706          ANDI.W  #second_half, D1    ; get the second 8 bits of D1
00002C68  1A01                    2707          MOVE.B  D1, D5              ; move D1 to D5 to convert it to ASCII
00002C6A                          2708          
00002C6A  4EB8 11C8               2709          JSR     ITOA_BYTE_BRANCH    ; print out the bit of data
00002C6E                          2710          
00002C6E  14FC 002C               2711          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002C72  14FC 0020               2712          MOVE.B  #$20,(A2)+          ; Add space after comma
00002C76                          2713          
00002C76  2800                    2714          MOVE.L  D0,D4               ; Store the data in D4
00002C78  0244 0E00               2715          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002C7C  1A3C 0009               2716          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002C80  EA6C                    2717          LSR.W   D5,D4               ; Do the actual shift
00002C82  4EB9 00002CE4           2718          JSR     EA_GEN_SRC
00002C88                          2719          
00002C88  4EF8 1E10               2720          JMP     EA_FINISH
00002C8C                          2721  *------------------------------------------------------------------------------------------------*
00002C8C                          2722  EA_BRANCH       ; 9: ea_branch
00002C8C  14FC 0020               2723          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C90  14FC 0020               2724          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C94  14FC 0020               2725          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C98  14FC 0020               2726          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C9C  14FC 0020               2727          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002CA0  14FC 0020               2728          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002CA4                          2729  
00002CA4  2600                    2730          MOVE.L  D0,D3               ; D0 is current instruction word
00002CA6  0243 00F0               2731          ANDI.W  #third_nibble,D3   ; Extract 3rd nibble from instruction word
00002CAA  1A3C 0004               2732          MOVE.B  #right4,D5
00002CAE                          2733          
00002CAE  2800                    2734          MOVE.L  D0,D4               ; D0 is current instruction word
00002CB0  0244 000F               2735          ANDI.W  #fourth_nibble,D4   ; Extract 4th nibble from instruction word
00002CB4                          2736           
00002CB4  B63C 0000               2737          CMP.B   #0,D3               ; check if 3rd nibble is 0. 
00002CB8  6700 0006               2738          BEQ     FOURTH_NIBBLE_CHECK
00002CBC                          2739          
00002CBC  6000 0018               2740          BRA     BRANCH_WORD_CHECK
00002CC0                          2741          
00002CC0                          2742  FOURTH_NIBBLE_CHECK                 
00002CC0  B83C 0000               2743          CMP.B   #0,D4               ; check if the 4th nibble is 0. 
00002CC4                          2744          
00002CC4  3A15                    2745          MOVE.W  (A5),D5            ; store the 16-bit displacement into D5
00002CC6                          2746          
00002CC6  260D                    2747          MOVE.L  A5,D3              ; Store A5 address into D3
00002CC8                          2748          
00002CC8  DA43                    2749          ADD.W   D3,D5              ; Add the address to D5 to get the displacement. 
00002CCA                          2750          
00002CCA  14FC 0024               2751          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002CCE                          2752          
00002CCE  4EB8 11F6               2753          JSR     ITOA_WORD_BRANCH    ; Print. 
00002CD2                          2754  
00002CD2  4EF8 1E10               2755          JMP     EA_FINISH
00002CD6                          2756  
00002CD6                          2757  BRANCH_WORD_CHECK
00002CD6  4245                    2758          CLR     D5                  ; handles 8-bit displacement. 
00002CD8  DA03                    2759          ADD.B   D3,D5               ; add d3 and d4 to d5
00002CDA  DA04                    2760          ADD.B   D4,D5
00002CDC                          2761          
00002CDC  4EB8 11C8               2762          JSR     ITOA_BYTE_BRANCH    ; Print. 
00002CE0                          2763  
00002CE0  4EF8 1E10               2764          JMP     EA_FINISH
00002CE4                          2765  
00002CE4                          2766  EA_GEN_SRC
00002CE4  41F9 00002CF2           2767          LEA     EA_GEN_TABLE_SRC, A0
00002CEA  C6FC 0006               2768          MULU    #6, D3              ; use D3 to jump to the proper src mode and dst mode. 
00002CEE  4EF0 3000               2769          JMP     0(A0,D3)            ; jump to each ea src generation table entry 
00002CF2                          2770  
00002CF2                          2771  EA_GEN_TABLE_SRC
00002CF2  4EF9 00002D22           2772          JMP     EA_Dn                       ; 000: Dn
00002CF8  4EF9 00002D2E           2773          JMP     EA_An                       ; 001: An
00002CFE  4EF9 00002D3A           2774          JMP     EA_An_Indirect              ; 010: (An)
00002D04  4EF9 00002D4E           2775          JMP     EA_An_Indirect_Inc          ; 011: (An)+
00002D0A  4EF9 00002D66           2776          JMP     EA_An_Indirect_Dec          ; 100: -(An)
00002D10  4EF9 00002D7E           2777          JMP     EA_UNSUPPORTED              ; 101: Unsupported EA
00002D16  4EF9 00002D7E           2778          JMP     EA_UNSUPPORTED              ; 110: Unsupported EA
00002D1C  4EF9 00002D82           2779          JMP     EA_Absolute_And_Immediate   ; 111: (xxx).W,(xxx).L, or #<data>
00002D22                          2780  
00002D22                          2781  EA_Dn               ; 000: Dn
00002D22  14FC 0044               2782          MOVE.B  #'D',(A2)+
00002D26  0604 0030               2783          ADDI.B  #$30,D4
00002D2A  14C4                    2784          MOVE.B  D4,(A2)+
00002D2C  4E75                    2785          RTS
00002D2E                          2786  
00002D2E                          2787  EA_An               ; 001: An
00002D2E  14FC 0041               2788          MOVE.B  #'A',(A2)+
00002D32  0604 0030               2789          ADDI.B  #$30,D4
00002D36  14C4                    2790          MOVE.B  D4,(A2)+
00002D38  4E75                    2791          RTS
00002D3A                          2792  
00002D3A                          2793  EA_An_Indirect      ; 010: (An)
00002D3A  14FC 0028               2794          MOVE.B  #'(',(A2)+
00002D3E  14FC 0041               2795          MOVE.B  #'A',(A2)+
00002D42  0604 0030               2796          ADDI.B  #$30,D4
00002D46  14C4                    2797          MOVE.B  D4,(A2)+
00002D48  14FC 0029               2798          MOVE.B  #')',(A2)+
00002D4C  4E75                    2799          RTS
00002D4E                          2800          
00002D4E                          2801  EA_An_Indirect_Inc  ; 011: (An)+
00002D4E  14FC 0028               2802          MOVE.B  #'(',(A2)+
00002D52  14FC 0041               2803          MOVE.B  #'A',(A2)+
00002D56  0604 0030               2804          ADDI.B  #$30, D4
00002D5A  14C4                    2805          MOVE.B  D4,(A2)+
00002D5C  14FC 0029               2806          MOVE.B  #')',(A2)+
00002D60  14FC 002B               2807          MOVE.B  #'+',(A2)+
00002D64  4E75                    2808          RTS
00002D66                          2809          
00002D66                          2810  EA_An_Indirect_Dec  ; 100: -(An)
00002D66  14FC 002D               2811          MOVE.B  #'-',(A2)+
00002D6A  14FC 0028               2812          MOVE.B  #'(',(A2)+
00002D6E  14FC 0041               2813          MOVE.B  #'A',(A2)+
00002D72  0604 0030               2814          ADDI.B  #$30,D4
00002D76  14C4                    2815          MOVE.B  D4,(A2)+
00002D78  14FC 0029               2816          MOVE.B  #')',(A2)+
00002D7C  4E75                    2817          RTS
00002D7E                          2818  
00002D7E                          2819  EA_UNSUPPORTED
00002D7E  6000 00CA               2820          BRA     EA_ERROR
00002D82                          2821          
00002D82                          2822  EA_Absolute_And_Immediate           ; 111: (xxx).W,(xxx).L, or #<data>
00002D82  B83C 0000               2823          CMP.B   #0,D4               ; If D4 is (xxx).W
00002D86  6700 0016               2824          BEQ     ABSOLUTE_WORD
00002D8A                          2825          
00002D8A  B83C 0001               2826          CMP.B   #1,D4               ; If D4 is (xxx).L
00002D8E  6700 001A               2827          BEQ     ABSOLUTE_LONG
00002D92                          2828          
00002D92  B83C 0004               2829          CMP.B   #4,D4               ; If D4 is #<data>  
00002D96  6700 001E               2830          BEQ     IMMEDIATE
00002D9A                          2831          
00002D9A  6000 00AE               2832          BRA     EA_ERROR    
00002D9E                          2833  
00002D9E                          2834  ABSOLUTE_WORD
00002D9E  14FC 0024               2835          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002DA2  7401                    2836          MOVE.L  #1,D2               ; Insert 1 to D2 
00002DA4  4EB8 1132               2837          JSR     ITOA                ; Convert word hex values to ITOA
00002DA8  4E75                    2838          RTS
00002DAA                          2839          
00002DAA                          2840  ABSOLUTE_LONG
00002DAA  14FC 0024               2841          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002DAE  7402                    2842          MOVE.L  #2,D2               ; Insert 2 to D2
00002DB0  4EB8 1132               2843          JSR     ITOA                ; Convert long hex values to ITOA
00002DB4  4E75                    2844          RTS
00002DB6                          2845     
00002DB6                          2846  IMMEDIATE
00002DB6  14FC 0023               2847          MOVE.B  #$23,(A2)+          ; Add # symbol
00002DBA  14FC 0024               2848          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002DBE                          2849  
00002DBE  BC3C 0001               2850          CMP.B   #1,D6               ; If MOVE.b (code0001)
00002DC2  6700 0020               2851          BEQ     DO_ITOA_MOVE
00002DC6  BC3C 0002               2852          CMP.B   #2, D6              ; If MOVE.l / MOVEA.l (code0010)
00002DCA  6700 0018               2853          BEQ     DO_ITOA_MOVE
00002DCE  BC3C 0003               2854          CMP.B   #3, D6              ; If MOVE.w / MOVEA.w (code0011)
00002DD2  6700 0010               2855          BEQ     DO_ITOA_MOVE        
00002DD6  BC3C 000D               2856          CMP.B   #13, D6             ; If ADD / ADDA (code1101)
00002DDA  6700 000E               2857          BEQ     DO_ITOA_OPMODE
00002DDE                          2858          
00002DDE  4EB8 1132               2859          JSR     ITOA                ; Go to ITOA when not a move instruction
00002DE2  4E75                    2860          RTS
00002DE4                          2861          
00002DE4                          2862  DO_ITOA_MOVE
00002DE4  4EB8 1154               2863          JSR ITOA_MOVE
00002DE8  4E75                    2864          RTS
00002DEA                          2865                
00002DEA                          2866  DO_ITOA_OPMODE
00002DEA  4EB8 1176               2867          JSR ITOA_OPMODE
00002DEE  4E75                    2868          RTS
00002DF0                          2869  
00002DF0                          2870  An_CHECK 
00002DF0  B63C 0001               2871          CMP.B   #1,D3               ; If mode is An     
00002DF4  6700 0054               2872          BEQ     EA_ERROR            ; Then branch to error message
00002DF8  4E75                    2873          RTS   
00002DFA                          2874        
00002DFA                          2875  Dn_CHECK 
00002DFA  B63C 0000               2876          CMP.B   #0,D3               ; If mode is Dn     
00002DFE  6700 004A               2877          BEQ     EA_ERROR            ; Then branch to error message
00002E02  4E75                    2878          RTS  
00002E04                          2879                
00002E04                          2880  IMMEDIATE_CHECK
00002E04  B63C 0007               2881          CMP.B   #7,D3
00002E08  6700 0004               2882          BEQ     IMMEDIATE_REGISTER_CHECK
00002E0C  4E75                    2883          RTS
00002E0E                          2884          
00002E0E                          2885  IMMEDIATE_REGISTER_CHECK
00002E0E  B83C 0004               2886          CMP.B   #4,D4               ; If 100 in register
00002E12  6700 0036               2887          BEQ     EA_ERROR            ; Branch to invalid
00002E16  4E75                    2888          RTS   
00002E18                          2889                     
00002E18                          2890  OP_ERROR  
00002E18  14FC 0044               2891          MOVE.B  #'D',(A2)+
00002E1C  14FC 0041               2892          MOVE.B  #'A',(A2)+
00002E20  14FC 0054               2893          MOVE.B  #'T',(A2)+
00002E24  14FC 0041               2894          MOVE.B  #'A',(A2)+
00002E28  14FC 0020               2895          MOVE.B  #' ',(A2)+
00002E2C  14FC 0020               2896          MOVE.B  #' ',(A2)+
00002E30  14FC 0020               2897          MOVE.B  #' ',(A2)+
00002E34  14FC 0020               2898          MOVE.B  #' ',(A2)+
00002E38  14FC 0020               2899          MOVE.B  #' ',(A2)+
00002E3C  14FC 0024               2900          MOVE.B  #'$',(A2)+
00002E40  3A00                    2901          MOVE.W  D0,D5
00002E42  4EB8 1218               2902          JSR     ITOA_WORD_ERROR
00002E46  4EF8 13CC               2903          JMP     OP_FINISH
00002E4A                          2904          
00002E4A                          2905  EA_ERROR
00002E4A  45F9 00005009           2906          LEA     error_buffer,A2
00002E50  7637                    2907          MOVE.L  #55,D3 
00002E52                          2908         
00002E52                          2909  EA_ERROR_LOOP
00002E52  14FC 0000               2910          MOVE.B  #0,(A2)+
00002E56  5343                    2911          SUBI    #1,D3
00002E58  6EF8                    2912          BGT     EA_ERROR_LOOP
00002E5A  45F9 00005009           2913          LEA     error_buffer,A2
00002E60  14FC 0044               2914          MOVE.B  #'D',(A2)+
00002E64  14FC 0041               2915          MOVE.B  #'A',(A2)+
00002E68  14FC 0054               2916          MOVE.B  #'T',(A2)+
00002E6C  14FC 0041               2917          MOVE.B  #'A',(A2)+
00002E70  14FC 0020               2918          MOVE.B  #' ',(A2)+
00002E74  14FC 0020               2919          MOVE.B  #' ',(A2)+
00002E78  14FC 0020               2920          MOVE.B  #' ',(A2)+
00002E7C  14FC 0020               2921          MOVE.B  #' ',(A2)+
00002E80  14FC 0020               2922          MOVE.B  #' ',(A2)+
00002E84  14FC 0024               2923          MOVE.B  #'$',(A2)+
00002E88  3A00                    2924          MOVE.W  D0,D5
00002E8A  4EB8 1218               2925          JSR     ITOA_WORD_ERROR
00002E8E  4EF8 1E10               2926          JMP     EA_FINISH
00002E92                          2927          
00002E92  FFFF FFFF               2928  DONE    SIMHALT             ; halt simulator
00002E96                          2929  
00002E96                          2930  * Put variables and constants here
00002E96                          2931      
00002E96  =00000040               2932  buffer_size         EQU         64 
00002E96  =00005000               2933  decoded_buffer      EQU         $5000  
00002E96  =00005009               2934  error_buffer        EQU         $5009
00002E96  =0000000D               2935  CR                  EQU         $0D
00002E96  =0000000A               2936  LF                  EQU         $0A
00002E96  =0000A000               2937  stack               EQU         $0000A000
00002E96  =0000001E               2938  lines_p_screen      EQU         30
00002E96  =00000003               2939  right3              EQU         3
00002E96  =00000004               2940  right4              EQU         4
00002E96  =00000006               2941  right6              EQU         6
00002E96  =00000008               2942  right8              EQU         8
00002E96  =00000009               2943  right9              EQU         9
00002E96  =0000000C               2944  right12             EQU         12
00002E96  =00000010               2945  right16             EQU         16
00002E96  =00000018               2946  right24             EQU         24
00002E96= 20                      2947  ascii_y_n           DC.B        32
00002E97  =00000059               2948  y_uppercase         EQU         $59         
00002E97  =00000079               2949  y_lowercase         EQU         $79
00002E97  =0000004E               2950  n_uppercase         EQU         $4E
00002E97  =0000006E               2951  n_lowercase         EQU         $6E
00002E97  =00000002               2952  task2               EQU         $02
00002E97  =00000005               2953  task5               EQU         $05
00002E97  =00000009               2954  task9               EQU         $09
00002E97  =0000000D               2955  task13              EQU         $0D
00002E97  =0000000E               2956  task14              EQU         $0E
00002E97  =0000F000               2957  first_nibble        EQU         $F000
00002E97  =00000F00               2958  second_nibble       EQU         $0F00   
00002E97  =000000F0               2959  third_nibble        EQU         $00F0
00002E97  =0000000F               2960  fourth_nibble       EQU         $000F
00002E97  =000000FF               2961  second_half         EQU         $00FF
00002E97  =000001C0               2962  dst_mode            EQU         $01C0
00002E97  =00000E00               2963  dst_reg             EQU         $0E00
00002E97  =00000038               2964  src_mode            EQU         $0038
00002E97  =00000007               2965  src_reg             EQU         $0007
00002E97  =00000100               2966  bit8                EQU         $0100
00002E97                          2967  
00002E97  =00000000               2968  ea_type_immediate   EQU     0       ; EA Type = immediate
00002E97  =00000001               2969  ea_type_move        EQU     1       ; EA Type = move
00002E97  =00000002               2970  ea_type_movea       EQU     2       ; EA Type = movea
00002E97  =00000003               2971  ea_type_lea         EQU     3       ; EA Type = lea
00002E97  =00000004               2972  ea_type_dstonly     EQU     4       ; EA Type = clr, neg, not, jsr, jmp
00002E97  =00000005               2973  ea_type_ext         EQU     5       ; EA Type = ext, add, adda
00002E97  =00000006               2974  ea_type_movem       EQU     6       ; EA Type = movem
00002E97  =00000007               2975  ea_type_shifts      EQU     7       ; EA Type = ASL/ASR/LSL/LSR/ROL/ROR
00002E97  =00000008               2976  ea_type_quick       EQU     8       ; EA Type = addq, subq
00002E97  =00000009               2977  ea_type_branch      EQU     9       ; EA Type = bra, bsr, bcc
00002E97                          2978             
00002E97= 57 65 6C 63 6F 6D ...   2979  WELCOME             DC.B        'Welcome to the 68k Disassembler of Avery and Alan',CR,LF,CR,LF,0
00002ECD                          2980  
00002ECD= 50 6C 65 61 73 65 ...   2981  USER_INST           DC.B        'Please follow the proper input instructions below: ',CR,LF
00002F02= 2D 20 53 74 61 72 ...   2982                      DC.B        '- Starting address must be lower than ending address.',CR,LF
00002F39= 2D 20 54 68 65 20 ...   2983                      DC.B        '- The values for the starting and ending address must be an even value.',CR,LF
00002F82= 2D 20 53 74 61 72 ...   2984                      DC.B        '- Starting and ending address must be inputted as hexadecimal value.',CR,LF
00002FC8= 2D 20 44 6F 20 6E ...   2985                      DC.B        '- Do not put spaces in between input characters.',CR,LF
00002FFA= 2D 20 56 61 6C 69 ...   2986                      DC.B        '- Valid characters include: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F',CR,LF,0
00003047                          2987                  
00003047= 50 72 65 73 73 20 ...   2988  ENTER_PROMPT        DC.B        'Press enter to continue...',CR,LF,0
00003064= 50 72 65 73 73 20 ...   2989  PROMPT_AGAIN        DC.B        'Press Y to continue / N to exit.',CR,LF,0
00003087= 50 72 6F 67 72 61 ...   2990  EXIT_PROMPT         DC.B        'Program has execution has stopped.',CR,LF,0
000030AC= 45 6E 74 65 72 20 ...   2991  PROMPT_V_END        DC.B        'Enter a valid ending address: ',CR,LF,0
000030CD= 45 52 52 4F 52 3A ...   2992  ERROR_MESSAGE       DC.B        'ERROR: The input is invalid.',CR,LF,0  
000030EC= 45 52 52 4F 52 3A ...   2993  ODD_ERROR_MESSAGE   DC.B        'ERROR: The last digit of the address is odd, which is invalid.',CR,LF,0
0000312D                          2994        
0000312D= 45 6E 74 65 72 20 ...   2995  START_IN            DC.B        'Enter a starting address: ',CR,LF,0 
0000314A= 45 6E 74 65 72 20 ...   2996  END_IN              DC.B        'Enter an ending address: ',CR,LF,0 
00003166                          2997  START_ADDRESS       DS.B        32     
00003186                          2998  END_ADDRESS         DS.B        32 
000031A6                          2999       
000031A6                          3000      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_LONG       2DAA
ABSOLUTE_WORD       2D9E
ADDQ_EA_CALC        2BAA
ADD_PARENTHESIS     2AC0
AND_OR_CHECK        22D4
AN_CHECK            2DF0
AN_FINISH           2A04
ASCII_TO_HEX_LETTER  109A
ASCII_Y_N           2E96
ATOI                1074
BACK_PARENTHESIS    2ACA
BIT8                100
BRANCH_WORD_CHECK   2CD6
BUFFER_SIZE         40
CHANGE_TO_001       20D6
CHANGE_TO_EIGHT     2C04
CHECK1_BIT_0        26A8
CHECK1_BIT_1        2680
CHECK1_BIT_10       24EE
CHECK1_BIT_11       24C0
CHECK1_BIT_12       2492
CHECK1_BIT_13       2464
CHECK1_BIT_14       2436
CHECK1_BIT_2        2658
CHECK1_BIT_3        2630
CHECK1_BIT_4        2602
CHECK1_BIT_5        25D4
CHECK1_BIT_6        25A6
CHECK1_BIT_7        2578
CHECK1_BIT_8        254A
CHECK1_BIT_9        251C
CHECK_BIT_0         29BE
CHECK_BIT_1         2996
CHECK_BIT_10        2806
CHECK_BIT_11        27D8
CHECK_BIT_12        27AA
CHECK_BIT_13        277C
CHECK_BIT_14        274E
CHECK_BIT_2         296E
CHECK_BIT_3         2946
CHECK_BIT_4         2918
CHECK_BIT_5         28EA
CHECK_BIT_6         28BC
CHECK_BIT_7         288E
CHECK_BIT_8         2860
CHECK_BIT_9         2834
CHECK_IF_ZERO       2B50
CODE0000            1448
CODE0001            1462
CODE0010            1466
CODE0011            147E
CODE0100            1496
CODE0101            14B0
CODE0110            14B4
CODE0111            1540
CODE1000            1544
CODE1001            1564
CODE1010            1568
CODE1011            156C
CODE1100            1570
CODE1101            158A
CODE1110            15A4
CODE1111            1622
COMPLETE_END        10FC
COMPLETE_START      10F4
CONTINUE_OR_END     131E
CR                  D
D4_AN_SETONE_0      2594
D4_AN_SETONE_1      25C2
D4_AN_SETONE_2      25F0
D4_AN_SETONE_3      261E
D4_AN_SETONE_4      2646
D4_AN_SETONE_5      266E
D4_AN_SETONE_6      2696
D4_AN_SETONE_7      26BE
D4_AN_SET_0         287C
D4_AN_SET_1         2850
D4_AN_SET_2         2822
D4_AN_SET_3         27F4
D4_AN_SET_4         27C6
D4_AN_SET_5         2798
D4_AN_SET_6         276A
D4_AN_SET_7         273C
D4_DN_SETONE_0      2424
D4_DN_SETONE_1      2452
D4_DN_SETONE_2      2480
D4_DN_SETONE_3      24AE
D4_DN_SETONE_4      24DC
D4_DN_SETONE_5      250A
D4_DN_SETONE_6      2538
D4_DN_SETONE_7      2566
D4_DN_SET_0         29D4
D4_DN_SET_1         29AC
D4_DN_SET_2         2984
D4_DN_SET_3         295C
D4_DN_SET_4         2934
D4_DN_SET_5         2906
D4_DN_SET_6         28D8
D4_DN_SET_7         28AA
DECODED_BUFFER      5000
DECODE_MEMORY       1396
DECODE_PAUSE        130A
DECODING_ITERATION  12E6
DISP_UI             100C
DISP_W              1000
DN_CHECK            2DFA
DN_DST              224A
DN_SRC              2288
DONE                2E92
DONT_CHANGE         2C08
DO_ITOA_MOVE        2DE4
DO_ITOA_OPMODE      2DEA
DST_MODE            1C0
DST_REG             E00
EA_ABSOLUTE_AND_IMMEDIATE  2D82
EA_ADDA             2364
EA_AN               2D2E
EA_AND              22E6
EA_AN_INDIRECT      2D3A
EA_AN_INDIRECT_DEC  2D66
EA_AN_INDIRECT_INC  2D4E
EA_BRANCH           2C8C
EA_CLEAR            2110
EA_DN               2D22
EA_DSTONLY          20F0
EA_ERROR            2E4A
EA_ERROR_LOOP       2E52
EA_EXT              21B6
EA_EXT_TABLE        21D2
EA_FINISH           1E10
EA_GEN_SRC          2CE4
EA_GEN_TABLE_SRC    2CF2
EA_IMMEDIATE        1F34
EA_JSR              215E
EA_LEA              206C
EA_MEMORY_SHIFTS    2A62
EA_MOVE             1F90
EA_MOVEA            2000
EA_MOVEM            23AC
EA_MULS_MULU_DIV    230E
EA_OPMODE_012456    2202
EA_OPMODE_37        22F6
EA_OR               22EC
EA_QUICK            2B9A
EA_REGISTER_SHIFTS  2AD8
EA_SHIFTS           2A18
EA_SHIFTS_TABLE     2A32
EA_SIZE_ADDA        1EEA
EA_SIZE_B           1F12
EA_SIZE_DONE        1F32
EA_SIZE_GENERAL     1E56
EA_SIZE_L           1F28
EA_SIZE_MEMORY_SHIFTS  1EFE
EA_SIZE_MOVE        1E72
EA_SIZE_MOVEA       1E8E
EA_SIZE_MOVEM       1EA2
EA_SIZE_OPMODE_012456  1EB6
EA_SIZE_W           1F1C
EA_SIZE_W_MEMORY    1F26
EA_START            1DFE
EA_TYPE_BRANCH      9
EA_TYPE_DSTONLY     4
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_SHIFTS      7
EA_TYPE_TABLE       1E16
EA_UNSUPPORTED      2D7E
END_ADDRESS         3186
END_IN              314A
ENTER_PROMPT        3047
ERROR_BUFFER        5009
ERROR_MESSAGE       30CD
EXIT                1386
EXIT_PROMPT         3087
FINISH_MOVEM_MEM_TO_REG  29E6
FINISH_REG_TO_MEM   26D0
FIRST_NIBBLE        F000
FOURTH_NIBBLE       F
FOURTH_NIBBLE_CHECK  2CC0
FRONT_FORMAT        2AB2
IMMEDIATE           2DB6
IMMEDIATE_CHECK     2E04
IMMEDIATE_EIGHT     2B5A
IMMEDIATE_REGISTER_CHECK  2E0E
IMMEDIATE_SRC       2B0C
INPUT_INVALID       10BC
ITOA                1132
ITOA_BYTE           11BA
ITOA_BYTE_BRANCH    11C8
ITOA_BYTE_CONVERT   12A2
ITOA_CONVERT_A_TO_F  12D2
ITOA_DONE           12DE
ITOA_LONG           1238
ITOA_LONGADDRESS    126A
ITOA_MOVE           1154
ITOA_NIBBLE_CONVERT  12C2
ITOA_OPMODE         1176
ITOA_WORD           11DA
ITOA_WORD_BRANCH    11F6
ITOA_WORD_ERROR     1218
JSR_ABSOLUTE_CHECK  21A6
JSR_AN_VALID        219C
JSR_NOP_RTS         186C
LAST_DIGIT_CHECK    10DA
LAST_DIGIT_ODD      1116
LEA_SRC_VALID       20AA
LF                  A
LINES_P_SCREEN      1E
MEMORY_1110_LEFT    15DA
MEMORY_1110_RIGHT   15FE
MEM_TO_REG          26F6
MEM_TO_REG_CONTINUE  271E
MOVEA_DST_VALID     2062
MOVEQ_EA_CALC       2C32
NOP_CHECK           189A
NOP_CHECK_THREE     18CA
NOP_CHECK_TWO       18B2
NORMAL_FINISH       2A12
N_LOWERCASE         6E
N_UPPERCASE         4E
ODD_ERROR_MESSAGE   30EC
OP_0000_TABLE       1626
OP_0100_TABLE       1686
OP_1100_TABLE       16E6
OP_1101_TABLE       1746
OP_1110_TABLE_REGISTER  17A6
OP_ADD              1D1A
OP_ADDA             1D36
OP_ADDI             194E
OP_ADDQ             1A4A
OP_AND              1CFE
OP_ASL              1D72
OP_ASR              1D56
OP_AS_CHECK         1806
OP_BCC              1ADA
OP_BCS              1AF6
OP_BEQ              1B2E
OP_BGE              1BBA
OP_BGT              1BF2
OP_BHI              1AA2
OP_BLE              1C0E
OP_BLS              1ABE
OP_BLT              1BD6
OP_BMI              1B9E
OP_BNE              1B12
OP_BPL              1B82
OP_BRA              1A6A
OP_BSR              1A86
OP_BVC              1B4A
OP_BVS              1B66
OP_CLEAR_DATA       13D2
OP_CLEAR_DATA_LOOP  13DE
OP_CLR              19B2
OP_CMP              1CA2
OP_DIVU             1C4E
OP_ERROR            2E18
OP_FINISH           13CC
OP_JSR              19EE
OP_LEA              1A2E
OP_LSL              1DAA
OP_LSR              1D8E
OP_LS_CHECK         1828
OP_MOVE             1992
OP_MOVEA            196E
OP_MOVEM            1A0A
OP_MOVEQ            1C2A
OP_MULS             1CDE
OP_MULU             1CBE
OP_NOP              19CE
OP_OR               1C6E
OP_ROL              1DE2
OP_ROR              1DC6
OP_RO_CHECK         184A
OP_RTS              19DE
OP_SUB              1C86
OP_SUBI             192E
OP_TABLE            13E8
OP_UNSUPPORTED      192A
PRINT1_A0           259C
PRINT1_A1           25CA
PRINT1_A2           25F8
PRINT1_A3           2626
PRINT1_A4           264E
PRINT1_A5           2676
PRINT1_A6           269E
PRINT1_A7           26C6
PRINT1_D0           242C
PRINT1_D1           245A
PRINT1_D2           2488
PRINT1_D3           24B6
PRINT1_D4           24E4
PRINT1_D5           2512
PRINT1_D6           2540
PRINT1_D7           256E
PRINT_A0            2884
PRINT_A1            2856
PRINT_A2            282A
PRINT_A3            27FC
PRINT_A4            27CE
PRINT_A5            27A0
PRINT_A6            2772
PRINT_A7            2744
PRINT_D0            29DC
PRINT_D1            29B4
PRINT_D2            298C
PRINT_D3            2964
PRINT_D4            293C
PRINT_D5            290E
PRINT_D6            28E0
PRINT_D7            28B2
PROMPT_AGAIN        3064
PROMPT_END          1040
PROMPT_START        1018
PROMPT_VA_END       1052
PROMPT_V_END        30AC
READ_END            1060
READ_START          102C
REGISTER_SRC        2B60
REG_TO_MEM          2406
RIGHT12             C
RIGHT16             10
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT6              6
RIGHT8              8
RIGHT9              9
RTS_CHECK           18E2
RTS_CHECK_THREE     1912
RTS_CHECK_TWO       18FA
SECOND_HALF         FF
SECOND_NIBBLE       F00
SRC_MODE            38
SRC_REG             7
STACK               A000
START               1000
START_ADDRESS       3166
START_DECODING      12E4
START_IN            312D
TASK13              D
TASK14              E
TASK2               2
TASK5               5
TASK9               9
THIRD_NIBBLE        F0
USER_INST           2ECD
VALIDATE_END        1070
VALIDATE_START      103C
WELCOME             2E97
Y_LOWERCASE         79
Y_UPPERCASE         59
