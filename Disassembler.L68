00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/8/2020 10:38:59 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler for the Motorola MC68000 Microprocessor
00000000                             3  * Written by :  Avery Mortenson & Alan Luu
00000000                             4  * Date       :  2/12/2020
00000000                             5  * Description:  An inverse assembler (disassembler) that will 
00000000                             6  * convert a memory image of instructions and data back 
00000000                             7  * to the MC68000 assembly code and that will output the 
00000000                             8  * disassembled code to the display.
00000000                             9  *-----------------------------------------------------------
00001000                            10      ORG    $1000
00001000                            11  START:            
00001000                            12  *------------------------------------------------------------*
00001000                            13  * D0: used for the tasks
00001000                            14  * D1: used to hold the size of the input obtained. 
00001000                            15  * D5: used to store the starting and ending address 
00001000                            16  * temporarily before moving them to A4 and A6 correspondingly. 
00001000                            17  * D6: used to check the last digit to see if the input 
00001000                            18  * for the starting and ending address causes a bus error. 
00001000                            19  * A1: a pointer to the message to print out. 
00001000                            20  *------------------------------------------------------------*
00001000                            21  
00001000  103C 000E                 22  DISP_W      MOVE.B  #14,D0                  ; Display Welcome Message. 
00001004  43F9 00002510             23              LEA     WELCOME,A1
0000100A  4E4F                      24              TRAP    #15
0000100C                            25  
0000100C                            26  * Put program code here
0000100C                            27  
0000100C  103C 000E                 28  DISP_UI         MOVE.B  #14,D0              ; Display User Instructions. 
00001010  43F9 00002546             29                  LEA     USER_INST,A1
00001016  4E4F                      30                  TRAP    #15    
00001018                            31  
00001018  4FF9 0000A000             32  PROMPT_START    LEA     stack, SP           ; SP = stack ($A0000)
0000101E  43F9 00002725             33                  LEA     START_IN,A1         ; Display starting address message
00001024  103C 000E                 34                  MOVE.B  #14,D0
00001028  4E4F                      35                  TRAP    #15       
0000102A                            36       
0000102A  43F9 0000275E             37  READ_START      LEA     START_ADDRESS,A1    ; Store user's starting address input
00001030  103C 0002                 38                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001034  4E4F                      39                  TRAP    #15
00001036  1C3C 0000                 40                  MOVE.B  #0,D6               ; Used to indicate we are at start address
0000103A                            41  
0000103A  6000 0022                 42  VALIDATE_START  BRA     ATOI
0000103E                            43  
0000103E  43F9 00002742             44  PROMPT_END      LEA     END_IN,A1           ; Display starting address message
00001044  103C 000E                 45                  MOVE.B  #14,D0
00001048  4E4F                      46                  TRAP    #15            
0000104A  43F9 0000277E             47  READ_END        LEA     END_ADDRESS,A1      ; Store user's starting address input
00001050  103C 0002                 48                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001054  4E4F                      49                  TRAP    #15
00001056  1C3C 0001                 50                  MOVE.B  #1,D6               ; Used to indicate we are at end address
0000105A                            51  
0000105A  6000 0002                 52  VALIDATE_END    BRA     ATOI
0000105E                            53                 
0000105E                            54  * D0 stores the value to pushed from A1.
0000105E                            55  
0000105E  1019                      56  ATOI            MOVE.B  (A1)+,D0    ; Move to next character in A1 and store in D0          
00001060  B03C 0030                 57                  CMP.B   #$30,D0
00001064  6D00 0040                 58                  BLT     INPUT_INVALID
00001068  B03C 0039                 59                  CMP.B   #$39,D0
0000106C  6E00 0016                 60                  BGT     ASCII_TO_HEX_LETTER
00001070  0400 0030                 61                  SUB.B   #$30,D0     ; Subtract by 30 to get the numbers 0-9
00001074  DA80                      62                  ADD.L   D0,D5
00001076  5341                      63                  SUBI    #1,D1       ; Decrement input's length to move to next character          
00001078  B23C 0000                 64                  CMP.B   #0,D1       ; Compare to see if we're at the last digit
0000107C  6700 0046                 65                  BEQ     LAST_DIGIT_CHECK
00001080  E98D                      66                  LSL.L   #4,D5
00001082  60DA                      67                  BRA     ATOI
00001084                            68  
00001084                            69    
00001084  B03C 0041                 70  ASCII_TO_HEX_LETTER     CMP.B   #$41,D0
00001088  6D00 001C                 71                          BLT     INPUT_INVALID
0000108C  B03C 0046                 72                          CMP.B   #$46, D0
00001090  6E00 0014                 73                          BGT     INPUT_INVALID 
00001094  0400 0031                 74                          SUB.B   #$31,D0     ; Subtract by 31 to get the numbers A-F
00001098  5D00                      75                          SUB.B   #6,D0
0000109A  DA80                      76                          ADD.L   D0,D5
0000109C  5341                      77                          SUBI    #1,D1
0000109E  6700 0024                 78                          BEQ     LAST_DIGIT_CHECK
000010A2  E98D                      79                          LSL.L   #4,D5
000010A4  60B8                      80                          BRA     ATOI     
000010A6                            81  
000010A6                            82                      
000010A6  43F9 000024B2             83  INPUT_INVALID   LEA     ERROR_MESSAGE, A1   ; Display error message
000010AC  103C 000E                 84                  MOVE.B  #14, D0
000010B0  4E4F                      85                  TRAP    #15
000010B2  4206                      86                  CLR.B   D6
000010B4                            87                  
000010B4  BC3C 0000                 88                  CMP.B   #0,D6           ; When D6 is 0
000010B8  6700 FF5E                 89                  BEQ     PROMPT_START    ; Go back to start prompt
000010BC  BC3C 0001                 90                  CMP.B   #1,D6           ; When D6 is 1
000010C0  6700 FF7C                 91                  BEQ     PROMPT_END      ; Go back to end prompt
000010C4                            92  
000010C4                            93                            
000010C4  2E05                      94  LAST_DIGIT_CHECK    MOVE.L  D5, D7          ; D7 used as temporary storage
000010C6  E20F                      95                      LSR.B   #1, D7          ; Check for carry bit to see if last digit is odd
000010C8  6500 002E                 96                      BCS     LAST_DIGIT_ODD  ; branch when there is a carry; this indicates odd last digit 
000010CC  4287                      97                      CLR.L   D7
000010CE  BC3C 0000                 98                      CMP.B   #0,D6
000010D2  6700 000A                 99                      BEQ     COMPLETE_START  
000010D6  BC3C 0001                100                      CMP.B   #1,D6
000010DA  6700 000A                101                      BEQ     COMPLETE_END
000010DE                           102  
000010DE  2845                     103  COMPLETE_START      MOVEA.L D5, A4  ; A4 holds the starting address
000010E0  4285                     104                      CLR.L   D5 
000010E2  6000 FF5A                105                      BRA PROMPT_END
000010E6                           106  
000010E6  2C45                     107  COMPLETE_END        MOVEA.L D5, A6  ; A6 holds the ending address
000010E8  2A4C                     108                      MOVEA.L A4, A5  ; Store starting address into current address
000010EA                           109                      
000010EA                           110                      *Clear the data and address registers used to obtain the starting and ending address 
000010EA  4280                     111                      CLR.L   D0
000010EC  4285                     112                      CLR.L   D5
000010EE  4286                     113                      CLR.L   D6
000010F0  327C 0000                114                      MOVEA   #0, A1
000010F4  6000 017C                115                      BRA     START_DECODING  ; All inputs are valid, go to the decode process
000010F8                           116                      
000010F8  43F9 000024D0            117  LAST_DIGIT_ODD      LEA     ODD_ERROR_MESSAGE, A1 
000010FE  103C 000E                118                      MOVE.B  #14, D0
00001102  4E4F                     119                      TRAP    #15
00001104                           120                      
00001104  BC3C 0000                121                      CMP.B   #0,D6           ; When D6 is 0
00001108  6700 FF0E                122                      BEQ     PROMPT_START    ; Go back to start prompt
0000110C  BC3C 0001                123                      CMP.B   #1,D6           ; When D6 is 1
00001110  6700 FF2C                124                      BEQ     PROMPT_END      ; Go back to end prompt
00001114                           125  
00001114                           126  *--------------------------------------------------------------------------------------
00001114                           127  * param D2 data size to convert into ASCII
00001114                           128  * param A2 a pointer to decode_buf
00001114                           129  * param A5 the current address
00001114                           130  * itoa (D2, A2, A5) {
00001114                           131  * D0 byte data in ACII
00001114                           132  * D1 #sfhit
00001114                           133  * D7 long data to convert into ASCII
00001114                           134  * }
00001114                           135          
00001114                           136  ITOA                                ; convert integer to ASCII  
00001114  48E7 C000                137          MOVEM.L D0-D1,-(SP) 
00001118  B43C 0000                138          CMP.B   #%00, D2            ; byte
0000111C  6700 007E                139          BEQ     ITOA_BYTE
00001120  B43C 0001                140          CMP.B   #%01, D2            ; word
00001124  6700 0084                141          BEQ     ITOA_WORD
00001128  B43C 0002                142          CMP.B   #%10, D2            ; long
0000112C  6700 0098                143          BEQ     ITOA_LONG
00001130  4EF9 000011F8            144          JMP     ITOA_LONGADDRESS    ; long address
00001136                           145          
00001136                           146  ITOA_MOVE                           ; convert integer to ASCII
00001136  48E7 C000                147          MOVEM.L D0-D1,-(SP) 
0000113A  B43C 0001                148          CMP.B   #%01, D2            ; byte
0000113E  6700 005C                149          BEQ     ITOA_BYTE
00001142  B43C 0003                150          CMP.B   #%11, D2            ; word
00001146  6700 0062                151          BEQ     ITOA_WORD
0000114A  B43C 0002                152          CMP.B   #%10,D2             ; long
0000114E  6700 0076                153          BEQ     ITOA_LONG
00001152  4EF9 000011F8            154          JMP     ITOA_LONGADDRESS    ; long address
00001158                           155          
00001158                           156  ITOA_OPMODE                         ; convert integer to ASCII
00001158  48E7 C000                157          MOVEM.L D0-D1,-(SP) 
0000115C  B43C 0000                158          CMP.B   #%000,D2            ; When 0 then byte
00001160  6700 003A                159          BEQ     ITOA_BYTE
00001164  B43C 0004                160          CMP.B   #%100,D2            ; When 4 then byte
00001168  6700 0032                161          BEQ     ITOA_BYTE 
0000116C  B43C 0001                162          CMP.B   #%001,D2            ; When 1 then word
00001170  6700 0038                163          BEQ     ITOA_WORD
00001174  B43C 0003                164          CMP.B   #%011,D2            ; When 3 then word
00001178  6700 0030                165          BEQ     ITOA_WORD
0000117C  B43C 0005                166          CMP.B   #%101,D2            ; When 5 then word
00001180  6700 0028                167          BEQ     ITOA_WORD 
00001184  B43C 0002                168          CMP.B   #%010,D2            ; When 2 then long
00001188  6700 003C                169          BEQ     ITOA_LONG
0000118C  B43C 0006                170          CMP.B   #%110,D2            ; When 6 then long
00001190  6700 0034                171          BEQ     ITOA_LONG
00001194  B43C 0007                172          CMP.B   #%111,D2            ; When 7 then long
00001198  6700 002C                173          BEQ     ITOA_LONG
0000119C                           174          
0000119C                           175  ITOA_BYTE
0000119C  3E1D                     176          MOVE.W  (A5)+,D7
0000119E  4EB9 00001230            177          JSR     ITOA_BYTE_CONVERT
000011A4  4EF9 0000126C            178          JMP     ITOA_DONE
000011AA                           179          
000011AA                           180  ITOA_WORD
000011AA  3E15                     181          MOVE.W  (A5),D7
000011AC  123C 0008                182          MOVE.B  #right8, D1
000011B0  E26F                     183          LSR.W   D1,D7
000011B2  4EB9 00001230            184          JSR     ITOA_BYTE_CONVERT
000011B8  3E1D                     185          MOVE.W  (A5)+, D7
000011BA  4EB9 00001230            186          JSR     ITOA_BYTE_CONVERT
000011C0  4EF9 0000126C            187          JMP     ITOA_DONE
000011C6                           188          
000011C6                           189  ITOA_LONG
000011C6  3E15                     190          MOVE.W  (A5),D7
000011C8  123C 0008                191          MOVE.B  #right8, D1
000011CC  E26F                     192          LSR.W   D1, D7
000011CE  4EB9 00001230            193          JSR     ITOA_BYTE_CONVERT
000011D4  3E1D                     194          MOVE.W  (A5)+, D7
000011D6  4EB9 00001230            195          JSR     ITOA_BYTE_CONVERT
000011DC                           196          
000011DC  3E15                     197          MOVE.W  (A5),D7
000011DE  123C 0008                198          MOVE.B  #right8, D1
000011E2  E26F                     199          LSR.W   D1, D7
000011E4  4EB9 00001230            200          JSR     ITOA_BYTE_CONVERT
000011EA  3E1D                     201          MOVE.W  (A5)+, D7
000011EC  4EB9 00001230            202          JSR     ITOA_BYTE_CONVERT
000011F2  4EF9 0000126C            203          JMP     ITOA_DONE
000011F8                           204  
000011F8                           205  ITOA_LONGADDRESS
000011F8  3E0D                     206          MOVE.W  A5,D7
000011FA  123C 0018                207          MOVE.B  #right24,D1
000011FE  E26F                     208          LSR.W   D1,D7
00001200  4EB9 00001230            209          JSR     ITOA_BYTE_CONVERT
00001206  3E0D                     210          MOVE.W  A5,D7
00001208  123C 0010                211          MOVE.B  #right16,D1
0000120C  E26F                     212          LSR.W   D1,D7
0000120E  4EB9 00001230            213          JSR     ITOA_BYTE_CONVERT
00001214  3E0D                     214          MOVE.W  A5,D7
00001216  123C 0008                215          MOVE.B  #right8,D1
0000121A  E26F                     216          LSR.W   D1,D7
0000121C  4EB9 00001230            217          JSR     ITOA_BYTE_CONVERT
00001222  3E0D                     218          MOVE.W  A5,D7
00001224  4EB9 00001230            219          JSR     ITOA_BYTE_CONVERT   
0000122A  4EF9 0000126C            220          JMP     ITOA_DONE   
00001230                           221  
00001230                           222  ITOA_BYTE_CONVERT
00001230  3007                     223          MOVE.W  D7, D0 
00001232  0240 00F0                224          ANDI.W  #$F0, D0
00001236  123C 0004                225          MOVE.B  #right4, D1
0000123A  E268                     226          LSR.W   D1, D0
0000123C  4EB9 00001250            227          JSR     ITOA_NIBBLE_CONVERT
00001242                           228          
00001242  3007                     229          MOVE.W  D7, D0
00001244  0240 000F                230          ANDI.W  #$0F, D0
00001248  4EB9 00001250            231          JSR     ITOA_NIBBLE_CONVERT
0000124E  4E75                     232          RTS
00001250                           233          
00001250                           234  ITOA_NIBBLE_CONVERT
00001250  B03C 0009                235          CMP.B   #9, D0
00001254  6E00 000A                236          BGT     ITOA_CONVERT_A_TO_F
00001258  0600 0030                237          ADD.B   #$30, D0
0000125C  14C0                     238          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
0000125E  4E75                     239          RTS
00001260                           240          
00001260                           241  ITOA_CONVERT_A_TO_F
00001260  0400 000A                242          SUBI.B  #10, D0
00001264  0600 0041                243          ADDI.B  #$41, D0
00001268  14C0                     244          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
0000126A  4E75                     245          RTS
0000126C                           246  
0000126C                           247  ITOA_DONE
0000126C  4CDF 0003                248          MOVEM.L (SP)+, D0-D1
00001270  4E75                     249          RTS
00001272                           250  
00001272                           251  *-------------------------------------------------------------------------------*
00001272                           252  START_DECODING
00001272  4282                     253          CLR.L   D2
00001274                           254          
00001274                           255  DECODING_ITERATION
00001274                           256          ;decoding the current address
00001274  4EB9 000012FC            257          JSR     DECODE_MEMORY
0000127A  103C 000D                258          MOVE.B  #task13, D0
0000127E  43F9 00005000            259          LEA     decoded_buffer, A1
00001284  4E4F                     260          TRAP    #15
00001286                           261          
00001286                           262          ;check if decoding has finished or if the screen is filled 
00001286  BDCD                     263          CMP.L   A5, A6
00001288  6F00 0022                264          BLE     CONTINUE_OR_END     ; If A6-A5 <= 0, go to CONTINUE_OR_END 
0000128C                           265          
0000128C                           266          ;have yet to reach the ending address
0000128C  5202                     267          ADDQ.B  #1, D2              ; D2 (screen_line_counter)++
0000128E  B43C 0014                268          CMP.B   #lines_p_screen, D2
00001292  6C00 0004                269          BGE     DECODE_PAUSE
00001296                           270          ;not yet reached the maximum lines per screen. 
00001296  60DC                     271          BRA     DECODING_ITERATION
00001298                           272  
00001298                           273  DECODE_PAUSE
00001298  103C 000E                274          MOVE.B  #task14, D0
0000129C  43F9 000026C0            275          LEA     ENTER_PROMPT, A1
000012A2  4E4F                     276          TRAP    #15
000012A4  103C 0005                277          MOVE.B  #task5, D0
000012A8  4E4F                     278          TRAP    #15
000012AA  60C6                     279          BRA     START_DECODING
000012AC                           280  
000012AC                           281  CONTINUE_OR_END
000012AC  103C 000E                282          MOVE.B  #task14, D0
000012B0  43F9 000026DD            283          LEA     PROMPT_AGAIN, A1
000012B6  4E4F                     284          TRAP    #15
000012B8                           285          
000012B8  103C 0002                286          MOVE.B  #task2, D0
000012BC  43F9 000023AA            287          LEA     ascii_y_n, A1
000012C2  4E4F                     288          TRAP    #15
000012C4                           289          
000012C4  1639 000023AA            290          MOVE.B  ascii_y_n, D3
000012CA  0C03 0059                291          CMPI.B  #y_uppercase, D3
000012CE  6700 FD48                292          BEQ     PROMPT_START
000012D2  0C03 0079                293          CMPI.B  #y_lowercase, D3
000012D6  6700 FD40                294          BEQ     PROMPT_START
000012DA  0C03 004E                295          CMPI.B  #n_uppercase, D3
000012DE  6700 000C                296          BEQ     EXIT
000012E2  0C03 006E                297          CMPI.B  #n_lowercase, D3
000012E6  6700 0004                298          BEQ     EXIT
000012EA  60C0                     299          BRA     CONTINUE_OR_END 
000012EC                           300          
000012EC                           301  EXIT
000012EC  103C 000E                302          MOVE.B  #task14, D0
000012F0  43F9 00002700            303          LEA     EXIT_PROMPT, A1
000012F6  4E4F                     304          TRAP    #15  
000012F8  6000 10AC                305          BRA     DONE             
000012FC                           306  *---------------------------------------------------------------------------------*
000012FC                           307  * D0: the current instruction. 
000012FC                           308  * D1: used as temp storage
000012FC                           309  * D2: data size 
000012FC                           310  * D3: loop counter for the amount of lines per screen. 
000012FC                           311  * D4: 
000012FC                           312  * D5: #shifts
000012FC                           313  * D6: store first nibble
000012FC                           314  * D7: 
000012FC                           315  * A0: 
000012FC                           316  * A1: A pointer to the message to print out. 
000012FC                           317  * A2: A pointer to the decode_buffer. 
000012FC                           318  * A3: 
000012FC                           319  * A4: Store the starting address and increment to the ending address. 
000012FC                           320  * A5: The current address. 
000012FC                           321  * A6: Store the ending address. 
000012FC                           322  * A7: Stack pointer. 
000012FC                           323  *---------------------------------------------------------------------------------*                             
000012FC                           324  DECODE_MEMORY       
000012FC  48E7 2002                325          MOVEM.L D2/A6, -(SP)
00001300                           326                  
00001300                           327          ;zero clear the decode_buffer
00001300  4EB9 00001338            328          JSR     OP_CLEAR_DATA
00001306  45F9 00005000            329          LEA     decoded_buffer, A2  Load decode buffer into A2
0000130C                           330                  
0000130C                           331          ;print out the current address
0000130C  7403                     332          MOVE.L  #$0003, D2
0000130E  4EB8 1114                333          JSR      ITOA
00001312                           334          
00001312  14FC 0009                335          MOVE.B  #$9, (A2)+  ; Add space after long address
00001316                           336                  
00001316                           337          ;load the next instruction and jump to the opcode table entry
00001316  41F9 0000134E            338          LEA     OP_TABLE, A0
0000131C  4280                     339          CLR.L   D0
0000131E  301D                     340          MOVE.W  (A5)+, D0       ; Store A5's value into D0, then increment A5
00001320  2200                     341          MOVE.L  D0, D1          ; Store A5's value from D0 into D1
00001322  1A3C 000C                342          MOVE.B  #right12, D5    ; Store 12 into D5
00001326  EA69                     343          LSR.W   D5, D1          ; Shift first nibble into LSB position
00001328  2C01                     344          MOVE.L  D1, D6          ; Store first nibble into D6
0000132A  C2FC 0006                345          MULU    #6, D1          ; Multiply 6 to D1
0000132E  4EF0 1000                346          JMP     0(A0, D1)       ; Go to displacement (A0 + D1 * 6)      
00001332                           347  OP_FINISH
00001332  4CDF 4004                348          MOVEM.L (SP)+, D2/A6,
00001336  4E75                     349          RTS
00001338                           350  
00001338                           351  *------------------------------------------------------------------------------------*
00001338                           352  *Clear the 32 bits within the decoded_buffer       
00001338                           353  OP_CLEAR_DATA
00001338  4283                     354          CLR.L   D3
0000133A  163C 0040                355          MOVE.B  #buffer_size, D3
0000133E  45F9 00005000            356          LEA     decoded_buffer, A2
00001344                           357          
00001344                           358  OP_CLEAR_DATA_LOOP
00001344  14FC 0000                359          MOVE.B  #0, (A2)+
00001348  5343                     360          SUBI    #1, D3
0000134A  6EF8                     361          BGT     OP_CLEAR_DATA_LOOP
0000134C  4E75                     362          RTS
0000134E                           363  
0000134E                           364  *------------------------------------------------------------------------------------*
0000134E                           365  OP_TABLE
0000134E  4EF9 000013AE            366          JMP     code0000    ; ADDI.bwl/ ANDI.bwl / CMPI.bwl / EORI.bwl / ORI.bwl / SUBI.bwl 
00001354  4EF9 000013C8            367          JMP     code0001    ; MOVE.b
0000135A  4EF9 000013CC            368          JMP     code0010    ; MOVE.l / MOVEA.l
00001360  4EF9 000013E4            369          JMP     code0011    ; MOVE.w / MOVEA.w
00001366  4EF9 000013FC            370          JMP     code0100    ; CLR.bwl / JMP / JSR / LEA / MOVEM.wl / NOP / NOT.bwl / RTS / STOP / TRAP
0000136C  4EF9 00001416            371          JMP     code0101    ; ADDQ.bwl / SUBQ.bwl / Scc / Dbcc
00001372  4EF9 0000141A            372          JMP     code0110    ; BRA.bw / BSR.bw / Bcc.bw
00001378  4EF9 00001432            373          JMP     code0111    ; MOVEQ
0000137E  4EF9 00001436            374          JMP     code1000    ; DIVS / DIVU / CR.bwl
00001384  4EF9 00001456            375          JMP     code1001    ; SUB.bwl / SUBA.wl
0000138A  4EF9 0000145A            376          JMP     code1010    ;   [unassigned]
00001390  4EF9 0000145E            377          JMP     code1011    ; CMP.bwl / CMPA.wl / EOR.bwl
00001396  4EF9 00001462            378          JMP     code1100    ; MULS / MULU / AND.bwl
0000139C  4EF9 0000147C            379          JMP     code1101    ; ADD.bwl / ADDA.wl / ADDX.bwl
000013A2  4EF9 00001496            380          JMP     code1110    ; ASL.bwl / ASR.bwl / LSL.bwl / LSR.bwl / ROR.bwl / ROL.bwl
000013A8  4EF9 00001514            381          JMP     code1111    ;   [unassigned]
000013AE                           382          
000013AE                           383  code0000                            ; Opcodes ADDI and SUBI
000013AE  2200                     384          MOVE.L  D0,D1               ; D0 is current instruction word
000013B0  0241 0F00                385          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
000013B4  1A3C 0008                386          MOVE.B  #right8,D5          ; Used to shift 8 times to right
000013B8  EA69                     387          LSR.W   D5,D1               ; Shift nibble into LSB position
000013BA  C2FC 0006                388          MULU    #6, D1              ; Set displacement 
000013BE  41F9 00001518            389          LEA     OP_0000_TABLE,A0    ; Load table into A0
000013C4  4EF0 1000                390          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000013C8                           391  
000013C8                           392  code0001                            ; Opcode MOVE.B
000013C8  6000 0436                393          BRA     OP_MOVE             ; Go to opcode MOVE
000013CC                           394  
000013CC                           395  code0010                            ; Opcodes MOVE.L and MOVEA.L 
000013CC  2200                     396          MOVE.L  D0,D1               ; D0 is current instruction word
000013CE  0241 01C0                397          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
000013D2  1A3C 0006                398          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000013D6  EA69                     399          LSR.W   D5,D1               ; Shift dst mode into LSB position
000013D8  B23C 0001                400          CMP.B   #1, D1              ; When 001 in destination mode
000013DC  6700 03FE                401          BEQ     OP_MOVEA            ; Go to opcode MOVEA
000013E0  6000 041E                402          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
000013E4                           403  
000013E4                           404  code0011                            ; Opcodes MOVE.W and MOVEA.W 
000013E4  2200                     405          MOVE.L  D0,D1               ; D0 is current instruction word
000013E6  0241 01C0                406          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
000013EA  1A3C 0006                407          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000013EE  EA69                     408          LSR.W   D5,D1               ; Shift dst mode into LSB position
000013F0  B23C 0001                409          CMP.B   #1, D1              ; When 001 in destination mode
000013F4  6700 03E6                410          BEQ     OP_MOVEA            ; Go to opcode MOVEA
000013F8  6000 0406                411          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
000013FC                           412  
000013FC                           413  code0100                            ; Opcodes CLR, JSR, LEA, MOVEM, NOP, RTS
000013FC  2200                     414          MOVE.L  D0,D1               ; D0 is current instruction word
000013FE  0241 0F00                415          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
00001402  1A3C 0008                416          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001406  EA69                     417          LSR.W   D5,D1               ; Shift nibble into LSB position
00001408  C2FC 0006                418          MULU    #6, D1              ; Set displacement 
0000140C  41F9 00001578            419          LEA     OP_0100_TABLE,A0    ; Load table into A0
00001412  4EF0 1000                420          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00001416                           421  
00001416                           422  code0101                            ; Opcode ADDQ.B/W/L
00001416  6000 04AC                423          BRA     OP_ADDQ             ; Go to opcode ADDQ
0000141A                           424  
0000141A                           425  code0110                            ; Opcodes BRA and BSR
0000141A  2200                     426          MOVE.L  D0,D1               ; D0 is current instruction word
0000141C  0241 0F00                427          ANDI.W  #second_nibble,D1   ; Extract 2nd 4 bits from instruction word
00001420  1A3C 0008                428          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001424  EA69                     429          LSR.W   D5,D1               ; Shift nibble into LSB position
00001426  B23C 0000                430          CMP.B   #0, D1              ; When 0000 in destination mode
0000142A  6700 04B8                431          BEQ     OP_BRA              ; Go to opcode BRA
0000142E  6000 0524                432          BRA     OP_BSR              ; Otherwise, go to opcode BSR
00001432                           433  
00001432                           434  code0111                            ; Opcode MOVEQ
00001432  6000 053C                435          BRA     OP_MOVEQ            ; Go to opcode MOVEQ
00001436                           436  
00001436                           437  code1000                            ; Opcodes DIVU word and OR.B/W/L
00001436  2200                     438          MOVE.L  D0,D1               ; D0 is current instruction word
00001438  0241 01C0                439          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000143C  1A3C 0006                440          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001440  EA69                     441          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001442  B23C 0003                442          CMP.B   #3,D1               ; When 011 in destination mode
00001446  6700 0550                443          BEQ     OP_DIVU             ; Go to opcode DIVU word
0000144A  B23C 0007                444          CMP.B   #7,D1               ; When 111
0000144E  6700 033C                445          BEQ     OP_UNSUPPORTED      ; Go to opcode unsupported
00001452  6000 0564                446          BRA     OP_OR               ; Otherwise, go to opcode OR
00001456                           447  
00001456                           448  code1001                            ; Opcode SUB.B/W/L
00001456  6000 0578                449          BRA     OP_SUB              ; Go to opcode SUB   
0000145A                           450  
0000145A                           451  code1010                            ; Opcode not supported 
0000145A  6000 0330                452          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
0000145E                           453       
0000145E                           454  code1011                            ; Opcode CMP.B/W/L
0000145E  6000 058C                455          BRA     OP_CMP              ; Go to opcode CMP
00001462                           456  
00001462                           457  code1100                            ; Opcodes MULS, MULU, AND.B/W/L
00001462  2200                     458          MOVE.L  D0,D1               ; D0 is current instruction word
00001464  0241 01C0                459          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001468  1A3C 0006                460          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000146C  EA69                     461          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000146E  C2FC 0006                462          MULU    #6, D1              ; Set displacement 
00001472  41F9 000015D8            463          LEA     OP_1100_TABLE,A0    ; Load table into A0
00001478  4EF0 1000                464          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
0000147C                           465  
0000147C                           466  code1101                            ; Opcodes ADD.B/W/L, ADDA.B/W/L
0000147C  2200                     467          MOVE.L  D0,D1               ; D0 is current instruction word
0000147E  0241 01C0                468          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001482  1A3C 0006                469          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001486  EA69                     470          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001488  C2FC 0006                471          MULU    #6, D1              ; Set displacement 
0000148C  41F9 00001638            472          LEA     OP_1101_TABLE,A0    ; Load table into A0
00001492  4EF0 1000                473          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
00001496                           474  
00001496                           475  code1110                            ; Opcodes ASL.B/W/L, ASR.B/W/L, LSL.B/W/L, LSR.B/W/L, ROL.B/W/L, ROR.B/W/L   
00001496  2200                     476          MOVE.L  D0,D1               ; D0 is current instruction word
00001498  0241 01C0                477          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
0000149C  1A3C 0006                478          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000014A0  EA69                     479          LSR.W   D5,D1               ; Shift dst mode into LSB position
000014A2                           480     
000014A2                           481          ; Check Memory Shifts
000014A2  B23C 0007                482          CMP.B   #7, D1              ; When 111
000014A6  6700 0024                483          BEQ     MEMORY_1110_LEFT    ; Go to Memory Shift Left Side
000014AA                           484      
000014AA  B23C 0003                485          CMP.B   #3, D1              ; When 011
000014AE  6700 0040                486          BEQ     MEMORY_1110_RIGHT   ; Go Memory Shift Right Side
000014B2                           487      
000014B2                           488          ; Check Register Shifts
000014B2  2200                     489          MOVE.L  D0,D1                       ; D0 is current instruction word
000014B4  0241 0038                490          ANDI.W  #src_mode,D1                ; Extract 5-3 bits from instruction word
000014B8  1A3C 0003                491          MOVE.B  #right3,D5                  ; Used to shift 3 times to right
000014BC  EA69                     492          LSR.W   D5,D1                       ; Shift 5-3 bits into LSB position
000014BE  C2FC 0006                493          MULU    #6,D1                       ; Set displacement 
000014C2  41F9 00001698            494          LEA     OP_1110_TABLE_REGISTER,A0   ; Load table into A0
000014C8  4EF0 1000                495          JMP     0(A0,D1)                    ; go to displacement (A0 + D1 * 6)
000014CC                           496  
000014CC                           497  MEMORY_1110_LEFT    
000014CC  2200                     498          MOVE.L  D0,D1               ; D0 is current instruction word
000014CE  0241 0E00                499          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
000014D2  1A3C 0009                500          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000014D6  EA69                     501          LSR.W   D5,D1               ; Shift dst reg into LSB position
000014D8  B23C 0000                502          CMP.B   #0,D1               ; When D1 is 0
000014DC  6700 05DE                503          BEQ     OP_ASL              ; Go to opcode ASL
000014E0  B23C 0001                504          CMP.B   #1, D1              ; when D1 is 1
000014E4  6700 060E                505          BEQ     OP_LSL              ; Go to opcode LSL
000014E8  B23C 0003                506          CMP.B   #3, D1              ; When D1 is 3
000014EC  6700 063E                507          BEQ     OP_ROL              ; Go to opcode ROL
000014F0                           508  
000014F0                           509  MEMORY_1110_RIGHT
000014F0  2200                     510          MOVE.L  D0,D1               ; D0 is current instruction word
000014F2  0241 0E00                511          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
000014F6  1A3C 0009                512          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000014FA  EA69                     513          LSR.W   D5,D1               ; Shift dst reg into LSB position
000014FC  B23C 0000                514          CMP.B   #0,D1               ; When D1 is 0
00001500  6700 059E                515          BEQ     OP_ASR              ; Go to opcode ASR
00001504  B23C 0001                516          CMP.B   #1, D1              ; when D1 is 1
00001508  6700 05CE                517          BEQ     OP_LSR              ; Go to opcode LSR
0000150C  B23C 0003                518          CMP.B   #3, D1              ; When D1 is 3
00001510  6700 05FE                519          BEQ     OP_ROR              ; Go to opcode ROR
00001514                           520  
00001514                           521  code1111                            ; Opcode not supported 
00001514  6000 0276                522          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
00001518                           523           
00001518                           524  OP_0000_TABLE
00001518  4EF9 0000178C            525          JMP     OP_UNSUPPORTED  ; 0 Go to opcode unsupported  
0000151E  4EF9 0000178C            526          JMP     OP_UNSUPPORTED  ; 1 Go to opcode unsupported  
00001524  4EF9 0000178C            527          JMP     OP_UNSUPPORTED  ; 2 Go to opcode unsupported  
0000152A  4EF9 0000178C            528          JMP     OP_UNSUPPORTED  ; 3 Go to opcode unsupported  
00001530  4EF9 0000179C            529          JMP     OP_SUBI         ; 4 Go to opcode SUBI
00001536  4EF9 0000178C            530          JMP     OP_UNSUPPORTED  ; 5 Go to opcode unsupported  
0000153C  4EF9 000017BC            531          JMP     OP_ADDI         ; 6 Go to opcode ADDI
00001542  4EF9 0000178C            532          JMP     OP_UNSUPPORTED  ; 7 Go to opcode unsupported  
00001548  4EF9 0000178C            533          JMP     OP_UNSUPPORTED  ; 8 Go to opcode unsupported  
0000154E  4EF9 0000178C            534          JMP     OP_UNSUPPORTED  ; 9 Go to opcode unsupported  
00001554  4EF9 0000178C            535          JMP     OP_UNSUPPORTED  ; A Go to opcode unsupported  
0000155A  4EF9 0000178C            536          JMP     OP_UNSUPPORTED  ; B Go to opcode unsupported  
00001560  4EF9 0000178C            537          JMP     OP_UNSUPPORTED  ; C Go to opcode unsupported  
00001566  4EF9 0000178C            538          JMP     OP_UNSUPPORTED  ; D Go to opcode unsupported  
0000156C  4EF9 0000178C            539          JMP     OP_UNSUPPORTED  ; E Go to opcode unsupported  
00001572  4EF9 0000178C            540          JMP     OP_UNSUPPORTED  ; F Go to opcode unsupported  
00001578                           541      
00001578                           542  OP_0100_TABLE
00001578  4EF9 0000178C            543          JMP     OP_UNSUPPORTED      ; 0 Go to opcode unsupported  
0000157E  4EF9 000018A8            544          JMP     OP_LEA              ; 1 Go to opcode LEA
00001584  4EF9 00001820            545          JMP     OP_CLR              ; 2 Go to opcode CLR
0000158A  4EF9 000018A8            546          JMP     OP_LEA              ; 3 Go to opcode LEA
00001590  4EF9 0000178C            547          JMP     OP_UNSUPPORTED      ; 4 Go to opcode unsupported  
00001596  4EF9 000018A8            548          JMP     OP_LEA              ; 5 Go to opcode LEA
0000159C  4EF9 000017BC            549          JMP     OP_ADDI             ; 6 Go to opcode ADDI
000015A2  4EF9 000018A8            550          JMP     OP_LEA              ; 7 Go to opcode LEA
000015A8  4EF9 00001884            551          JMP     OP_MOVEM            ; 8 Go to opcode MOVEM
000015AE  4EF9 000018A8            552          JMP     OP_LEA              ; 9 Go to opcode LEA
000015B4  4EF9 0000178C            553          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000015BA  4EF9 000018A8            554          JMP     OP_LEA              ; B Go to opcode LEA
000015C0  4EF9 00001884            555          JMP     OP_MOVEM            ; C Go to opcode MOVEM
000015C6  4EF9 000018A8            556          JMP     OP_LEA              ; D Go to opcode LEA
000015CC  4EF9 0000175E            557          JMP     JSR_NOP_RTS         ; E Go to opcode JSR, NOP, or RTS
000015D2  4EF9 0000178C            558          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000015D8                           559      
000015D8                           560  OP_1100_TABLE
000015D8  4EF9 00001A48            561          JMP     OP_AND              ; 0 Go to opcode AND 
000015DE  4EF9 00001A48            562          JMP     OP_AND              ; 1 Go to opcode AND
000015E4  4EF9 00001A48            563          JMP     OP_AND              ; 2 Go to opcode AND
000015EA  4EF9 00001A08            564          JMP     OP_MULU             ; 3 Go to opcode MULU
000015F0  4EF9 00001A48            565          JMP     OP_AND              ; 4 Go to opcode AND 
000015F6  4EF9 00001A48            566          JMP     OP_AND              ; 5 Go to opcode AND
000015FC  4EF9 00001A48            567          JMP     OP_AND              ; 6 Go to opcode AND
00001602  4EF9 00001A28            568          JMP     OP_MULS             ; 7 Go to opcode MULS
00001608  4EF9 0000178C            569          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000160E  4EF9 0000178C            570          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001614  4EF9 0000178C            571          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
0000161A  4EF9 0000178C            572          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
00001620  4EF9 0000178C            573          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001626  4EF9 0000178C            574          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000162C  4EF9 0000178C            575          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001632  4EF9 0000178C            576          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001638                           577      
00001638                           578  OP_1101_TABLE
00001638  4EF9 00001A64            579          JMP     OP_ADD              ; 0 Go to opcode ADD 
0000163E  4EF9 00001A64            580          JMP     OP_ADD              ; 1 Go to opcode ADD
00001644  4EF9 00001A64            581          JMP     OP_ADD              ; 2 Go to opcode ADD
0000164A  4EF9 00001A80            582          JMP     OP_ADDA             ; 3 Go to opcode ADDA
00001650  4EF9 00001A64            583          JMP     OP_ADD              ; 4 Go to opcode ADD 
00001656  4EF9 00001A64            584          JMP     OP_ADD              ; 5 Go to opcode ADD
0000165C  4EF9 00001A64            585          JMP     OP_ADD              ; 6 Go to opcode ADD
00001662  4EF9 00001A80            586          JMP     OP_ADDA             ; 7 Go to opcode ADDA
00001668  4EF9 0000178C            587          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000166E  4EF9 0000178C            588          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001674  4EF9 0000178C            589          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
0000167A  4EF9 0000178C            590          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
00001680  4EF9 0000178C            591          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001686  4EF9 0000178C            592          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000168C  4EF9 0000178C            593          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001692  4EF9 0000178C            594          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001698                           595      
00001698                           596  OP_1110_TABLE_REGISTER
00001698  4EF9 000016F8            597          JMP     OP_AS_CHECK         ; 0 Check if AS is left or right
0000169E  4EF9 0000171A            598          JMP     OP_LS_CHECK         ; 1 Check if LS is left or right
000016A4  4EF9 0000178C            599          JMP     OP_UNSUPPORTED      ; 2 Go to opcode unsupported  
000016AA  4EF9 0000173C            600          JMP     OP_RO_CHECK         ; 3 Check if RO is left or right
000016B0  4EF9 000016F8            601          JMP     OP_AS_CHECK         ; 4 Check if AS is left or right
000016B6  4EF9 0000171A            602          JMP     OP_LS_CHECK         ; 5 Check if LS is left or right
000016BC  4EF9 0000178C            603          JMP     OP_UNSUPPORTED      ; 6 Go to opcode unsupported 
000016C2  4EF9 0000173C            604          JMP     OP_RO_CHECK         ; 7 Check if RO is left or right
000016C8  4EF9 0000178C            605          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
000016CE  4EF9 0000178C            606          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
000016D4  4EF9 0000178C            607          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000016DA  4EF9 0000178C            608          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
000016E0  4EF9 0000178C            609          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
000016E6  4EF9 0000178C            610          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
000016EC  4EF9 0000178C            611          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
000016F2  4EF9 0000178C            612          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000016F8                           613  
000016F8                           614  OP_AS_CHECK
000016F8  2200                     615          MOVE.L  D0,D1               ; D0 is current instruction word
000016FA  0241 01C0                616          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000016FE  1A3C 0006                617          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001702  EA69                     618          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001704  0201 0004                619          ANDI.B  #4,D1               ; Get only bit 8 (dr)
00001708  E449                     620          LSR.W   #2,D1
0000170A                           621  
0000170A  B23C 0001                622          CMP.B   #1,D1               ; Go left
0000170E  6700 03AC                623          BEQ     OP_ASL              ; 1 Go to opcode ASL
00001712  B23C 0000                624          CMP.B   #0,D1               ; Go right
00001716  6700 0388                625          BEQ     OP_ASR              ; 0 Go to opcode ASR
0000171A                           626          
0000171A                           627  OP_LS_CHECK
0000171A  2200                     628          MOVE.L  D0,D1               ; D0 is current instruction word
0000171C  0241 01C0                629          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00001720  1A3C 0006                630          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001724  EA69                     631          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001726  0201 0004                632          ANDI.B  #4,D1               ; Get only bit 8 (dr)
0000172A  E449                     633          LSR.W   #2,D1
0000172C                           634  
0000172C  B23C 0001                635          CMP.B   #1,D1               ; Go left
00001730  6700 03C2                636          BEQ     OP_LSL              ; 1 Go to opcode LSL
00001734  B23C 0000                637          CMP.B   #0,D1               ; Go right
00001738  6700 039E                638          BEQ     OP_LSR              ; 0 Go to opcode LSR
0000173C                           639          
0000173C                           640  
0000173C                           641  OP_RO_CHECK
0000173C  2200                     642          MOVE.L  D0,D1               ; D0 is current instruction word
0000173E  0241 01C0                643          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00001742  1A3C 0006                644          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001746  EA69                     645          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001748  0201 0004                646          ANDI.B  #4,D1               ; Get only bit 8 (dr)
0000174C  E449                     647          LSR.W   #2,D1
0000174E                           648  
0000174E  B23C 0001                649          CMP.B   #1,D1               ; Go left
00001752  6700 03D8                650          BEQ     OP_ROL              ; 1 Go to opcode ROL
00001756  B23C 0000                651          CMP.B   #0,D1               ; Go right
0000175A  6700 03B4                652          BEQ     OP_ROR              ; 0 Go to opcode ROR
0000175E                           653          
0000175E                           654  JSR_NOP_RTS
0000175E  2200                     655          MOVE.L  D0,D1               ; D0 is current instruction word
00001760  0241 01C0                656          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001764  1A3C 0006                657          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001768  EA69                     658          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000176A  B23C 0002                659          CMP.B   #2, D1              ; When 010 in destination mode
0000176E  6700 00F8                660          BEQ     OP_JSR              ; Go to opcode JSR
00001772  2200                     661          MOVE.L  D0,D1               ; D0 is current instruction word
00001774  0241 0007                662          ANDI.W  #src_reg,D1         ; Extract src reg position from instruction word
00001778  B23C 0001                663          CMP.B   #1,D1               ; When 001 in src register
0000177C  6700 00BE                664          BEQ     OP_NOP              ; Go to opcode NOP
00001780  B23C 0005                665          CMP.B   #5,D1               ; When 005 in src register
00001784  6700 00D2                666          BEQ     OP_RTS              ; Go to opcode RTS
00001788  6000 0002                667          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported 
0000178C                           668  
0000178C                           669  OP_UNSUPPORTED
0000178C  43F9 00002497            670          LEA     OPCODE_INVALID,A1 
00001792  103C 000E                671          MOVE.B  #14,D0
00001796  4E4F                     672          TRAP    #15
00001798  6000 0C0C                673          BRA     DONE
0000179C                           674          
0000179C                           675  *----------------------------------------------------------------------------------------------*
0000179C                           676  * param D0 the current instruction in word
0000179C                           677  * param D1 the EA type
0000179C                           678  * param A2 a pointer to the decode_buffer
0000179C                           679  * param A5 current address
0000179C                           680  * ea_start(D0, D1, A2, A5){
0000179C                           681  * D2: size
0000179C                           682  * D3: src mode, dst mode
0000179C                           683  * D4: src regs, dst regs
0000179C                           684  * D5: #shifts
0000179C                           685  * D7: immediate data
0000179C                           686  * A0: EA_TYPE_TABLE
0000179C                           687  *       0 = ea_immediate
0000179C                           688  * }
0000179C                           689  
0000179C                           690  *----------------------------------------------------------------------------------------------*
0000179C                           691  * First 4 bits: 0000
0000179C                           692  OP_SUBI
0000179C  14FC 0053                693          MOVE.B  #'S',(A2)+
000017A0  14FC 0055                694          MOVE.B  #'U',(A2)+
000017A4  14FC 0042                695          MOVE.B  #'B',(A2)+
000017A8  14FC 0049                696          MOVE.B  #'I',(A2)+
000017AC  223C 00000000            697          MOVE.L  #ea_type_immediate,D1
000017B2  4EB9 00001B48            698          JSR     EA_START
000017B8  4EF8 1332                699          JMP     OP_FINISH
000017BC                           700          
000017BC                           701  OP_ADDI
000017BC  14FC 0041                702          MOVE.B  #'A',(A2)+
000017C0  14FC 0044                703          MOVE.B  #'D',(A2)+
000017C4  14FC 0044                704          MOVE.B  #'D',(A2)+
000017C8  14FC 0049                705          MOVE.B  #'I',(A2)+
000017CC  223C 00000000            706          MOVE.L  #ea_type_immediate,D1
000017D2  4EB9 00001B48            707          JSR     EA_START
000017D8  4EF8 1332                708          JMP     OP_FINISH
000017DC                           709  
000017DC                           710  *-----------------------------------------------------------------------------------------------*
000017DC                           711  * First 4 bits: 0001
000017DC                           712  OP_MOVEA
000017DC  14FC 004D                713          MOVE.B  #'M',(A2)+
000017E0  14FC 004F                714          MOVE.B  #'O',(A2)+
000017E4  14FC 0056                715          MOVE.B  #'V',(A2)+
000017E8  14FC 0045                716          MOVE.B  #'E',(A2)+
000017EC  14FC 0041                717          MOVE.B  #'A',(A2)+
000017F0  223C 00000002            718          MOVE.L  #ea_type_movea,D1
000017F6  4EB9 00001B48            719          JSR     EA_START
000017FC  4EF8 1332                720          JMP     OP_FINISH
00001800                           721  
00001800                           722  *------------------------------------------------------------------------------------------------*
00001800                           723  * First 4 bits: 0011
00001800                           724  OP_MOVE
00001800  14FC 004D                725          MOVE.B  #'M',(A2)+
00001804  14FC 004F                726          MOVE.B  #'O',(A2)+
00001808  14FC 0056                727          MOVE.B  #'V',(A2)+
0000180C  14FC 0045                728          MOVE.B  #'E',(A2)+
00001810  223C 00000001            729          MOVE.L  #ea_type_move,D1
00001816  4EB9 00001B48            730          JSR     EA_START
0000181C  4EF8 1332                731          JMP     OP_FINISH
00001820                           732  
00001820                           733  *------------------------------------------------------------------------------------------------*
00001820                           734  * First 4 bits: 0100
00001820                           735  OP_CLR
00001820  14FC 0043                736          MOVE.B  #'C',(A2)+
00001824  14FC 004C                737          MOVE.B  #'L',(A2)+
00001828  14FC 0052                738          MOVE.B  #'R',(A2)+
0000182C  223C 00000004            739          MOVE.L  #ea_type_dstonly,D1
00001832  4EB9 00001B48            740          JSR     EA_START
00001838  4EF8 1332                741          JMP     OP_FINISH
0000183C                           742          
0000183C                           743  OP_NOP
0000183C  14FC 004E                744          MOVE.B  #'N',(A2)+
00001840  14FC 004F                745          MOVE.B  #'O',(A2)+
00001844  14FC 0050                746          MOVE.B  #'P',(A2)+
00001848  223C 00000000            747          MOVE.L  #ea_type_immediate,D1
0000184E  4EB9 00001B48            748          JSR     EA_START
00001854  4EF8 1332                749          JMP     OP_FINISH
00001858                           750          
00001858                           751  OP_RTS
00001858  14FC 0052                752          MOVE.B  #'R',(A2)+
0000185C  14FC 0054                753          MOVE.B  #'T',(A2)+
00001860  14FC 0053                754          MOVE.B  #'S',(A2)+
00001864  4EF8 1332                755          JMP     OP_FINISH
00001868                           756          
00001868                           757  OP_JSR
00001868  14FC 004A                758          MOVE.B  #'J',(A2)+
0000186C  14FC 0053                759          MOVE.B  #'S',(A2)+
00001870  14FC 0052                760          MOVE.B  #'R',(A2)+
00001874  223C 00000004            761          MOVE.L  #ea_type_dstonly,D1
0000187A  4EB9 00001B48            762          JSR     EA_START
00001880  4EF8 1332                763          JMP     OP_FINISH
00001884                           764  
00001884                           765  OP_MOVEM
00001884  14FC 004D                766          MOVE.B  #'M',(A2)+
00001888  14FC 004F                767          MOVE.B  #'O',(A2)+
0000188C  14FC 0056                768          MOVE.B  #'V',(A2)+
00001890  14FC 0045                769          MOVE.B  #'E',(A2)+
00001894  14FC 004D                770          MOVE.B  #'M',(A2)+
00001898  223C 00000000            771          MOVE.L  #ea_type_immediate,D1
0000189E  4EB9 00001B48            772          JSR     EA_START
000018A4  4EF8 1332                773          JMP     OP_FINISH
000018A8                           774          
000018A8                           775  OP_LEA
000018A8  14FC 004C                776          MOVE.B  #'L',(A2)+
000018AC  14FC 0045                777          MOVE.B  #'E',(A2)+
000018B0  14FC 0041                778          MOVE.B  #'A',(A2)+
000018B4  223C 00000003            779          MOVE.L  #ea_type_lea,D1
000018BA  4EB9 00001B48            780          JSR     EA_START
000018C0  4EF8 1332                781          JMP     OP_FINISH
000018C4                           782  
000018C4                           783  *------------------------------------------------------------------------------------------------*
000018C4                           784  * First 4 bits: 0101
000018C4                           785  OP_ADDQ
000018C4  14FC 0041                786          MOVE.B  #'A',(A2)+
000018C8  14FC 0044                787          MOVE.B  #'D',(A2)+
000018CC  14FC 0044                788          MOVE.B  #'D',(A2)+
000018D0  14FC 0051                789          MOVE.B  #'Q',(A2)+
000018D4  223C 00000000            790          MOVE.L  #ea_type_immediate,D1
000018DA  4EB9 00001B48            791          JSR     EA_START
000018E0  4EF8 1332                792          JMP     OP_FINISH
000018E4                           793          
000018E4                           794  *------------------------------------------------------------------------------------------------*
000018E4                           795  * First 4 bits: 0110
000018E4                           796  OP_BRA
000018E4  14FC 0042                797          MOVE.B  #'B',(A2)+
000018E8  14FC 0052                798          MOVE.B  #'R',(A2)+
000018EC  14FC 0041                799          MOVE.B  #'A',(A2)+
000018F0  223C 00000000            800          MOVE.L  #ea_type_immediate,D1
000018F6  4EB9 00001B48            801          JSR     EA_START
000018FC  4EF8 1332                802          JMP     OP_FINISH
00001900                           803  
00001900                           804  OP_BCC
00001900  14FC 0042                805          MOVE.B  #'B',(A2)+
00001904  14FC 0043                806          MOVE.B  #'C',(A2)+
00001908  14FC 0043                807          MOVE.B  #'C',(A2)+
0000190C  223C 00000000            808          MOVE.L  #ea_type_immediate,D1
00001912  4EB9 00001B48            809          JSR     EA_START
00001918  4EF8 1332                810          JMP     OP_FINISH
0000191C                           811          
0000191C                           812  OP_BGT
0000191C  14FC 0042                813          MOVE.B  #'B',(A2)+
00001920  14FC 0047                814          MOVE.B  #'G',(A2)+
00001924  14FC 0054                815          MOVE.B  #'T',(A2)+
00001928  223C 00000000            816          MOVE.L  #ea_type_immediate,D1
0000192E  4EB9 00001B48            817          JSR     EA_START
00001934  4EF8 1332                818          JMP     OP_FINISH
00001938                           819  
00001938                           820  OP_BLE
00001938  14FC 0042                821          MOVE.B  #'B',(A2)+
0000193C  14FC 004C                822          MOVE.B  #'L',(A2)+
00001940  14FC 0045                823          MOVE.B  #'E',(A2)+
00001944  223C 00000000            824          MOVE.L  #ea_type_immediate,D1
0000194A  4EB9 00001B48            825          JSR     EA_START
00001950  4EF8 1332                826          JMP     OP_FINISH
00001954                           827          
00001954                           828  OP_BSR
00001954  14FC 0042                829          MOVE.B  #'B',(A2)+
00001958  14FC 0053                830          MOVE.B  #'S',(A2)+
0000195C  14FC 0052                831          MOVE.B  #'R',(A2)+
00001960  223C 00000000            832          MOVE.L  #ea_type_immediate,D1
00001966  4EB9 00001B48            833          JSR     EA_START
0000196C  4EF8 1332                834          JMP     OP_FINISH
00001970                           835  *------------------------------------------------------------------------------------------------*
00001970                           836  * First 4 bits: 0111
00001970                           837  OP_MOVEQ
00001970  14FC 004D                838          MOVE.B  #'M',(A2)+
00001974  14FC 004F                839          MOVE.B  #'O',(A2)+
00001978  14FC 0056                840          MOVE.B  #'V',(A2)+
0000197C  14FC 0056                841          MOVE.B  #'V',(A2)+
00001980  14FC 0045                842          MOVE.B  #'E',(A2)+
00001984  14FC 0051                843          MOVE.B  #'Q',(A2)+
00001988  223C 00000000            844          MOVE.L  #ea_type_immediate,D1
0000198E  4EB9 00001B48            845          JSR     EA_START
00001994  4EF8 1332                846          JMP     OP_FINISH
00001998                           847          
00001998                           848  *------------------------------------------------------------------------------------------------*
00001998                           849  * First 4 bits: 1000
00001998                           850  OP_DIVU
00001998  14FC 0044                851          MOVE.B  #'D',(A2)+
0000199C  14FC 0049                852          MOVE.B  #'I',(A2)+
000019A0  14FC 0056                853          MOVE.B  #'V',(A2)+
000019A4  14FC 0055                854          MOVE.B  #'U',(A2)+
000019A8  223C 00000005            855          MOVE.L  #ea_type_ext,D1
000019AE  4EB9 00001B48            856          JSR     EA_START
000019B4  4EF8 1332                857          JMP     OP_FINISH
000019B8                           858    
000019B8                           859  OP_OR
000019B8  14FC 004F                860          MOVE.B  #'O',(A2)+
000019BC  14FC 0052                861          MOVE.B  #'R',(A2)+
000019C0  223C 00000005            862          MOVE.L  #ea_type_ext,D1
000019C6  4EB9 00001B48            863          JSR     EA_START
000019CC  4EF8 1332                864          JMP     OP_FINISH
000019D0                           865  
000019D0                           866  *------------------------------------------------------------------------------------------------*
000019D0                           867  * First 4 bits: 1001
000019D0                           868  OP_SUB
000019D0  14FC 0053                869          MOVE.B  #'S',(A2)+
000019D4  14FC 0055                870          MOVE.B  #'U',(A2)+
000019D8  14FC 0042                871          MOVE.B  #'B',(A2)+
000019DC  223C 00000005            872          MOVE.L  #ea_type_ext,D1
000019E2  4EB9 00001B48            873          JSR     EA_START
000019E8  4EF8 1332                874          JMP     OP_FINISH
000019EC                           875          
000019EC                           876  *------------------------------------------------------------------------------------------------*
000019EC                           877  * First 4 bits: 1011
000019EC                           878  OP_CMP
000019EC  14FC 0043                879          MOVE.B  #'C',(A2)+
000019F0  14FC 004D                880          MOVE.B  #'M',(A2)+
000019F4  14FC 0050                881          MOVE.B  #'P',(A2)+
000019F8  223C 00000005            882          MOVE.L  #ea_type_ext,D1
000019FE  4EB9 00001B48            883          JSR     EA_START
00001A04  4EF8 1332                884          JMP     OP_FINISH
00001A08                           885          
00001A08                           886  *------------------------------------------------------------------------------------------------*
00001A08                           887  * First 4 bits: 1100
00001A08                           888  OP_MULU
00001A08  14FC 004D                889          MOVE.B  #'M',(A2)+
00001A0C  14FC 0055                890          MOVE.B  #'U',(A2)+
00001A10  14FC 004C                891          MOVE.B  #'L',(A2)+
00001A14  14FC 0055                892          MOVE.B  #'U',(A2)+
00001A18  223C 00000005            893          MOVE.L  #ea_type_ext,D1
00001A1E  4EB9 00001B48            894          JSR     EA_START
00001A24  4EF8 1332                895          JMP     OP_FINISH
00001A28                           896          
00001A28                           897  OP_MULS
00001A28  14FC 004D                898          MOVE.B  #'M',(A2)+
00001A2C  14FC 0055                899          MOVE.B  #'U',(A2)+
00001A30  14FC 004C                900          MOVE.B  #'L',(A2)+
00001A34  14FC 0053                901          MOVE.B  #'S',(A2)+
00001A38  223C 00000005            902          MOVE.L  #ea_type_ext,D1
00001A3E  4EB9 00001B48            903          JSR     EA_START
00001A44  4EF8 1332                904          JMP     OP_FINISH
00001A48                           905          
00001A48                           906  OP_AND
00001A48  14FC 0041                907          MOVE.B  #'A',(A2)+
00001A4C  14FC 004E                908          MOVE.B  #'N',(A2)+
00001A50  14FC 0044                909          MOVE.B  #'D',(A2)+
00001A54  223C 00000005            910          MOVE.L  #ea_type_ext,D1
00001A5A  4EB9 00001B48            911          JSR     EA_START
00001A60  4EF8 1332                912          JMP     OP_FINISH
00001A64                           913          
00001A64                           914  *------------------------------------------------------------------------------------------------*
00001A64                           915  * First 4 bits: 1101
00001A64                           916  OP_ADD
00001A64  14FC 0041                917          MOVE.B  #'A',(A2)+
00001A68  14FC 0044                918          MOVE.B  #'D',(A2)+
00001A6C  14FC 0044                919          MOVE.B  #'D',(A2)+
00001A70  223C 00000005            920          MOVE.L  #ea_type_ext,D1
00001A76  4EB9 00001B48            921          JSR     EA_START
00001A7C  4EF8 1332                922          JMP     OP_FINISH
00001A80                           923  
00001A80                           924  OP_ADDA
00001A80  14FC 0041                925          MOVE.B  #'A',(A2)+
00001A84  14FC 0044                926          MOVE.B  #'D',(A2)+
00001A88  14FC 0044                927          MOVE.B  #'D',(A2)+
00001A8C  14FC 0041                928          MOVE.B  #'A',(A2)+
00001A90  223C 00000005            929          MOVE.L  #ea_type_ext,D1
00001A96  4EB9 00001B48            930          JSR     EA_START
00001A9C  4EF8 1332                931          JMP     OP_FINISH
00001AA0                           932          
00001AA0                           933  *------------------------------------------------------------------------------------------------*
00001AA0                           934  * First 4 bits: 1110
00001AA0                           935  OP_ASR
00001AA0  14FC 0041                936          MOVE.B  #'A',(A2)+
00001AA4  14FC 0053                937          MOVE.B  #'S',(A2)+
00001AA8  14FC 0052                938          MOVE.B  #'R',(A2)+
00001AAC  223C 00000007            939          MOVE.L  #ea_type_shifts,D1
00001AB2  4EB9 00001B48            940          JSR     EA_START
00001AB8  4EF8 1332                941          JMP     OP_FINISH
00001ABC                           942  OP_ASL
00001ABC  14FC 0041                943          MOVE.B  #'A',(A2)+
00001AC0  14FC 0053                944          MOVE.B  #'S',(A2)+
00001AC4  14FC 004C                945          MOVE.B  #'L',(A2)+
00001AC8  223C 00000007            946          MOVE.L  #ea_type_shifts,D1
00001ACE  4EB9 00001B48            947          JSR     EA_START
00001AD4  4EF8 1332                948          JMP     OP_FINISH
00001AD8                           949          
00001AD8                           950  OP_LSR
00001AD8  14FC 004C                951          MOVE.B  #'L',(A2)+
00001ADC  14FC 0053                952          MOVE.B  #'S',(A2)+
00001AE0  14FC 0052                953          MOVE.B  #'R',(A2)+
00001AE4  223C 00000007            954          MOVE.L  #ea_type_shifts,D1
00001AEA  4EB9 00001B48            955          JSR     EA_START
00001AF0  4EF8 1332                956          JMP     OP_FINISH
00001AF4                           957         
00001AF4                           958  OP_LSL
00001AF4  14FC 004C                959          MOVE.B  #'L',(A2)+
00001AF8  14FC 0053                960          MOVE.B  #'S',(A2)+
00001AFC  14FC 004C                961          MOVE.B  #'L',(A2)+
00001B00  223C 00000007            962          MOVE.L  #ea_type_shifts,D1
00001B06  4EB9 00001B48            963          JSR     EA_START
00001B0C  4EF8 1332                964          JMP     OP_FINISH
00001B10                           965          
00001B10                           966  OP_ROR
00001B10  14FC 0052                967          MOVE.B  #'R',(A2)+
00001B14  14FC 004F                968          MOVE.B  #'O',(A2)+
00001B18  14FC 0052                969          MOVE.B  #'R',(A2)+
00001B1C  223C 00000007            970          MOVE.L  #ea_type_shifts,D1
00001B22  4EB9 00001B48            971          JSR     EA_START
00001B28  4EF8 1332                972          JMP     OP_FINISH
00001B2C                           973          
00001B2C                           974  OP_ROL
00001B2C  14FC 0052                975          MOVE.B  #'R',(A2)+
00001B30  14FC 004F                976          MOVE.B  #'O',(A2)+
00001B34  14FC 004C                977          MOVE.B  #'L',(A2)+
00001B38  223C 00000007            978          MOVE.L  #ea_type_shifts,D1
00001B3E  4EB9 00001B48            979          JSR     EA_START
00001B44  4EF8 1332                980          JMP     OP_FINISH
00001B48                           981          
00001B48                           982  *-----------------------------------------------------------------------*   
00001B48                           983  EA_START
00001B48  48E7 38C0                984          MOVEM.L D2-D4/A0-A1, -(SP)
00001B4C                           985          
00001B4C  41F9 00001B60            986          LEA     EA_TYPE_TABLE, A0
00001B52  C2FC 0006                987          MULU    #6, D1
00001B56  4EF0 1000                988          JMP     0(A0, D1)
00001B5A                           989          
00001B5A                           990  EA_FINISH
00001B5A  4CDF 031C                991          MOVEM.L (SP)+, D2-D4/A0-A1
00001B5E  4E75                     992          RTS
00001B60                           993          
00001B60                           994  EA_TYPE_TABLE
00001B60  4EF9 00001C7E            995          JMP     EA_IMMEDIATE        ; 0: ea_immediate
00001B66  4EF9 00001CD2            996          JMP     EA_MOVE             ; 1: ea_move
00001B6C  4EF9 00001D3A            997          JMP     EA_MOVEA            ; 2: ea_movea
00001B72  4EF9 00001DA2            998          JMP     EA_LEA              ; 3: ea_lea
00001B78  4EF9 00001E18            999          JMP     EA_DSTONLY          ; 4: ea_dstonly
00001B7E  4EF9 00001EC2           1000          JMP     EA_EXT              ; 5: ea_ext
00001B84  4EF9 000020A2           1001          JMP     EA_MOVEM            ; 6: ea_movem
00001B8A  4EF9 000020A2           1002          JMP     EA_SHIFTS           ; 7: ea_shifts
00001B90  4EF9 00002218           1003          JMP     EA_QUICK            ; 8: ea_quick
00001B96  4EF9 00002218           1004          JMP     EA_branch           ; 9: ea_branch
00001B9C  4EF8 1B5A               1005          JMP     EA_FINISH
00001BA0                          1006          
00001BA0                          1007  EA_SIZE_GENERAL
00001BA0  B43C 0000               1008          CMP.B   #%00,D2             ; .b
00001BA4  6700 00B6               1009          BEQ     EA_SIZE_B       
00001BA8  B43C 0001               1010          CMP.B   #%01,D2             ; .w
00001BAC  6700 00B8               1011          BEQ     EA_SIZE_W       
00001BB0  B43C 0002               1012          CMP.B   #%10,D2             ; .l
00001BB4  6700 00BC               1013          BEQ     EA_SIZE_L
00001BB8  6000 079C               1014          BRA     EA_WRONG_SIZE       ; wrong size
00001BBC                          1015  
00001BBC                          1016  EA_SIZE_MOVE
00001BBC  B43C 0001               1017          CMP.B   #%01,D2             ; .b
00001BC0  6700 009A               1018          BEQ     EA_SIZE_B       
00001BC4  B43C 0003               1019          CMP.B   #%11,D2             ; .w
00001BC8  6700 009C               1020          BEQ     EA_SIZE_W       
00001BCC  B43C 0002               1021          CMP.B   #%10,D2             ; .l
00001BD0  6700 00A0               1022          BEQ     EA_SIZE_L
00001BD4  6000 0780               1023          BRA     EA_WRONG_SIZE       ; wrong size
00001BD8                          1024  
00001BD8                          1025  EA_SIZE_MOVEA     
00001BD8  B43C 0003               1026          CMP.B   #%11,D2             ; .w
00001BDC  6700 0088               1027          BEQ     EA_SIZE_W       
00001BE0  B43C 0002               1028          CMP.B   #%10,D2             ; .l
00001BE4  6700 008C               1029          BEQ     EA_SIZE_L
00001BE8  6000 076C               1030          BRA     EA_WRONG_SIZE       ; wrong size
00001BEC                          1031  
00001BEC                          1032  EA_SIZE_OPMODE_012456               ; Check opmode field for size
00001BEC  B43C 0000               1033          CMP.B   #%000,D2            ; When 0 then .b
00001BF0  6700 006A               1034          BEQ     EA_SIZE_B
00001BF4  B43C 0004               1035          CMP.B   #%100,D2            ; When 4 then .b
00001BF8  6700 0062               1036          BEQ     EA_SIZE_B  
00001BFC  B43C 0001               1037          CMP.B   #%001,D2            ; When 1 then .w
00001C00  6700 0064               1038          BEQ     EA_SIZE_W
00001C04  B43C 0005               1039          CMP.B   #%101,D2            ; When 5 then .w
00001C08  6700 005C               1040          BEQ     EA_SIZE_W 
00001C0C  B43C 0002               1041          CMP.B   #%010,D2            ; When 2 then .l
00001C10  6700 0060               1042          BEQ     EA_SIZE_L
00001C14  B43C 0006               1043          CMP.B   #%110,D2            ; When 6 then .l
00001C18  6700 0058               1044          BEQ     EA_SIZE_L
00001C1C  6000 0738               1045          BRA     EA_WRONG_SIZE       ; wrong size
00001C20                          1046  
00001C20                          1047  EA_SIZE_ADDA                        ; Check opmode field for size
00001C20  B43C 0003               1048          CMP.B   #%011,D2            ; When 3 then .w
00001C24  6700 0040               1049          BEQ     EA_SIZE_W       
00001C28  B43C 0007               1050          CMP.B   #%111,D2            ; When 7 then .l
00001C2C  6700 0044               1051          BEQ     EA_SIZE_L
00001C30  6000 0724               1052          BRA     EA_WRONG_SIZE       ; wrong size
00001C34                          1053          
00001C34                          1054  EA_SIZE_MULS_MULU_DIV               ; Check opmode field for size
00001C34  B43C 0003               1055          CMP.B   #%011,D2            ; When 3 then .w MULU, DIVU
00001C38  6700 002C               1056          BEQ     EA_SIZE_W       
00001C3C  B43C 0007               1057          CMP.B   #%111,D2            ; When 7 then .l MULS
00001C40  6700 0024               1058          BEQ     EA_SIZE_W
00001C44  6000 0710               1059          BRA     EA_WRONG_SIZE       ; wrong size
00001C48                          1060          
00001C48                          1061  EA_SIZE_MEMORY_SHIFTS
00001C48  B43C 0000               1062          CMP.B   #%00,D2             ; .w
00001C4C  6700 0022               1063          BEQ     EA_SIZE_W_MEMORY      
00001C50  B43C 0001               1064          CMP.B   #%01,D2             ; .l
00001C54  6700 001C               1065          BEQ     EA_SIZE_L      
00001C58  6000 06FC               1066          BRA     EA_WRONG_SIZE       ; wrong size
00001C5C                          1067  
00001C5C                          1068  EA_SIZE_B
00001C5C  14FC 002E               1069          MOVE.B  #'.',(A2)+
00001C60  14FC 0042               1070          MOVE.B  #'B',(A2)+
00001C64  4E75                    1071          RTS
00001C66                          1072  EA_SIZE_W
00001C66  14FC 002E               1073          MOVE.B  #'.',(A2)+
00001C6A  14FC 0057               1074          MOVE.B  #'W',(A2)+
00001C6E  4E75                    1075          RTS     
00001C70                          1076  EA_SIZE_W_MEMORY
00001C70  4E75                    1077          RTS        
00001C72                          1078  EA_SIZE_L
00001C72  14FC 002E               1079          MOVE.B  #'.',(A2)+
00001C76  14FC 004C               1080          MOVE.B  #'L',(A2)+
00001C7A  4E75                    1081          RTS
00001C7C                          1082  EA_SIZE_DONE
00001C7C  4E75                    1083          RTS
00001C7E                          1084          
00001C7E                          1085  EA_IMMEDIATE                        ; 0 ea_immediate
00001C7E  2200                    1086          MOVE.L  D0,D1
00001C80  0241 01C0               1087          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00001C84  1A3C 0006               1088          MOVE.B  #right6,D5          ; Store 6 into D5
00001C88  EA69                    1089          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00001C8A  0201 0003               1090          ANDI.B  #3,D1               ; Remove the front bit from D1
00001C8E  1401                    1091          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00001C90  4EB8 1BA0               1092          JSR     EA_SIZE_GENERAL     ; Get size 
00001C94                          1093          
00001C94  14FC 0020               1094          MOVE.B  #$20,(A2)+          ; Add space after size
00001C98  14FC 0020               1095          MOVE.B  #$20,(A2)+          ; Add space 
00001C9C                          1096  
00001C9C                          1097          ; Get source and store into decode buffer
00001C9C  7804                    1098          MOVE.L  #4,D4               ; Store 100 into D4 (Used to jump to immediate)
00001C9E  7607                    1099          MOVE.L  #7,D3               ; Store 111 into D3 (Go to absolute and immediate)
00001CA0  4EB9 00002218           1100          JSR     EA_GEN_SRC          ; Get EA src print 
00001CA6                          1101  
00001CA6  14FC 002C               1102          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001CAA  14FC 0020               1103          MOVE.B  #$20,(A2)+          ; Add space after comma
00001CAE                          1104  
00001CAE                          1105          ; Get desination and store into decode buffer
00001CAE  2800                    1106          MOVE.L  D0,D4               ; Store the current address into D4 
00001CB0  0244 0007               1107          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00001CB4                          1108          
00001CB4  2600                    1109          MOVE.L  D0,D3               ; Store the current address into D3 
00001CB6  0243 0038               1110          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00001CBA  1A3C 0003               1111          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00001CBE  EA6B                    1112          LSR.W   D5,D3               ; do the actual shift 
00001CC0  B63C 0001               1113          CMP.B   #1,D3               ; If dest mode is 001: An
00001CC4  6700 06B0               1114          BEQ     DST_INVALID         ; Go to invalid message 
00001CC8  4EB9 00002218           1115          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00001CCE                          1116  
00001CCE  4EF8 1B5A               1117          JMP     EA_FINISH           ; Opcode is finish
00001CD2                          1118  
00001CD2                          1119  
00001CD2                          1120  EA_MOVE                             ; 1: ea_move
00001CD2  2200                    1121          MOVE.L  D0,D1
00001CD4  0241 F000               1122          ANDI.W  #first_nibble,D1
00001CD8  1A3C 000C               1123          MOVE.B  #right12,D5 
00001CDC  EA69                    1124          LSR.W   D5,D1
00001CDE  0201 0003               1125          ANDI.B  #3,D1
00001CE2  1401                    1126          MOVE.B  D1,D2
00001CE4  4EB8 1BBC               1127          JSR     EA_SIZE_MOVE
00001CE8                          1128          
00001CE8  14FC 0020               1129          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001CEC  14FC 0020               1130          MOVE.B  #$20,(A2)+          ; Print out a space
00001CF0                          1131          
00001CF0                          1132          ; Get source and store into decode buffer
00001CF0  2800                    1133          MOVE.L  D0,D4               ; Store the src reg in D4
00001CF2  0244 0007               1134          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001CF6                          1135          
00001CF6  2600                    1136          MOVE.L  D0,D3               ; Store the src mode in D3
00001CF8  0243 0038               1137          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001CFC  1A3C 0003               1138          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001D00  EA6B                    1139          LSR.W   D5,D3               ; Do the actual shift 
00001D02  4EB9 00002218           1140          JSR     EA_GEN_SRC
00001D08                          1141          
00001D08  14FC 002C               1142          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001D0C  14FC 0020               1143          MOVE.B  #$20,(A2)+          ; Add space after comma
00001D10                          1144          
00001D10                          1145          ; Get desination and store into decode buffer
00001D10  2800                    1146          MOVE.L  D0,D4               ; Store the dest reg in D4
00001D12  0244 0E00               1147          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001D16  1A3C 0009               1148          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001D1A  EA6C                    1149          LSR.W   D5,D4               ; Do the actual shift
00001D1C                          1150          
00001D1C  2600                    1151          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001D1E  0243 01C0               1152          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001D22  1A3C 0006               1153          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001D26  EA6B                    1154          LSR.W   D5,D3               ; Do the actual shift 
00001D28  B63C 0001               1155          CMP.B   #1,D3               ; If dest mode is 001: An
00001D2C  6700 0648               1156          BEQ     DST_INVALID         ; Go to invalid message 
00001D30  4EB9 00002218           1157          JSR     EA_GEN_SRC          ; Get EA print
00001D36                          1158          
00001D36  4EF8 1B5A               1159          JMP     EA_FINISH           ; Opcode is finish
00001D3A                          1160  
00001D3A                          1161             
00001D3A                          1162  EA_MOVEA                            ; 2: ea_movea
00001D3A  2200                    1163          MOVE.L  D0,D1
00001D3C  0241 F000               1164          ANDI.W  #first_nibble,D1
00001D40  1A3C 000C               1165          MOVE.B  #right12,D5 
00001D44  EA69                    1166          LSR.W   D5,D1
00001D46  0201 0003               1167          ANDI.B  #3,D1
00001D4A  1401                    1168          MOVE.B  D1,D2
00001D4C  4EB8 1BD8               1169          JSR     EA_SIZE_MOVEA 
00001D50                          1170          
00001D50  14FC 0020               1171          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001D54                          1172          
00001D54                          1173          ; Get source and store into decode buffer
00001D54  2800                    1174          MOVE.L  D0,D4               ; Store the src reg in D4
00001D56  0244 0007               1175          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001D5A                          1176          
00001D5A  2600                    1177          MOVE.L  D0,D3               ; Store the src mode in D3
00001D5C  0243 0038               1178          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001D60  1A3C 0003               1179          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001D64  EA6B                    1180          LSR.W   D5,D3               ; Do the actual shift 
00001D66  4EB9 00002218           1181          JSR     EA_GEN_SRC
00001D6C                          1182          
00001D6C  14FC 002C               1183          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001D70  14FC 0020               1184          MOVE.B  #$20,(A2)+          ; Add space after comma
00001D74                          1185          
00001D74                          1186          ; Get desination and store into decode buffer
00001D74  2800                    1187          MOVE.L  D0,D4               ; Store the dest reg in D4
00001D76  0244 0E00               1188          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001D7A  1A3C 0009               1189          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001D7E  EA6C                    1190          LSR.W   D5,D4               ; Do the actual shift
00001D80                          1191          
00001D80  2600                    1192          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001D82  0243 01C0               1193          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001D86  1A3C 0006               1194          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001D8A  EA6B                    1195          LSR.W   D5,D3               ; Do the actual shift 
00001D8C  B63C 0001               1196          CMP.B   #1,D3               ; If dst mode is 001: An 
00001D90  6700 0006               1197          BEQ     MOVEA_DST_VALID     ; dst is valid, so branch 
00001D94  6000 05E0               1198          BRA     DST_INVALID         ; Otherwise, go to invalid message 
00001D98                          1199          
00001D98                          1200  MOVEA_DST_VALID
00001D98  4EB9 00002218           1201          JSR     EA_GEN_SRC          ; Get EA print
00001D9E  4EF8 1B5A               1202          JMP     EA_FINISH           ; Opcode is finish
00001DA2                          1203  
00001DA2                          1204  EA_LEA                              ; 3: ea_lea
00001DA2  14FC 0020               1205          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00001DA6  14FC 0020               1206          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00001DAA  14FC 0020               1207          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00001DAE  14FC 0020               1208          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00001DB2                          1209          
00001DB2  2800                    1210          MOVE.L  D0,D4               ; Store the src reg in D4
00001DB4  0244 0007               1211          ANDI.W  #src_reg,D4         ; get the bits at 2-0
00001DB8                          1212          
00001DB8  2600                    1213          MOVE.L  D0,D3               ; Store the src mode in D3
00001DBA  0243 0038               1214          ANDI.W  #src_mode,D3        ; get bits 5-3
00001DBE  1A3C 0003               1215          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB
00001DC2  EA6B                    1216          LSR.W   D5,D3               ; do the actual shift 
00001DC4  B67C 0002               1217          CMP     #2,D3               ; If D3 (src mode) is 010 (An)
00001DC8  6700 000E               1218          BEQ     LEA_SRC_VALID
00001DCC  B67C 0007               1219          CMP     #7,D3               ; If D3 (src mode) is 111 (W or L)
00001DD0  6700 0006               1220          BEQ     LEA_SRC_VALID
00001DD4  6000 05B0               1221          BRA     SRC_INVALID         ; when src mode is not 010 or 111, branch to error message
00001DD8                          1222          
00001DD8                          1223  LEA_SRC_VALID        
00001DD8  4EB9 00002218           1224          JSR     EA_GEN_SRC          ; Go to function 
00001DDE                          1225   
00001DDE  14FC 002C               1226          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001DE2  14FC 0020               1227          MOVE.B  #$20,(A2)+          ; Add space after comma
00001DE6                          1228  
00001DE6  2600                    1229          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001DE8  0243 01C0               1230          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001DEC  1A3C 0006               1231          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001DF0  EA6B                    1232          LSR.W   D5,D3               ; Do the actual shift
00001DF2  B63C 0007               1233          CMP.B   #7,D3               ; Check if D3 is 111
00001DF6  6700 0006               1234          BEQ     CHANGE_TO_001       ; change the D3 bits to 001 
00001DFA  6000 057A               1235          BRA     DST_INVALID         ; Print out an error message if bits 8-6 (dst mode) are not 111
00001DFE                          1236    
00001DFE                          1237  CHANGE_TO_001
00001DFE  163C 0001               1238          MOVE.B  #%001,D3            ; set D3 to 001 to ensure the print out A 
00001E02                          1239          
00001E02  2800                    1240          MOVE.L  D0,D4               ; Store the dest reg in D4 to get the Address register number
00001E04  0244 0E00               1241          ANDI.W  #dst_reg,D4         ; get the bits at 11-9
00001E08  1A3C 0009               1242          MOVE.B  #right9,D5          ; shift the bits 11-9 to the LSB
00001E0C  EA6C                    1243          LSR.W   D5,D4               ; do the actual shift
00001E0E  4EB9 00002218           1244          JSR     EA_GEN_SRC          ; Print out the address register
00001E14  4EF8 1B5A               1245          JMP     EA_FINISH           ; Opcode is finish
00001E18                          1246  
00001E18                          1247  EA_DSTONLY                          ; 4: ea_dstonly
00001E18  2200                    1248          MOVE.L  D0,D1
00001E1A  0241 0F00               1249          ANDI.W  #second_nibble,D1   ; get second nibble from D1
00001E1E  1A3C 0008               1250          MOVE.B  #right8,D5 
00001E22  EA69                    1251          LSR.W   D5,D1     
00001E24  B23C 0002               1252          CMP.B   #2, D1              ; When 0010 for second nibble
00001E28  6700 000E               1253          BEQ     EA_CLEAR            ; Then do EA_CLEAR
00001E2C  B23C 000E               1254          CMP.B   #$E, D1             ; When 1110 for second nibble
00001E30  6700 004C               1255          BEQ     EA_JSR              ; Then do EA_JSR
00001E34  6000 0540               1256          BRA     DST_INVALID     
00001E38                          1257          
00001E38                          1258  EA_CLEAR
00001E38  2200                    1259          MOVE.L  D0,D1
00001E3A  0241 01C0               1260          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00001E3E  1A3C 0006               1261          MOVE.B  #right6,D5          ; Store 6 into D5
00001E42  EA69                    1262          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00001E44  0201 0003               1263          ANDI.B  #3,D1               ; Remove the front bit from D1
00001E48  1401                    1264          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00001E4A  4EB8 1BA0               1265          JSR     EA_SIZE_GENERAL     ; Get size 
00001E4E                          1266          
00001E4E  14FC 0020               1267          MOVE.B  #$20,(A2)+          ; Add space after size
00001E52  14FC 0020               1268          MOVE.B  #$20,(A2)+          ; Add space 
00001E56  14FC 0020               1269          MOVE.B  #$20,(A2)+          ; Add space 
00001E5A                          1270          
00001E5A                          1271          ; Get desination and store into decode buffer
00001E5A  2800                    1272          MOVE.L  D0,D4               ; Store the current address into D4 
00001E5C  0244 0007               1273          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00001E60                          1274          
00001E60  2600                    1275          MOVE.L  D0,D3               ; Store the current address into D3 
00001E62  0243 0038               1276          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00001E66  1A3C 0003               1277          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00001E6A  EA6B                    1278          LSR.W   D5,D3               ; do the actual shift 
00001E6C  B63C 0001               1279          CMP.B   #1,D3               ; If dest mode is 001: An
00001E70  6700 0504               1280          BEQ     DST_INVALID         ; Go to invalid message 
00001E74  4EB9 00002218           1281          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00001E7A  4EF8 1B5A               1282          JMP     EA_FINISH           ; Opcode is finish
00001E7E                          1283          
00001E7E  14FC 0020               1284  EA_JSR  MOVE.B  #$20,(A2)+          ; Add space 
00001E82  14FC 0020               1285          MOVE.B  #$20,(A2)+          ; Add space 
00001E86  14FC 0020               1286          MOVE.B  #$20,(A2)+          ; Add space 
00001E8A  14FC 0020               1287          MOVE.B  #$20,(A2)+          ; Add space 
00001E8E  14FC 0020               1288          MOVE.B  #$20,(A2)+          ; Add space 
00001E92                          1289  
00001E92                          1290          ; Get EA and store into decode buffer   
00001E92  2800                    1291          MOVE.L  D0,D4               ; Store the current address into D4 
00001E94  0244 0007               1292          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00001E98                          1293          
00001E98  2600                    1294          MOVE.L  D0,D3               ; Store the current address into D3 
00001E9A  0243 0038               1295          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00001E9E  1A3C 0003               1296          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00001EA2  EA6B                    1297          LSR.W   D5,D3               ; do the actual shift 
00001EA4  B67C 0002               1298          CMP     #2,D3               ; If D3 (src mode) is 010: (An)
00001EA8  6700 000E               1299          BEQ     JSR_EA_VALID
00001EAC  B67C 0007               1300          CMP     #7,D3               ; If D3 (src mode) is 111: (W or L)
00001EB0  6700 0006               1301          BEQ     JSR_EA_VALID
00001EB4  6000 04E0               1302          BRA     EA_INVALID          ; Otherwise, branch to invalid message
00001EB8                          1303          
00001EB8                          1304  JSR_EA_VALID
00001EB8  4EB9 00002218           1305          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00001EBE  4EF8 1B5A               1306          JMP     EA_FINISH           ; Opcode is finish
00001EC2                          1307  
00001EC2                          1308  EA_EXT                              ; 5: ea_ext
00001EC2  2200                    1309          MOVE.L  D0,D1
00001EC4  0241 01C0               1310          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1 (get opmode)
00001EC8  1A3C 0006               1311          MOVE.B  #right6,D5          ; Store 6 into D5
00001ECC  EA69                    1312          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00001ECE  1401                    1313          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00001ED0  C2FC 0006               1314          MULU    #6, D1              ; Multiply 6 to D1 
00001ED4  41F9 00001EDE           1315          LEA     EA_EXT_TABLE,A0     ; Load table into A0
00001EDA  4EF0 1000               1316          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00001EDE                          1317  
00001EDE                          1318  EA_EXT_TABLE
00001EDE  4EF9 00001F0E           1319          JMP     EA_OPMODE_012456    ; 000: ADD/SUB/CMP/OR/AND
00001EE4  4EF9 00001F0E           1320          JMP     EA_OPMODE_012456    ; 001: ADD/SUB/CMP/OR/AND
00001EEA  4EF9 00001F0E           1321          JMP     EA_OPMODE_012456    ; 010: ADD/SUB/CMP/OR/AND
00001EF0  4EF9 00001FF8           1322          JMP     EA_OPMODE_37        ; 011: ADDA/MULS/MULU/DIVU
00001EF6  4EF9 00001F0E           1323          JMP     EA_OPMODE_012456    ; 100: ADD/SUB/CMP/OR/AND
00001EFC  4EF9 00001F0E           1324          JMP     EA_OPMODE_012456    ; 101: ADD/SUB/CMP/OR/AND
00001F02  4EF9 00001F0E           1325          JMP     EA_OPMODE_012456    ; 110: ADD/SUB/CMP/OR/AND
00001F08  4EF9 00001FF8           1326          JMP     EA_OPMODE_37        ; 111: ADDA/MULS/MULU/DIVU
00001F0E                          1327  
00001F0E                          1328  EA_OPMODE_012456
00001F0E  4EB8 1BEC               1329          JSR     EA_SIZE_OPMODE_012456    
00001F12                          1330          
00001F12  14FC 0020               1331          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001F16  14FC 0020               1332          MOVE.B  #$20,(A2)+          ; Print out a space 
00001F1A  14FC 0020               1333          MOVE.B  #$20,(A2)+          ; Print out a space
00001F1E                          1334          
00001F1E                          1335          ; Operation: <ea> + Dn -> Dn
00001F1E  B43C 0000               1336          CMP.B   #%000,D2            ; When 0 then Dn is destination
00001F22  6700 002E               1337          BEQ     Dn_DST
00001F26  B43C 0001               1338          CMP.B   #%001,D2            ; When 1 then Dn is destination
00001F2A  6700 0026               1339          BEQ     Dn_DST
00001F2E  B43C 0002               1340          CMP.B   #%010,D2            ; When 2 then Dn is destination
00001F32  6700 001E               1341          BEQ     Dn_DST
00001F36                          1342          
00001F36                          1343          ; Operation: Dn + <ea> -> <ea>
00001F36  B43C 0004               1344          CMP.B   #%100,D2            ; When 4 then Dn is source
00001F3A  6700 0054               1345          BEQ     Dn_SRC  
00001F3E  B43C 0005               1346          CMP.B   #%101,D2            ; When 5 then Dn is source
00001F42  6700 004C               1347          BEQ     Dn_SRC 
00001F46  B43C 0006               1348          CMP.B   #%110,D2            ; When 6 then Dn is source
00001F4A  6700 0044               1349          BEQ     Dn_SRC 
00001F4E                          1350          
00001F4E  6000 0446               1351          BRA     EA_INVALID
00001F52                          1352  
00001F52                          1353  Dn_DST
00001F52                          1354          ; Get source and store into decode buffer
00001F52  2800                    1355          MOVE.L  D0,D4               ; Store the src reg in D4
00001F54  0244 0007               1356          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001F58                          1357          
00001F58  2600                    1358          MOVE.L  D0,D3               ; Store the src mode in D3
00001F5A  0243 0038               1359          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001F5E  1A3C 0003               1360          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001F62  EA6B                    1361          LSR.W   D5,D3               ; Do the actual shift 
00001F64  4EB9 00001FD6           1362          JSR     AND_OR_CHECK 
00001F6A  4EB9 00002218           1363          JSR     EA_GEN_SRC          ; Get EA print
00001F70                          1364          
00001F70  14FC 002C               1365          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001F74  14FC 0020               1366          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F78                          1367          
00001F78                          1368          ; Get desination and store into decode buffer
00001F78  2800                    1369          MOVE.L  D0,D4               ; Store the dest reg in D4
00001F7A  0244 0E00               1370          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001F7E  1A3C 0009               1371          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001F82  EA6C                    1372          LSR.W   D5,D4               ; Do the actual shift
00001F84                          1373          
00001F84  7600                    1374          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
00001F86  4EB9 00002218           1375          JSR     EA_GEN_SRC          ; Get the Dn print
00001F8C  4EF8 1B5A               1376          JMP     EA_FINISH           ; Opcode is finish
00001F90                          1377            
00001F90                          1378  Dn_SRC  
00001F90  BC3C 000B               1379          CMP.B   #11,D6              ; If first nibble is 1011 (indicates CMP opcode)
00001F94  6700 0400               1380          BEQ     EA_INVALID          ; Then branch to error message
00001F98                          1381       
00001F98                          1382          ; Get source and store into decode buffer
00001F98  2800                    1383          MOVE.L  D0,D4               ; Store the src reg in D4
00001F9A  0244 0E00               1384          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001F9E  1A3C 0009               1385          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001FA2  EA6C                    1386          LSR.W   D5,D4               ; Do the actual shift
00001FA4                          1387          
00001FA4  7600                    1388          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
00001FA6  4EB9 00002218           1389          JSR     EA_GEN_SRC          ; Get the Dn print
00001FAC                          1390          
00001FAC  14FC 002C               1391          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001FB0  14FC 0020               1392          MOVE.B  #$20,(A2)+          ; Add space after comma
00001FB4                          1393  
00001FB4                          1394          ; Get destination and store into decode buffer
00001FB4  2800                    1395          MOVE.L  D0,D4               ; Store the dst reg in D4
00001FB6  0244 0007               1396          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001FBA                          1397          
00001FBA  2600                    1398          MOVE.L  D0,D3               ; Store the dest mode in D3
00001FBC  0243 0038               1399          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001FC0  1A3C 0003               1400          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001FC4  EA6B                    1401          LSR.W   D5,D3               ; Do the actual shift
00001FC6  4EB9 0000232E           1402          JSR     An_CHECK            ; Check if mode is An
00001FCC                          1403         
00001FCC  4EB9 00002218           1404          JSR     EA_GEN_SRC          ; Get EA print
00001FD2  4EF8 1B5A               1405          JMP     EA_FINISH           ; Opcode is finish
00001FD6                          1406  
00001FD6                          1407  AND_OR_CHECK
00001FD6  BC3C 000C               1408          CMP.B   #12,D6              ; If first nibble is 1100 (indicates AND opcode)
00001FDA  6700 000C               1409          BEQ     EA_AND              
00001FDE  BC3C 0008               1410          CMP.B   #8,D6               ; If first nibble is 1000 (indicates OR opcode)
00001FE2  6700 000A               1411          BEQ     EA_OR 
00001FE6  4E75                    1412          RTS
00001FE8                          1413  EA_AND
00001FE8  4EF9 0000232E           1414          JMP     An_CHECK            ; Go check if mode is An 
00001FEE                          1415      
00001FEE                          1416  EA_OR
00001FEE  14FC 0020               1417          MOVE.B  #$20,(A2)+          ; Print out a space
00001FF2  4EF9 0000232E           1418          JMP     An_CHECK            ; Check if mode is An
00001FF8                          1419          
00001FF8                          1420  EA_OPMODE_37
00001FF8  BC3C 0008               1421          CMP.B   #8,D6               ; If first nibble 1000: DIVU
00001FFC  6700 0012               1422          BEQ     EA_MULS_MULU_DIV
00002000  BC3C 000C               1423          CMP.B   #12,D6              ; If first nibble 1100: MULS/MULU
00002004  6700 000A               1424          BEQ     EA_MULS_MULU_DIV
00002008  BC3C 000D               1425          CMP.B   #13,D6              ; If first nibble 1101: ADDA
0000200C  6700 0050               1426          BEQ     EA_ADDA                
00002010                          1427  
00002010                          1428  EA_MULS_MULU_DIV
00002010  4EB8 1C34               1429          JSR     EA_SIZE_MULS_MULU_DIV 
00002014  143C 0001               1430          MOVe.B  #1,D2               ; Set D2 to 1, since we know size is word   
00002018                          1431  
00002018  14FC 0020               1432          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000201C  14FC 0020               1433          MOVE.B  #$20,(A2)+          ; Print out a space
00002020                          1434          
00002020                          1435          ; Get source and store into decode buffer
00002020  2800                    1436          MOVE.L  D0,D4               ; Store the src reg in D4
00002022  0244 0007               1437          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002026                          1438          
00002026  2600                    1439          MOVE.L  D0,D3               ; Store the src mode in D3
00002028  0243 0038               1440          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000202C  1A3C 0003               1441          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002030  EA6B                    1442          LSR.W   D5,D3               ; Do the actual shift
00002032  4EB9 0000232E           1443          JSR     An_CHECK            ; Check if mode is An 
00002038  4EB9 00002218           1444          JSR     EA_GEN_SRC          ; Go get EA print
0000203E                          1445          
0000203E  14FC 002C               1446          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002042  14FC 0020               1447          MOVE.B  #$20,(A2)+          ; Add space after comma
00002046                          1448          
00002046                          1449          ; Get desination and store into decode buffer
00002046  2800                    1450          MOVE.L  D0,D4               ; Store the dest reg in D4
00002048  0244 0E00               1451          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000204C  1A3C 0009               1452          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002050  EA6C                    1453          LSR.W   D5,D4               ; Do the actual shift
00002052                          1454          
00002052  7600                    1455          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
00002054  4EB9 00002218           1456          JSR     EA_GEN_SRC          ; Go get EA print
0000205A  4EF8 1B5A               1457          JMP     EA_FINISH           ; Opcode is finish
0000205E                          1458  
0000205E                          1459  EA_ADDA
0000205E  4EB8 1C20               1460          JSR     EA_SIZE_ADDA        ; Get size    
00002062                          1461  
00002062  14FC 0020               1462          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002066  14FC 0020               1463          MOVE.B  #$20,(A2)+          ; Print out a space
0000206A                          1464          
0000206A                          1465          ; Get source and store into decode buffer
0000206A  2800                    1466          MOVE.L  D0,D4               ; Store the src reg in D4
0000206C  0244 0007               1467          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002070                          1468          
00002070  2600                    1469          MOVE.L  D0,D3               ; Store the src mode in D3
00002072  0243 0038               1470          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002076  1A3C 0003               1471          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000207A  EA6B                    1472          LSR.W   D5,D3               ; Do the actual shift 
0000207C  4EB9 00002218           1473          JSR     EA_GEN_SRC
00002082                          1474          
00002082  14FC 002C               1475          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002086  14FC 0020               1476          MOVE.B  #$20,(A2)+          ; Add space after comma
0000208A                          1477          
0000208A                          1478          ; Get desination and store into decode buffer
0000208A  2800                    1479          MOVE.L  D0,D4               ; Store the dest reg in D4
0000208C  0244 0E00               1480          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002090  1A3C 0009               1481          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002094  EA6C                    1482          LSR.W   D5,D4               ; Do the actual shift
00002096                          1483          
00002096  7601                    1484          MOVE.L  #1,D3               ; Store 001 into D3, so it can jump to An 
00002098  4EB9 00002218           1485          JSR     EA_GEN_SRC          ; Go get EA print
0000209E  4EF8 1B5A               1486          JMP     EA_FINISH           ; Opcode is finish
000020A2                          1487  
000020A2                          1488  EA_MOVEM        ; 6: ea_movem
000020A2                          1489  
000020A2                          1490  EA_SHIFTS       ; 7: ea_shifts
000020A2  2200                    1491          MOVE.L  D0,D1               ; D0 is current instruction word
000020A4  0241 01C0               1492          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000020A8  1A3C 0006               1493          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000020AC  EA69                    1494          LSR.W   D5,D1               ; Shift dst mode into LSB position
000020AE  C2FC 0006               1495          MULU    #6, D1              ; Set displacement 
000020B2  41F9 000020BC           1496          LEA     EA_SHIFTS_TABLE,A0  ; Load table into A0
000020B8  4EF0 1000               1497          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000020BC                          1498  
000020BC                          1499  EA_SHIFTS_TABLE
000020BC  4EF9 0000215E           1500          JMP     EA_REGISTER_SHIFTS  ; 000 Register
000020C2  4EF9 0000215E           1501          JMP     EA_REGISTER_SHIFTS  ; 001 Register
000020C8  4EF9 0000215E           1502          JMP     EA_REGISTER_SHIFTS  ; 010 Register
000020CE  4EF9 000020EC           1503          JMP     EA_MEMORY_SHIFTS    ; 011 Memory
000020D4  4EF9 0000215E           1504          JMP     EA_REGISTER_SHIFTS  ; 100 Register
000020DA  4EF9 0000215E           1505          JMP     EA_REGISTER_SHIFTS  ; 101 Register
000020E0  4EF9 0000215E           1506          JMP     EA_REGISTER_SHIFTS  ; 110 Register
000020E6  4EF9 000020EC           1507          JMP     EA_MEMORY_SHIFTS    ; 111 Memory
000020EC                          1508          
000020EC                          1509  EA_MEMORY_SHIFTS
000020EC                          1510          ; Get EA and store into decode buffer
000020EC  2800                    1511          MOVE.L  D0,D4               ; Store the EA reg in D4
000020EE  0244 0007               1512          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000020F2                          1513          
000020F2  2600                    1514          MOVE.L  D0,D3               ; Store the EA mode in D3
000020F4  0243 0038               1515          ANDI.W  #src_mode,D3        ; Get bits 5-3
000020F8  1A3C 0003               1516          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000020FC  EA6B                    1517          LSR.W   D5,D3               ; Do the actual shift
000020FE  4EB9 0000232E           1518          JSR     An_CHECK            ; Check if mode is An 
00002104  4EB9 00002338           1519          JSR     Dn_CHECK            ; Check if mode is Dn
0000210A  4EB9 00002342           1520          JSR     IMMEDIATE_CHECK     ; Check if mode is immediate
00002110                          1521          
00002110  14FC 0020               1522          MOVE.B  #$20,(A2)+          ; Print out a space 
00002114  14FC 0020               1523          MOVE.B  #$20,(A2)+          ; Print out a space
00002118  14FC 0020               1524          MOVE.B  #$20,(A2)+          ; Print out a space
0000211C  14FC 0020               1525          MOVE.B  #$20,(A2)+          ; Print out a space
00002120                          1526          
00002120  4EB9 00002138           1527          JSR     FRONT_FORMAT
00002126  4EB9 00002218           1528          JSR     EA_GEN_SRC          ; Go get EA print
0000212C  B63C 002A               1529          CMP.B   #$2A,D3             ; When mode is 111 * 6 (2A)
00002130  6700 001E               1530          BEQ     BACK_PARENTHESIS  
00002134  4EF8 1B5A               1531          JMP     EA_FINISH           ; Opcode is finish
00002138                          1532  
00002138                          1533  FRONT_FORMAT
00002138  B63C 0007               1534          CMP.B   #7,D3               ; When mode is 111
0000213C  6700 0008               1535          BEQ     ADD_PARENTHESIS
00002140  14FC 0020               1536          MOVE.B  #$20,(A2)+          ; Print out a space
00002144  4E75                    1537          RTS
00002146                          1538          
00002146                          1539  ADD_PARENTHESIS
00002146  14FC 0020               1540          MOVE.B  #$20,(A2)+          ; Print out a space
0000214A  14FC 0028               1541          MOVE.B  #'(',(A2)+
0000214E  4E75                    1542          RTS
00002150                          1543          
00002150                          1544  BACK_PARENTHESIS            
00002150  14FC 0029               1545          MOVE.B  #')',(A2)+
00002154  1404                    1546          MOVE.B  D4,D2
00002156  4EB8 1C48               1547          JSR     EA_SIZE_MEMORY_SHIFTS
0000215A  4EF8 1B5A               1548          JMP     EA_FINISH           ; Opcode is finish
0000215E                          1549      
0000215E                          1550  EA_REGISTER_SHIFTS
0000215E  2200                    1551          MOVE.L  D0,D1
00002160  0241 01C0               1552          ANDI.W  #dst_mode,D1
00002164  1A3C 0006               1553          MOVE.B  #right6,D5 
00002168  EA69                    1554          LSR.W   D5,D1
0000216A  0201 0003               1555          ANDI.B  #3,D1               ; Remove bit 8 and get bits 7-6
0000216E  1401                    1556          MOVE.B  D1,D2
00002170  4EB8 1BA0               1557          JSR     EA_SIZE_GENERAL
00002174                          1558          
00002174  2600                    1559          MOVE.L  D0,D3               ; Store the instruction in D3
00002176  0243 0038               1560          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000217A  1A3C 0003               1561          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000217E  EA6B                    1562          LSR.W   D5,D3               ; Do the actual shift 
00002180  0203 0004               1563          ANDI.B  #4,D3               ; Get bit 5(ir) from bits 5-3
00002184  E44B                    1564          LSR.W   #2,D3
00002186                          1565  
00002186  B63C 0000               1566          CMP.B   #0,D3               ; When D1 is 0 (immediate)
0000218A  6700 0006               1567          BEQ     IMMEDIATE_SRC
0000218E  6000 0052               1568          BRA     REGISTER_SRC        ; When D1 is 1 (register)
00002192                          1569          
00002192                          1570  IMMEDIATE_SRC
00002192  14FC 0020               1571          MOVE.B  #$20,(A2)+          ; Add space
00002196  14FC 0020               1572          MOVE.B  #$20,(A2)+          ; Add space
0000219A  14FC 0020               1573          MOVE.B  #$20,(A2)+          ; Add space
0000219E                          1574          
0000219E                          1575          ; Get source and store into decode buffer
0000219E  2800                    1576          MOVE.L  D0,D4               ; Store the src reg in D4
000021A0  0244 0E00               1577          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
000021A4  1A3C 0009               1578          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
000021A8  EA6C                    1579          LSR.W   D5,D4               ; Do the actual shift
000021AA  4EB9 000021D2           1580          JSR     CHECK_IF_ZERO       ; Check if register is 0
000021B0                          1581          
000021B0  14FC 0023               1582          MOVE.B  #$23,(A2)+          ; Add # symbol
000021B4  0604 0030               1583          ADDI.B  #$30,D4             ; Convert hex to ASCII
000021B8  14C4                    1584          MOVE.B  D4,(A2)+            ; Store into buffer
000021BA                          1585          
000021BA  14FC 002C               1586          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000021BE  14FC 0020               1587          MOVE.B  #$20,(A2)+          ; Add space after comma
000021C2                          1588  
000021C2                          1589          ; Get destination and store into decode buffer
000021C2  2800                    1590          MOVE.L  D0,D4               ; Store the src reg in D4
000021C4  0244 0007               1591          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000021C8  4EB9 00002256           1592          JSR     EA_Dn               ; store Dn into decode buffer
000021CE  4EF8 1B5A               1593          JMP     EA_FINISH           ; Opcode is finish
000021D2                          1594                
000021D2                          1595  CHECK_IF_ZERO
000021D2  B83C 0000               1596          CMP.B   #0,D4               ; When D4 is 0 
000021D6  6700 0004               1597          BEQ     IMMEDIATE_EIGHT     ; Branch
000021DA  4E75                    1598          RTS
000021DC                          1599  
000021DC                          1600  IMMEDIATE_EIGHT
000021DC  183C 0008               1601          MOVE.B  #8,D4               ; Store 8 into D4 
000021E0  4E75                    1602          RTS
000021E2                          1603  
000021E2                          1604  REGISTER_SRC        
000021E2  14FC 0020               1605          MOVE.B  #$20,(A2)+          ; Add space
000021E6  14FC 0020               1606          MOVE.B  #$20,(A2)+          ; Add space
000021EA  14FC 0020               1607          MOVE.B  #$20,(A2)+          ; Add space
000021EE                          1608          
000021EE                          1609          ; Get source and store into decode buffer
000021EE  2800                    1610          MOVE.L  D0,D4               ; Store the src reg in D4
000021F0  0244 0E00               1611          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
000021F4  1A3C 0009               1612          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
000021F8  EA6C                    1613          LSR.W   D5,D4               ; Do the actual shift
000021FA  4EB9 00002256           1614          JSR     EA_Dn               ; store Dn into decode buffer
00002200                          1615          
00002200  14FC 002C               1616          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002204  14FC 0020               1617          MOVE.B  #$20,(A2)+          ; Add space after comma
00002208                          1618  
00002208                          1619          ; Get destination and store into decode buffer
00002208  2800                    1620          MOVE.L  D0,D4               ; Store the src reg in D4
0000220A  0244 0007               1621          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000220E  4EB9 00002256           1622          JSR     EA_Dn               ; store Dn into decode buffer
00002214  4EF8 1B5A               1623          JMP     EA_FINISH           ; Opcode is finish
00002218                          1624  
00002218                          1625  EA_QUICK        ; 8: ea_quick
00002218                          1626  
00002218                          1627  EA_BRANCH       ; 9: ea_branch
00002218                          1628  
00002218                          1629  EA_REG
00002218                          1630  
00002218                          1631  EA_GEN_SRC
00002218  41F9 00002226           1632          LEA     EA_GEN_TABLE_SRC, A0
0000221E  C6FC 0006               1633          MULU    #6, D3              ; use D3 to jump to the proper src mode and dst mode. 
00002222  4EF0 3000               1634          JMP     0(A0,D3)            ; jump to each ea src generation table entry 
00002226                          1635  
00002226                          1636  EA_GEN_TABLE_SRC
00002226  4EF9 00002256           1637          JMP     EA_Dn                       ; 000: Dn
0000222C  4EF9 00002262           1638          JMP     EA_An                       ; 001: An
00002232  4EF9 0000226E           1639          JMP     EA_An_Indirect              ; 010: (An)
00002238  4EF9 00002282           1640          JMP     EA_An_Indirect_Inc          ; 011: (An)+
0000223E  4EF9 0000229A           1641          JMP     EA_An_Indirect_Dec          ; 100: -(An)
00002244  4EF9 000022B2           1642          JMP     EA_UNSUPPORTED              ; 101: Unsupported EA
0000224A  4EF9 000022B2           1643          JMP     EA_UNSUPPORTED              ; 110: Unsupported EA
00002250  4EF9 000022C0           1644          JMP     EA_Absolute_And_Immediate   ; 111: (xxx).W,(xxx).L, or #<data>
00002256                          1645  
00002256                          1646  EA_Dn               ; 000: Dn
00002256  14FC 0044               1647          MOVE.B  #'D',(A2)+
0000225A  0604 0030               1648          ADDI.B  #$30,D4
0000225E  14C4                    1649          MOVE.B  D4,(A2)+
00002260  4E75                    1650          RTS
00002262                          1651  
00002262                          1652  EA_An               ; 001: An
00002262  14FC 0041               1653          MOVE.B  #'A',(A2)+
00002266  0604 0030               1654          ADDI.B  #$30,D4
0000226A  14C4                    1655          MOVE.B  D4,(A2)+
0000226C  4E75                    1656          RTS
0000226E                          1657  
0000226E                          1658  EA_An_Indirect      ; 010: (An)
0000226E  14FC 0028               1659          MOVE.B  #'(',(A2)+
00002272  14FC 0041               1660          MOVE.B  #'A',(A2)+
00002276  0604 0030               1661          ADDI.B  #$30,D4
0000227A  14C4                    1662          MOVE.B  D4,(A2)+
0000227C  14FC 0029               1663          MOVE.B  #')',(A2)+
00002280  4E75                    1664          RTS
00002282                          1665          
00002282                          1666  EA_An_Indirect_Inc  ; 011: (An)+
00002282  14FC 0028               1667          MOVE.B  #'(',(A2)+
00002286  14FC 0041               1668          MOVE.B  #'A',(A2)+
0000228A  0604 0030               1669          ADDI.B  #$30, D4
0000228E  14C4                    1670          MOVE.B  D4,(A2)+
00002290  14FC 0029               1671          MOVE.B  #')',(A2)+
00002294  14FC 002B               1672          MOVE.B  #'+',(A2)+
00002298  4E75                    1673          RTS
0000229A                          1674          
0000229A                          1675  EA_An_Indirect_Dec  ; 100: -(An)
0000229A  14FC 002D               1676          MOVE.B  #'-',(A2)+
0000229E  14FC 0028               1677          MOVE.B  #'(',(A2)+
000022A2  14FC 0041               1678          MOVE.B  #'A',(A2)+
000022A6  0604 0030               1679          ADDI.B  #$30,D4
000022AA  14C4                    1680          MOVE.B  D4,(A2)+
000022AC  14FC 0029               1681          MOVE.B  #')',(A2)+
000022B0  4E75                    1682          RTS
000022B2                          1683  
000022B2                          1684  EA_UNSUPPORTED
000022B2  43F9 000023F5           1685          LEA     EA_TYPE_ERROR,A1
000022B8  103C 000E               1686          MOVE.B  #14,D0
000022BC  4E4F                    1687          TRAP    #15  
000022BE  4E75                    1688          RTS 
000022C0                          1689          
000022C0                          1690  EA_Absolute_And_Immediate           ; 111: (xxx).W,(xxx).L, or #<data>
000022C0  B83C 0000               1691          CMP.B   #0,D4               ; If D4 is (xxx).W
000022C4  6700 0016               1692          BEQ     ABSOLUTE_WORD
000022C8                          1693          
000022C8  B83C 0001               1694          CMP.B   #1,D4               ; If D4 is (xxx).L
000022CC  6700 001A               1695          BEQ     ABSOLUTE_LONG
000022D0                          1696          
000022D0  B83C 0004               1697          CMP.B   #4,D4               ; If D4 is #<data>  
000022D4  6700 001E               1698          BEQ     IMMEDIATE
000022D8                          1699          
000022D8  6000 008C               1700          BRA     ABSOLUTE_IMMEDIATE_ERROR    
000022DC                          1701  
000022DC                          1702  ABSOLUTE_WORD
000022DC  14FC 0024               1703          MOVE.B  #$24,(A2)+          ; Add $ symbol
000022E0  7401                    1704          MOVE.L  #1,D2               ; Insert 1 to D2 
000022E2  4EB8 1114               1705          JSR     ITOA                ; Convert word hex values to ITOA
000022E6  4E75                    1706          RTS
000022E8                          1707          
000022E8                          1708  ABSOLUTE_LONG
000022E8  14FC 0024               1709          MOVE.B  #$24,(A2)+          ; Add $ symbol
000022EC  7402                    1710          MOVE.L  #2,D2               ; Insert 2 to D2
000022EE  4EB8 1114               1711          JSR     ITOA                ; Convert long hex values to ITOA
000022F2  4E75                    1712          RTS
000022F4                          1713     
000022F4                          1714  IMMEDIATE
000022F4  14FC 0023               1715          MOVE.B  #$23,(A2)+          ; Add # symbol
000022F8  14FC 0024               1716          MOVE.B  #$24,(A2)+          ; Add $ symbol
000022FC                          1717  
000022FC  BC3C 0001               1718          CMP.B   #1,D6               ; If MOVE.b (code0001)
00002300  6700 0020               1719          BEQ     DO_ITOA_MOVE
00002304  BC3C 0002               1720          CMP.B   #2, D6              ; If MOVE.l / MOVEA.l (code0010)
00002308  6700 0018               1721          BEQ     DO_ITOA_MOVE
0000230C  BC3C 0003               1722          CMP.B   #3, D6              ; If MOVE.w / MOVEA.w (code0011)
00002310  6700 0010               1723          BEQ     DO_ITOA_MOVE        
00002314  BC3C 000D               1724          CMP.B   #13, D6             ; If ADD / ADDA (code1101)
00002318  6700 000E               1725          BEQ     DO_ITOA_OPMODE
0000231C                          1726          
0000231C  4EB8 1114               1727          JSR     ITOA                ; Go to ITOA when not a move instruction
00002320  4E75                    1728          RTS
00002322                          1729          
00002322                          1730  DO_ITOA_MOVE
00002322  4EB8 1136               1731          JSR ITOA_MOVE
00002326  4E75                    1732          RTS
00002328                          1733                
00002328                          1734  DO_ITOA_OPMODE
00002328  4EB8 1158               1735          JSR ITOA_OPMODE
0000232C  4E75                    1736          RTS
0000232E                          1737  
0000232E                          1738  An_CHECK 
0000232E  B63C 0001               1739          CMP.B   #1,D3               ; If mode is An     
00002332  6700 0062               1740          BEQ     EA_INVALID          ; Then branch to error message
00002336  4E75                    1741          RTS   
00002338                          1742        
00002338                          1743  Dn_CHECK 
00002338  B63C 0000               1744          CMP.B   #0,D3               ; If mode is An     
0000233C  6700 0058               1745          BEQ     EA_INVALID          ; Then branch to error message
00002340  4E75                    1746          RTS    
00002342                          1747       
00002342                          1748  IMMEDIATE_CHECK
00002342  B63C 0007               1749          CMP.B   #7,D3
00002346  6700 0004               1750          BEQ     REGISTER_CHECK
0000234A  4E75                    1751          RTS
0000234C                          1752          
0000234C                          1753  REGISTER_CHECK
0000234C  B63C 0004               1754          CMP.B   #4,D3               ; If 100 in register
00002350  6700 0044               1755          BEQ     EA_INVALID          ; Branch to invalid
00002354  4E75                    1756          RTS   
00002356                          1757                
00002356                          1758  EA_WRONG_SIZE 
00002356  43F9 000023AB           1759          LEA     WRONG_SIZE_MESSAGE, A1 
0000235C  103C 000E               1760          MOVE.B  #14, D0
00002360  4E4F                    1761          TRAP    #15
00002362  6000 0042               1762          BRA     DONE
00002366                          1763          
00002366                          1764  ABSOLUTE_IMMEDIATE_ERROR  
00002366  43F9 000023B9           1765          LEA     ABSOLUTE_WRONGREG, A1 
0000236C  103C 000E               1766          MOVE.B  #14, D0
00002370  4E4F                    1767          TRAP    #15
00002372  6000 0032               1768          BRA     DONE
00002376                          1769          
00002376                          1770  DST_INVALID
00002376  43F9 00002417           1771          LEA     DST_INVALID_MSG, A1 
0000237C  103C 000E               1772          MOVE.B  #14, D0
00002380  4E4F                    1773          TRAP    #15
00002382  6000 0022               1774          BRA     DONE
00002386                          1775          
00002386                          1776  SRC_INVALID 
00002386  43F9 00002449           1777          LEA     SRC_INVALID_MSG, A1 
0000238C  103C 000E               1778          MOVE.B  #14, D0
00002390  4E4F                    1779          TRAP    #15
00002392  6000 0012               1780          BRA     DONE
00002396                          1781          
00002396                          1782  EA_INVALID  
00002396  43F9 00002476           1783          LEA     EA_INVALID_MSG, A1 
0000239C  103C 000E               1784          MOVE.B  #14, D0
000023A0  4E4F                    1785          TRAP    #15
000023A2  6000 0002               1786          BRA     DONE
000023A6                          1787           
000023A6  FFFF FFFF               1788  DONE    SIMHALT             ; halt simulator
000023AA                          1789  
000023AA                          1790  * Put variables and constants here
000023AA                          1791     
000023AA                          1792         
000023AA  =00000040               1793  buffer_size         EQU         64 
000023AA  =00005000               1794  decoded_buffer      EQU         $5000
000023AA                          1795     
000023AA  =0000000D               1796  CR                  EQU         $0D
000023AA  =0000000A               1797  LF                  EQU         $0A
000023AA  =0000A000               1798  stack               EQU         $0000A000
000023AA  =00000014               1799  lines_p_screen      EQU         20
000023AA  =00000003               1800  right3              EQU         3
000023AA  =00000004               1801  right4              EQU         4
000023AA  =00000006               1802  right6              EQU         6
000023AA  =00000008               1803  right8              EQU         8
000023AA  =00000009               1804  right9              EQU         9
000023AA  =0000000C               1805  right12             EQU         12
000023AA  =00000010               1806  right16             EQU         16
000023AA  =00000018               1807  right24             EQU         24
000023AA= 20                      1808  ascii_y_n           DC.B        32
000023AB  =00000059               1809  y_uppercase         EQU         $59         
000023AB  =00000079               1810  y_lowercase         EQU         $79
000023AB  =0000004E               1811  n_uppercase         EQU         $4E
000023AB  =0000006E               1812  n_lowercase         EQU         $6E
000023AB  =00000002               1813  task2               EQU         $02
000023AB  =00000005               1814  task5               EQU         $05
000023AB  =00000009               1815  task9               EQU         $09
000023AB  =0000000D               1816  task13              EQU         $0D
000023AB  =0000000E               1817  task14              EQU         $0E
000023AB  =0000F000               1818  first_nibble        EQU         $F000
000023AB  =00000F00               1819  second_nibble       EQU         $0F00   
000023AB  =000000F0               1820  third_nibble        EQU         $00F0
000023AB  =0000000F               1821  fourth_nibble       EQU         $000F
000023AB  =000001C0               1822  dst_mode            EQU         $01C0
000023AB  =00000E00               1823  dst_reg             EQU         $0E00
000023AB  =00000038               1824  src_mode            EQU         $0038
000023AB  =00000007               1825  src_reg             EQU         $0007
000023AB  =00000100               1826  bit8                EQU         $0100
000023AB                          1827  
000023AB  =00000000               1828  ea_type_immediate   EQU     0       ; EA Type = immediate
000023AB  =00000001               1829  ea_type_move        EQU     1       ; EA Type = move
000023AB  =00000002               1830  ea_type_movea       EQU     2       ; EA Type = movea
000023AB  =0000000C               1831  ea_type_movea6      EQU     12      ; EA Type = movea * 6
000023AB  =00000003               1832  ea_type_lea         EQU     3       ; EA Type = lea
000023AB  =00000004               1833  ea_type_dstonly     EQU     4       ; EA Type = clr, neg, not, jsr, jmp
000023AB  =00000005               1834  ea_type_ext         EQU     5       ; EA Type = ext, add, adda
000023AB  =00000006               1835  ea_type_movem       EQU     6       ; EA Type = movem
000023AB  =00000007               1836  ea_type_shifts      EQU     7       ; EA Type = ASL/ASR/LSL/LSR/ROL/ROR
000023AB                          1837  ; ea_type_trap        EQU     7       ; EA Type = trap
000023AB  =00000008               1838  ea_type_quick       EQU     8       ; EA Type = addq, subq
000023AB  =00000009               1839  ea_type_branch      EQU     9       ; EA Type = bra, bsr, bcc
000023AB  =00000000               1840  ea_bcc_flag         EQU     0       ; EA Type = branch, flag = bcc
000023AB  =00000001               1841  ea_dbcc_flag        EQU     1       ; EA Type = branch, flag = dbcc
000023AB  =00000002               1842  ea_scc_flag         EQU     2       ; EA Type = branch, flag = scc
000023AB  =00000007               1843  ea_type_shifts      EQU     7
000023AB                          1844  
000023AB= 57 72 6F 6E 67 20 ...   1845  WRONG_SIZE_MESSAGE  DC.B    'Wrong size.',CR,LF,0
000023B9= 45 52 52 4F 52 3A ...   1846  ABSOLUTE_WRONGREG   DC.B    'ERROR: Register does not exist for Absolute and immediate',CR,LF,0
000023F5= 45 52 52 4F 52 3A ...   1847  EA_TYPE_ERROR       DC.B    'ERROR: EA type is not supported',CR,LF,0
00002417= 45 52 52 4F 52 3A ...   1848  DST_INVALID_MSG     DC.B    'ERROR: Destination effective address is invalid',CR,LF,0
00002449= 45 52 52 4F 52 3A ...   1849  SRC_INVALID_MSG     DC.B    'ERROR: Source effective address is invalid',CR,LF,0
00002476= 45 52 52 4F 52 3A ...   1850  EA_INVALID_MSG      DC.B    'ERROR: Invalid addressing mode',CR,LF,0
00002497= 45 52 52 4F 52 3A ...   1851  OPCODE_INVALID      DC.B    'ERROR: Opcode is invalid',CR,LF,0
000024B2= 45 52 52 4F 52 3A ...   1852  ERROR_MESSAGE       DC.B    'ERROR: The input is invalid',CR,LF,0  
000024D0= 45 52 52 4F 52 3A ...   1853  ODD_ERROR_MESSAGE   DC.B    'ERROR: The last digit of the address is odd, which is invalid',CR,LF,0  
00002510                          1854               
00002510= 57 65 6C 63 6F 6D ...   1855  WELCOME             DC.B        'Welcome to the 68k Disassembler of Avery and Alan',CR,LF,CR,LF,0
00002546                          1856  
00002546= 50 6C 65 61 73 65 ...   1857  USER_INST           DC.B        'Please follow the proper input instructions below: ',CR,LF
0000257B= 2D 20 53 74 61 72 ...   1858                      DC.B        '- Starting address must be lower than ending address.',CR,LF
000025B2= 2D 20 54 68 65 20 ...   1859                      DC.B        '- The values for the starting and ending address must be an even value.',CR,LF
000025FB= 2D 20 53 74 61 72 ...   1860                      DC.B        '- Starting and ending address must be inputted as hexadecimal value.',CR,LF
00002641= 2D 20 44 6F 20 6E ...   1861                      DC.B        '- Do not put spaces in between input characters.',CR,LF
00002673= 2D 20 56 61 6C 69 ...   1862                      DC.B        '- Valid characters include: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F',CR,LF,0
000026C0                          1863                  
000026C0= 50 72 65 73 73 20 ...   1864  ENTER_PROMPT        DC.B        'Press enter to continue...',CR,LF,0
000026DD= 50 72 65 73 73 20 ...   1865  PROMPT_AGAIN        DC.B        'Press Y to continue / N to exit.',CR,LF,0
00002700= 50 72 6F 67 72 61 ...   1866  EXIT_PROMPT         DC.B        'Program has execution has stopped.',CR,LF,0
00002725                          1867        
00002725= 45 6E 74 65 72 20 ...   1868  START_IN            DC.B        'Enter a starting address: ',CR,LF,0 
00002742= 45 6E 74 65 72 20 ...   1869  END_IN              DC.B        'Enter an ending address: ',CR,LF,0 
0000275E                          1870  START_ADDRESS       DS.B        32     
0000277E                          1871  END_ADDRESS         DS.B        32 
0000279E                          1872       
0000279E                          1873  
0000279E                          1874      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_IMMEDIATE_ERROR  2366
ABSOLUTE_LONG       22E8
ABSOLUTE_WORD       22DC
ABSOLUTE_WRONGREG   23B9
ADD_PARENTHESIS     2146
AND_OR_CHECK        1FD6
AN_CHECK            232E
ASCII_TO_HEX_LETTER  1084
ASCII_Y_N           23AA
ATOI                105E
BACK_PARENTHESIS    2150
BIT8                100
BUFFER_SIZE         40
CHANGE_TO_001       1DFE
CHECK_IF_ZERO       21D2
CODE0000            13AE
CODE0001            13C8
CODE0010            13CC
CODE0011            13E4
CODE0100            13FC
CODE0101            1416
CODE0110            141A
CODE0111            1432
CODE1000            1436
CODE1001            1456
CODE1010            145A
CODE1011            145E
CODE1100            1462
CODE1101            147C
CODE1110            1496
CODE1111            1514
COMPLETE_END        10E6
COMPLETE_START      10DE
CONTINUE_OR_END     12AC
CR                  D
DECODED_BUFFER      5000
DECODE_MEMORY       12FC
DECODE_PAUSE        1298
DECODING_ITERATION  1274
DISP_UI             100C
DISP_W              1000
DN_CHECK            2338
DN_DST              1F52
DN_SRC              1F90
DONE                23A6
DO_ITOA_MOVE        2322
DO_ITOA_OPMODE      2328
DST_INVALID         2376
DST_INVALID_MSG     2417
DST_MODE            1C0
DST_REG             E00
EA_ABSOLUTE_AND_IMMEDIATE  22C0
EA_ADDA             205E
EA_AN               2262
EA_AND              1FE8
EA_AN_INDIRECT      226E
EA_AN_INDIRECT_DEC  229A
EA_AN_INDIRECT_INC  2282
EA_BCC_FLAG         0
EA_BRANCH           2218
EA_CLEAR            1E38
EA_DBCC_FLAG        1
EA_DN               2256
EA_DSTONLY          1E18
EA_EXT              1EC2
EA_EXT_TABLE        1EDE
EA_FINISH           1B5A
EA_GEN_SRC          2218
EA_GEN_TABLE_SRC    2226
EA_IMMEDIATE        1C7E
EA_INVALID          2396
EA_INVALID_MSG      2476
EA_JSR              1E7E
EA_LEA              1DA2
EA_MEMORY_SHIFTS    20EC
EA_MOVE             1CD2
EA_MOVEA            1D3A
EA_MOVEM            20A2
EA_MULS_MULU_DIV    2010
EA_OPMODE_012456    1F0E
EA_OPMODE_37        1FF8
EA_OR               1FEE
EA_QUICK            2218
EA_REG              2218
EA_REGISTER_SHIFTS  215E
EA_SCC_FLAG         2
EA_SHIFTS           20A2
EA_SHIFTS_TABLE     20BC
EA_SIZE_ADDA        1C20
EA_SIZE_B           1C5C
EA_SIZE_DONE        1C7C
EA_SIZE_GENERAL     1BA0
EA_SIZE_L           1C72
EA_SIZE_MEMORY_SHIFTS  1C48
EA_SIZE_MOVE        1BBC
EA_SIZE_MOVEA       1BD8
EA_SIZE_MULS_MULU_DIV  1C34
EA_SIZE_OPMODE_012456  1BEC
EA_SIZE_W           1C66
EA_SIZE_W_MEMORY    1C70
EA_START            1B48
EA_TYPE_BRANCH      9
EA_TYPE_DSTONLY     4
EA_TYPE_ERROR       23F5
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_SHIFTS      7
EA_TYPE_TABLE       1B60
EA_UNSUPPORTED      22B2
EA_WRONG_SIZE       2356
END_ADDRESS         277E
END_IN              2742
ENTER_PROMPT        26C0
ERROR_MESSAGE       24B2
EXIT                12EC
EXIT_PROMPT         2700
FIRST_NIBBLE        F000
FOURTH_NIBBLE       F
FRONT_FORMAT        2138
IMMEDIATE           22F4
IMMEDIATE_CHECK     2342
IMMEDIATE_EIGHT     21DC
IMMEDIATE_SRC       2192
INPUT_INVALID       10A6
ITOA                1114
ITOA_BYTE           119C
ITOA_BYTE_CONVERT   1230
ITOA_CONVERT_A_TO_F  1260
ITOA_DONE           126C
ITOA_LONG           11C6
ITOA_LONGADDRESS    11F8
ITOA_MOVE           1136
ITOA_NIBBLE_CONVERT  1250
ITOA_OPMODE         1158
ITOA_WORD           11AA
JSR_EA_VALID        1EB8
JSR_NOP_RTS         175E
LAST_DIGIT_CHECK    10C4
LAST_DIGIT_ODD      10F8
LEA_SRC_VALID       1DD8
LF                  A
LINES_P_SCREEN      14
MEMORY_1110_LEFT    14CC
MEMORY_1110_RIGHT   14F0
MOVEA_DST_VALID     1D98
N_LOWERCASE         6E
N_UPPERCASE         4E
ODD_ERROR_MESSAGE   24D0
OPCODE_INVALID      2497
OP_0000_TABLE       1518
OP_0100_TABLE       1578
OP_1100_TABLE       15D8
OP_1101_TABLE       1638
OP_1110_TABLE_REGISTER  1698
OP_ADD              1A64
OP_ADDA             1A80
OP_ADDI             17BC
OP_ADDQ             18C4
OP_AND              1A48
OP_ASL              1ABC
OP_ASR              1AA0
OP_AS_CHECK         16F8
OP_BCC              1900
OP_BGT              191C
OP_BLE              1938
OP_BRA              18E4
OP_BSR              1954
OP_CLEAR_DATA       1338
OP_CLEAR_DATA_LOOP  1344
OP_CLR              1820
OP_CMP              19EC
OP_DIVU             1998
OP_FINISH           1332
OP_JSR              1868
OP_LEA              18A8
OP_LSL              1AF4
OP_LSR              1AD8
OP_LS_CHECK         171A
OP_MOVE             1800
OP_MOVEA            17DC
OP_MOVEM            1884
OP_MOVEQ            1970
OP_MULS             1A28
OP_MULU             1A08
OP_NOP              183C
OP_OR               19B8
OP_ROL              1B2C
OP_ROR              1B10
OP_RO_CHECK         173C
OP_RTS              1858
OP_SUB              19D0
OP_SUBI             179C
OP_TABLE            134E
OP_UNSUPPORTED      178C
PROMPT_AGAIN        26DD
PROMPT_END          103E
PROMPT_START        1018
READ_END            104A
READ_START          102A
REGISTER_CHECK      234C
REGISTER_SRC        21E2
RIGHT12             C
RIGHT16             10
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT6              6
RIGHT8              8
RIGHT9              9
SECOND_NIBBLE       F00
SRC_INVALID         2386
SRC_INVALID_MSG     2449
SRC_MODE            38
SRC_REG             7
STACK               A000
START               1000
START_ADDRESS       275E
START_DECODING      1272
START_IN            2725
TASK13              D
TASK14              E
TASK2               2
TASK5               5
TASK9               9
THIRD_NIBBLE        F0
USER_INST           2546
VALIDATE_END        105A
VALIDATE_START      103A
WELCOME             2510
WRONG_SIZE_MESSAGE  23AB
Y_LOWERCASE         79
Y_UPPERCASE         59
