00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/9/2020 7:37:40 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler for the Motorola MC68000 Microprocessor
00000000                             3  * Written by :  Avery Mortenson & Alan Luu
00000000                             4  * Date       :  2/12/2020
00000000                             5  * Description:  An inverse assembler (disassembler) that will 
00000000                             6  * convert a memory image of instructions and data back 
00000000                             7  * to the MC68000 assembly code and that will output the 
00000000                             8  * disassembled code to the display.
00000000                             9  *-----------------------------------------------------------
00001000                            10      ORG    $1000
00001000                            11  START:            
00001000                            12  *------------------------------------------------------------*
00001000                            13  * D0: used for the tasks
00001000                            14  * D1: used to hold the size of the input obtained. 
00001000                            15  * D5: used to store the starting and ending address 
00001000                            16  * temporarily before moving them to A4 and A6 correspondingly. 
00001000                            17  * D6: used to check the last digit to see if the input 
00001000                            18  * for the starting and ending address causes a bus error. 
00001000                            19  * A1: a pointer to the message to print out. 
00001000                            20  *------------------------------------------------------------*
00001000  103C 000E                 21  DISP_W      MOVE.B  #14,D0                  ; Display Welcome Message. 
00001004  43F9 00002FA2             22              LEA     WELCOME,A1
0000100A  4E4F                      23              TRAP    #15
0000100C                            24  
0000100C                            25  * Put program code here
0000100C                            26  
0000100C  103C 000E                 27  DISP_UI         MOVE.B  #14,D0              ; Display User Instructions. 
00001010  43F9 00002FD8             28                  LEA     USER_INST,A1
00001016  4E4F                      29                  TRAP    #15    
00001018                            30  
00001018  4285                      31  PROMPT_START    CLR.L   D5
0000101A  4FF9 0000A000             32                  LEA     stack, SP           ; SP = stack ($A0000)
00001020  43F9 000031D8             33                  LEA     START_IN,A1         ; Display starting address message
00001026  103C 000E                 34                  MOVE.B  #14,D0
0000102A  4E4F                      35                  TRAP    #15       
0000102C                            36       
0000102C  43F9 00003211             37  READ_START      LEA     START_ADDRESS,A1    ; Store user's starting address input
00001032  103C 0002                 38                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001036  4E4F                      39                  TRAP    #15
00001038  1C3C 0000                 40                  MOVE.B  #0,D6               ; Used to indicate we are at start address
0000103C                            41  
0000103C  6000 0036                 42  VALIDATE_START  BRA     ATOI
00001040                            43  
00001040  4285                      44  PROMPT_END      CLR.L   D5
00001042  43F9 000031F5             45                  LEA     END_IN,A1           ; Display ending address message
00001048  103C 000E                 46                  MOVE.B  #14,D0
0000104C  4E4F                      47                  TRAP    #15
0000104E  6000 0010                 48                  BRA     READ_END
00001052                            49  
00001052  4285                      50  PROMPT_VA_END   CLR.L   D5                  ; prompt a valid ending address
00001054  43F9 000031B7             51                  LEA     PROMPT_V_END,A1     ; Display ending address message
0000105A  103C 000E                 52                  MOVE.B  #14,D0
0000105E  4E4F                      53                  TRAP    #15
00001060                            54              
00001060  43F9 00003231             55  READ_END        LEA     END_ADDRESS,A1      ; Store user's starting address input
00001066  103C 0002                 56                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
0000106A  4E4F                      57                  TRAP    #15
0000106C  1C3C 0001                 58                  MOVE.B  #1,D6               ; Used to indicate we are at end address
00001070                            59  
00001070  6000 0002                 60  VALIDATE_END    BRA     ATOI
00001074                            61                 
00001074                            62  * D0 stores the value to pushed from A1.
00001074                            63  
00001074  1019                      64  ATOI            MOVE.B  (A1)+,D0    ; Move to next character in A1 and store in D0          
00001076  B03C 0030                 65                  CMP.B   #$30,D0
0000107A  6D00 0040                 66                  BLT     INPUT_INVALID
0000107E  B03C 0039                 67                  CMP.B   #$39,D0
00001082  6E00 0016                 68                  BGT     ASCII_TO_HEX_LETTER
00001086  0400 0030                 69                  SUB.B   #$30,D0     ; Subtract by 30 to get the numbers 0-9
0000108A  DA80                      70                  ADD.L   D0,D5
0000108C  5341                      71                  SUBI    #1,D1       ; Decrement input's length to move to next character          
0000108E  B23C 0000                 72                  CMP.B   #0,D1       ; Compare to see if we're at the last digit
00001092  6700 0046                 73                  BEQ     LAST_DIGIT_CHECK
00001096  E98D                      74                  LSL.L   #4,D5
00001098  60DA                      75                  BRA     ATOI
0000109A                            76  
0000109A                            77    
0000109A  B03C 0041                 78  ASCII_TO_HEX_LETTER     CMP.B   #$41,D0
0000109E  6D00 001C                 79                          BLT     INPUT_INVALID
000010A2  B03C 0046                 80                          CMP.B   #$46, D0
000010A6  6E00 0014                 81                          BGT     INPUT_INVALID 
000010AA  0400 0031                 82                          SUB.B   #$31,D0     ; Subtract by 31 to get the numbers A-F
000010AE  5D00                      83                          SUB.B   #6,D0
000010B0  DA80                      84                          ADD.L   D0,D5
000010B2  5341                      85                          SUBI    #1,D1
000010B4  6700 0024                 86                          BEQ     LAST_DIGIT_CHECK
000010B8  E98D                      87                          LSL.L   #4,D5
000010BA  60B8                      88                          BRA     ATOI     
000010BC                            89  
000010BC                            90                      
000010BC  43F9 00002F44             91  INPUT_INVALID   LEA     ERROR_MESSAGE, A1   ; Display error message
000010C2  103C 000E                 92                  MOVE.B  #14, D0
000010C6  4E4F                      93                  TRAP    #15
000010C8  4206                      94                  CLR.B   D6
000010CA                            95                  
000010CA  BC3C 0000                 96                  CMP.B   #0,D6           ; When D6 is 0
000010CE  6700 FF48                 97                  BEQ     PROMPT_START    ; Go back to start prompt
000010D2  BC3C 0001                 98                  CMP.B   #1,D6           ; When D6 is 1
000010D6  6700 FF68                 99                  BEQ     PROMPT_END      ; Go back to end prompt
000010DA                           100  
000010DA                           101                            
000010DA  2E05                     102  LAST_DIGIT_CHECK    MOVE.L  D5, D7          ; D7 used as temporary storage
000010DC  E20F                     103                      LSR.B   #1, D7          ; Check for carry bit to see if last digit is odd
000010DE  6500 0036                104                      BCS     LAST_DIGIT_ODD  ; branch when there is a carry; this indicates odd last digit 
000010E2  4287                     105                      CLR.L   D7
000010E4  BC3C 0000                106                      CMP.B   #0,D6
000010E8  6700 000A                107                      BEQ     COMPLETE_START  
000010EC  BC3C 0001                108                      CMP.B   #1,D6
000010F0  6700 000A                109                      BEQ     COMPLETE_END
000010F4                           110  
000010F4  2845                     111  COMPLETE_START      MOVEA.L D5, A4  ; A4 holds the starting address
000010F6  4285                     112                      CLR.L   D5 
000010F8  6000 FF46                113                      BRA PROMPT_END
000010FC                           114  
000010FC  2C45                     115  COMPLETE_END        MOVEA.L D5, A6  ; A6 holds the ending address
000010FE                           116  
000010FE  3A0C                     117                      MOVE.W  A4, D5          ; move starting address to D5
00001100  BA4E                     118                      CMP.W   A6, D5          ; check if the ending address is less than starting address. 
00001102  6E00 FF4E                119                      BGT     PROMPT_VA_END   ; branch to prompt new ending address if so. 
00001106                           120              
00001106  2A4C                     121                      MOVEA.L A4, A5  ; Store starting address into current address
00001108                           122                      
00001108                           123                      *Clear the data and address registers used to obtain the starting and ending address 
00001108  4280                     124                      CLR.L   D0
0000110A  4285                     125                      CLR.L   D5
0000110C  4286                     126                      CLR.L   D6
0000110E  327C 0000                127                      MOVEA   #0, A1
00001112  6000 01D2                128                      BRA     START_DECODING  ; All inputs are valid, go to the decode process
00001116                           129                      
00001116  43F9 00002F62            130  LAST_DIGIT_ODD      LEA     ODD_ERROR_MESSAGE, A1 
0000111C  103C 000E                131                      MOVE.B  #14, D0
00001120  4E4F                     132                      TRAP    #15
00001122                           133                      
00001122  BC3C 0000                134                      CMP.B   #0,D6           ; When D6 is 0
00001126  6700 FEF0                135                      BEQ     PROMPT_START    ; Go back to start prompt
0000112A  BC3C 0001                136                      CMP.B   #1,D6           ; When D6 is 1
0000112E  6700 FF10                137                      BEQ     PROMPT_END      ; Go back to end prompt
00001132                           138  *--------------------------------------------------------------------------------------
00001132                           139  * param D2 data size to convert into ASCII
00001132                           140  * param A2 a pointer to decode_buf
00001132                           141  * param A5 the current address
00001132                           142  * itoa (D2, A2, A5) {
00001132                           143  * D0 byte data in ACII
00001132                           144  * D1 #sfhit
00001132                           145  * D7 long data to convert into ASCII
00001132                           146  * }
00001132                           147          
00001132                           148  ITOA                                ; convert integer to ASCII  
00001132  48E7 C000                149          MOVEM.L D0-D1,-(SP) 
00001136  B43C 0000                150          CMP.B   #%00, D2            ; byte
0000113A  6700 007E                151          BEQ     ITOA_BYTE
0000113E  B43C 0001                152          CMP.B   #%01, D2            ; word
00001142  6700 0096                153          BEQ     ITOA_WORD
00001146  B43C 0002                154          CMP.B   #%10, D2            ; long
0000114A  6700 00EE                155          BEQ     ITOA_LONG
0000114E  4EF9 0000126C            156          JMP     ITOA_LONGADDRESS    ; long address
00001154                           157          
00001154                           158  ITOA_MOVE                           ; convert integer to ASCII
00001154  48E7 C000                159          MOVEM.L D0-D1,-(SP) 
00001158  B43C 0001                160          CMP.B   #%01, D2            ; byte
0000115C  6700 005C                161          BEQ     ITOA_BYTE
00001160  B43C 0003                162          CMP.B   #%11, D2            ; word
00001164  6700 0074                163          BEQ     ITOA_WORD
00001168  B43C 0002                164          CMP.B   #%10,D2             ; long
0000116C  6700 00CC                165          BEQ     ITOA_LONG
00001170  4EF9 0000126C            166          JMP     ITOA_LONGADDRESS    ; long address
00001176                           167          
00001176                           168  ITOA_OPMODE                         ; convert integer to ASCII
00001176  48E7 C000                169          MOVEM.L D0-D1,-(SP) 
0000117A  B43C 0000                170          CMP.B   #%000,D2            ; When 0 then byte
0000117E  6700 003A                171          BEQ     ITOA_BYTE
00001182  B43C 0004                172          CMP.B   #%100,D2            ; When 4 then byte
00001186  6700 0032                173          BEQ     ITOA_BYTE 
0000118A  B43C 0001                174          CMP.B   #%001,D2            ; When 1 then word
0000118E  6700 004A                175          BEQ     ITOA_WORD
00001192  B43C 0003                176          CMP.B   #%011,D2            ; When 3 then word
00001196  6700 0042                177          BEQ     ITOA_WORD
0000119A  B43C 0005                178          CMP.B   #%101,D2            ; When 5 then word
0000119E  6700 003A                179          BEQ     ITOA_WORD 
000011A2  B43C 0002                180          CMP.B   #%010,D2            ; When 2 then long
000011A6  6700 0092                181          BEQ     ITOA_LONG
000011AA  B43C 0006                182          CMP.B   #%110,D2            ; When 6 then long
000011AE  6700 008A                183          BEQ     ITOA_LONG
000011B2  B43C 0007                184          CMP.B   #%111,D2            ; When 7 then long
000011B6  6700 0082                185          BEQ     ITOA_LONG
000011BA                           186          
000011BA                           187  ITOA_BYTE
000011BA  3E1D                     188          MOVE.W  (A5)+,D7
000011BC  4EB9 000012A4            189          JSR     ITOA_BYTE_CONVERT
000011C2  4EF9 000012E0            190          JMP     ITOA_DONE
000011C8                           191  
000011C8                           192  ITOA_BYTE_BRANCH
000011C8  48E7 C000                193          MOVEM.L D0-D1,-(SP)
000011CC  3E05                     194          MOVE.W  D5,D7
000011CE  4EB9 000012A4            195          JSR     ITOA_BYTE_CONVERT
000011D4  4EF9 000012E0            196          JMP     ITOA_DONE
000011DA                           197          
000011DA                           198  ITOA_WORD
000011DA  3E15                     199          MOVE.W  (A5),D7
000011DC  123C 0008                200          MOVE.B  #right8, D1
000011E0  E26F                     201          LSR.W   D1,D7
000011E2  4EB9 000012A4            202          JSR     ITOA_BYTE_CONVERT
000011E8  3E1D                     203          MOVE.W  (A5)+, D7
000011EA  4EB9 000012A4            204          JSR     ITOA_BYTE_CONVERT
000011F0  4EF9 000012E0            205          JMP     ITOA_DONE
000011F6                           206          
000011F6                           207  ITOA_WORD_BRANCH
000011F6  48E7 C000                208          MOVEM.L D0-D1,-(SP) 
000011FA  3E05                     209          MOVE.W  D5,D7
000011FC  123C 0008                210          MOVE.B  #right8, D1
00001200  E26F                     211          LSR.W   D1,D7
00001202  4EB9 000012A4            212          JSR     ITOA_BYTE_CONVERT
00001208  3E05                     213          MOVE.W  D5, D7
0000120A  361D                     214          MOVE.W  (A5)+, D3
0000120C  4EB9 000012A4            215          JSR     ITOA_BYTE_CONVERT
00001212  4EF9 000012E0            216          JMP     ITOA_DONE
00001218                           217          
00001218                           218  ITOA_WORD_ERROR
00001218  48E7 C000                219          MOVEM.L D0-D1,-(SP) 
0000121C  3E00                     220          MOVE.W  D0,D7
0000121E  123C 0008                221          MOVE.B  #right8, D1
00001222  E26F                     222          LSR.W   D1,D7
00001224  4EB9 000012A4            223          JSR     ITOA_BYTE_CONVERT
0000122A  3E00                     224          MOVE.W  D0, D7
0000122C  361D                     225          MOVE.W  (A5)+, D3
0000122E  4EB9 000012A4            226          JSR     ITOA_BYTE_CONVERT
00001234  4EF9 000012E0            227          JMP     ITOA_DONE
0000123A                           228          
0000123A                           229  ITOA_LONG
0000123A  3E15                     230          MOVE.W  (A5),D7
0000123C  123C 0008                231          MOVE.B  #right8, D1
00001240  E26F                     232          LSR.W   D1, D7
00001242  4EB9 000012A4            233          JSR     ITOA_BYTE_CONVERT
00001248  3E1D                     234          MOVE.W  (A5)+, D7
0000124A  4EB9 000012A4            235          JSR     ITOA_BYTE_CONVERT
00001250                           236          
00001250  3E15                     237          MOVE.W  (A5),D7
00001252  123C 0008                238          MOVE.B  #right8, D1
00001256  E26F                     239          LSR.W   D1, D7
00001258  4EB9 000012A4            240          JSR     ITOA_BYTE_CONVERT
0000125E  3E1D                     241          MOVE.W  (A5)+, D7
00001260  4EB9 000012A4            242          JSR     ITOA_BYTE_CONVERT
00001266  4EF9 000012E0            243          JMP     ITOA_DONE
0000126C                           244  
0000126C                           245  ITOA_LONGADDRESS
0000126C  3E0D                     246          MOVE.W  A5,D7
0000126E  123C 0018                247          MOVE.B  #right24,D1
00001272  E26F                     248          LSR.W   D1,D7
00001274  4EB9 000012A4            249          JSR     ITOA_BYTE_CONVERT
0000127A  3E0D                     250          MOVE.W  A5,D7
0000127C  123C 0010                251          MOVE.B  #right16,D1
00001280  E26F                     252          LSR.W   D1,D7
00001282  4EB9 000012A4            253          JSR     ITOA_BYTE_CONVERT
00001288  3E0D                     254          MOVE.W  A5,D7
0000128A  123C 0008                255          MOVE.B  #right8,D1
0000128E  E26F                     256          LSR.W   D1,D7
00001290  4EB9 000012A4            257          JSR     ITOA_BYTE_CONVERT
00001296  3E0D                     258          MOVE.W  A5,D7
00001298  4EB9 000012A4            259          JSR     ITOA_BYTE_CONVERT   
0000129E  4EF9 000012E0            260          JMP     ITOA_DONE   
000012A4                           261  
000012A4                           262  ITOA_BYTE_CONVERT
000012A4  3007                     263          MOVE.W  D7, D0 
000012A6  0240 00F0                264          ANDI.W  #$F0, D0
000012AA  123C 0004                265          MOVE.B  #right4, D1
000012AE  E268                     266          LSR.W   D1, D0
000012B0  4EB9 000012C4            267          JSR     ITOA_NIBBLE_CONVERT
000012B6                           268          
000012B6  3007                     269          MOVE.W  D7, D0
000012B8  0240 000F                270          ANDI.W  #$0F, D0
000012BC  4EB9 000012C4            271          JSR     ITOA_NIBBLE_CONVERT
000012C2  4E75                     272          RTS
000012C4                           273          
000012C4                           274  ITOA_NIBBLE_CONVERT
000012C4  B03C 0009                275          CMP.B   #9, D0
000012C8  6E00 000A                276          BGT     ITOA_CONVERT_A_TO_F
000012CC  0600 0030                277          ADD.B   #$30, D0
000012D0  14C0                     278          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
000012D2  4E75                     279          RTS
000012D4                           280          
000012D4                           281  ITOA_CONVERT_A_TO_F
000012D4  0400 000A                282          SUBI.B  #10, D0
000012D8  0600 0041                283          ADDI.B  #$41, D0
000012DC  14C0                     284          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
000012DE  4E75                     285          RTS
000012E0                           286  
000012E0                           287  ITOA_DONE
000012E0  4CDF 0003                288          MOVEM.L (SP)+, D0-D1
000012E4  4E75                     289          RTS
000012E6                           290  *-------------------------------------------------------------------------------*
000012E6                           291  START_DECODING
000012E6  4282                     292          CLR.L   D2
000012E8                           293          
000012E8                           294  DECODING_ITERATION
000012E8                           295          ;decoding the current address
000012E8  4EB9 00001398            296          JSR     DECODE_MEMORY
000012EE  103C 000D                297          MOVE.B  #task13, D0
000012F2  43F9 00005000            298          LEA     decoded_buffer, A1
000012F8  4E4F                     299          TRAP    #15
000012FA                           300          
000012FA                           301          ;check if decoding has finished or if the screen is filled 
000012FA  BDCD                     302          CMP.L   A5, A6
000012FC  6F00 0022                303          BLE     CONTINUE_OR_END     ; If A6-A5 <= 0, go to CONTINUE_OR_END 
00001300                           304          
00001300                           305          ;have yet to reach the ending address
00001300  5202                     306          ADDQ.B  #1, D2              ; D2 (screen_line_counter)++
00001302  B43C 001E                307          CMP.B   #lines_p_screen, D2
00001306  6C00 0004                308          BGE     DECODE_PAUSE
0000130A                           309          ;not yet reached the maximum lines per screen. 
0000130A  60DC                     310          BRA     DECODING_ITERATION
0000130C                           311  
0000130C                           312  DECODE_PAUSE
0000130C  103C 000E                313          MOVE.B  #task14, D0
00001310  43F9 00003152            314          LEA     ENTER_PROMPT, A1
00001316  4E4F                     315          TRAP    #15
00001318  103C 0005                316          MOVE.B  #task5, D0
0000131C  4E4F                     317          TRAP    #15
0000131E  60C6                     318          BRA     START_DECODING
00001320                           319  
00001320                           320  CONTINUE_OR_END
00001320  4280                     321          CLR.L   D0
00001322  4281                     322          CLR.L   D1
00001324  4282                     323          CLR.L   D2
00001326  4283                     324          CLR.L   D3
00001328  4284                     325          CLR.L   D4
0000132A  4285                     326          CLR.L   D5
0000132C  4286                     327          CLR.L   D6
0000132E  4287                     328          CLR.L   D7
00001330  327C 0000                329          MOVEA   #0,A1
00001334  347C 0000                330          MOVEA   #0,A2
00001338  367C 0000                331          MOVEA   #0,A3
0000133C  387C 0000                332          MOVEA   #0,A4
00001340  3A7C 0000                333          MOVEA   #0,A5
00001344  3C7C 0000                334          MOVEA   #0,A6
00001348                           335  
00001348  103C 000E                336          MOVE.B  #task14, D0
0000134C  43F9 0000316F            337          LEA     PROMPT_AGAIN, A1
00001352  4E4F                     338          TRAP    #15
00001354                           339          
00001354  103C 0002                340          MOVE.B  #task2, D0
00001358  43F9 00002E3C            341          LEA     ascii_y_n, A1
0000135E  4E4F                     342          TRAP    #15
00001360                           343          
00001360  1639 00002E3C            344          MOVE.B  ascii_y_n, D3
00001366  0C03 0059                345          CMPI.B  #y_uppercase, D3
0000136A  6700 FCAC                346          BEQ     PROMPT_START
0000136E  0C03 0079                347          CMPI.B  #y_lowercase, D3
00001372  6700 FCA4                348          BEQ     PROMPT_START
00001376  0C03 004E                349          CMPI.B  #n_uppercase, D3
0000137A  6700 000C                350          BEQ     EXIT
0000137E  0C03 006E                351          CMPI.B  #n_lowercase, D3
00001382  6700 0004                352          BEQ     EXIT
00001386  6098                     353          BRA     CONTINUE_OR_END 
00001388                           354          
00001388                           355  EXIT
00001388  103C 000E                356          MOVE.B  #task14, D0
0000138C  43F9 00003192            357          LEA     EXIT_PROMPT, A1
00001392  4E4F                     358          TRAP    #15  
00001394  6000 1AA2                359          BRA     DONE             
00001398                           360  *---------------------------------------------------------------------------------*
00001398                           361  * D0: the current instruction. 
00001398                           362  * D1: used as temp storage
00001398                           363  * D2: data size 
00001398                           364  * D3: loop counter for the amount of lines per screen. 
00001398                           365  * D4: 
00001398                           366  * D5: #shifts
00001398                           367  * D6: store first nibble
00001398                           368  * D7: 
00001398                           369  * A0: 
00001398                           370  * A1: A pointer to the message to print out. 
00001398                           371  * A2: A pointer to the decode_buffer. 
00001398                           372  * A3: 
00001398                           373  * A4: Store the starting address and increment to the ending address. 
00001398                           374  * A5: The current address. 
00001398                           375  * A6: Store the ending address. 
00001398                           376  * A7: Stack pointer. 
00001398                           377  *---------------------------------------------------------------------------------*                             
00001398                           378  DECODE_MEMORY       
00001398  48E7 2002                379          MOVEM.L D2/A6, -(SP)
0000139C                           380                  
0000139C                           381          ;zero clear the decode_buffer
0000139C  4EB9 000013D4            382          JSR     OP_CLEAR_DATA
000013A2  45F9 00005000            383          LEA     decoded_buffer, A2  Load decode buffer into A2
000013A8                           384                  
000013A8                           385          ;print out the current address
000013A8  7403                     386          MOVE.L  #$0003, D2
000013AA  4EB8 1132                387          JSR      ITOA
000013AE                           388          
000013AE  14FC 0009                389          MOVE.B  #$9, (A2)+  ; Add space after long address
000013B2                           390                  
000013B2                           391          ;load the next instruction and jump to the opcode table entry
000013B2  41F9 000013EA            392          LEA     OP_TABLE, A0
000013B8  4280                     393          CLR.L   D0
000013BA  301D                     394          MOVE.W  (A5)+, D0       ; Store A5's value into D0, then increment A5
000013BC  2200                     395          MOVE.L  D0, D1          ; Store A5's value from D0 into D1
000013BE  1A3C 000C                396          MOVE.B  #right12, D5    ; Store 12 into D5
000013C2  EA69                     397          LSR.W   D5, D1          ; Shift first nibble into LSB position
000013C4  2C01                     398          MOVE.L  D1, D6          ; Store first nibble into D6
000013C6  C2FC 0006                399          MULU    #6, D1          ; Multiply 6 to D1
000013CA  4EF0 1000                400          JMP     0(A0, D1)       ; Go to displacement (A0 + D1 * 6)      
000013CE                           401  OP_FINISH
000013CE  4CDF 4004                402          MOVEM.L (SP)+, D2/A6,
000013D2  4E75                     403          RTS
000013D4                           404  *------------------------------------------------------------------------------------*
000013D4                           405  *Clear the 32 bits within the decoded_buffer       
000013D4                           406  OP_CLEAR_DATA
000013D4  4283                     407          CLR.L   D3
000013D6  163C 0040                408          MOVE.B  #buffer_size, D3
000013DA  45F9 00005000            409          LEA     decoded_buffer, A2
000013E0                           410          
000013E0                           411  OP_CLEAR_DATA_LOOP
000013E0  14FC 0000                412          MOVE.B  #0, (A2)+
000013E4  5343                     413          SUBI    #1, D3
000013E6  6EF8                     414          BGT     OP_CLEAR_DATA_LOOP
000013E8  4E75                     415          RTS
000013EA                           416  
000013EA                           417  *------------------------------------------------------------------------------------*
000013EA                           418  OP_TABLE
000013EA  4EF9 0000144A            419          JMP     code0000    ; ADDI.bwl/ ANDI.bwl / CMPI.bwl / EORI.bwl / ORI.bwl / SUBI.bwl 
000013F0  4EF9 00001464            420          JMP     code0001    ; MOVE.b
000013F6  4EF9 00001468            421          JMP     code0010    ; MOVE.l / MOVEA.l
000013FC  4EF9 00001480            422          JMP     code0011    ; MOVE.w / MOVEA.w
00001402  4EF9 00001498            423          JMP     code0100    ; CLR.bwl / JMP / JSR / LEA / MOVEM.wl / NOP / NOT.bwl / RTS / STOP / TRAP
00001408  4EF9 000014B2            424          JMP     code0101    ; ADDQ.bwl / SUBQ.bwl / Scc / Dbcc
0000140E  4EF9 000014B6            425          JMP     code0110    ; BRA.bw / BSR.bw / Bcc.bw
00001414  4EF9 00001542            426          JMP     code0111    ; MOVEQ
0000141A  4EF9 00001546            427          JMP     code1000    ; DIVS / DIVU / CR.bwl
00001420  4EF9 00001566            428          JMP     code1001    ; SUB.bwl / SUBA.wl
00001426  4EF9 0000156A            429          JMP     code1010    ;   [unassigned]
0000142C  4EF9 0000156E            430          JMP     code1011    ; CMP.bwl / CMPA.wl / EOR.bwl
00001432  4EF9 00001572            431          JMP     code1100    ; MULS / MULU / AND.bwl
00001438  4EF9 0000158C            432          JMP     code1101    ; ADD.bwl / ADDA.wl / ADDX.bwl
0000143E  4EF9 000015A6            433          JMP     code1110    ; ASL.bwl / ASR.bwl / LSL.bwl / LSR.bwl / ROR.bwl / ROL.bwl
00001444  4EF9 00001624            434          JMP     code1111    ;   [unassigned]
0000144A                           435          
0000144A                           436  code0000                            ; Opcodes ADDI and SUBI
0000144A  2200                     437          MOVE.L  D0,D1               ; D0 is current instruction word
0000144C  0241 0F00                438          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
00001450  1A3C 0008                439          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001454  EA69                     440          LSR.W   D5,D1               ; Shift nibble into LSB position
00001456  C2FC 0006                441          MULU    #6, D1              ; Set displacement 
0000145A  41F9 00001628            442          LEA     OP_0000_TABLE,A0    ; Load table into A0
00001460  4EF0 1000                443          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00001464                           444  
00001464                           445  code0001                            ; Opcode MOVE.B
00001464  6000 052E                446          BRA     OP_MOVE             ; Go to opcode MOVE
00001468                           447  
00001468                           448  code0010                            ; Opcodes MOVE.L and MOVEA.L 
00001468  2200                     449          MOVE.L  D0,D1               ; D0 is current instruction word
0000146A  0241 01C0                450          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000146E  1A3C 0006                451          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001472  EA69                     452          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001474  B23C 0001                453          CMP.B   #1, D1              ; When 001 in destination mode
00001478  6700 04F6                454          BEQ     OP_MOVEA            ; Go to opcode MOVEA
0000147C  6000 0516                455          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001480                           456  
00001480                           457  code0011                            ; Opcodes MOVE.W and MOVEA.W 
00001480  2200                     458          MOVE.L  D0,D1               ; D0 is current instruction word
00001482  0241 01C0                459          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001486  1A3C 0006                460          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000148A  EA69                     461          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000148C  B23C 0001                462          CMP.B   #1, D1              ; When 001 in destination mode
00001490  6700 04DE                463          BEQ     OP_MOVEA            ; Go to opcode MOVEA
00001494  6000 04FE                464          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001498                           465  
00001498                           466  code0100                            ; Opcodes CLR, JSR, LEA, MOVEM, NOP, RTS
00001498  2200                     467          MOVE.L  D0,D1               ; D0 is current instruction word
0000149A  0241 0F00                468          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
0000149E  1A3C 0008                469          MOVE.B  #right8,D5          ; Used to shift 8 times to right
000014A2  EA69                     470          LSR.W   D5,D1               ; Shift nibble into LSB position
000014A4  C2FC 0006                471          MULU    #6, D1              ; Set displacement 
000014A8  41F9 00001688            472          LEA     OP_0100_TABLE,A0    ; Load table into A0
000014AE  4EF0 1000                473          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000014B2                           474  
000014B2                           475  code0101                            ; Opcode ADDQ.B/W/L
000014B2  6000 0598                476          BRA     OP_ADDQ             ; Go to opcode ADDQ
000014B6                           477  
000014B6                           478  code0110                            ; Opcodes BRA / BSR / BHI
000014B6  2200                     479          MOVE.L  D0,D1               ; D0 is current instruction word
000014B8  0241 0F00                480          ANDI.W  #second_nibble,D1   ; Extract 2nd 4 bits from instruction word
000014BC  1A3C 0008                481          MOVE.B  #right8,D5          ; Used to shift 8 times to right
000014C0  EA69                     482          LSR.W   D5,D1               ; Shift nibble into LSB position
000014C2  B23C 0000                483          CMP.B   #0, D1              ; When 0000 in second nibble 
000014C6  6700 05A4                484          BEQ     OP_BRA              ; Go to opcode BRA
000014CA  B23C 0001                485          CMP.B   #1, D1              ; When 0001 in second nibble 
000014CE  6700 05B8                486          BEQ     OP_BSR              ; Go to opcode BSR
000014D2  B23C 0002                487          CMP.B   #2, D1              ; When 0010 in second nibble 
000014D6  6700 05CC                488          BEQ     OP_BHI              ; Go to opcode BHI
000014DA  B23C 0003                489          CMP.B   #3, D1              ; When 0011 in second nibble
000014DE  6700 05E0                490          BEQ     OP_BLS              ; Go to opcode BLS
000014E2  B23C 0004                491          CMP.B   #4, D1              ; When 0100 in second nibble
000014E6  6700 05F4                492          BEQ     OP_BCC              ; Go to opcode BCC
000014EA  B23C 0005                493          CMP.B   #5, D1              ; When 0101 in second nibble
000014EE  6700 0608                494          BEQ     OP_BCS              ; Go to opcode BCS
000014F2  B23C 0006                495          CMP.B   #6, D1              ; When 0110 in second nibble
000014F6  6700 061C                496          BEQ     OP_BNE              ; Go to opcode BNE
000014FA  B23C 0007                497          CMP.B   #7, D1              ; When 0111 in second nibble
000014FE  6700 0630                498          BEQ     OP_BEQ              ; Go to opcode BEQ
00001502  B23C 0008                499          CMP.B   #8, D1              ; When 1000 in second nibble
00001506  6700 0644                500          BEQ     OP_BVC              ; Go to opcode BVC
0000150A  B23C 0009                501          CMP.B   #9, D1              ; When 1001 in second nibble
0000150E  6700 0658                502          BEQ     OP_BVS              ; Go to opcode BVS
00001512  B23C 000A                503          CMP.B   #10, D1             ; When 1010 in second nibble
00001516  6700 066C                504          BEQ     OP_BPL              ; Go to opcode BPL
0000151A  B23C 000B                505          CMP.B   #11, D1             ; When 1011 in second nibble
0000151E  6700 0680                506          BEQ     OP_BMI              ; Go to opcode BMI
00001522  B23C 000C                507          CMP.B   #12, D1             ; When 1100 in second nibble
00001526  6700 0694                508          BEQ     OP_BGE              ; Go to opcode BGE
0000152A  B23C 000D                509          CMP.B   #13, D1             ; When 1101 in second nibble
0000152E  6700 06A8                510          BEQ     OP_BLT              ; Go to opcode BLT
00001532  B23C 000E                511          CMP.B   #14, D1             ; When 1110 in second nibble
00001536  6700 06BC                512          BEQ     OP_BGT              ; Go to opcode BGT
0000153A  B23C 000F                513          CMP.B   #15, D1             ; When 1111 in second nibble
0000153E  6700 06D0                514          BEQ     OP_BLE              ; Go to opcode BLE
00001542                           515  
00001542                           516  code0111                            ; Opcode MOVEQ
00001542  6000 06E8                517          BRA     OP_MOVEQ            ; Go to opcode MOVEQ
00001546                           518  
00001546                           519  code1000                            ; Opcodes DIVU word and OR.B/W/L
00001546  2200                     520          MOVE.L  D0,D1               ; D0 is current instruction word
00001548  0241 01C0                521          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000154C  1A3C 0006                522          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001550  EA69                     523          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001552  B23C 0003                524          CMP.B   #3,D1               ; When 011 in destination mode
00001556  6700 06F8                525          BEQ     OP_DIVU             ; Go to opcode DIVU word
0000155A  B23C 0007                526          CMP.B   #7,D1               ; When 111
0000155E  6700 03CC                527          BEQ     OP_UNSUPPORTED      ; Go to opcode unsupported
00001562  6000 070C                528          BRA     OP_OR               ; Otherwise, go to opcode OR
00001566                           529  
00001566                           530  code1001                            ; Opcode SUB.B/W/L
00001566  6000 0720                531          BRA     OP_SUB              ; Go to opcode SUB   
0000156A                           532          
0000156A                           533  code1010                            ; Opcode not supported 
0000156A  6000 03C0                534          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
0000156E                           535       
0000156E                           536  code1011                            ; Opcode CMP.B/W/L
0000156E  6000 0734                537          BRA     OP_CMP              ; Go to opcode CMP
00001572                           538  
00001572                           539  code1100                            ; Opcodes MULS, MULU, AND.B/W/L
00001572  2200                     540          MOVE.L  D0,D1               ; D0 is current instruction word
00001574  0241 01C0                541          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001578  1A3C 0006                542          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000157C  EA69                     543          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000157E  C2FC 0006                544          MULU    #6, D1              ; Set displacement 
00001582  41F9 000016E8            545          LEA     OP_1100_TABLE,A0    ; Load table into A0
00001588  4EF0 1000                546          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
0000158C                           547  
0000158C                           548  code1101                            ; Opcodes ADD.B/W/L, ADDA.B/W/L
0000158C  2200                     549          MOVE.L  D0,D1               ; D0 is current instruction word
0000158E  0241 01C0                550          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001592  1A3C 0006                551          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001596  EA69                     552          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001598  C2FC 0006                553          MULU    #6, D1              ; Set displacement 
0000159C  41F9 00001748            554          LEA     OP_1101_TABLE,A0    ; Load table into A0
000015A2  4EF0 1000                555          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
000015A6                           556  
000015A6                           557  code1110                            ; Opcodes ASL.B/W/L, ASR.B/W/L, LSL.B/W/L, LSR.B/W/L, ROL.B/W/L, ROR.B/W/L   
000015A6  2200                     558          MOVE.L  D0,D1               ; D0 is current instruction word
000015A8  0241 01C0                559          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000015AC  1A3C 0006                560          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000015B0  EA69                     561          LSR.W   D5,D1               ; Shift dst mode into LSB position
000015B2                           562     
000015B2                           563          ; Check Memory Shifts
000015B2  B23C 0007                564          CMP.B   #7, D1              ; When 111
000015B6  6700 0024                565          BEQ     MEMORY_1110_LEFT    ; Go to Memory Shift Left Side
000015BA                           566      
000015BA  B23C 0003                567          CMP.B   #3, D1              ; When 011
000015BE  6700 0040                568          BEQ     MEMORY_1110_RIGHT   ; Go Memory Shift Right Side
000015C2                           569      
000015C2                           570          ; Check Register Shifts
000015C2  2200                     571          MOVE.L  D0,D1                       ; D0 is current instruction word
000015C4  0241 0038                572          ANDI.W  #src_mode,D1                ; Extract 5-3 bits from instruction word
000015C8  1A3C 0003                573          MOVE.B  #right3,D5                  ; Used to shift 3 times to right
000015CC  EA69                     574          LSR.W   D5,D1                       ; Shift 5-3 bits into LSB position
000015CE  C2FC 0006                575          MULU    #6,D1                       ; Set displacement 
000015D2  41F9 000017A8            576          LEA     OP_1110_TABLE_REGISTER,A0   ; Load table into A0
000015D8  4EF0 1000                577          JMP     0(A0,D1)                    ; go to displacement (A0 + D1 * 6)
000015DC                           578  
000015DC                           579  MEMORY_1110_LEFT    
000015DC  2200                     580          MOVE.L  D0,D1               ; D0 is current instruction word
000015DE  0241 0E00                581          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
000015E2  1A3C 0009                582          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000015E6  EA69                     583          LSR.W   D5,D1               ; Shift dst reg into LSB position
000015E8  B23C 0000                584          CMP.B   #0,D1               ; When D1 is 0
000015EC  6700 0786                585          BEQ     OP_ASL              ; Go to opcode ASL
000015F0  B23C 0001                586          CMP.B   #1, D1              ; when D1 is 1
000015F4  6700 07B6                587          BEQ     OP_LSL              ; Go to opcode LSL
000015F8  B23C 0003                588          CMP.B   #3, D1              ; When D1 is 3
000015FC  6700 07E6                589          BEQ     OP_ROL              ; Go to opcode ROL
00001600                           590  
00001600                           591  MEMORY_1110_RIGHT
00001600  2200                     592          MOVE.L  D0,D1               ; D0 is current instruction word
00001602  0241 0E00                593          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
00001606  1A3C 0009                594          MOVE.B  #right9,D5          ; Used to shift 9 times to right
0000160A  EA69                     595          LSR.W   D5,D1               ; Shift dst reg into LSB position
0000160C  B23C 0000                596          CMP.B   #0,D1               ; When D1 is 0
00001610  6700 0746                597          BEQ     OP_ASR              ; Go to opcode ASR
00001614  B23C 0001                598          CMP.B   #1, D1              ; when D1 is 1
00001618  6700 0776                599          BEQ     OP_LSR              ; Go to opcode LSR
0000161C  B23C 0003                600          CMP.B   #3, D1              ; When D1 is 3
00001620  6700 07A6                601          BEQ     OP_ROR              ; Go to opcode ROR
00001624                           602  
00001624                           603  code1111                            ; Opcode not supported 
00001624  6000 0306                604          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
00001628                           605           
00001628                           606  OP_0000_TABLE
00001628  4EF9 0000192C            607          JMP     OP_UNSUPPORTED  ; 0 Go to opcode unsupported  
0000162E  4EF9 0000192C            608          JMP     OP_UNSUPPORTED  ; 1 Go to opcode unsupported  
00001634  4EF9 0000192C            609          JMP     OP_UNSUPPORTED  ; 2 Go to opcode unsupported  
0000163A  4EF9 0000192C            610          JMP     OP_UNSUPPORTED  ; 3 Go to opcode unsupported  
00001640  4EF9 00001930            611          JMP     OP_SUBI         ; 4 Go to opcode SUBI
00001646  4EF9 0000192C            612          JMP     OP_UNSUPPORTED  ; 5 Go to opcode unsupported  
0000164C  4EF9 00001950            613          JMP     OP_ADDI         ; 6 Go to opcode ADDI
00001652  4EF9 0000192C            614          JMP     OP_UNSUPPORTED  ; 7 Go to opcode unsupported  
00001658  4EF9 0000192C            615          JMP     OP_UNSUPPORTED  ; 8 Go to opcode unsupported  
0000165E  4EF9 0000192C            616          JMP     OP_UNSUPPORTED  ; 9 Go to opcode unsupported  
00001664  4EF9 0000192C            617          JMP     OP_UNSUPPORTED  ; A Go to opcode unsupported  
0000166A  4EF9 0000192C            618          JMP     OP_UNSUPPORTED  ; B Go to opcode unsupported  
00001670  4EF9 0000192C            619          JMP     OP_UNSUPPORTED  ; C Go to opcode unsupported  
00001676  4EF9 0000192C            620          JMP     OP_UNSUPPORTED  ; D Go to opcode unsupported  
0000167C  4EF9 0000192C            621          JMP     OP_UNSUPPORTED  ; E Go to opcode unsupported  
00001682  4EF9 0000192C            622          JMP     OP_UNSUPPORTED  ; F Go to opcode unsupported  
00001688                           623      
00001688                           624  OP_0100_TABLE
00001688  4EF9 0000192C            625          JMP     OP_UNSUPPORTED      ; 0 Go to opcode unsupported  
0000168E  4EF9 00001A30            626          JMP     OP_LEA              ; 1 Go to opcode LEA
00001694  4EF9 000019B4            627          JMP     OP_CLR              ; 2 Go to opcode CLR
0000169A  4EF9 00001A30            628          JMP     OP_LEA              ; 3 Go to opcode LEA
000016A0  4EF9 0000192C            629          JMP     OP_UNSUPPORTED      ; 4 Go to opcode unsupported  
000016A6  4EF9 00001A30            630          JMP     OP_LEA              ; 5 Go to opcode LEA
000016AC  4EF9 00001950            631          JMP     OP_ADDI             ; 6 Go to opcode ADDI
000016B2  4EF9 00001A30            632          JMP     OP_LEA              ; 7 Go to opcode LEA
000016B8  4EF9 00001A0C            633          JMP     OP_MOVEM            ; 8 Go to opcode MOVEM
000016BE  4EF9 00001A30            634          JMP     OP_LEA              ; 9 Go to opcode LEA
000016C4  4EF9 0000192C            635          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000016CA  4EF9 00001A30            636          JMP     OP_LEA              ; B Go to opcode LEA
000016D0  4EF9 00001A0C            637          JMP     OP_MOVEM            ; C Go to opcode MOVEM
000016D6  4EF9 00001A30            638          JMP     OP_LEA              ; D Go to opcode LEA
000016DC  4EF9 0000186E            639          JMP     JSR_NOP_RTS         ; E Go to opcode JSR, NOP, or RTS
000016E2  4EF9 0000192C            640          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000016E8                           641      
000016E8                           642  OP_1100_TABLE
000016E8  4EF9 00001D00            643          JMP     OP_AND              ; 0 Go to opcode AND 
000016EE  4EF9 00001D00            644          JMP     OP_AND              ; 1 Go to opcode AND
000016F4  4EF9 00001D00            645          JMP     OP_AND              ; 2 Go to opcode AND
000016FA  4EF9 00001CC0            646          JMP     OP_MULU             ; 3 Go to opcode MULU
00001700  4EF9 00001D00            647          JMP     OP_AND              ; 4 Go to opcode AND 
00001706  4EF9 00001D00            648          JMP     OP_AND              ; 5 Go to opcode AND
0000170C  4EF9 00001D00            649          JMP     OP_AND              ; 6 Go to opcode AND
00001712  4EF9 00001CE0            650          JMP     OP_MULS             ; 7 Go to opcode MULS
00001718  4EF9 0000192C            651          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000171E  4EF9 0000192C            652          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001724  4EF9 0000192C            653          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
0000172A  4EF9 0000192C            654          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
00001730  4EF9 0000192C            655          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001736  4EF9 0000192C            656          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000173C  4EF9 0000192C            657          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001742  4EF9 0000192C            658          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001748                           659      
00001748                           660  OP_1101_TABLE
00001748  4EF9 00001D1C            661          JMP     OP_ADD              ; 0 Go to opcode ADD 
0000174E  4EF9 00001D1C            662          JMP     OP_ADD              ; 1 Go to opcode ADD
00001754  4EF9 00001D1C            663          JMP     OP_ADD              ; 2 Go to opcode ADD
0000175A  4EF9 00001D38            664          JMP     OP_ADDA             ; 3 Go to opcode ADDA
00001760  4EF9 00001D1C            665          JMP     OP_ADD              ; 4 Go to opcode ADD 
00001766  4EF9 00001D1C            666          JMP     OP_ADD              ; 5 Go to opcode ADD
0000176C  4EF9 00001D1C            667          JMP     OP_ADD              ; 6 Go to opcode ADD
00001772  4EF9 00001D38            668          JMP     OP_ADDA             ; 7 Go to opcode ADDA
00001778  4EF9 0000192C            669          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000177E  4EF9 0000192C            670          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001784  4EF9 0000192C            671          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
0000178A  4EF9 0000192C            672          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
00001790  4EF9 0000192C            673          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001796  4EF9 0000192C            674          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000179C  4EF9 0000192C            675          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
000017A2  4EF9 0000192C            676          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000017A8                           677      
000017A8                           678  OP_1110_TABLE_REGISTER
000017A8  4EF9 00001808            679          JMP     OP_AS_CHECK         ; 0 Check if AS is left or right
000017AE  4EF9 0000182A            680          JMP     OP_LS_CHECK         ; 1 Check if LS is left or right
000017B4  4EF9 0000192C            681          JMP     OP_UNSUPPORTED      ; 2 Go to opcode unsupported  
000017BA  4EF9 0000184C            682          JMP     OP_RO_CHECK         ; 3 Check if RO is left or right
000017C0  4EF9 00001808            683          JMP     OP_AS_CHECK         ; 4 Check if AS is left or right
000017C6  4EF9 0000182A            684          JMP     OP_LS_CHECK         ; 5 Check if LS is left or right
000017CC  4EF9 0000192C            685          JMP     OP_UNSUPPORTED      ; 6 Go to opcode unsupported 
000017D2  4EF9 0000184C            686          JMP     OP_RO_CHECK         ; 7 Check if RO is left or right
000017D8  4EF9 0000192C            687          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
000017DE  4EF9 0000192C            688          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
000017E4  4EF9 0000192C            689          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000017EA  4EF9 0000192C            690          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
000017F0  4EF9 0000192C            691          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
000017F6  4EF9 0000192C            692          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
000017FC  4EF9 0000192C            693          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001802  4EF9 0000192C            694          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001808                           695  
00001808                           696  OP_AS_CHECK
00001808  2200                     697          MOVE.L  D0,D1               ; D0 is current instruction word
0000180A  0241 01C0                698          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
0000180E  1A3C 0006                699          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001812  EA69                     700          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001814  0201 0004                701          ANDI.B  #4,D1               ; Get only bit 8 (dr)
00001818  E449                     702          LSR.W   #2,D1
0000181A                           703  
0000181A  B23C 0001                704          CMP.B   #1,D1               ; Go left
0000181E  6700 0554                705          BEQ     OP_ASL              ; 1 Go to opcode ASL
00001822  B23C 0000                706          CMP.B   #0,D1               ; Go right
00001826  6700 0530                707          BEQ     OP_ASR              ; 0 Go to opcode ASR
0000182A                           708          
0000182A                           709  OP_LS_CHECK
0000182A  2200                     710          MOVE.L  D0,D1               ; D0 is current instruction word
0000182C  0241 01C0                711          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00001830  1A3C 0006                712          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001834  EA69                     713          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001836  0201 0004                714          ANDI.B  #4,D1               ; Get only bit 8 (dr)
0000183A  E449                     715          LSR.W   #2,D1
0000183C                           716  
0000183C  B23C 0001                717          CMP.B   #1,D1               ; Go left
00001840  6700 056A                718          BEQ     OP_LSL              ; 1 Go to opcode LSL
00001844  B23C 0000                719          CMP.B   #0,D1               ; Go right
00001848  6700 0546                720          BEQ     OP_LSR              ; 0 Go to opcode LSR
0000184C                           721          
0000184C                           722  OP_RO_CHECK
0000184C  2200                     723          MOVE.L  D0,D1               ; D0 is current instruction word
0000184E  0241 01C0                724          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00001852  1A3C 0006                725          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001856  EA69                     726          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001858  0201 0004                727          ANDI.B  #4,D1               ; Get only bit 8 (dr)
0000185C  E449                     728          LSR.W   #2,D1
0000185E                           729  
0000185E  B23C 0001                730          CMP.B   #1,D1               ; Go left
00001862  6700 0580                731          BEQ     OP_ROL              ; 1 Go to opcode ROL
00001866  B23C 0000                732          CMP.B   #0,D1               ; Go right
0000186A  6700 055C                733          BEQ     OP_ROR              ; 0 Go to opcode ROR
0000186E                           734          
0000186E                           735  JSR_NOP_RTS
0000186E  2200                     736          MOVE.L  D0,D1               ; D0 is current instruction word
00001870  0241 01C0                737          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001874  1A3C 0006                738          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001878  EA69                     739          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000187A  B23C 0002                740          CMP.B   #2, D1              ; When 010 in destination mode
0000187E  6700 0170                741          BEQ     OP_JSR              ; Go to opcode JSR
00001882                           742          
00001882  2200                     743          MOVE.L  D0,D1               ; D0 is current instruction word
00001884  0241 000F                744          ANDI.W  #fourth_nibble,D1   ; Extract dst mode position from instruction word
00001888  B23C 0001                745          CMP.B   #1, D1  
0000188C  6700 000E                746          BEQ     NOP_CHECK
00001890  B23C 0005                747          CMP.B   #5, D1  
00001894  6700 004E                748          BEQ     RTS_CHECK
00001898  6000 0092                749          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000189C                           750          
0000189C                           751  NOP_CHECK
0000189C  2200                     752          MOVE.L  D0,D1               ; D0 is current instruction word
0000189E  0241 F000                753          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
000018A2  1A3C 000C                754          MOVE.B  #right12,D5         ; Used to shift 6 times to right
000018A6  EA69                     755          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018A8  B23C 0004                756          CMP.B   #4, D1              
000018AC  6700 0006                757          BEQ     NOP_CHECK_TWO
000018B0  6000 007A                758          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018B4                           759          
000018B4                           760  NOP_CHECK_TWO
000018B4  2200                     761          MOVE.L  D0,D1               ; D0 is current instruction word
000018B6  0241 0F00                762          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
000018BA  1A3C 0008                763          MOVE.B  #right8,D5          ; Used to shift 6 times to right
000018BE  EA69                     764          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018C0  B23C 000E                765          CMP.B   #14, D1            
000018C4  6700 0006                766          BEQ     NOP_CHECK_THREE
000018C8  6000 0062                767          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018CC                           768  
000018CC                           769  NOP_CHECK_THREE
000018CC  2200                     770          MOVE.L  D0,D1               ; D0 is current instruction word
000018CE  0241 00F0                771          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
000018D2  1A3C 0004                772          MOVE.B  #right4,D5          ; Used to shift 6 times to right
000018D6  EA69                     773          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018D8  B23C 0007                774          CMP.B   #7, D1              
000018DC  6700 00F2                775          BEQ     OP_NOP
000018E0  6000 004A                776          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018E4                           777       
000018E4                           778  RTS_CHECK
000018E4  2200                     779          MOVE.L  D0,D1               ; D0 is current instruction word
000018E6  0241 F000                780          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
000018EA  1A3C 000C                781          MOVE.B  #right12,D5         ; Used to shift 6 times to right
000018EE  EA69                     782          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018F0  B23C 0004                783          CMP.B   #4, D1              
000018F4  6700 0006                784          BEQ     RTS_CHECK_TWO
000018F8  6000 0032                785          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018FC                           786          
000018FC                           787  RTS_CHECK_TWO
000018FC  2200                     788          MOVE.L  D0,D1               ; D0 is current instruction word
000018FE  0241 0F00                789          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
00001902  1A3C 0008                790          MOVE.B  #right8,D5          ; Used to shift 6 times to right
00001906  EA69                     791          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001908  B23C 000E                792          CMP.B   #14, D1             
0000190C  6700 0006                793          BEQ     RTS_CHECK_THREE
00001910  6000 001A                794          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
00001914                           795  
00001914                           796  RTS_CHECK_THREE
00001914  2200                     797          MOVE.L  D0,D1               ; D0 is current instruction word
00001916  0241 00F0                798          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
0000191A  1A3C 0004                799          MOVE.B  #right4,D5          ; Used to shift 6 times to right
0000191E  EA69                     800          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001920  B23C 0007                801          CMP.B   #7, D1             
00001924  6700 00BA                802          BEQ     OP_RTS
00001928  6000 0002                803          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000192C                           804  
0000192C                           805  OP_UNSUPPORTED
0000192C  6000 14D6                806       BRA DECODE_ERROR        
00001930                           807  *----------------------------------------------------------------------------------------------*
00001930                           808  * param D0 the current instruction in word
00001930                           809  * param D1 the EA type
00001930                           810  * param A2 a pointer to the decode_buffer
00001930                           811  * param A5 current address
00001930                           812  * ea_start(D0, D1, A2, A5){
00001930                           813  * D2: size
00001930                           814  * D3: src mode, dst mode
00001930                           815  * D4: src regs, dst regs
00001930                           816  * D5: #shifts
00001930                           817  * D7: immediate data
00001930                           818  * A0: EA_TYPE_TABLE
00001930                           819  *       0 = ea_immediate
00001930                           820  * }
00001930                           821  
00001930                           822  *----------------------------------------------------------------------------------------------*
00001930                           823  * First 4 bits: 0000
00001930                           824  OP_SUBI
00001930  14FC 0053                825          MOVE.B  #'S',(A2)+
00001934  14FC 0055                826          MOVE.B  #'U',(A2)+
00001938  14FC 0042                827          MOVE.B  #'B',(A2)+
0000193C  14FC 0049                828          MOVE.B  #'I',(A2)+
00001940  223C 00000000            829          MOVE.L  #ea_type_immediate,D1
00001946  4EB9 00001E00            830          JSR     EA_START
0000194C  4EF8 13CE                831          JMP     OP_FINISH
00001950                           832          
00001950                           833  OP_ADDI
00001950  14FC 0041                834          MOVE.B  #'A',(A2)+
00001954  14FC 0044                835          MOVE.B  #'D',(A2)+
00001958  14FC 0044                836          MOVE.B  #'D',(A2)+
0000195C  14FC 0049                837          MOVE.B  #'I',(A2)+
00001960  223C 00000000            838          MOVE.L  #ea_type_immediate,D1
00001966  4EB9 00001E00            839          JSR     EA_START
0000196C  4EF8 13CE                840          JMP     OP_FINISH
00001970                           841  
00001970                           842  *-----------------------------------------------------------------------------------------------*
00001970                           843  * First 4 bits: 0001
00001970                           844  OP_MOVEA
00001970  14FC 004D                845          MOVE.B  #'M',(A2)+
00001974  14FC 004F                846          MOVE.B  #'O',(A2)+
00001978  14FC 0056                847          MOVE.B  #'V',(A2)+
0000197C  14FC 0045                848          MOVE.B  #'E',(A2)+
00001980  14FC 0041                849          MOVE.B  #'A',(A2)+
00001984  223C 00000002            850          MOVE.L  #ea_type_movea,D1
0000198A  4EB9 00001E00            851          JSR     EA_START
00001990  4EF8 13CE                852          JMP     OP_FINISH
00001994                           853  
00001994                           854  *------------------------------------------------------------------------------------------------*
00001994                           855  * First 4 bits: 0011
00001994                           856  OP_MOVE
00001994  14FC 004D                857          MOVE.B  #'M',(A2)+
00001998  14FC 004F                858          MOVE.B  #'O',(A2)+
0000199C  14FC 0056                859          MOVE.B  #'V',(A2)+
000019A0  14FC 0045                860          MOVE.B  #'E',(A2)+
000019A4  223C 00000001            861          MOVE.L  #ea_type_move,D1
000019AA  4EB9 00001E00            862          JSR     EA_START
000019B0  4EF8 13CE                863          JMP     OP_FINISH
000019B4                           864  
000019B4                           865  *------------------------------------------------------------------------------------------------*
000019B4                           866  * First 4 bits: 0100
000019B4                           867  OP_CLR
000019B4  14FC 0043                868          MOVE.B  #'C',(A2)+
000019B8  14FC 004C                869          MOVE.B  #'L',(A2)+
000019BC  14FC 0052                870          MOVE.B  #'R',(A2)+
000019C0  223C 00000004            871          MOVE.L  #ea_type_dstonly,D1
000019C6  4EB9 00001E00            872          JSR     EA_START
000019CC  4EF8 13CE                873          JMP     OP_FINISH
000019D0                           874          
000019D0                           875  OP_NOP
000019D0  14FC 004E                876          MOVE.B  #'N',(A2)+
000019D4  14FC 004F                877          MOVE.B  #'O',(A2)+
000019D8  14FC 0050                878          MOVE.B  #'P',(A2)+
000019DC  4EF8 13CE                879          JMP     OP_FINISH
000019E0                           880          
000019E0                           881  OP_RTS
000019E0  14FC 0052                882          MOVE.B  #'R',(A2)+
000019E4  14FC 0054                883          MOVE.B  #'T',(A2)+
000019E8  14FC 0053                884          MOVE.B  #'S',(A2)+
000019EC  4EF8 13CE                885          JMP     OP_FINISH
000019F0                           886          
000019F0                           887  OP_JSR
000019F0  14FC 004A                888          MOVE.B  #'J',(A2)+
000019F4  14FC 0053                889          MOVE.B  #'S',(A2)+
000019F8  14FC 0052                890          MOVE.B  #'R',(A2)+
000019FC  223C 00000004            891          MOVE.L  #ea_type_dstonly,D1
00001A02  4EB9 00001E00            892          JSR     EA_START
00001A08  4EF8 13CE                893          JMP     OP_FINISH
00001A0C                           894  
00001A0C                           895  OP_MOVEM
00001A0C  14FC 004D                896          MOVE.B  #'M',(A2)+
00001A10  14FC 004F                897          MOVE.B  #'O',(A2)+
00001A14  14FC 0056                898          MOVE.B  #'V',(A2)+
00001A18  14FC 0045                899          MOVE.B  #'E',(A2)+
00001A1C  14FC 004D                900          MOVE.B  #'M',(A2)+
00001A20  223C 00000006            901          MOVE.L  #ea_type_movem,D1
00001A26  4EB9 00001E00            902          JSR     EA_START
00001A2C  4EF8 13CE                903          JMP     OP_FINISH
00001A30                           904          
00001A30                           905  OP_LEA
00001A30  14FC 004C                906          MOVE.B  #'L',(A2)+
00001A34  14FC 0045                907          MOVE.B  #'E',(A2)+
00001A38  14FC 0041                908          MOVE.B  #'A',(A2)+
00001A3C  223C 00000003            909          MOVE.L  #ea_type_lea,D1
00001A42  4EB9 00001E00            910          JSR     EA_START
00001A48  4EF8 13CE                911          JMP     OP_FINISH
00001A4C                           912  
00001A4C                           913  *------------------------------------------------------------------------------------------------*
00001A4C                           914  * First 4 bits: 0101
00001A4C                           915  OP_ADDQ
00001A4C  14FC 0041                916          MOVE.B  #'A',(A2)+
00001A50  14FC 0044                917          MOVE.B  #'D',(A2)+
00001A54  14FC 0044                918          MOVE.B  #'D',(A2)+
00001A58  14FC 0051                919          MOVE.B  #'Q',(A2)+
00001A5C  223C 00000008            920          MOVE.L  #ea_type_quick,D1
00001A62  4EB9 00001E00            921          JSR     EA_START
00001A68  4EF8 13CE                922          JMP     OP_FINISH
00001A6C                           923          
00001A6C                           924  *------------------------------------------------------------------------------------------------*
00001A6C                           925  * First 4 bits: 0110
00001A6C                           926  OP_BRA
00001A6C  14FC 0042                927          MOVE.B  #'B',(A2)+
00001A70  14FC 0052                928          MOVE.B  #'R',(A2)+
00001A74  14FC 0041                929          MOVE.B  #'A',(A2)+
00001A78  223C 00000009            930          MOVE.L  #ea_type_branch,D1
00001A7E  4EB9 00001E00            931          JSR     EA_START
00001A84  4EF8 13CE                932          JMP     OP_FINISH
00001A88                           933  
00001A88                           934  OP_BSR
00001A88  14FC 0042                935          MOVE.B  #'B',(A2)+
00001A8C  14FC 0053                936          MOVE.B  #'S',(A2)+
00001A90  14FC 0052                937          MOVE.B  #'R',(A2)+
00001A94  223C 00000009            938          MOVE.L  #ea_type_branch,D1
00001A9A  4EB9 00001E00            939          JSR     EA_START
00001AA0  4EF8 13CE                940          JMP     OP_FINISH
00001AA4                           941          
00001AA4                           942  OP_BHI
00001AA4  14FC 0042                943          MOVE.B  #'B',(A2)+
00001AA8  14FC 0048                944          MOVE.B  #'H',(A2)+
00001AAC  14FC 0049                945          MOVE.B  #'I',(A2)+
00001AB0  223C 00000009            946          MOVE.L  #ea_type_branch,D1
00001AB6  4EB9 00001E00            947          JSR     EA_START
00001ABC  4EF8 13CE                948          JMP     OP_FINISH
00001AC0                           949  
00001AC0                           950  OP_BLS
00001AC0  14FC 0042                951          MOVE.B  #'B',(A2)+
00001AC4  14FC 004C                952          MOVE.B  #'L',(A2)+
00001AC8  14FC 0053                953          MOVE.B  #'S',(A2)+
00001ACC  223C 00000009            954          MOVE.L  #ea_type_branch,D1
00001AD2  4EB9 00001E00            955          JSR     EA_START
00001AD8  4EF8 13CE                956          JMP     OP_FINISH
00001ADC                           957  
00001ADC                           958  OP_BCC
00001ADC  14FC 0042                959          MOVE.B  #'B',(A2)+
00001AE0  14FC 0043                960          MOVE.B  #'C',(A2)+
00001AE4  14FC 0043                961          MOVE.B  #'C',(A2)+
00001AE8  223C 00000009            962          MOVE.L  #ea_type_branch,D1
00001AEE  4EB9 00001E00            963          JSR     EA_START
00001AF4  4EF8 13CE                964          JMP     OP_FINISH
00001AF8                           965          
00001AF8                           966  OP_BCS
00001AF8  14FC 0042                967          MOVE.B  #'B',(A2)+
00001AFC  14FC 0043                968          MOVE.B  #'C',(A2)+
00001B00  14FC 0053                969          MOVE.B  #'S',(A2)+
00001B04  223C 00000009            970          MOVE.L  #ea_type_branch,D1
00001B0A  4EB9 00001E00            971          JSR     EA_START
00001B10  4EF8 13CE                972          JMP     OP_FINISH
00001B14                           973  
00001B14                           974  OP_BNE
00001B14  14FC 0042                975          MOVE.B  #'B',(A2)+
00001B18  14FC 004E                976          MOVE.B  #'N',(A2)+
00001B1C  14FC 0045                977          MOVE.B  #'E',(A2)+
00001B20  223C 00000009            978          MOVE.L  #ea_type_branch,D1
00001B26  4EB9 00001E00            979          JSR     EA_START
00001B2C  4EF8 13CE                980          JMP     OP_FINISH
00001B30                           981  
00001B30                           982  OP_BEQ
00001B30  14FC 0042                983          MOVE.B  #'B',(A2)+
00001B34  14FC 0045                984          MOVE.B  #'E',(A2)+
00001B38  14FC 0051                985          MOVE.B  #'Q',(A2)+
00001B3C  223C 00000009            986          MOVE.L  #ea_type_branch,D1
00001B42  4EB9 00001E00            987          JSR     EA_START
00001B48  4EF8 13CE                988          JMP     OP_FINISH
00001B4C                           989  
00001B4C                           990  OP_BVC
00001B4C  14FC 0042                991          MOVE.B  #'B',(A2)+
00001B50  14FC 0056                992          MOVE.B  #'V',(A2)+
00001B54  14FC 0043                993          MOVE.B  #'C',(A2)+
00001B58  223C 00000009            994          MOVE.L  #ea_type_branch,D1
00001B5E  4EB9 00001E00            995          JSR     EA_START
00001B64  4EF8 13CE                996          JMP     OP_FINISH
00001B68                           997  
00001B68                           998  OP_BVS
00001B68  14FC 0042                999          MOVE.B  #'B',(A2)+
00001B6C  14FC 0056               1000          MOVE.B  #'V',(A2)+
00001B70  14FC 0053               1001          MOVE.B  #'S',(A2)+
00001B74  223C 00000009           1002          MOVE.L  #ea_type_branch,D1
00001B7A  4EB9 00001E00           1003          JSR     EA_START
00001B80  4EF8 13CE               1004          JMP     OP_FINISH
00001B84                          1005  
00001B84                          1006  OP_BPL
00001B84  14FC 0042               1007          MOVE.B  #'B',(A2)+
00001B88  14FC 0050               1008          MOVE.B  #'P',(A2)+
00001B8C  14FC 004C               1009          MOVE.B  #'L',(A2)+
00001B90  223C 00000009           1010          MOVE.L  #ea_type_branch,D1
00001B96  4EB9 00001E00           1011          JSR     EA_START
00001B9C  4EF8 13CE               1012          JMP     OP_FINISH
00001BA0                          1013  
00001BA0                          1014  OP_BMI
00001BA0  14FC 0042               1015          MOVE.B  #'B',(A2)+
00001BA4  14FC 004D               1016          MOVE.B  #'M',(A2)+
00001BA8  14FC 0049               1017          MOVE.B  #'I',(A2)+
00001BAC  223C 00000009           1018          MOVE.L  #ea_type_branch,D1
00001BB2  4EB9 00001E00           1019          JSR     EA_START
00001BB8  4EF8 13CE               1020          JMP     OP_FINISH
00001BBC                          1021  
00001BBC                          1022  OP_BGE
00001BBC  14FC 0042               1023          MOVE.B  #'B',(A2)+
00001BC0  14FC 0047               1024          MOVE.B  #'G',(A2)+
00001BC4  14FC 0045               1025          MOVE.B  #'E',(A2)+
00001BC8  223C 00000009           1026          MOVE.L  #ea_type_branch,D1
00001BCE  4EB9 00001E00           1027          JSR     EA_START
00001BD4  4EF8 13CE               1028          JMP     OP_FINISH
00001BD8                          1029  
00001BD8                          1030  OP_BLT
00001BD8  14FC 0042               1031          MOVE.B  #'B',(A2)+
00001BDC  14FC 004C               1032          MOVE.B  #'L',(A2)+
00001BE0  14FC 0054               1033          MOVE.B  #'T',(A2)+
00001BE4  223C 00000009           1034          MOVE.L  #ea_type_branch,D1
00001BEA  4EB9 00001E00           1035          JSR     EA_START
00001BF0  4EF8 13CE               1036          JMP     OP_FINISH
00001BF4                          1037  
00001BF4                          1038  OP_BGT
00001BF4  14FC 0042               1039          MOVE.B  #'B',(A2)+
00001BF8  14FC 0047               1040          MOVE.B  #'G',(A2)+
00001BFC  14FC 0054               1041          MOVE.B  #'T',(A2)+
00001C00  223C 00000009           1042          MOVE.L  #ea_type_branch,D1
00001C06  4EB9 00001E00           1043          JSR     EA_START
00001C0C  4EF8 13CE               1044          JMP     OP_FINISH
00001C10                          1045  
00001C10                          1046  OP_BLE
00001C10  14FC 0042               1047          MOVE.B  #'B',(A2)+
00001C14  14FC 004C               1048          MOVE.B  #'L',(A2)+
00001C18  14FC 0045               1049          MOVE.B  #'E',(A2)+
00001C1C  223C 00000009           1050          MOVE.L  #ea_type_branch,D1
00001C22  4EB9 00001E00           1051          JSR     EA_START
00001C28  4EF8 13CE               1052          JMP     OP_FINISH
00001C2C                          1053  *------------------------------------------------------------------------------------------------*
00001C2C                          1054  * First 4 bits: 0111
00001C2C                          1055  OP_MOVEQ
00001C2C  14FC 004D               1056          MOVE.B  #'M',(A2)+
00001C30  14FC 004F               1057          MOVE.B  #'O',(A2)+
00001C34  14FC 0056               1058          MOVE.B  #'V',(A2)+
00001C38  14FC 0045               1059          MOVE.B  #'E',(A2)+
00001C3C  14FC 0051               1060          MOVE.B  #'Q',(A2)+
00001C40  223C 00000008           1061          MOVE.L  #ea_type_quick,D1
00001C46  4EB9 00001E00           1062          JSR     EA_START
00001C4C  4EF8 13CE               1063          JMP     OP_FINISH
00001C50                          1064          
00001C50                          1065  *------------------------------------------------------------------------------------------------*
00001C50                          1066  * First 4 bits: 1000
00001C50                          1067  OP_DIVU
00001C50  14FC 0044               1068          MOVE.B  #'D',(A2)+
00001C54  14FC 0049               1069          MOVE.B  #'I',(A2)+
00001C58  14FC 0056               1070          MOVE.B  #'V',(A2)+
00001C5C  14FC 0055               1071          MOVE.B  #'U',(A2)+
00001C60  223C 00000005           1072          MOVE.L  #ea_type_ext,D1
00001C66  4EB9 00001E00           1073          JSR     EA_START
00001C6C  4EF8 13CE               1074          JMP     OP_FINISH
00001C70                          1075    
00001C70                          1076  OP_OR
00001C70  14FC 004F               1077          MOVE.B  #'O',(A2)+
00001C74  14FC 0052               1078          MOVE.B  #'R',(A2)+
00001C78  223C 00000005           1079          MOVE.L  #ea_type_ext,D1
00001C7E  4EB9 00001E00           1080          JSR     EA_START
00001C84  4EF8 13CE               1081          JMP     OP_FINISH
00001C88                          1082  
00001C88                          1083  *------------------------------------------------------------------------------------------------*
00001C88                          1084  * First 4 bits: 1001
00001C88                          1085  OP_SUB
00001C88  14FC 0053               1086          MOVE.B  #'S',(A2)+
00001C8C  14FC 0055               1087          MOVE.B  #'U',(A2)+
00001C90  14FC 0042               1088          MOVE.B  #'B',(A2)+
00001C94  223C 00000005           1089          MOVE.L  #ea_type_ext,D1
00001C9A  4EB9 00001E00           1090          JSR     EA_START
00001CA0  4EF8 13CE               1091          JMP     OP_FINISH
00001CA4                          1092          
00001CA4                          1093  *------------------------------------------------------------------------------------------------*
00001CA4                          1094  * First 4 bits: 1011
00001CA4                          1095  OP_CMP
00001CA4  14FC 0043               1096          MOVE.B  #'C',(A2)+
00001CA8  14FC 004D               1097          MOVE.B  #'M',(A2)+
00001CAC  14FC 0050               1098          MOVE.B  #'P',(A2)+
00001CB0  223C 00000005           1099          MOVE.L  #ea_type_ext,D1
00001CB6  4EB9 00001E00           1100          JSR     EA_START
00001CBC  4EF8 13CE               1101          JMP     OP_FINISH
00001CC0                          1102          
00001CC0                          1103  *------------------------------------------------------------------------------------------------*
00001CC0                          1104  * First 4 bits: 1100
00001CC0                          1105  OP_MULU
00001CC0  14FC 004D               1106          MOVE.B  #'M',(A2)+
00001CC4  14FC 0055               1107          MOVE.B  #'U',(A2)+
00001CC8  14FC 004C               1108          MOVE.B  #'L',(A2)+
00001CCC  14FC 0055               1109          MOVE.B  #'U',(A2)+
00001CD0  223C 00000005           1110          MOVE.L  #ea_type_ext,D1
00001CD6  4EB9 00001E00           1111          JSR     EA_START
00001CDC  4EF8 13CE               1112          JMP     OP_FINISH
00001CE0                          1113          
00001CE0                          1114  OP_MULS
00001CE0  14FC 004D               1115          MOVE.B  #'M',(A2)+
00001CE4  14FC 0055               1116          MOVE.B  #'U',(A2)+
00001CE8  14FC 004C               1117          MOVE.B  #'L',(A2)+
00001CEC  14FC 0053               1118          MOVE.B  #'S',(A2)+
00001CF0  223C 00000005           1119          MOVE.L  #ea_type_ext,D1
00001CF6  4EB9 00001E00           1120          JSR     EA_START
00001CFC  4EF8 13CE               1121          JMP     OP_FINISH
00001D00                          1122          
00001D00                          1123  OP_AND
00001D00  14FC 0041               1124          MOVE.B  #'A',(A2)+
00001D04  14FC 004E               1125          MOVE.B  #'N',(A2)+
00001D08  14FC 0044               1126          MOVE.B  #'D',(A2)+
00001D0C  223C 00000005           1127          MOVE.L  #ea_type_ext,D1
00001D12  4EB9 00001E00           1128          JSR     EA_START
00001D18  4EF8 13CE               1129          JMP     OP_FINISH
00001D1C                          1130          
00001D1C                          1131  *------------------------------------------------------------------------------------------------*
00001D1C                          1132  * First 4 bits: 1101
00001D1C                          1133  OP_ADD
00001D1C  14FC 0041               1134          MOVE.B  #'A',(A2)+
00001D20  14FC 0044               1135          MOVE.B  #'D',(A2)+
00001D24  14FC 0044               1136          MOVE.B  #'D',(A2)+
00001D28  223C 00000005           1137          MOVE.L  #ea_type_ext,D1
00001D2E  4EB9 00001E00           1138          JSR     EA_START
00001D34  4EF8 13CE               1139          JMP     OP_FINISH
00001D38                          1140  
00001D38                          1141  OP_ADDA
00001D38  14FC 0041               1142          MOVE.B  #'A',(A2)+
00001D3C  14FC 0044               1143          MOVE.B  #'D',(A2)+
00001D40  14FC 0044               1144          MOVE.B  #'D',(A2)+
00001D44  14FC 0041               1145          MOVE.B  #'A',(A2)+
00001D48  223C 00000005           1146          MOVE.L  #ea_type_ext,D1
00001D4E  4EB9 00001E00           1147          JSR     EA_START
00001D54  4EF8 13CE               1148          JMP     OP_FINISH
00001D58                          1149          
00001D58                          1150  *------------------------------------------------------------------------------------------------*
00001D58                          1151  * First 4 bits: 1110
00001D58                          1152  OP_ASR
00001D58  14FC 0041               1153          MOVE.B  #'A',(A2)+
00001D5C  14FC 0053               1154          MOVE.B  #'S',(A2)+
00001D60  14FC 0052               1155          MOVE.B  #'R',(A2)+
00001D64  223C 00000007           1156          MOVE.L  #ea_type_shifts,D1
00001D6A  4EB9 00001E00           1157          JSR     EA_START
00001D70  4EF8 13CE               1158          JMP     OP_FINISH
00001D74                          1159  OP_ASL
00001D74  14FC 0041               1160          MOVE.B  #'A',(A2)+
00001D78  14FC 0053               1161          MOVE.B  #'S',(A2)+
00001D7C  14FC 004C               1162          MOVE.B  #'L',(A2)+
00001D80  223C 00000007           1163          MOVE.L  #ea_type_shifts,D1
00001D86  4EB9 00001E00           1164          JSR     EA_START
00001D8C  4EF8 13CE               1165          JMP     OP_FINISH
00001D90                          1166          
00001D90                          1167  OP_LSR
00001D90  14FC 004C               1168          MOVE.B  #'L',(A2)+
00001D94  14FC 0053               1169          MOVE.B  #'S',(A2)+
00001D98  14FC 0052               1170          MOVE.B  #'R',(A2)+
00001D9C  223C 00000007           1171          MOVE.L  #ea_type_shifts,D1
00001DA2  4EB9 00001E00           1172          JSR     EA_START
00001DA8  4EF8 13CE               1173          JMP     OP_FINISH
00001DAC                          1174         
00001DAC                          1175  OP_LSL
00001DAC  14FC 004C               1176          MOVE.B  #'L',(A2)+
00001DB0  14FC 0053               1177          MOVE.B  #'S',(A2)+
00001DB4  14FC 004C               1178          MOVE.B  #'L',(A2)+
00001DB8  223C 00000007           1179          MOVE.L  #ea_type_shifts,D1
00001DBE  4EB9 00001E00           1180          JSR     EA_START
00001DC4  4EF8 13CE               1181          JMP     OP_FINISH
00001DC8                          1182          
00001DC8                          1183  OP_ROR
00001DC8  14FC 0052               1184          MOVE.B  #'R',(A2)+
00001DCC  14FC 004F               1185          MOVE.B  #'O',(A2)+
00001DD0  14FC 0052               1186          MOVE.B  #'R',(A2)+
00001DD4  223C 00000007           1187          MOVE.L  #ea_type_shifts,D1
00001DDA  4EB9 00001E00           1188          JSR     EA_START
00001DE0  4EF8 13CE               1189          JMP     OP_FINISH
00001DE4                          1190          
00001DE4                          1191  OP_ROL
00001DE4  14FC 0052               1192          MOVE.B  #'R',(A2)+
00001DE8  14FC 004F               1193          MOVE.B  #'O',(A2)+
00001DEC  14FC 004C               1194          MOVE.B  #'L',(A2)+
00001DF0  223C 00000007           1195          MOVE.L  #ea_type_shifts,D1
00001DF6  4EB9 00001E00           1196          JSR     EA_START
00001DFC  4EF8 13CE               1197          JMP     OP_FINISH
00001E00                          1198          
00001E00                          1199  *------------------------------------------------------------------------------------------------*
00001E00                          1200  EA_START
00001E00  48E7 38C0               1201          MOVEM.L D2-D4/A0-A1, -(SP)
00001E04                          1202          
00001E04  41F9 00001E18           1203          LEA     EA_TYPE_TABLE, A0
00001E0A  C2FC 0006               1204          MULU    #6, D1
00001E0E  4EF0 1000               1205          JMP     0(A0, D1)
00001E12                          1206          
00001E12                          1207  EA_FINISH
00001E12  4CDF 031C               1208          MOVEM.L (SP)+, D2-D4/A0-A1
00001E16  4E75                    1209          RTS
00001E18                          1210          
00001E18                          1211  EA_TYPE_TABLE
00001E18  4EF9 00001F36           1212          JMP     EA_IMMEDIATE        ; 0: ea_immediate
00001E1E  4EF9 00001F8E           1213          JMP     EA_MOVE             ; 1: ea_move
00001E24  4EF9 00001FFA           1214          JMP     EA_MOVEA            ; 2: ea_movea
00001E2A  4EF9 00002066           1215          JMP     EA_LEA              ; 3: ea_lea
00001E30  4EF9 000020E4           1216          JMP     EA_DSTONLY          ; 4: ea_dstonly
00001E36  4EF9 00002196           1217          JMP     EA_EXT              ; 5: ea_ext
00001E3C  4EF9 00002386           1218          JMP     EA_MOVEM            ; 6: ea_movem
00001E42  4EF9 000029EA           1219          JMP     EA_SHIFTS           ; 7: ea_shifts
00001E48  4EF9 00002B6C           1220          JMP     EA_QUICK            ; 8: ea_quick
00001E4E  4EF9 00002C2E           1221          JMP     EA_branch           ; 9: ea_branch
00001E54  4EF8 1E12               1222          JMP     EA_FINISH
00001E58                          1223          
00001E58                          1224  EA_SIZE_GENERAL
00001E58  B43C 0000               1225          CMP.B   #%00,D2             ; .b
00001E5C  6700 00B6               1226          BEQ     EA_SIZE_B       
00001E60  B43C 0001               1227          CMP.B   #%01,D2             ; .w
00001E64  6700 00B8               1228          BEQ     EA_SIZE_W       
00001E68  B43C 0002               1229          CMP.B   #%10,D2             ; .l
00001E6C  6700 00BC               1230          BEQ     EA_SIZE_L
00001E70  6000 0F92               1231          BRA     DECODE_ERROR        ; wrong size
00001E74                          1232  
00001E74                          1233  EA_SIZE_MOVE
00001E74  B43C 0001               1234          CMP.B   #%01,D2             ; .b
00001E78  6700 009A               1235          BEQ     EA_SIZE_B       
00001E7C  B43C 0003               1236          CMP.B   #%11,D2             ; .w
00001E80  6700 009C               1237          BEQ     EA_SIZE_W       
00001E84  B43C 0002               1238          CMP.B   #%10,D2             ; .l
00001E88  6700 00A0               1239          BEQ     EA_SIZE_L
00001E8C  6000 0F76               1240          BRA     DECODE_ERROR        ; wrong size
00001E90                          1241  
00001E90                          1242  EA_SIZE_MOVEA     
00001E90  B43C 0003               1243          CMP.B   #%11,D2             ; .w
00001E94  6700 0088               1244          BEQ     EA_SIZE_W       
00001E98  B43C 0002               1245          CMP.B   #%10,D2             ; .l
00001E9C  6700 008C               1246          BEQ     EA_SIZE_L
00001EA0  6000 0F62               1247          BRA     DECODE_ERROR        ; wrong size
00001EA4                          1248          
00001EA4                          1249  EA_SIZE_MOVEM     
00001EA4  B43C 0000               1250          CMP.B   #%0000,D2           ; .w
00001EA8  6700 0074               1251          BEQ     EA_SIZE_W       
00001EAC  B43C 0004               1252          CMP.B   #%0100,D2           ; .l
00001EB0  6700 0078               1253          BEQ     EA_SIZE_L
00001EB4  6000 0F4E               1254          BRA     DECODE_ERROR        ; wrong size
00001EB8                          1255  
00001EB8                          1256  EA_SIZE_OPMODE_012456               ; Check opmode field for size
00001EB8  B43C 0000               1257          CMP.B   #%000,D2            ; When 0 then .b
00001EBC  6700 0056               1258          BEQ     EA_SIZE_B
00001EC0  B43C 0004               1259          CMP.B   #%100,D2            ; When 4 then .b
00001EC4  6700 004E               1260          BEQ     EA_SIZE_B  
00001EC8  B43C 0001               1261          CMP.B   #%001,D2            ; When 1 then .w
00001ECC  6700 0050               1262          BEQ     EA_SIZE_W
00001ED0  B43C 0005               1263          CMP.B   #%101,D2            ; When 5 then .w
00001ED4  6700 0048               1264          BEQ     EA_SIZE_W 
00001ED8  B43C 0002               1265          CMP.B   #%010,D2            ; When 2 then .l
00001EDC  6700 004C               1266          BEQ     EA_SIZE_L
00001EE0  B43C 0006               1267          CMP.B   #%110,D2            ; When 6 then .l
00001EE4  6700 0044               1268          BEQ     EA_SIZE_L
00001EE8  6000 0F1A               1269          BRA     DECODE_ERROR        ; wrong size
00001EEC                          1270  
00001EEC                          1271  EA_SIZE_ADDA                        ; Check opmode field for size
00001EEC  B43C 0003               1272          CMP.B   #%011,D2            ; When 3 then .w
00001EF0  6700 002C               1273          BEQ     EA_SIZE_W       
00001EF4  B43C 0007               1274          CMP.B   #%111,D2            ; When 7 then .l
00001EF8  6700 0030               1275          BEQ     EA_SIZE_L
00001EFC  6000 0F06               1276          BRA     DECODE_ERROR        ; wrong size
00001F00                          1277                  
00001F00                          1278  EA_SIZE_MEMORY_SHIFTS
00001F00  B43C 0000               1279          CMP.B   #%00,D2             ; .w
00001F04  6700 0022               1280          BEQ     EA_SIZE_W_MEMORY      
00001F08  B43C 0001               1281          CMP.B   #%01,D2             ; .l
00001F0C  6700 001C               1282          BEQ     EA_SIZE_L      
00001F10  6000 0EF2               1283          BRA     DECODE_ERROR        ; wrong size
00001F14                          1284  
00001F14                          1285  EA_SIZE_B
00001F14  14FC 002E               1286          MOVE.B  #'.',(A2)+
00001F18  14FC 0042               1287          MOVE.B  #'B',(A2)+
00001F1C  4E75                    1288          RTS
00001F1E                          1289  EA_SIZE_W
00001F1E  14FC 002E               1290          MOVE.B  #'.',(A2)+
00001F22  14FC 0057               1291          MOVE.B  #'W',(A2)+
00001F26  4E75                    1292          RTS     
00001F28                          1293  EA_SIZE_W_MEMORY
00001F28  4E75                    1294          RTS        
00001F2A                          1295  EA_SIZE_L
00001F2A  14FC 002E               1296          MOVE.B  #'.',(A2)+
00001F2E  14FC 004C               1297          MOVE.B  #'L',(A2)+
00001F32  4E75                    1298          RTS
00001F34                          1299  EA_SIZE_DONE
00001F34  4E75                    1300          RTS
00001F36                          1301  *------------------------------------------------------------------------------------------------*     
00001F36                          1302  EA_IMMEDIATE                        ; 0 ea_immediate
00001F36  2200                    1303          MOVE.L  D0,D1
00001F38  0241 01C0               1304          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00001F3C  1A3C 0006               1305          MOVE.B  #right6,D5          ; Store 6 into D5
00001F40  EA69                    1306          LSR.W   D5,D1               ; Shift D1 six times to LSB position
00001F42  0201 0003               1307          ANDI.B  #3,D1               ; Remove the front bit from D1
00001F46  1401                    1308          MOVE.B  D1,D2               ; Store D1 into D2 (used to check size)
00001F48  4EB8 1E58               1309          JSR     EA_SIZE_GENERAL     ; Get size 
00001F4C                          1310          
00001F4C  14FC 0020               1311          MOVE.B  #$20,(A2)+          ; Add space after size
00001F50  14FC 0020               1312          MOVE.B  #$20,(A2)+          ; Add space 
00001F54  14FC 0020               1313          MOVE.B  #$20,(A2)+          ; Add space
00001F58                          1314  
00001F58                          1315          ; Get source and store into decode buffer
00001F58  7804                    1316          MOVE.L  #4,D4               ; Store 100 into D4 (jump to immed)
00001F5A  7607                    1317          MOVE.L  #7,D3               ; Store 111 into D3 (Go abs and immed)
00001F5C  4EB9 00002C86           1318          JSR     EA_GEN_SRC          ; Get EA src print 
00001F62                          1319  
00001F62  14FC 002C               1320          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001F66  14FC 0020               1321          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F6A                          1322  
00001F6A                          1323          ; Get desination and store into decode buffer
00001F6A  2800                    1324          MOVE.L  D0,D4               ; Store the current address into D4 
00001F6C  0244 0007               1325          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00001F70                          1326          
00001F70  2600                    1327          MOVE.L  D0,D3               ; Store the current address into D3 
00001F72  0243 0038               1328          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00001F76  1A3C 0003               1329          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00001F7A  EA6B                    1330          LSR.W   D5,D3               ; do the actual shift 
00001F7C  B63C 0001               1331          CMP.B   #1,D3               ; If dest mode is 001: An
00001F80  6700 0E82               1332          BEQ     DECODE_ERROR        ; Go to invalid message 
00001F84  4EB9 00002C86           1333          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00001F8A                          1334  
00001F8A  4EF8 1E12               1335          JMP     EA_FINISH           ; Opcode is finish
00001F8E                          1336  *------------------------------------------------------------------------------------------------*
00001F8E                          1337  EA_MOVE                             ; 1: ea_move
00001F8E  2200                    1338          MOVE.L  D0,D1
00001F90  0241 F000               1339          ANDI.W  #first_nibble,D1
00001F94  1A3C 000C               1340          MOVE.B  #right12,D5 
00001F98  EA69                    1341          LSR.W   D5,D1
00001F9A  0201 0003               1342          ANDI.B  #3,D1
00001F9E  1401                    1343          MOVE.B  D1,D2
00001FA0  4EB8 1E74               1344          JSR     EA_SIZE_MOVE
00001FA4                          1345          
00001FA4  14FC 0020               1346          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001FA8  14FC 0020               1347          MOVE.B  #$20,(A2)+          ; Print out a space
00001FAC  14FC 0020               1348          MOVE.B  #$20,(A2)+          ; Print out a space
00001FB0                          1349          
00001FB0                          1350          ; Get source and store into decode buffer
00001FB0  2800                    1351          MOVE.L  D0,D4               ; Store the src reg in D4
00001FB2  0244 0007               1352          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001FB6                          1353          
00001FB6  2600                    1354          MOVE.L  D0,D3               ; Store the src mode in D3
00001FB8  0243 0038               1355          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001FBC  1A3C 0003               1356          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001FC0  EA6B                    1357          LSR.W   D5,D3               ; Do the actual shift 
00001FC2  4EB9 00002C86           1358          JSR     EA_GEN_SRC
00001FC8                          1359          
00001FC8  14FC 002C               1360          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001FCC  14FC 0020               1361          MOVE.B  #$20,(A2)+          ; Add space after comma
00001FD0                          1362          
00001FD0                          1363          ; Get desination and store into decode buffer
00001FD0  2800                    1364          MOVE.L  D0,D4               ; Store the dest reg in D4
00001FD2  0244 0E00               1365          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001FD6  1A3C 0009               1366          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001FDA  EA6C                    1367          LSR.W   D5,D4               ; Do the actual shift
00001FDC                          1368          
00001FDC  2600                    1369          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001FDE  0243 01C0               1370          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001FE2  1A3C 0006               1371          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001FE6  EA6B                    1372          LSR.W   D5,D3               ; Do the actual shift 
00001FE8  B63C 0001               1373          CMP.B   #1,D3               ; If dest mode is 001: An
00001FEC  6700 0E16               1374          BEQ     DECODE_ERROR        ; Go to invalid message 
00001FF0  4EB9 00002C86           1375          JSR     EA_GEN_SRC          ; Get EA print
00001FF6                          1376          
00001FF6  4EF8 1E12               1377          JMP     EA_FINISH           ; Opcode is finish
00001FFA                          1378  *------------------------------------------------------------------------------------------------*          
00001FFA                          1379  EA_MOVEA                            ; 2: ea_movea
00001FFA  2200                    1380          MOVE.L  D0,D1
00001FFC  0241 F000               1381          ANDI.W  #first_nibble,D1
00002000  1A3C 000C               1382          MOVE.B  #right12,D5 
00002004  EA69                    1383          LSR.W   D5,D1
00002006  0201 0003               1384          ANDI.B  #3,D1
0000200A  1401                    1385          MOVE.B  D1,D2
0000200C  4EB8 1E90               1386          JSR     EA_SIZE_MOVEA 
00002010                          1387          
00002010  14FC 0020               1388          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002014  14FC 0020               1389          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002018                          1390          
00002018                          1391          ; Get source and store into decode buffer
00002018  2800                    1392          MOVE.L  D0,D4               ; Store the src reg in D4
0000201A  0244 0007               1393          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000201E                          1394          
0000201E  2600                    1395          MOVE.L  D0,D3               ; Store the src mode in D3
00002020  0243 0038               1396          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002024  1A3C 0003               1397          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002028  EA6B                    1398          LSR.W   D5,D3               ; Do the actual shift 
0000202A  4EB9 00002C86           1399          JSR     EA_GEN_SRC
00002030                          1400          
00002030  14FC 002C               1401          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002034  14FC 0020               1402          MOVE.B  #$20,(A2)+          ; Add space after comma
00002038                          1403          
00002038                          1404          ; Get desination and store into decode buffer
00002038  2800                    1405          MOVE.L  D0,D4               ; Store the dest reg in D4
0000203A  0244 0E00               1406          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000203E  1A3C 0009               1407          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002042  EA6C                    1408          LSR.W   D5,D4               ; Do the actual shift
00002044                          1409          
00002044  2600                    1410          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00002046  0243 01C0               1411          ANDI.W  #dst_mode,D3        ; Get bits 8-6
0000204A  1A3C 0006               1412          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
0000204E  EA6B                    1413          LSR.W   D5,D3               ; Do the actual shift 
00002050  B63C 0001               1414          CMP.B   #1,D3               ; If dst mode is 001: An 
00002054  6700 0006               1415          BEQ     MOVEA_DST_VALID     ; dst is valid, so branch 
00002058  6000 0DAA               1416          BRA     DECODE_ERROR        ; Otherwise, go to invalid message 
0000205C                          1417          
0000205C                          1418  MOVEA_DST_VALID
0000205C  4EB9 00002C86           1419          JSR     EA_GEN_SRC          ; Get EA print
00002062  4EF8 1E12               1420          JMP     EA_FINISH           ; Opcode is finish
00002066                          1421  *------------------------------------------------------------------------------------------------*
00002066                          1422  EA_LEA                              ; 3: ea_lea
00002066  14FC 0020               1423          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000206A  14FC 0020               1424          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000206E  14FC 0020               1425          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002072  14FC 0020               1426          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002076  14FC 0020               1427          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000207A  14FC 0020               1428          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000207E                          1429  
0000207E  2800                    1430          MOVE.L  D0,D4               ; Store the src reg in D4
00002080  0244 0007               1431          ANDI.W  #src_reg,D4         ; get the bits at 2-0
00002084                          1432          
00002084  2600                    1433          MOVE.L  D0,D3               ; Store the src mode in D3
00002086  0243 0038               1434          ANDI.W  #src_mode,D3        ; get bits 5-3
0000208A  1A3C 0003               1435          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB
0000208E  EA6B                    1436          LSR.W   D5,D3               ; do the actual shift 
00002090  B67C 0002               1437          CMP     #2,D3               ; If D3 (src mode) is 010 (An)
00002094  6700 000E               1438          BEQ     LEA_SRC_VALID
00002098  B67C 0007               1439          CMP     #7,D3               ; If D3 (src mode) is 111 (W or L)
0000209C  6700 0006               1440          BEQ     LEA_SRC_VALID
000020A0  6000 0D62               1441          BRA     DECODE_ERROR        ; when src mode is not 010 or 111, branch to error message
000020A4                          1442          
000020A4                          1443  LEA_SRC_VALID        
000020A4  4EB9 00002C86           1444          JSR     EA_GEN_SRC          ; Go to function 
000020AA                          1445   
000020AA  14FC 002C               1446          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000020AE  14FC 0020               1447          MOVE.B  #$20,(A2)+          ; Add space after comma
000020B2                          1448  
000020B2  2600                    1449          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
000020B4  0243 01C0               1450          ANDI.W  #dst_mode,D3        ; Get bits 8-6
000020B8  1A3C 0006               1451          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
000020BC  EA6B                    1452          LSR.W   D5,D3               ; Do the actual shift
000020BE  B63C 0007               1453          CMP.B   #7,D3               ; Check if D3 is 111
000020C2  6700 0006               1454          BEQ     CHANGE_TO_001       ; change the D3 bits to 001 
000020C6  6000 0D3C               1455          BRA     DECODE_ERROR        ; Print out an error message if bits 8-6 (dst mode) are not 111
000020CA                          1456    
000020CA                          1457  CHANGE_TO_001
000020CA  163C 0001               1458          MOVE.B  #%001,D3            ; set D3 to 001 to ensure the print out A 
000020CE                          1459          
000020CE  2800                    1460          MOVE.L  D0,D4               ; Store the dest reg in D4 to get the Address register number
000020D0  0244 0E00               1461          ANDI.W  #dst_reg,D4         ; get the bits at 11-9
000020D4  1A3C 0009               1462          MOVE.B  #right9,D5          ; shift the bits 11-9 to the LSB
000020D8  EA6C                    1463          LSR.W   D5,D4               ; do the actual shift
000020DA  4EB9 00002C86           1464          JSR     EA_GEN_SRC          ; Print out the address register
000020E0  4EF8 1E12               1465          JMP     EA_FINISH           ; Opcode is finish
000020E4                          1466  *------------------------------------------------------------------------------------------------*
000020E4                          1467  EA_DSTONLY                          ; 4: ea_dstonly
000020E4  2200                    1468          MOVE.L  D0,D1
000020E6  0241 0F00               1469          ANDI.W  #second_nibble,D1   ; get second nibble from D1
000020EA  1A3C 0008               1470          MOVE.B  #right8,D5 
000020EE  EA69                    1471          LSR.W   D5,D1     
000020F0  B23C 0002               1472          CMP.B   #2, D1              ; When 0010 for second nibble
000020F4  6700 000E               1473          BEQ     EA_CLEAR            ; Then do EA_CLEAR
000020F8  B23C 000E               1474          CMP.B   #$E, D1             ; When 1110 for second nibble
000020FC  6700 0050               1475          BEQ     EA_JSR              ; Then do EA_JSR
00002100  6000 0D02               1476          BRA     DECODE_ERROR     
00002104                          1477          
00002104                          1478  EA_CLEAR
00002104  2200                    1479          MOVE.L  D0,D1
00002106  0241 01C0               1480          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
0000210A  1A3C 0006               1481          MOVE.B  #right6,D5          ; Store 6 into D5
0000210E  EA69                    1482          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002110  0201 0003               1483          ANDI.B  #3,D1               ; Remove the front bit from D1
00002114  1401                    1484          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002116  4EB8 1E58               1485          JSR     EA_SIZE_GENERAL     ; Get size 
0000211A                          1486          
0000211A  14FC 0020               1487          MOVE.B  #$20,(A2)+          ; Add space after size
0000211E  14FC 0020               1488          MOVE.B  #$20,(A2)+          ; Add space 
00002122  14FC 0020               1489          MOVE.B  #$20,(A2)+          ; Add space 
00002126  14FC 0020               1490          MOVE.B  #$20,(A2)+          ; Add space
0000212A                          1491          
0000212A                          1492          ; Get desination and store into decode buffer
0000212A  2800                    1493          MOVE.L  D0,D4               ; Store the current address into D4 
0000212C  0244 0007               1494          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00002130                          1495          
00002130  2600                    1496          MOVE.L  D0,D3               ; Store the current address into D3 
00002132  0243 0038               1497          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002136  1A3C 0003               1498          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
0000213A  EA6B                    1499          LSR.W   D5,D3               ; do the actual shift 
0000213C  B63C 0001               1500          CMP.B   #1,D3               ; If dest mode is 001: An
00002140  6700 0CC2               1501          BEQ     DECODE_ERROR        ; Go to invalid message 
00002144  4EB9 00002C86           1502          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
0000214A  4EF8 1E12               1503          JMP     EA_FINISH           ; Opcode is finish
0000214E                          1504          
0000214E  14FC 0020               1505  EA_JSR  MOVE.B  #$20,(A2)+          ; Add space 
00002152  14FC 0020               1506          MOVE.B  #$20,(A2)+          ; Add space 
00002156  14FC 0020               1507          MOVE.B  #$20,(A2)+          ; Add space 
0000215A  14FC 0020               1508          MOVE.B  #$20,(A2)+          ; Add space 
0000215E  14FC 0020               1509          MOVE.B  #$20,(A2)+          ; Add space 
00002162  14FC 0020               1510          MOVE.B  #$20,(A2)+          ; Add space
00002166                          1511  
00002166                          1512          ; Get EA and store into decode buffer   
00002166  2800                    1513          MOVE.L  D0,D4               ; Store the current address into D4 
00002168  0244 0007               1514          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
0000216C                          1515          
0000216C  2600                    1516          MOVE.L  D0,D3               ; Store the current address into D3 
0000216E  0243 0038               1517          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002172  1A3C 0003               1518          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002176  EA6B                    1519          LSR.W   D5,D3               ; do the actual shift 
00002178  B67C 0002               1520          CMP     #2,D3               ; If D3 (src mode) is 010: (An)
0000217C  6700 000E               1521          BEQ     JSR_EA_VALID
00002180  B67C 0007               1522          CMP     #7,D3               ; If D3 (src mode) is 111: (W or L)
00002184  6700 0006               1523          BEQ     JSR_EA_VALID
00002188  6000 0C7A               1524          BRA     DECODE_ERROR        ; Otherwise, branch to invalid message
0000218C                          1525          
0000218C                          1526  JSR_EA_VALID
0000218C  4EB9 00002C86           1527          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00002192  4EF8 1E12               1528          JMP     EA_FINISH           ; Opcode is finish
00002196                          1529  *------------------------------------------------------------------------------------------------*
00002196                          1530  EA_EXT                              ; 5: ea_ext
00002196  2200                    1531          MOVE.L  D0,D1
00002198  0241 01C0               1532          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1 (get opmode)
0000219C  1A3C 0006               1533          MOVE.B  #right6,D5          ; Store 6 into D5
000021A0  EA69                    1534          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
000021A2  1401                    1535          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
000021A4  C2FC 0006               1536          MULU    #6, D1              ; Multiply 6 to D1 
000021A8  41F9 000021B2           1537          LEA     EA_EXT_TABLE,A0     ; Load table into A0
000021AE  4EF0 1000               1538          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000021B2                          1539  
000021B2                          1540  EA_EXT_TABLE
000021B2  4EF9 000021E2           1541          JMP     EA_OPMODE_012456    ; 000: ADD/SUB/CMP/OR/AND
000021B8  4EF9 000021E2           1542          JMP     EA_OPMODE_012456    ; 001: ADD/SUB/CMP/OR/AND
000021BE  4EF9 000021E2           1543          JMP     EA_OPMODE_012456    ; 010: ADD/SUB/CMP/OR/AND
000021C4  4EF9 000022D0           1544          JMP     EA_OPMODE_37        ; 011: ADDA/MULS/MULU/DIVU
000021CA  4EF9 000021E2           1545          JMP     EA_OPMODE_012456    ; 100: ADD/SUB/CMP/OR/AND
000021D0  4EF9 000021E2           1546          JMP     EA_OPMODE_012456    ; 101: ADD/SUB/CMP/OR/AND
000021D6  4EF9 000021E2           1547          JMP     EA_OPMODE_012456    ; 110: ADD/SUB/CMP/OR/AND
000021DC  4EF9 000022D0           1548          JMP     EA_OPMODE_37        ; 111: ADDA/MULS/MULU/DIVU
000021E2                          1549  
000021E2                          1550  EA_OPMODE_012456
000021E2  4EB8 1EB8               1551          JSR     EA_SIZE_OPMODE_012456    
000021E6                          1552          
000021E6  14FC 0020               1553          MOVE.B  #$20,(A2)+          ; Print out a space after the size
000021EA  14FC 0020               1554          MOVE.B  #$20,(A2)+          ; Print out a space 
000021EE  14FC 0020               1555          MOVE.B  #$20,(A2)+          ; Print out a space
000021F2  14FC 0020               1556          MOVE.B  #$20,(A2)+          ; Add space
000021F6                          1557          
000021F6                          1558          ; Operation: <ea> + Dn -> Dn
000021F6  B43C 0000               1559          CMP.B   #%000,D2            ; When 0 then Dn is destination
000021FA  6700 002E               1560          BEQ     Dn_DST
000021FE  B43C 0001               1561          CMP.B   #%001,D2            ; When 1 then Dn is destination
00002202  6700 0026               1562          BEQ     Dn_DST
00002206  B43C 0002               1563          CMP.B   #%010,D2            ; When 2 then Dn is destination
0000220A  6700 001E               1564          BEQ     Dn_DST
0000220E                          1565          
0000220E                          1566          ; Operation: Dn + <ea> -> <ea>
0000220E  B43C 0004               1567          CMP.B   #%100,D2            ; When 4 then Dn is source
00002212  6700 0054               1568          BEQ     Dn_SRC  
00002216  B43C 0005               1569          CMP.B   #%101,D2            ; When 5 then Dn is source
0000221A  6700 004C               1570          BEQ     Dn_SRC 
0000221E  B43C 0006               1571          CMP.B   #%110,D2            ; When 6 then Dn is source
00002222  6700 0044               1572          BEQ     Dn_SRC 
00002226                          1573          
00002226  6000 0BDC               1574          BRA     DECODE_ERROR
0000222A                          1575  
0000222A                          1576  Dn_DST
0000222A                          1577          ; Get source and store into decode buffer
0000222A  2800                    1578          MOVE.L  D0,D4               ; Store the src reg in D4
0000222C  0244 0007               1579          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002230                          1580          
00002230  2600                    1581          MOVE.L  D0,D3               ; Store the src mode in D3
00002232  0243 0038               1582          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002236  1A3C 0003               1583          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000223A  EA6B                    1584          LSR.W   D5,D3               ; Do the actual shift 
0000223C  4EB9 000022AE           1585          JSR     AND_OR_CHECK 
00002242  4EB9 00002C86           1586          JSR     EA_GEN_SRC          ; Get EA print
00002248                          1587          
00002248  14FC 002C               1588          MOVE.B  #$2C,(A2)+          ; Add comma after size print
0000224C  14FC 0020               1589          MOVE.B  #$20,(A2)+          ; Add space after comma
00002250                          1590          
00002250                          1591          ; Get desination and store into decode buffer
00002250  2800                    1592          MOVE.L  D0,D4               ; Store the dest reg in D4
00002252  0244 0E00               1593          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002256  1A3C 0009               1594          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000225A  EA6C                    1595          LSR.W   D5,D4               ; Do the actual shift
0000225C                          1596          
0000225C  7600                    1597          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000225E  4EB9 00002C86           1598          JSR     EA_GEN_SRC          ; Get the Dn print
00002264  4EF8 1E12               1599          JMP     EA_FINISH           ; Opcode is finish
00002268                          1600            
00002268                          1601  Dn_SRC  
00002268  BC3C 000B               1602          CMP.B   #11,D6              ; If first nibble is 1011 (indicates CMP opcode)
0000226C  6700 0B96               1603          BEQ     DECODE_ERROR        ; Then branch to error message
00002270                          1604       
00002270                          1605          ; Get source and store into decode buffer
00002270  2800                    1606          MOVE.L  D0,D4               ; Store the src reg in D4
00002272  0244 0E00               1607          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002276  1A3C 0009               1608          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000227A  EA6C                    1609          LSR.W   D5,D4               ; Do the actual shift
0000227C                          1610          
0000227C  7600                    1611          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000227E  4EB9 00002C86           1612          JSR     EA_GEN_SRC          ; Get the Dn print
00002284                          1613          
00002284  14FC 002C               1614          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002288  14FC 0020               1615          MOVE.B  #$20,(A2)+          ; Add space after comma
0000228C                          1616  
0000228C                          1617          ; Get destination and store into decode buffer
0000228C  2800                    1618          MOVE.L  D0,D4               ; Store the dst reg in D4
0000228E  0244 0007               1619          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002292                          1620          
00002292  2600                    1621          MOVE.L  D0,D3               ; Store the dest mode in D3
00002294  0243 0038               1622          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002298  1A3C 0003               1623          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000229C  EA6B                    1624          LSR.W   D5,D3               ; Do the actual shift
0000229E  4EB9 00002D9C           1625          JSR     An_CHECK            ; Check if mode is An
000022A4                          1626         
000022A4  4EB9 00002C86           1627          JSR     EA_GEN_SRC          ; Get EA print
000022AA  4EF8 1E12               1628          JMP     EA_FINISH           ; Opcode is finish
000022AE                          1629  
000022AE                          1630  AND_OR_CHECK
000022AE  BC3C 000C               1631          CMP.B   #12,D6              ; If first nibble is 1100 (indicates AND opcode)
000022B2  6700 000C               1632          BEQ     EA_AND              
000022B6  BC3C 0008               1633          CMP.B   #8,D6               ; If first nibble is 1000 (indicates OR opcode)
000022BA  6700 000A               1634          BEQ     EA_OR 
000022BE  4E75                    1635          RTS
000022C0                          1636  EA_AND
000022C0  4EF9 00002D9C           1637          JMP     An_CHECK            ; Go check if mode is An 
000022C6                          1638      
000022C6                          1639  EA_OR
000022C6  14FC 0020               1640          MOVE.B  #$20,(A2)+          ; Add space
000022CA  4EF9 00002D9C           1641          JMP     An_CHECK            ; Check if mode is An
000022D0                          1642          
000022D0                          1643  EA_OPMODE_37
000022D0  BC3C 0008               1644          CMP.B   #8,D6               ; If first nibble 1000: DIVU
000022D4  6700 0012               1645          BEQ     EA_MULS_MULU_DIV
000022D8  BC3C 000C               1646          CMP.B   #12,D6              ; If first nibble 1100: MULS/MULU
000022DC  6700 000A               1647          BEQ     EA_MULS_MULU_DIV
000022E0  BC3C 000D               1648          CMP.B   #13,D6              ; If first nibble 1101: ADDA
000022E4  6700 0058               1649          BEQ     EA_ADDA                
000022E8                          1650  
000022E8                          1651  EA_MULS_MULU_DIV
000022E8  143C 0001               1652          MOVE.B  #1,D2               ; Set D2 to 1, since we know size is word   
000022EC                          1653  
000022EC  14FC 0020               1654          MOVE.B  #$20,(A2)+          ; Print out a space
000022F0  14FC 0020               1655          MOVE.B  #$20,(A2)+          ; Print out a space
000022F4  14FC 0020               1656          MOVE.B  #$20,(A2)+          ; Print out a space
000022F8  14FC 0020               1657          MOVE.B  #$20,(A2)+          ; Add space
000022FC  14FC 0020               1658          MOVE.B  #$20,(A2)+          ; Add space
00002300                          1659  
00002300                          1660          ; Get source and store into decode buffer
00002300  2800                    1661          MOVE.L  D0,D4               ; Store the src reg in D4
00002302  0244 0007               1662          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002306                          1663          
00002306  2600                    1664          MOVE.L  D0,D3               ; Store the src mode in D3
00002308  0243 0038               1665          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000230C  1A3C 0003               1666          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002310  EA6B                    1667          LSR.W   D5,D3               ; Do the actual shift
00002312  4EB9 00002D9C           1668          JSR     An_CHECK            ; Check if mode is An 
00002318  4EB9 00002C86           1669          JSR     EA_GEN_SRC          ; Go get EA print
0000231E                          1670          
0000231E  14FC 002C               1671          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002322  14FC 0020               1672          MOVE.B  #$20,(A2)+          ; Add space after comma
00002326                          1673          
00002326                          1674          ; Get desination and store into decode buffer
00002326  2800                    1675          MOVE.L  D0,D4               ; Store the dest reg in D4
00002328  0244 0E00               1676          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000232C  1A3C 0009               1677          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002330  EA6C                    1678          LSR.W   D5,D4               ; Do the actual shift
00002332                          1679          
00002332  7600                    1680          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
00002334  4EB9 00002C86           1681          JSR     EA_GEN_SRC          ; Go get EA print
0000233A  4EF8 1E12               1682          JMP     EA_FINISH           ; Opcode is finish
0000233E                          1683  
0000233E                          1684  EA_ADDA
0000233E  4EB8 1EEC               1685          JSR     EA_SIZE_ADDA        ; Get size    
00002342                          1686  
00002342  14FC 0020               1687          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002346  14FC 0020               1688          MOVE.B  #$20,(A2)+          ; Print out a space
0000234A  14FC 0020               1689          MOVE.B  #$20,(A2)+          ; Add space        
0000234E                          1690          
0000234E                          1691          
0000234E                          1692          ; Get source and store into decode buffer
0000234E  2800                    1693          MOVE.L  D0,D4               ; Store the src reg in D4
00002350  0244 0007               1694          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002354                          1695          
00002354  2600                    1696          MOVE.L  D0,D3               ; Store the src mode in D3
00002356  0243 0038               1697          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000235A  1A3C 0003               1698          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000235E  EA6B                    1699          LSR.W   D5,D3               ; Do the actual shift 
00002360  4EB9 00002C86           1700          JSR     EA_GEN_SRC
00002366                          1701          
00002366  14FC 002C               1702          MOVE.B  #$2C,(A2)+          ; Add comma after size print
0000236A  14FC 0020               1703          MOVE.B  #$20,(A2)+          ; Add space after comma
0000236E                          1704          
0000236E                          1705          ; Get desination and store into decode buffer
0000236E  2800                    1706          MOVE.L  D0,D4               ; Store the dest reg in D4
00002370  0244 0E00               1707          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002374  1A3C 0009               1708          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002378  EA6C                    1709          LSR.W   D5,D4               ; Do the actual shift
0000237A                          1710          
0000237A  7601                    1711          MOVE.L  #1,D3               ; Store 001 into D3, so it can jump to An 
0000237C  4EB9 00002C86           1712          JSR     EA_GEN_SRC          ; Go get EA print
00002382  4EF8 1E12               1713          JMP     EA_FINISH           ; Opcode is finish
00002386                          1714  *------------------------------------------------------------------------------------------------*
00002386                          1715  EA_MOVEM        ; 6: ea_movem
00002386  2200                    1716          MOVE.L  D0, D1
00002388  0241 00F0               1717          ANDI.W  #third_nibble,D1
0000238C  1A3C 0004               1718          MOVE.B  #right4,D5 
00002390  EA69                    1719          LSR.W   D5,D1
00002392  0201 0004               1720          ANDI.B  #4,D1
00002396  1401                    1721          MOVE.B  D1,D2
00002398  4EB8 1EA4               1722          JSR     EA_SIZE_MOVEM       ; get the size of the MOVEM as .W or .L 
0000239C                          1723  
0000239C  14FC 0020               1724          MOVE.B  #$20,(A2)+          ; Print out a space after the size
000023A0  14FC 0020               1725          MOVE.B  #$20,(A2)+          ; Print out a space
000023A4                          1726          
000023A4                          1727  *-----------------------------------------------------------------------------------*
000023A4                          1728  * HANDLE the case where src mode is 010. 
000023A4  2600                    1729          MOVE.L  D0,D3               ; Store the src mode in D3
000023A6  0243 0038               1730          ANDI.W  #src_mode,D3        ; Get bits 5-3
000023AA  1A3C 0003               1731          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000023AE  EA6B                    1732          LSR.W   D5,D3 
000023B0                          1733  
000023B0  B63C 0002               1734          CMP.B   #2, D3
000023B4  6700 0312               1735          BEQ     MEM_TO_REG        
000023B8                          1736  
000023B8                          1737  *-----------------------------------------------------------------------------------*
000023B8                          1738  
000023B8  2200                    1739          MOVE.L  D0, D1
000023BA  0241 0F00               1740          ANDI.W  #second_nibble,D1
000023BE  1A3C 0008               1741          MOVE.B  #right8,D5 
000023C2  EA69                    1742          LSR.W   D5,D1
000023C4  0201 0006               1743          ANDI.B  #6, D1              ; Get the Dr field
000023C8                          1744          
000023C8  B23C 0000               1745          CMP.B   #0, D1              ; check if Dr field is 0. 
000023CC  6700 000A               1746          BEQ     REG_TO_MEM
000023D0                          1747  
000023D0  B23C 0004               1748          CMP.B   #4, D1              ; check if Dr field is 1. 
000023D4  6700 02F2               1749          BEQ     MEM_TO_REG
000023D8                          1750  
000023D8                          1751  REG_TO_MEM                          ; pre-decrement - D7-D0,A7-A0
000023D8  3C15                    1752          MOVE.W  (A5), D6            ; store the register list mask field for REG to MEM
000023DA                          1753          
000023DA                          1754  * Print out the proper data and address registers. 
000023DA                          1755  * FIRST NIBBLE CHECK D0 - D3
000023DA                          1756  *-----------------------------------------------------------------------------------*
000023DA                          1757  * Print out D0 if mask field states to. 
000023DA                          1758  
000023DA  3606                    1759          MOVE.W  D6, D3
000023DC  0243 F000               1760          ANDI.W  #first_nibble,D3
000023E0  1A3C 000C               1761          MOVE.B  #right12,D5 
000023E4  EA6B                    1762          LSR.W   D5,D3
000023E6  0203 0008               1763          ANDI.B  #8,D3
000023EA  B63C 0008               1764          CMP.B   #8,D3
000023EE  6700 0006               1765          BEQ     D4_Dn_SETONE_0      ; SETONE refers to the set for reg to mem branch. 
000023F2  6000 0014               1766          BRA     CHECK1_BIT_14
000023F6                          1767  D4_Dn_SETONE_0
000023F6  183C 0000               1768          MOVE.B  #$0, D4
000023FA                          1769          
000023FA  6000 0002               1770          BRA     PRINT1_D0
000023FE                          1771          
000023FE                          1772  PRINT1_D0
000023FE  4EB9 00002CC4           1773          JSR     EA_Dn
00002404  14FC 002F               1774          MOVE.B  #$2F,(A2)+
00002408                          1775          
00002408                          1776  *-----------------------------------------------------------------------------------*
00002408                          1777  * Print out D1 if mask field states to. 
00002408                          1778  
00002408                          1779  CHECK1_BIT_14
00002408  3606                    1780          MOVE.W  D6, D3
0000240A  0243 F000               1781          ANDI.W  #first_nibble,D3
0000240E  1A3C 000C               1782          MOVE.B  #right12,D5 
00002412  EA6B                    1783          LSR.W   D5,D3
00002414  0203 0004               1784          ANDI.B  #4,D3
00002418  B63C 0004               1785          CMP.B   #4,D3
0000241C  6700 0006               1786          BEQ     D4_Dn_SETONE_1      ; SETONE refers to the set for reg to mem branch. 
00002420  6000 0014               1787          BRA     CHECK1_BIT_13
00002424                          1788  D4_Dn_SETONE_1
00002424  183C 0001               1789          MOVE.B  #$1, D4
00002428                          1790          
00002428  6000 0002               1791          BRA     PRINT1_D1
0000242C                          1792          
0000242C                          1793  PRINT1_D1
0000242C  4EB9 00002CC4           1794          JSR     EA_Dn
00002432  14FC 002F               1795          MOVE.B  #$2F,(A2)+
00002436                          1796  
00002436                          1797  *-----------------------------------------------------------------------------------*
00002436                          1798  * Print out D2 if mask field states to. 
00002436                          1799  
00002436                          1800  CHECK1_BIT_13
00002436  3606                    1801          MOVE.W  D6, D3
00002438  0243 F000               1802          ANDI.W  #first_nibble,D3
0000243C  1A3C 000C               1803          MOVE.B  #right12,D5 
00002440  EA6B                    1804          LSR.W   D5,D3
00002442  0203 0002               1805          ANDI.B  #2,D3
00002446  B63C 0002               1806          CMP.B   #2,D3
0000244A  6700 0006               1807          BEQ     D4_Dn_SETONE_2      ; SETONE refers to the set for reg to mem branch. 
0000244E  6000 0014               1808          BRA     CHECK1_BIT_12
00002452                          1809  D4_Dn_SETONE_2
00002452  183C 0002               1810          MOVE.B  #$2, D4
00002456                          1811          
00002456  6000 0002               1812          BRA     PRINT1_D2
0000245A                          1813          
0000245A                          1814  PRINT1_D2
0000245A  4EB9 00002CC4           1815          JSR     EA_Dn
00002460  14FC 002F               1816          MOVE.B  #$2F,(A2)+       
00002464                          1817  
00002464                          1818  *-----------------------------------------------------------------------------------*
00002464                          1819  * Print out D3 if mask field states to. 
00002464                          1820  
00002464                          1821  CHECK1_BIT_12
00002464  3606                    1822          MOVE.W  D6, D3
00002466  0243 F000               1823          ANDI.W  #first_nibble,D3
0000246A  1A3C 000C               1824          MOVE.B  #right12,D5 
0000246E  EA6B                    1825          LSR.W   D5,D3
00002470  0203 0001               1826          ANDI.B  #1,D3
00002474  B63C 0001               1827          CMP.B   #1,D3
00002478  6700 0006               1828          BEQ     D4_Dn_SETONE_3      ; SETONE refers to the set for reg to mem branch. 
0000247C  6000 0014               1829          BRA     CHECK1_BIT_11
00002480                          1830  D4_Dn_SETONE_3
00002480  183C 0003               1831          MOVE.B  #$3, D4
00002484                          1832          
00002484  6000 0002               1833          BRA     PRINT1_D3
00002488                          1834          
00002488                          1835  PRINT1_D3
00002488  4EB9 00002CC4           1836          JSR     EA_Dn
0000248E  14FC 002F               1837          MOVE.B  #$2F,(A2)+ 
00002492                          1838          
00002492                          1839  * SECOND NIBBLE CHECK D4 - D7
00002492                          1840  *-----------------------------------------------------------------------------------*
00002492                          1841  * Print out D4 if mask field states to. 
00002492                          1842  
00002492                          1843  
00002492                          1844  CHECK1_BIT_11
00002492  3606                    1845          MOVE.W  D6, D3
00002494  0243 0F00               1846          ANDI.W  #second_nibble,D3
00002498  1A3C 0008               1847          MOVE.B  #right8,D5 
0000249C  EA6B                    1848          LSR.W   D5,D3
0000249E  0203 0008               1849          ANDI.B  #8,D3
000024A2  B63C 0008               1850          CMP.B   #8,D3
000024A6  6700 0006               1851          BEQ     D4_Dn_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
000024AA  6000 0014               1852          BRA     CHECK1_BIT_10
000024AE                          1853  D4_Dn_SETONE_4
000024AE  183C 0004               1854          MOVE.B  #$4, D4
000024B2                          1855          
000024B2  6000 0002               1856          BRA     PRINT1_D4
000024B6                          1857          
000024B6                          1858  PRINT1_D4
000024B6  4EB9 00002CC4           1859          JSR     EA_Dn
000024BC  14FC 002F               1860          MOVE.B  #$2F,(A2)+ 
000024C0                          1861  
000024C0                          1862  *-----------------------------------------------------------------------------------*
000024C0                          1863  * Print out D5 if mask field states to. 
000024C0                          1864  
000024C0                          1865  CHECK1_BIT_10
000024C0  3606                    1866          MOVE.W  D6, D3
000024C2  0243 0F00               1867          ANDI.W  #second_nibble,D3
000024C6  1A3C 0008               1868          MOVE.B  #right8,D5 
000024CA  EA6B                    1869          LSR.W   D5,D3
000024CC  0203 0004               1870          ANDI.B  #4,D3
000024D0  B63C 0004               1871          CMP.B   #4,D3
000024D4  6700 0006               1872          BEQ     D4_Dn_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
000024D8  6000 0014               1873          BRA     CHECK1_BIT_9
000024DC                          1874  D4_Dn_SETONE_5
000024DC  183C 0005               1875          MOVE.B  #$5, D4
000024E0                          1876          
000024E0  6000 0002               1877          BRA     PRINT1_D5
000024E4                          1878          
000024E4                          1879  PRINT1_D5
000024E4  4EB9 00002CC4           1880          JSR     EA_Dn
000024EA  14FC 002F               1881          MOVE.B  #$2F,(A2)+ 
000024EE                          1882  
000024EE                          1883  *-----------------------------------------------------------------------------------*
000024EE                          1884  * Print out D6 if mask field states to. 
000024EE                          1885  
000024EE                          1886  CHECK1_BIT_9
000024EE  3606                    1887          MOVE.W  D6, D3
000024F0  0243 0F00               1888          ANDI.W  #second_nibble,D3
000024F4  1A3C 0008               1889          MOVE.B  #right8,D5 
000024F8  EA6B                    1890          LSR.W   D5,D3
000024FA  0203 0002               1891          ANDI.B  #2,D3
000024FE  B63C 0002               1892          CMP.B   #2,D3
00002502  6700 0006               1893          BEQ     D4_Dn_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
00002506  6000 0014               1894          BRA     CHECK1_BIT_8
0000250A                          1895  D4_Dn_SETONE_6
0000250A  183C 0006               1896          MOVE.B  #$6, D4
0000250E                          1897          
0000250E  6000 0002               1898          BRA     PRINT1_D6
00002512                          1899          
00002512                          1900  PRINT1_D6
00002512  4EB9 00002CC4           1901          JSR     EA_Dn
00002518  14FC 002F               1902          MOVE.B  #$2F,(A2)+ 
0000251C                          1903          
0000251C                          1904  *-----------------------------------------------------------------------------------*
0000251C                          1905  * Print out D7 if mask field states to. 
0000251C                          1906  
0000251C                          1907  CHECK1_BIT_8
0000251C  3606                    1908          MOVE.W  D6, D3
0000251E  0243 0F00               1909          ANDI.W  #second_nibble,D3
00002522  1A3C 0008               1910          MOVE.B  #right8,D5 
00002526  EA6B                    1911          LSR.W   D5,D3
00002528  0203 0001               1912          ANDI.B  #1,D3
0000252C  B63C 0001               1913          CMP.B   #1,D3
00002530  6700 0006               1914          BEQ     D4_Dn_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
00002534  6000 0014               1915          BRA     CHECK1_BIT_7
00002538                          1916  D4_Dn_SETONE_7
00002538  183C 0007               1917          MOVE.B  #$7, D4
0000253C                          1918          
0000253C  6000 0002               1919          BRA     PRINT1_D7
00002540                          1920          
00002540                          1921  PRINT1_D7
00002540  4EB9 00002CC4           1922          JSR     EA_Dn
00002546  14FC 002F               1923          MOVE.B  #$2F,(A2)+ 
0000254A                          1924  
0000254A                          1925  * THIRD NIBBLE CHECK - A0 / A3
0000254A                          1926  *-----------------------------------------------------------------------------------*
0000254A                          1927  * Print out A0 if mask field states to. 
0000254A                          1928  
0000254A                          1929  CHECK1_BIT_7
0000254A  3606                    1930          MOVE.W  D6, D3
0000254C  0243 00F0               1931          ANDI.W  #third_nibble,D3
00002550  1A3C 0004               1932          MOVE.B  #right4,D5 
00002554  EA6B                    1933          LSR.W   D5,D3
00002556  0203 0008               1934          ANDI.B  #8,D3
0000255A  B63C 0008               1935          CMP.B   #8,D3
0000255E  6700 0006               1936          BEQ     D4_An_SETONE_0       ; SETONE refers to the set for reg to mem branch. 
00002562  6000 0014               1937          BRA     CHECK1_BIT_6
00002566                          1938  D4_An_SETONE_0
00002566  183C 0000               1939          MOVE.B  #$0, D4
0000256A                          1940          
0000256A  6000 0002               1941          BRA     PRINT1_A0
0000256E                          1942          
0000256E                          1943  PRINT1_A0
0000256E  4EB9 00002CD0           1944          JSR     EA_An
00002574  14FC 002F               1945          MOVE.B  #$2F,(A2)+ 
00002578                          1946          
00002578                          1947  *-----------------------------------------------------------------------------------*
00002578                          1948  * Print out A1 if mask field states to. 
00002578                          1949  
00002578                          1950  CHECK1_BIT_6
00002578  3606                    1951          MOVE.W  D6, D3
0000257A  0243 00F0               1952          ANDI.W  #third_nibble,D3
0000257E  1A3C 0004               1953          MOVE.B  #right4,D5 
00002582  EA6B                    1954          LSR.W   D5,D3
00002584  0203 0004               1955          ANDI.B  #4,D3
00002588  B63C 0004               1956          CMP.B   #4,D3
0000258C  6700 0006               1957          BEQ     D4_An_SETONE_1       ; SETONE refers to the set for reg to mem branch. 
00002590  6000 0014               1958          BRA     CHECK1_BIT_5
00002594                          1959  D4_An_SETONE_1
00002594  183C 0001               1960          MOVE.B  #$1, D4
00002598                          1961          
00002598  6000 0002               1962          BRA     PRINT1_A1
0000259C                          1963          
0000259C                          1964  PRINT1_A1
0000259C  4EB9 00002CD0           1965          JSR     EA_An
000025A2  14FC 002F               1966          MOVE.B  #$2F,(A2)+ 
000025A6                          1967  
000025A6                          1968  *-----------------------------------------------------------------------------------*
000025A6                          1969  * Print out A2 if mask field states to. 
000025A6                          1970  
000025A6                          1971  CHECK1_BIT_5
000025A6  3606                    1972          MOVE.W  D6, D3
000025A8  0243 00F0               1973          ANDI.W  #third_nibble,D3
000025AC  1A3C 0004               1974          MOVE.B  #right4,D5 
000025B0  EA6B                    1975          LSR.W   D5,D3
000025B2  0203 0002               1976          ANDI.B  #2,D3
000025B6  B63C 0002               1977          CMP.B   #2,D3
000025BA  6700 0006               1978          BEQ     D4_An_SETONE_2       ; SETONE refers to the set for reg to mem branch. 
000025BE  6000 0014               1979          BRA     CHECK1_BIT_4
000025C2                          1980  D4_An_SETONE_2
000025C2  183C 0002               1981          MOVE.B  #$2, D4
000025C6                          1982          
000025C6  6000 0002               1983          BRA     PRINT1_A2
000025CA                          1984          
000025CA                          1985  PRINT1_A2
000025CA  4EB9 00002CD0           1986          JSR     EA_An
000025D0  14FC 002F               1987          MOVE.B  #$2F,(A2)+ 
000025D4                          1988  
000025D4                          1989  *-----------------------------------------------------------------------------------*
000025D4                          1990  * Print out A3 if mask field states to. 
000025D4                          1991  
000025D4                          1992  CHECK1_BIT_4
000025D4  3606                    1993          MOVE.W  D6, D3
000025D6  0243 00F0               1994          ANDI.W  #third_nibble,D3
000025DA  1A3C 0004               1995          MOVE.B  #right4,D5 
000025DE  EA6B                    1996          LSR.W   D5,D3
000025E0  0203 0001               1997          ANDI.B  #1,D3
000025E4  B63C 0001               1998          CMP.B   #1,D3
000025E8  6700 0006               1999          BEQ     D4_An_SETONE_3       ; SETONE refers to the set for reg to mem branch. 
000025EC  6000 0014               2000          BRA     CHECK1_BIT_3
000025F0                          2001  D4_An_SETONE_3
000025F0  183C 0003               2002          MOVE.B  #$3, D4
000025F4                          2003          
000025F4  6000 0002               2004          BRA     PRINT1_A3
000025F8                          2005          
000025F8                          2006  PRINT1_A3
000025F8  4EB9 00002CD0           2007          JSR     EA_An
000025FE  14FC 002F               2008          MOVE.B  #$2F,(A2)+ 
00002602                          2009  
00002602                          2010  * FOURTH NIBBLE CHECK A4 - A7 
00002602                          2011  *-----------------------------------------------------------------------------------*
00002602                          2012  * Print out A4 if mask field states to. 
00002602                          2013  
00002602                          2014  CHECK1_BIT_3
00002602  3606                    2015          MOVE.W  D6, D3
00002604  0243 000F               2016          ANDI.W  #fourth_nibble,D3
00002608  0203 0008               2017          ANDI.B  #8,D3
0000260C  B63C 0008               2018          CMP.B   #8,D3
00002610  6700 0006               2019          BEQ     D4_An_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
00002614  6000 0014               2020          BRA     CHECK1_BIT_2
00002618                          2021  D4_An_SETONE_4
00002618  183C 0004               2022          MOVE.B  #$4, D4
0000261C                          2023          
0000261C  6000 0002               2024          BRA     PRINT1_A4
00002620                          2025          
00002620                          2026  PRINT1_A4
00002620  4EB9 00002CD0           2027          JSR     EA_An
00002626  14FC 002F               2028          MOVE.B  #$2F,(A2)+ 
0000262A                          2029  
0000262A                          2030  *-----------------------------------------------------------------------------------*
0000262A                          2031  * Print out A5 if mask field states to. 
0000262A                          2032  
0000262A                          2033  CHECK1_BIT_2
0000262A  3606                    2034          MOVE.W  D6, D3
0000262C  0243 000F               2035          ANDI.W  #fourth_nibble,D3
00002630  0203 0004               2036          ANDI.B  #4,D3
00002634  B63C 0004               2037          CMP.B   #4,D3
00002638  6700 0006               2038          BEQ     D4_An_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
0000263C  6000 0014               2039          BRA     CHECK1_BIT_1
00002640                          2040  D4_An_SETONE_5
00002640  183C 0005               2041          MOVE.B  #$5, D4
00002644                          2042          
00002644  6000 0002               2043          BRA     PRINT1_A5
00002648                          2044          
00002648                          2045  PRINT1_A5
00002648  4EB9 00002CD0           2046          JSR     EA_An
0000264E  14FC 002F               2047          MOVE.B  #$2F,(A2)+ 
00002652                          2048  
00002652                          2049  *-----------------------------------------------------------------------------------*
00002652                          2050  * Print out A6 if mask field states to. 
00002652                          2051  
00002652                          2052  CHECK1_BIT_1
00002652  3606                    2053          MOVE.W  D6, D3
00002654  0243 000F               2054          ANDI.W  #fourth_nibble,D3
00002658  0203 0002               2055          ANDI.B  #2,D3
0000265C  B63C 0002               2056          CMP.B   #2,D3
00002660  6700 0006               2057          BEQ     D4_An_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
00002664  6000 0014               2058          BRA     CHECK1_BIT_0
00002668                          2059  D4_An_SETONE_6
00002668  183C 0006               2060          MOVE.B  #$6, D4
0000266C                          2061          
0000266C  6000 0002               2062          BRA     PRINT1_A6
00002670                          2063          
00002670                          2064  PRINT1_A6
00002670  4EB9 00002CD0           2065          JSR     EA_An
00002676  14FC 002F               2066          MOVE.B  #$2F,(A2)+ 
0000267A                          2067  
0000267A                          2068  *-----------------------------------------------------------------------------------*
0000267A                          2069  * Print out A7 if mask field states to. 
0000267A                          2070  
0000267A                          2071  CHECK1_BIT_0
0000267A  3606                    2072          MOVE.W  D6, D3
0000267C  0243 000F               2073          ANDI.W  #fourth_nibble,D3
00002680  0203 0001               2074          ANDI.B  #1,D3
00002684  B63C 0001               2075          CMP.B   #1,D3
00002688  6700 0006               2076          BEQ     D4_An_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
0000268C  6000 0014               2077          BRA     FINISH_REG_TO_MEM
00002690                          2078  D4_An_SETONE_7
00002690  183C 0007               2079          MOVE.B  #$7, D4
00002694                          2080          
00002694  6000 0002               2081          BRA     PRINT1_A7
00002698                          2082          
00002698                          2083  PRINT1_A7
00002698  4EB9 00002CD0           2084          JSR     EA_An
0000269E  14FC 002F               2085          MOVE.B  #$2F,(A2)+ 
000026A2                          2086  
000026A2                          2087  FINISH_REG_TO_MEM
000026A2  14FC 002C               2088          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000026A6  14FC 0020               2089          MOVE.B  #$20,(A2)+          ; Add space after comma
000026AA                          2090  
000026AA  2800                    2091          MOVE.L  D0,D4               ; Store the src reg in D4
000026AC  0244 0007               2092          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000026B0                          2093          
000026B0  2600                    2094          MOVE.L  D0,D3               ; Store the src mode in D3
000026B2  0243 0038               2095          ANDI.W  #src_mode,D3        ; Get bits 5-3
000026B6  1A3C 0003               2096          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000026BA  EA6B                    2097          LSR.W   D5,D3               ; Do the actual shift 
000026BC  4EB9 00002C86           2098          JSR     EA_GEN_SRC
000026C2                          2099          
000026C2  301D                    2100          MOVE.W  (A5)+, D0 
000026C4                          2101  
000026C4  4EF8 1E12               2102          JMP     EA_FINISH
000026C8                          2103  
000026C8                          2104  MEM_TO_REG                          ; post-increment + A7-A0,D7-D0
000026C8                          2105  
000026C8  B63C 0002               2106          CMP.B   #2, D3              ; check if the destination is (An)
000026CC  6700 0022               2107          BEQ     MEM_TO_REG_CONTINUE ; branch to print out the address and data registers. 
000026D0                          2108          
000026D0  2800                    2109          MOVE.L  D0,D4               ; Store the src reg in D4
000026D2  0244 0007               2110          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000026D6                          2111          
000026D6  2600                    2112          MOVE.L  D0,D3               ; Store the src mode in D3
000026D8  0243 0038               2113          ANDI.W  #src_mode,D3        ; Get bits 5-3
000026DC  1A3C 0003               2114          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000026E0  EA6B                    2115          LSR.W   D5,D3               ; Do the actual shift 
000026E2  4EB9 00002C86           2116          JSR     EA_GEN_SRC
000026E8                          2117          
000026E8  14FC 002C               2118          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000026EC  14FC 0020               2119          MOVE.B  #$20,(A2)+          ; Add space after comma
000026F0                          2120  
000026F0                          2121          
000026F0                          2122  * Print out the proper data and address registers. 
000026F0                          2123  * FIRST NIBBLE CHECK A7 - A4
000026F0                          2124  *-----------------------------------------------------------------------------------*
000026F0                          2125  * Print out A7 if mask field states to. 
000026F0                          2126  MEM_TO_REG_CONTINUE
000026F0  3C15                    2127          MOVE.W  (A5), D6            ; store the register list mask field for MEM to REG
000026F2                          2128          
000026F2  3606                    2129          MOVE.W  D6, D3
000026F4  0243 F000               2130          ANDI.W  #first_nibble,D3
000026F8  1A3C 000C               2131          MOVE.B  #right12,D5 
000026FC  EA6B                    2132          LSR.W   D5,D3
000026FE  0203 0008               2133          ANDI.B  #8,D3
00002702  B63C 0008               2134          CMP.B   #8,D3
00002706  6700 0006               2135          BEQ     D4_An_SET_7
0000270A  6000 0014               2136          BRA     CHECK_BIT_14
0000270E                          2137  D4_An_SET_7
0000270E  183C 0007               2138          MOVE.B  #$7, D4
00002712                          2139          
00002712  6000 0002               2140          BRA     PRINT_A7
00002716                          2141          
00002716                          2142  PRINT_A7
00002716  4EB9 00002CD0           2143          JSR     EA_An
0000271C  14FC 002F               2144          MOVE.B  #$2F,(A2)+
00002720                          2145          
00002720                          2146  *-----------------------------------------------------------------------------------*
00002720                          2147  * Print out A6 if mask field states to. 
00002720                          2148  
00002720                          2149  CHECK_BIT_14
00002720  3606                    2150          MOVE.W  D6, D3
00002722  0243 F000               2151          ANDI.W  #first_nibble,D3
00002726  1A3C 000C               2152          MOVE.B  #right12,D5 
0000272A  EA6B                    2153          LSR.W   D5,D3
0000272C  0203 0004               2154          ANDI.B  #4,D3
00002730  B63C 0004               2155          CMP.B   #4,D3
00002734  6700 0006               2156          BEQ     D4_An_SET_6
00002738  6000 0014               2157          BRA     CHECK_BIT_13
0000273C                          2158  D4_An_SET_6
0000273C  183C 0006               2159          MOVE.B  #$6, D4
00002740                          2160          
00002740  6000 0002               2161          BRA     PRINT_A6
00002744                          2162          
00002744                          2163  PRINT_A6
00002744  4EB9 00002CD0           2164          JSR     EA_An
0000274A  14FC 002F               2165          MOVE.B  #$2F,(A2)+
0000274E                          2166  
0000274E                          2167  *-----------------------------------------------------------------------------------*
0000274E                          2168  * Print out A5 if mask field states to. 
0000274E                          2169  
0000274E                          2170  CHECK_BIT_13
0000274E  3606                    2171          MOVE.W  D6, D3
00002750  0243 F000               2172          ANDI.W  #first_nibble,D3
00002754  1A3C 000C               2173          MOVE.B  #right12,D5 
00002758  EA6B                    2174          LSR.W   D5,D3
0000275A  0203 0002               2175          ANDI.B  #2,D3
0000275E  B63C 0002               2176          CMP.B   #2,D3
00002762  6700 0006               2177          BEQ     D4_An_SET_5
00002766  6000 0014               2178          BRA     CHECK_BIT_12
0000276A                          2179  D4_An_SET_5
0000276A  183C 0005               2180          MOVE.B  #$5, D4
0000276E                          2181          
0000276E  6000 0002               2182          BRA     PRINT_A5
00002772                          2183          
00002772                          2184  PRINT_A5
00002772  4EB9 00002CD0           2185          JSR     EA_An
00002778  14FC 002F               2186          MOVE.B  #$2F,(A2)+
0000277C                          2187  
0000277C                          2188  *-----------------------------------------------------------------------------------*
0000277C                          2189  * Print out A4 if mask field states to. 
0000277C                          2190          
0000277C                          2191  CHECK_BIT_12
0000277C  3606                    2192          MOVE.W  D6, D3
0000277E  0243 F000               2193          ANDI.W  #first_nibble,D3
00002782  1A3C 000C               2194          MOVE.B  #right12,D5 
00002786  EA6B                    2195          LSR.W   D5,D3
00002788  0203 0001               2196          ANDI.B  #1,D3
0000278C  B63C 0001               2197          CMP.B   #1,D3
00002790  6700 0006               2198          BEQ     D4_An_SET_4
00002794  6000 0014               2199          BRA     CHECK_BIT_11
00002798                          2200  D4_An_SET_4
00002798  183C 0004               2201          MOVE.B  #$4, D4
0000279C                          2202          
0000279C  6000 0002               2203          BRA     PRINT_A4
000027A0                          2204          
000027A0                          2205  PRINT_A4
000027A0  4EB9 00002CD0           2206          JSR     EA_An
000027A6  14FC 002F               2207          MOVE.B  #$2F,(A2)+
000027AA                          2208  
000027AA                          2209  *-----------------------------------------------------------------------------------*
000027AA                          2210  * Print out A3 if mask field states to. 
000027AA                          2211  * SECOND NIBBLE CHECK A7 - A4
000027AA                          2212    
000027AA                          2213  CHECK_BIT_11
000027AA  3606                    2214          MOVE.W  D6, D3
000027AC  0243 0F00               2215          ANDI.W  #second_nibble,D3
000027B0  1A3C 0008               2216          MOVE.B  #right8,D5 
000027B4  EA6B                    2217          LSR.W   D5,D3
000027B6  0203 0008               2218          ANDI.B  #8,D3
000027BA  B63C 0008               2219          CMP.B   #8,D3
000027BE  6700 0006               2220          BEQ     D4_An_SET_3
000027C2  6000 0014               2221          BRA     CHECK_BIT_10
000027C6                          2222  D4_An_SET_3
000027C6  183C 0003               2223          MOVE.B  #$3, D4
000027CA                          2224          
000027CA  6000 0002               2225          BRA     PRINT_A3
000027CE                          2226          
000027CE                          2227  PRINT_A3
000027CE  4EB9 00002CD0           2228          JSR     EA_An
000027D4  14FC 002F               2229          MOVE.B  #$2F,(A2)+     
000027D8                          2230  
000027D8                          2231  *-----------------------------------------------------------------------------------*
000027D8                          2232  * Print out A2 if mask field states to. 
000027D8                          2233    
000027D8                          2234  CHECK_BIT_10
000027D8  3606                    2235          MOVE.W  D6, D3
000027DA  0243 0F00               2236          ANDI.W  #second_nibble,D3
000027DE  1A3C 0008               2237          MOVE.B  #right8,D5 
000027E2  EA6B                    2238          LSR.W   D5,D3
000027E4  0203 0004               2239          ANDI.B  #4,D3
000027E8  B63C 0004               2240          CMP.B   #4,D3
000027EC  6700 0006               2241          BEQ     D4_An_SET_2
000027F0  6000 0014               2242          BRA     CHECK_BIT_9
000027F4                          2243  D4_An_SET_2
000027F4  183C 0002               2244          MOVE.B  #$2, D4
000027F8                          2245          
000027F8  6000 0002               2246          BRA     PRINT_A2
000027FC                          2247          
000027FC                          2248  PRINT_A2
000027FC  4EB9 00002CD0           2249          JSR     EA_An
00002802  14FC 002F               2250          MOVE.B  #$2F,(A2)+  
00002806                          2251  
00002806                          2252  *-----------------------------------------------------------------------------------*
00002806                          2253  * Print out A1 if mask field states to. 
00002806                          2254    
00002806                          2255  CHECK_BIT_9
00002806  3606                    2256          MOVE.W  D6, D3
00002808  0243 0F00               2257          ANDI.W  #second_nibble,D3
0000280C  1A3C 0008               2258          MOVE.B  #right8,D5 
00002810  EA6B                    2259          LSR.W   D5,D3
00002812  0203 0002               2260          ANDI.B  #2,D3
00002816  B63C 0002               2261          CMP.B   #2,D3
0000281A  6700 0006               2262          BEQ     D4_An_SET_1
0000281E  6000 0012               2263          BRA     CHECK_BIT_8
00002822                          2264  D4_An_SET_1
00002822  183C 0001               2265          MOVE.B  #$1, D4
00002826                          2266          
00002826  60D4                    2267          BRA     PRINT_A2
00002828                          2268          
00002828                          2269  PRINT_A1
00002828  4EB9 00002CD0           2270          JSR     EA_An
0000282E  14FC 002F               2271          MOVE.B  #$2F,(A2)+ 
00002832                          2272  
00002832                          2273  *-----------------------------------------------------------------------------------*
00002832                          2274  * Print out A0 if mask field states to. 
00002832                          2275    
00002832                          2276  CHECK_BIT_8
00002832  3606                    2277          MOVE.W  D6, D3
00002834  0243 0F00               2278          ANDI.W  #second_nibble,D3
00002838  1A3C 0008               2279          MOVE.B  #right8,D5 
0000283C  EA6B                    2280          LSR.W   D5,D3
0000283E  0203 0001               2281          ANDI.B  #1,D3
00002842  B63C 0001               2282          CMP.B   #1,D3
00002846  6700 0006               2283          BEQ     D4_An_SET_0
0000284A  6000 0014               2284          BRA     CHECK_BIT_7
0000284E                          2285  D4_An_SET_0
0000284E  183C 0000               2286          MOVE.B  #$0, D4
00002852                          2287          
00002852  6000 0002               2288          BRA     PRINT_A0
00002856                          2289          
00002856                          2290  PRINT_A0
00002856  4EB9 00002CD0           2291          JSR     EA_An
0000285C  14FC 002F               2292          MOVE.B  #$2F,(A2)+        
00002860                          2293  
00002860                          2294  *-----------------------------------------------------------------------------------*
00002860                          2295  * Print out D7 if mask field states to. 
00002860                          2296  * THIRD NIBBLE CHECK D7-D0
00002860                          2297  
00002860                          2298  CHECK_BIT_7
00002860  3606                    2299          MOVE.W  D6, D3
00002862  0243 00F0               2300          ANDI.W  #third_nibble,D3
00002866  1A3C 0004               2301          MOVE.B  #right4,D5 
0000286A  EA6B                    2302          LSR.W   D5,D3
0000286C  0203 0008               2303          ANDI.B  #8,D3
00002870  B63C 0008               2304          CMP.B   #8,D3
00002874  6700 0006               2305          BEQ     D4_Dn_SET_7
00002878  6000 0014               2306          BRA     CHECK_BIT_6
0000287C                          2307  D4_Dn_SET_7
0000287C  183C 0007               2308          MOVE.B  #$7, D4
00002880                          2309          
00002880  6000 0002               2310          BRA     PRINT_D7
00002884                          2311          
00002884                          2312  PRINT_D7
00002884  4EB9 00002CC4           2313          JSR     EA_Dn
0000288A  14FC 002F               2314          MOVE.B  #$2F,(A2)+
0000288E                          2315  
0000288E                          2316  *-----------------------------------------------------------------------------------*
0000288E                          2317  * Print out D6 if mask field states to. 
0000288E                          2318  
0000288E                          2319  CHECK_BIT_6
0000288E  3606                    2320          MOVE.W  D6, D3
00002890  0243 00F0               2321          ANDI.W  #third_nibble,D3
00002894  1A3C 0004               2322          MOVE.B  #right4,D5 
00002898  EA6B                    2323          LSR.W   D5,D3
0000289A  0203 0004               2324          ANDI.B  #4,D3
0000289E  B63C 0004               2325          CMP.B   #4,D3
000028A2  6700 0006               2326          BEQ     D4_Dn_SET_6
000028A6  6000 0014               2327          BRA     CHECK_BIT_5
000028AA                          2328  D4_Dn_SET_6
000028AA  183C 0006               2329          MOVE.B  #$6, D4
000028AE                          2330          
000028AE  6000 0002               2331          BRA     PRINT_D6
000028B2                          2332          
000028B2                          2333  PRINT_D6
000028B2  4EB9 00002CC4           2334          JSR     EA_Dn
000028B8  14FC 002F               2335          MOVE.B  #$2F,(A2)+
000028BC                          2336  
000028BC                          2337  *-----------------------------------------------------------------------------------*
000028BC                          2338  * Print out D5 if mask field states to. 
000028BC                          2339  
000028BC                          2340  CHECK_BIT_5
000028BC  3606                    2341          MOVE.W  D6, D3
000028BE  0243 00F0               2342          ANDI.W  #third_nibble,D3
000028C2  1A3C 0004               2343          MOVE.B  #right4,D5 
000028C6  EA6B                    2344          LSR.W   D5,D3
000028C8  0203 0002               2345          ANDI.B  #2,D3
000028CC  B63C 0002               2346          CMP.B   #2,D3
000028D0  6700 0006               2347          BEQ     D4_Dn_SET_5
000028D4  6000 0014               2348          BRA     CHECK_BIT_4
000028D8                          2349  D4_Dn_SET_5
000028D8  183C 0005               2350          MOVE.B  #$5, D4
000028DC                          2351          
000028DC  6000 0002               2352          BRA     PRINT_D5
000028E0                          2353          
000028E0                          2354  PRINT_D5
000028E0  4EB9 00002CC4           2355          JSR     EA_Dn
000028E6  14FC 002F               2356          MOVE.B  #$2F,(A2)+
000028EA                          2357  
000028EA                          2358  *-----------------------------------------------------------------------------------*
000028EA                          2359  * Print out D4 if mask field states to. 
000028EA                          2360  
000028EA                          2361  CHECK_BIT_4
000028EA  3606                    2362          MOVE.W  D6, D3
000028EC  0243 00F0               2363          ANDI.W  #third_nibble,D3
000028F0  1A3C 0004               2364          MOVE.B  #right4,D5 
000028F4  EA6B                    2365          LSR.W   D5,D3
000028F6  0203 0001               2366          ANDI.B  #1,D3
000028FA  B63C 0001               2367          CMP.B   #1,D3
000028FE  6700 0006               2368          BEQ     D4_Dn_SET_4
00002902  6000 0014               2369          BRA     CHECK_BIT_3
00002906                          2370  D4_Dn_SET_4
00002906  183C 0004               2371          MOVE.B  #$4, D4
0000290A                          2372          
0000290A  6000 0002               2373          BRA     PRINT_D4
0000290E                          2374          
0000290E                          2375  PRINT_D4
0000290E  4EB9 00002CC4           2376          JSR     EA_Dn
00002914  14FC 002F               2377          MOVE.B  #$2F,(A2)+
00002918                          2378  
00002918                          2379  *-----------------------------------------------------------------------------------*
00002918                          2380  * Print out D3 if mask field states to. 
00002918                          2381  * FOURTH NIBBLE CHECK / D3 - D0
00002918                          2382  
00002918                          2383  CHECK_BIT_3
00002918  3606                    2384          MOVE.W  D6, D3
0000291A  0243 000F               2385          ANDI.W  #fourth_nibble,D3
0000291E  0203 0008               2386          ANDI.B  #8,D3
00002922  B63C 0008               2387          CMP.B   #8,D3
00002926  6700 0006               2388          BEQ     D4_Dn_SET_3
0000292A  6000 0014               2389          BRA     CHECK_BIT_2
0000292E                          2390  D4_Dn_SET_3
0000292E  183C 0003               2391          MOVE.B  #$3, D4
00002932                          2392          
00002932  6000 0002               2393          BRA     PRINT_D3
00002936                          2394          
00002936                          2395  PRINT_D3
00002936  4EB9 00002CC4           2396          JSR     EA_Dn
0000293C  14FC 002F               2397          MOVE.B  #$2F,(A2)+
00002940                          2398  
00002940                          2399  *-----------------------------------------------------------------------------------*
00002940                          2400  * Print out D2 if mask field states to. 
00002940                          2401  
00002940                          2402  CHECK_BIT_2
00002940  3606                    2403          MOVE.W  D6, D3
00002942  0243 000F               2404          ANDI.W  #fourth_nibble,D3
00002946  0203 0004               2405          ANDI.B  #4,D3
0000294A  B63C 0004               2406          CMP.B   #4,D3
0000294E  6700 0006               2407          BEQ     D4_Dn_SET_2
00002952  6000 0014               2408          BRA     CHECK_BIT_1
00002956                          2409  D4_Dn_SET_2
00002956  183C 0002               2410          MOVE.B  #$2, D4
0000295A                          2411          
0000295A  6000 0002               2412          BRA     PRINT_D2
0000295E                          2413          
0000295E                          2414  PRINT_D2
0000295E  4EB9 00002CC4           2415          JSR     EA_Dn
00002964  14FC 002F               2416          MOVE.B  #$2F,(A2)+
00002968                          2417  
00002968                          2418  *-----------------------------------------------------------------------------------*
00002968                          2419  * Print out D1 if mask field states to. 
00002968                          2420  
00002968                          2421  CHECK_BIT_1
00002968  3606                    2422          MOVE.W  D6, D3
0000296A  0243 000F               2423          ANDI.W  #fourth_nibble,D3
0000296E  0203 0002               2424          ANDI.B  #2,D3
00002972  B63C 0002               2425          CMP.B   #2,D3
00002976  6700 0006               2426          BEQ     D4_Dn_SET_1
0000297A  6000 0014               2427          BRA     CHECK_BIT_0
0000297E                          2428  D4_Dn_SET_1
0000297E  183C 0001               2429          MOVE.B  #$1, D4
00002982                          2430          
00002982  6000 0002               2431          BRA     PRINT_D1
00002986                          2432          
00002986                          2433  PRINT_D1
00002986  4EB9 00002CC4           2434          JSR     EA_Dn
0000298C  14FC 002F               2435          MOVE.B  #$2F,(A2)+
00002990                          2436  
00002990                          2437  *-----------------------------------------------------------------------------------*
00002990                          2438  * Print out D0 if mask field states to. 
00002990                          2439  
00002990                          2440  CHECK_BIT_0
00002990  3606                    2441          MOVE.W  D6, D3
00002992  0243 000F               2442          ANDI.W  #fourth_nibble,D3
00002996  0203 0001               2443          ANDI.B  #1,D3
0000299A  B63C 0001               2444          CMP.B   #1,D3
0000299E  6700 0006               2445          BEQ     D4_Dn_SET_0
000029A2  6000 0014               2446          BRA     FINISH_MOVEM_MEM_TO_REG
000029A6                          2447  D4_Dn_SET_0
000029A6  183C 0000               2448          MOVE.B  #$0, D4
000029AA                          2449          
000029AA  6000 0002               2450          BRA     PRINT_D0
000029AE                          2451          
000029AE                          2452  PRINT_D0
000029AE  4EB9 00002CC4           2453          JSR     EA_Dn
000029B4  14FC 002F               2454          MOVE.B  #$2F,(A2)+
000029B8                          2455  
000029B8                          2456  FINISH_MOVEM_MEM_TO_REG
000029B8                          2457          
000029B8  2600                    2458          MOVE.L  D0,D3               ; Store the src mode in D3
000029BA  0243 0038               2459          ANDI.W  #src_mode,D3        ; Get bits 5-3
000029BE  1A3C 0003               2460          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000029C2  EA6B                    2461          LSR.W   D5,D3               ; Do the actual shift
000029C4                          2462  
000029C4  2800                    2463          MOVE.L  D0,D4               ; Store the dst reg in D4
000029C6  0244 0007               2464          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000029CA                          2465   
000029CA  B63C 0002               2466          CMP.B   #2, D3
000029CE  6700 0006               2467          BEQ     An_FINISH           ; branch to print out (An) 
000029D2  6000 0010               2468          BRA     NORMAL_FINISH       ; branch to the normal finish
000029D6                          2469  
000029D6                          2470  An_FINISH
000029D6  14FC 002C               2471          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000029DA  14FC 0020               2472          MOVE.B  #$20,(A2)+          ; Add space after comma
000029DE                          2473          
000029DE                          2474                      
000029DE  4EB9 00002C86           2475          JSR     EA_GEN_SRC
000029E4                          2476  
000029E4                          2477  NORMAL_FINISH
000029E4  301D                    2478          MOVE.W  (A5)+, D0
000029E6                          2479          
000029E6  4EF8 1E12               2480          JMP     EA_FINISH
000029EA                          2481  *------------------------------------------------------------------------------------------------*
000029EA                          2482  EA_SHIFTS       ; 7: ea_shifts
000029EA  2200                    2483          MOVE.L  D0,D1               ; D0 is current instruction word
000029EC  0241 01C0               2484          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000029F0  1A3C 0006               2485          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000029F4  EA69                    2486          LSR.W   D5,D1               ; Shift dst mode into LSB position
000029F6  C2FC 0006               2487          MULU    #6, D1              ; Set displacement 
000029FA  41F9 00002A04           2488          LEA     EA_SHIFTS_TABLE,A0  ; Load table into A0
00002A00  4EF0 1000               2489          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00002A04                          2490  
00002A04                          2491  EA_SHIFTS_TABLE
00002A04  4EF9 00002AAA           2492          JMP     EA_REGISTER_SHIFTS  ; 000 Register
00002A0A  4EF9 00002AAA           2493          JMP     EA_REGISTER_SHIFTS  ; 001 Register
00002A10  4EF9 00002AAA           2494          JMP     EA_REGISTER_SHIFTS  ; 010 Register
00002A16  4EF9 00002A34           2495          JMP     EA_MEMORY_SHIFTS    ; 011 Memory
00002A1C  4EF9 00002AAA           2496          JMP     EA_REGISTER_SHIFTS  ; 100 Register
00002A22  4EF9 00002AAA           2497          JMP     EA_REGISTER_SHIFTS  ; 101 Register
00002A28  4EF9 00002AAA           2498          JMP     EA_REGISTER_SHIFTS  ; 110 Register
00002A2E  4EF9 00002A34           2499          JMP     EA_MEMORY_SHIFTS    ; 111 Memory
00002A34                          2500          
00002A34                          2501  EA_MEMORY_SHIFTS
00002A34                          2502          ; Get EA and store into decode buffer
00002A34  2800                    2503          MOVE.L  D0,D4               ; Store the EA reg in D4
00002A36  0244 0007               2504          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002A3A                          2505          
00002A3A  2600                    2506          MOVE.L  D0,D3               ; Store the EA mode in D3
00002A3C  0243 0038               2507          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002A40  1A3C 0003               2508          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002A44  EA6B                    2509          LSR.W   D5,D3               ; Do the actual shift
00002A46  4EB9 00002D9C           2510          JSR     An_CHECK            ; Check if mode is An 
00002A4C  4EB9 00002DA6           2511          JSR     Dn_CHECK            ; Check if mode is Dn
00002A52  4EB9 00002DB0           2512          JSR     IMMEDIATE_CHECK     ; Check if mode is immediate
00002A58                          2513          
00002A58  14FC 0020               2514          MOVE.B  #$20,(A2)+          ; Print out a space 
00002A5C  14FC 0020               2515          MOVE.B  #$20,(A2)+          ; Print out a space
00002A60  14FC 0020               2516          MOVE.B  #$20,(A2)+          ; Print out a space
00002A64  14FC 0020               2517          MOVE.B  #$20,(A2)+          ; Print out a space
00002A68  14FC 0020               2518          MOVE.B  #$20,(A2)+          ; Add space
00002A6C                          2519          
00002A6C  4EB9 00002A84           2520          JSR     FRONT_FORMAT
00002A72  4EB9 00002C86           2521          JSR     EA_GEN_SRC          ; Go get EA print
00002A78  B63C 002A               2522          CMP.B   #$2A,D3             ; When mode is 111 * 6 (2A)
00002A7C  6700 001E               2523          BEQ     BACK_PARENTHESIS  
00002A80  4EF8 1E12               2524          JMP     EA_FINISH           ; Opcode is finish
00002A84                          2525  
00002A84                          2526  FRONT_FORMAT
00002A84  B63C 0007               2527          CMP.B   #7,D3               ; When mode is 111
00002A88  6700 0008               2528          BEQ     ADD_PARENTHESIS
00002A8C  14FC 0020               2529          MOVE.B  #$20,(A2)+          ; Print out a space
00002A90  4E75                    2530          RTS
00002A92                          2531          
00002A92                          2532  ADD_PARENTHESIS
00002A92  14FC 0020               2533          MOVE.B  #$20,(A2)+          ; Print out a space
00002A96  14FC 0028               2534          MOVE.B  #'(',(A2)+
00002A9A  4E75                    2535          RTS
00002A9C                          2536          
00002A9C                          2537  BACK_PARENTHESIS            
00002A9C  14FC 0029               2538          MOVE.B  #')',(A2)+
00002AA0  1404                    2539          MOVE.B  D4,D2
00002AA2  4EB8 1F00               2540          JSR     EA_SIZE_MEMORY_SHIFTS
00002AA6  4EF8 1E12               2541          JMP     EA_FINISH           ; Opcode is finish
00002AAA                          2542      
00002AAA                          2543  EA_REGISTER_SHIFTS
00002AAA  2200                    2544          MOVE.L  D0,D1
00002AAC  0241 01C0               2545          ANDI.W  #dst_mode,D1
00002AB0  1A3C 0006               2546          MOVE.B  #right6,D5 
00002AB4  EA69                    2547          LSR.W   D5,D1
00002AB6  0201 0003               2548          ANDI.B  #3,D1               ; Remove bit 8 and get bits 7-6
00002ABA  1401                    2549          MOVE.B  D1,D2
00002ABC  4EB8 1E58               2550          JSR     EA_SIZE_GENERAL
00002AC0                          2551          
00002AC0  2600                    2552          MOVE.L  D0,D3               ; Store the instruction in D3
00002AC2  0243 0038               2553          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002AC6  1A3C 0003               2554          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002ACA  EA6B                    2555          LSR.W   D5,D3               ; Do the actual shift 
00002ACC  0203 0004               2556          ANDI.B  #4,D3               ; Get bit 5(ir) from bits 5-3
00002AD0  E44B                    2557          LSR.W   #2,D3
00002AD2                          2558  
00002AD2  B63C 0000               2559          CMP.B   #0,D3               ; When D1 is 0 (immediate)
00002AD6  6700 0006               2560          BEQ     IMMEDIATE_SRC
00002ADA  6000 0056               2561          BRA     REGISTER_SRC        ; When D1 is 1 (register)
00002ADE                          2562          
00002ADE                          2563  IMMEDIATE_SRC
00002ADE  14FC 0020               2564          MOVE.B  #$20,(A2)+          ; Add space
00002AE2  14FC 0020               2565          MOVE.B  #$20,(A2)+          ; Add space
00002AE6  14FC 0020               2566          MOVE.B  #$20,(A2)+          ; Add space
00002AEA  14FC 0020               2567          MOVE.B  #$20,(A2)+          ; Add space
00002AEE                          2568          
00002AEE                          2569          ; Get source and store into decode buffer
00002AEE  2800                    2570          MOVE.L  D0,D4               ; Store the src reg in D4
00002AF0  0244 0E00               2571          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002AF4  1A3C 0009               2572          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002AF8  EA6C                    2573          LSR.W   D5,D4               ; Do the actual shift
00002AFA  4EB9 00002B22           2574          JSR     CHECK_IF_ZERO       ; Check if register is 0
00002B00                          2575          
00002B00  14FC 0023               2576          MOVE.B  #$23,(A2)+          ; Add # symbol
00002B04  0604 0030               2577          ADDI.B  #$30,D4             ; Convert hex to ASCII
00002B08  14C4                    2578          MOVE.B  D4,(A2)+            ; Store into buffer
00002B0A                          2579          
00002B0A  14FC 002C               2580          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B0E  14FC 0020               2581          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B12                          2582  
00002B12                          2583          ; Get destination and store into decode buffer
00002B12  2800                    2584          MOVE.L  D0,D4               ; Store the src reg in D4
00002B14  0244 0007               2585          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002B18  4EB9 00002CC4           2586          JSR     EA_Dn               ; store Dn into decode buffer
00002B1E  4EF8 1E12               2587          JMP     EA_FINISH           ; Opcode is finish
00002B22                          2588                
00002B22                          2589  CHECK_IF_ZERO
00002B22  B83C 0000               2590          CMP.B   #0,D4               ; When D4 is 0 
00002B26  6700 0004               2591          BEQ     IMMEDIATE_EIGHT     ; Branch
00002B2A  4E75                    2592          RTS
00002B2C                          2593  
00002B2C                          2594  IMMEDIATE_EIGHT
00002B2C  183C 0008               2595          MOVE.B  #8,D4               ; Store 8 into D4 
00002B30  4E75                    2596          RTS
00002B32                          2597  
00002B32                          2598  REGISTER_SRC        
00002B32  14FC 0020               2599          MOVE.B  #$20,(A2)+          ; Add space
00002B36  14FC 0020               2600          MOVE.B  #$20,(A2)+          ; Add space
00002B3A  14FC 0020               2601          MOVE.B  #$20,(A2)+          ; Add space
00002B3E  14FC 0020               2602          MOVE.B  #$20,(A2)+          ; Add space
00002B42                          2603  
00002B42                          2604          ; Get source and store into decode buffer
00002B42  2800                    2605          MOVE.L  D0,D4               ; Store the src reg in D4
00002B44  0244 0E00               2606          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B48  1A3C 0009               2607          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B4C  EA6C                    2608          LSR.W   D5,D4               ; Do the actual shift
00002B4E  4EB9 00002CC4           2609          JSR     EA_Dn               ; store Dn into decode buffer
00002B54                          2610          
00002B54  14FC 002C               2611          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B58  14FC 0020               2612          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B5C                          2613  
00002B5C                          2614          ; Get destination and store into decode buffer
00002B5C  2800                    2615          MOVE.L  D0,D4               ; Store the src reg in D4
00002B5E  0244 0007               2616          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002B62  4EB9 00002CC4           2617          JSR     EA_Dn               ; store Dn into decode buffer
00002B68  4EF8 1E12               2618          JMP     EA_FINISH           ; Opcode is finish
00002B6C                          2619  *------------------------------------------------------------------------------------------------*
00002B6C                          2620  EA_QUICK        ; 8: ea_quick
00002B6C  BC3C 0005               2621          CMP.B   #5, D6              ; check if the first nibble is 5 for ADDQ
00002B70  6700 000A               2622          BEQ     ADDQ_EA_CALC
00002B74                          2623          
00002B74  BC3C 0007               2624          CMP.B   #7, D6              ; check if the first nibble is 7 for MOVEQ
00002B78  6700 0072               2625          BEQ     MOVEQ_EA_CALC
00002B7C                          2626          
00002B7C                          2627  ADDQ_EA_CALC
00002B7C  2200                    2628          MOVE.L  D0,D1
00002B7E  0241 01C0               2629          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00002B82  1A3C 0006               2630          MOVE.B  #right6,D5          ; Store 6 into D5
00002B86  EA69                    2631          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002B88  0201 0003               2632          ANDI.B  #3,D1               ; Remove the front bit from D1
00002B8C  1401                    2633          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002B8E  4EB8 1E58               2634          JSR     EA_SIZE_GENERAL     ; Get size and print size.
00002B92                          2635          
00002B92  14FC 0020               2636          MOVE.B  #$20,(A2)+          ; Add space after size
00002B96  14FC 0020               2637          MOVE.B  #$20,(A2)+          ; Add space
00002B9A  14FC 0020               2638          MOVE.B  #$20,(A2)+          ; Add space
00002B9E                          2639          
00002B9E  14FC 0023               2640          MOVE.B  #$23,(A2)+          ; Add # symbol
00002BA2  14FC 0024               2641          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002BA6                          2642          
00002BA6  2800                    2643          MOVE.L  D0,D4               ; Store the data in D4
00002BA8  0244 0E00               2644          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002BAC  1A3C 0009               2645          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002BB0  EA6C                    2646          LSR.W   D5,D4               ; Do the actual shift
00002BB2                          2647          
00002BB2  B83C 0000               2648          CMP.B   #0, D4
00002BB6  6700 0006               2649          BEQ     CHANGE_TO_EIGHT
00002BBA                          2650          
00002BBA  6000 0006               2651          BRA     DONT_CHANGE
00002BBE                          2652  
00002BBE                          2653  CHANGE_TO_EIGHT
00002BBE  183C 0008               2654          MOVE.B  #8, D4
00002BC2                          2655  
00002BC2                          2656  DONT_CHANGE        
00002BC2  0604 0030               2657          ADDI.B  #$30, D4
00002BC6  14C4                    2658          MOVE.B  D4, (A2)+      
00002BC8                          2659          
00002BC8  14FC 002C               2660          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002BCC  14FC 0020               2661          MOVE.B  #$20,(A2)+          ; Add space after comma
00002BD0                          2662          
00002BD0  2800                    2663          MOVE.L  D0,D4               ; Store the src reg in D4
00002BD2  0244 0007               2664          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002BD6                          2665          
00002BD6  2600                    2666          MOVE.L  D0,D3               ; Store the src mode in D3
00002BD8  0243 0038               2667          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002BDC  1A3C 0003               2668          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002BE0  EA6B                    2669          LSR.W   D5,D3               ; Do the actual shift 
00002BE2  4EB9 00002C86           2670          JSR     EA_GEN_SRC
00002BE8                          2671          
00002BE8  4EF8 1E12               2672          JMP     EA_FINISH
00002BEC                          2673  
00002BEC                          2674  MOVEQ_EA_CALC
00002BEC  14FC 0020               2675          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002BF0  14FC 0020               2676          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002BF4  14FC 0020               2677          MOVE.B  #$20,(A2)+          ; Add space
00002BF8  14FC 0020               2678          MOVE.B  #$20,(A2)+          ; Add space
00002BFC                          2679  
00002BFC  14FC 0023               2680          MOVE.B  #$23,(A2)+          ; Add # symbol
00002C00  14FC 0024               2681          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C04                          2682          
00002C04  2200                    2683          MOVE.L  D0, D1              ; move D0 to D1
00002C06  0241 00FF               2684          ANDI.W  #second_half, D1    ; get the second 8 bits of D1
00002C0A  1A01                    2685          MOVE.B  D1, D5              ; move D1 to D5 to convert it to ASCII
00002C0C                          2686          
00002C0C  4EB8 11C8               2687          JSR     ITOA_BYTE_BRANCH    ; print out the bit of data
00002C10                          2688          
00002C10  14FC 002C               2689          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002C14  14FC 0020               2690          MOVE.B  #$20,(A2)+          ; Add space after comma
00002C18                          2691          
00002C18  2800                    2692          MOVE.L  D0,D4               ; Store the data in D4
00002C1A  0244 0E00               2693          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002C1E  1A3C 0009               2694          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002C22  EA6C                    2695          LSR.W   D5,D4               ; Do the actual shift
00002C24  4EB9 00002C86           2696          JSR     EA_GEN_SRC
00002C2A                          2697          
00002C2A  4EF8 1E12               2698          JMP     EA_FINISH
00002C2E                          2699  *------------------------------------------------------------------------------------------------*
00002C2E                          2700  EA_BRANCH       ; 9: ea_branch
00002C2E  14FC 0020               2701          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C32  14FC 0020               2702          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C36  14FC 0020               2703          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C3A  14FC 0020               2704          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C3E  14FC 0020               2705          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C42  14FC 0020               2706          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C46                          2707  
00002C46  2600                    2708          MOVE.L  D0,D3               ; D0 is current instruction word
00002C48  0243 00F0               2709          ANDI.W  #third_nibble,D3   ; Extract 3rd nibble from instruction word
00002C4C  1A3C 0004               2710          MOVE.B  #right4,D5
00002C50                          2711          
00002C50  2800                    2712          MOVE.L  D0,D4               ; D0 is current instruction word
00002C52  0244 000F               2713          ANDI.W  #fourth_nibble,D4   ; Extract 4th nibble from instruction word
00002C56                          2714           
00002C56  B63C 0000               2715          CMP.B   #0,D3               ; check if 3rd nibble is 0. 
00002C5A  6700 0006               2716          BEQ     FOURTH_NIBBLE_CHECK
00002C5E                          2717          
00002C5E  6000 0018               2718          BRA     BRANCH_WORD_CHECK
00002C62                          2719          
00002C62                          2720  FOURTH_NIBBLE_CHECK                 
00002C62  B83C 0000               2721          CMP.B   #0,D4               ; check if the 4th nibble is 0. 
00002C66                          2722          
00002C66  3A15                    2723          MOVE.W  (A5),D5            ; store the 16-bit displacement into D5
00002C68                          2724          
00002C68  260D                    2725          MOVE.L  A5,D3              ; Store A5 address into D3
00002C6A                          2726          
00002C6A  DA43                    2727          ADD.W   D3,D5              ; Add the address to D5 to get the displacement. 
00002C6C                          2728          
00002C6C  14FC 0024               2729          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C70                          2730          
00002C70  4EB8 11F6               2731          JSR     ITOA_WORD_BRANCH    ; Print. 
00002C74                          2732  
00002C74  4EF8 1E12               2733          JMP     EA_FINISH
00002C78                          2734  
00002C78                          2735  BRANCH_WORD_CHECK
00002C78  4245                    2736          CLR     D5                  ; handles 8-bit displacement. 
00002C7A  DA03                    2737          ADD.B   D3,D5               ; add d3 and d4 to d5
00002C7C  DA04                    2738          ADD.B   D4,D5
00002C7E                          2739          
00002C7E  4EB8 11C8               2740          JSR     ITOA_BYTE_BRANCH    ; Print. 
00002C82                          2741  
00002C82  4EF8 1E12               2742          JMP     EA_FINISH
00002C86                          2743  
00002C86                          2744  EA_GEN_SRC
00002C86  41F9 00002C94           2745          LEA     EA_GEN_TABLE_SRC, A0
00002C8C  C6FC 0006               2746          MULU    #6, D3              ; use D3 to jump to the proper src mode and dst mode. 
00002C90  4EF0 3000               2747          JMP     0(A0,D3)            ; jump to each ea src generation table entry 
00002C94                          2748  
00002C94                          2749  EA_GEN_TABLE_SRC
00002C94  4EF9 00002CC4           2750          JMP     EA_Dn                       ; 000: Dn
00002C9A  4EF9 00002CD0           2751          JMP     EA_An                       ; 001: An
00002CA0  4EF9 00002CDC           2752          JMP     EA_An_Indirect              ; 010: (An)
00002CA6  4EF9 00002CF0           2753          JMP     EA_An_Indirect_Inc          ; 011: (An)+
00002CAC  4EF9 00002D08           2754          JMP     EA_An_Indirect_Dec          ; 100: -(An)
00002CB2  4EF9 00002D20           2755          JMP     EA_UNSUPPORTED              ; 101: Unsupported EA
00002CB8  4EF9 00002D20           2756          JMP     EA_UNSUPPORTED              ; 110: Unsupported EA
00002CBE  4EF9 00002D2E           2757          JMP     EA_Absolute_And_Immediate   ; 111: (xxx).W,(xxx).L, or #<data>
00002CC4                          2758  
00002CC4                          2759  EA_Dn               ; 000: Dn
00002CC4  14FC 0044               2760          MOVE.B  #'D',(A2)+
00002CC8  0604 0030               2761          ADDI.B  #$30,D4
00002CCC  14C4                    2762          MOVE.B  D4,(A2)+
00002CCE  4E75                    2763          RTS
00002CD0                          2764  
00002CD0                          2765  EA_An               ; 001: An
00002CD0  14FC 0041               2766          MOVE.B  #'A',(A2)+
00002CD4  0604 0030               2767          ADDI.B  #$30,D4
00002CD8  14C4                    2768          MOVE.B  D4,(A2)+
00002CDA  4E75                    2769          RTS
00002CDC                          2770  
00002CDC                          2771  EA_An_Indirect      ; 010: (An)
00002CDC  14FC 0028               2772          MOVE.B  #'(',(A2)+
00002CE0  14FC 0041               2773          MOVE.B  #'A',(A2)+
00002CE4  0604 0030               2774          ADDI.B  #$30,D4
00002CE8  14C4                    2775          MOVE.B  D4,(A2)+
00002CEA  14FC 0029               2776          MOVE.B  #')',(A2)+
00002CEE  4E75                    2777          RTS
00002CF0                          2778          
00002CF0                          2779  EA_An_Indirect_Inc  ; 011: (An)+
00002CF0  14FC 0028               2780          MOVE.B  #'(',(A2)+
00002CF4  14FC 0041               2781          MOVE.B  #'A',(A2)+
00002CF8  0604 0030               2782          ADDI.B  #$30, D4
00002CFC  14C4                    2783          MOVE.B  D4,(A2)+
00002CFE  14FC 0029               2784          MOVE.B  #')',(A2)+
00002D02  14FC 002B               2785          MOVE.B  #'+',(A2)+
00002D06  4E75                    2786          RTS
00002D08                          2787          
00002D08                          2788  EA_An_Indirect_Dec  ; 100: -(An)
00002D08  14FC 002D               2789          MOVE.B  #'-',(A2)+
00002D0C  14FC 0028               2790          MOVE.B  #'(',(A2)+
00002D10  14FC 0041               2791          MOVE.B  #'A',(A2)+
00002D14  0604 0030               2792          ADDI.B  #$30,D4
00002D18  14C4                    2793          MOVE.B  D4,(A2)+
00002D1A  14FC 0029               2794          MOVE.B  #')',(A2)+
00002D1E  4E75                    2795          RTS
00002D20                          2796  
00002D20                          2797  EA_UNSUPPORTED
00002D20  43F9 00002E87           2798          LEA     EA_TYPE_ERROR,A1
00002D26  103C 000E               2799          MOVE.B  #14,D0
00002D2A  4E4F                    2800          TRAP    #15  
00002D2C  4E75                    2801          RTS 
00002D2E                          2802          
00002D2E                          2803  EA_Absolute_And_Immediate           ; 111: (xxx).W,(xxx).L, or #<data>
00002D2E  B83C 0000               2804          CMP.B   #0,D4               ; If D4 is (xxx).W
00002D32  6700 0016               2805          BEQ     ABSOLUTE_WORD
00002D36                          2806          
00002D36  B83C 0001               2807          CMP.B   #1,D4               ; If D4 is (xxx).L
00002D3A  6700 001A               2808          BEQ     ABSOLUTE_LONG
00002D3E                          2809          
00002D3E  B83C 0004               2810          CMP.B   #4,D4               ; If D4 is #<data>  
00002D42  6700 001E               2811          BEQ     IMMEDIATE
00002D46                          2812          
00002D46  6000 00BC               2813          BRA     DECODE_ERROR    
00002D4A                          2814  
00002D4A                          2815  ABSOLUTE_WORD
00002D4A  14FC 0024               2816          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D4E  7401                    2817          MOVE.L  #1,D2               ; Insert 1 to D2 
00002D50  4EB8 1132               2818          JSR     ITOA                ; Convert word hex values to ITOA
00002D54  4E75                    2819          RTS
00002D56                          2820          
00002D56                          2821  ABSOLUTE_LONG
00002D56  14FC 0024               2822          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D5A  7402                    2823          MOVE.L  #2,D2               ; Insert 2 to D2
00002D5C  4EB8 1132               2824          JSR     ITOA                ; Convert long hex values to ITOA
00002D60  4E75                    2825          RTS
00002D62                          2826     
00002D62                          2827  IMMEDIATE
00002D62  14FC 0023               2828          MOVE.B  #$23,(A2)+          ; Add # symbol
00002D66  14FC 0024               2829          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D6A                          2830  
00002D6A  BC3C 0001               2831          CMP.B   #1,D6               ; If MOVE.b (code0001)
00002D6E  6700 0020               2832          BEQ     DO_ITOA_MOVE
00002D72  BC3C 0002               2833          CMP.B   #2, D6              ; If MOVE.l / MOVEA.l (code0010)
00002D76  6700 0018               2834          BEQ     DO_ITOA_MOVE
00002D7A  BC3C 0003               2835          CMP.B   #3, D6              ; If MOVE.w / MOVEA.w (code0011)
00002D7E  6700 0010               2836          BEQ     DO_ITOA_MOVE        
00002D82  BC3C 000D               2837          CMP.B   #13, D6             ; If ADD / ADDA (code1101)
00002D86  6700 000E               2838          BEQ     DO_ITOA_OPMODE
00002D8A                          2839          
00002D8A  4EB8 1132               2840          JSR     ITOA                ; Go to ITOA when not a move instruction
00002D8E  4E75                    2841          RTS
00002D90                          2842          
00002D90                          2843  DO_ITOA_MOVE
00002D90  4EB8 1154               2844          JSR ITOA_MOVE
00002D94  4E75                    2845          RTS
00002D96                          2846                
00002D96                          2847  DO_ITOA_OPMODE
00002D96  4EB8 1176               2848          JSR ITOA_OPMODE
00002D9A  4E75                    2849          RTS
00002D9C                          2850  
00002D9C                          2851  An_CHECK 
00002D9C  B63C 0001               2852          CMP.B   #1,D3               ; If mode is An     
00002DA0  6700 0062               2853          BEQ     DECODE_ERROR        ; Then branch to error message
00002DA4  4E75                    2854          RTS   
00002DA6                          2855        
00002DA6                          2856  Dn_CHECK 
00002DA6  B63C 0000               2857          CMP.B   #0,D3               ; If mode is Dn     
00002DAA  6700 0058               2858          BEQ     DECODE_ERROR        ; Then branch to error message
00002DAE  4E75                    2859          RTS    
00002DB0                          2860       
00002DB0                          2861  IMMEDIATE_CHECK
00002DB0  B63C 0007               2862          CMP.B   #7,D3
00002DB4  6700 0004               2863          BEQ     REGISTER_CHECK
00002DB8  4E75                    2864          RTS
00002DBA                          2865          
00002DBA                          2866  REGISTER_CHECK
00002DBA  B83C 0004               2867          CMP.B   #4,D4               ; If 100 in register
00002DBE  6700 0044               2868          BEQ     DECODE_ERROR        ; Branch to invalid
00002DC2  4E75                    2869          RTS   
00002DC4                          2870                
00002DC4                          2871  EA_WRONG_SIZE 
00002DC4  43F9 00002E3D           2872          LEA     WRONG_SIZE_MESSAGE, A1 
00002DCA  103C 000E               2873          MOVE.B  #14, D0
00002DCE  4E4F                    2874          TRAP    #15
00002DD0  4EF8 1E12               2875          JMP     EA_FINISH
00002DD4                          2876          
00002DD4                          2877  ABSOLUTE_IMMEDIATE_ERROR  
00002DD4  43F9 00002E4B           2878          LEA     ABSOLUTE_WRONGREG, A1 
00002DDA  103C 000E               2879          MOVE.B  #14, D0
00002DDE  4E4F                    2880          TRAP    #15
00002DE0  4EF8 1E12               2881          JMP     EA_FINISH
00002DE4                          2882          
00002DE4                          2883  DST_INVALID
00002DE4  43F9 00002EA9           2884          LEA     DST_INVALID_MSG, A1 
00002DEA  103C 000E               2885          MOVE.B  #14, D0
00002DEE  4E4F                    2886          TRAP    #15
00002DF0  4EF8 1E12               2887          JMP     EA_FINISH
00002DF4                          2888          
00002DF4                          2889  SRC_INVALID 
00002DF4  43F9 00002EDB           2890          LEA     SRC_INVALID_MSG, A1 
00002DFA  103C 000E               2891          MOVE.B  #14, D0
00002DFE  4E4F                    2892          TRAP    #15
00002E00  4EF8 1E12               2893          JMP     EA_FINISH
00002E04                          2894          
00002E04                          2895  DECODE_ERROR  
00002E04  14FC 0044               2896          MOVE.B  #'D',(A2)+
00002E08  14FC 0041               2897          MOVE.B  #'A',(A2)+
00002E0C  14FC 0054               2898          MOVE.B  #'T',(A2)+
00002E10  14FC 0041               2899          MOVE.B  #'A',(A2)+
00002E14  14FC 0020               2900          MOVE.B  #' ',(A2)+
00002E18  14FC 0020               2901          MOVE.B  #' ',(A2)+
00002E1C  14FC 0020               2902          MOVE.B  #' ',(A2)+
00002E20  14FC 0020               2903          MOVE.B  #' ',(A2)+
00002E24  14FC 0020               2904          MOVE.B  #' ',(A2)+
00002E28  14FC 0020               2905          MOVE.B  #' ',(A2)+
00002E2C  14FC 0024               2906          MOVE.B  #'$',(A2)+
00002E30  4EB8 1218               2907          JSR ITOA_WORD_ERROR
00002E34  4EF8 1E12               2908          JMP     EA_FINISH
00002E38                          2909           
00002E38  FFFF FFFF               2910  DONE    SIMHALT             ; halt simulator
00002E3C                          2911  
00002E3C                          2912  * Put variables and constants here
00002E3C                          2913      
00002E3C  =00000040               2914  buffer_size         EQU         64 
00002E3C  =00005000               2915  decoded_buffer      EQU         $5000  
00002E3C  =0000000D               2916  CR                  EQU         $0D
00002E3C  =0000000A               2917  LF                  EQU         $0A
00002E3C  =0000A000               2918  stack               EQU         $0000A000
00002E3C  =0000001E               2919  lines_p_screen      EQU         30
00002E3C  =00000003               2920  right3              EQU         3
00002E3C  =00000004               2921  right4              EQU         4
00002E3C  =00000006               2922  right6              EQU         6
00002E3C  =00000008               2923  right8              EQU         8
00002E3C  =00000009               2924  right9              EQU         9
00002E3C  =0000000C               2925  right12             EQU         12
00002E3C  =00000010               2926  right16             EQU         16
00002E3C  =00000018               2927  right24             EQU         24
00002E3C= 20                      2928  ascii_y_n           DC.B        32
00002E3D  =00000059               2929  y_uppercase         EQU         $59         
00002E3D  =00000079               2930  y_lowercase         EQU         $79
00002E3D  =0000004E               2931  n_uppercase         EQU         $4E
00002E3D  =0000006E               2932  n_lowercase         EQU         $6E
00002E3D  =00000002               2933  task2               EQU         $02
00002E3D  =00000005               2934  task5               EQU         $05
00002E3D  =00000009               2935  task9               EQU         $09
00002E3D  =0000000D               2936  task13              EQU         $0D
00002E3D  =0000000E               2937  task14              EQU         $0E
00002E3D  =0000F000               2938  first_nibble        EQU         $F000
00002E3D  =00000F00               2939  second_nibble       EQU         $0F00   
00002E3D  =000000F0               2940  third_nibble        EQU         $00F0
00002E3D  =0000000F               2941  fourth_nibble       EQU         $000F
00002E3D  =000000FF               2942  second_half         EQU         $00FF
00002E3D  =000001C0               2943  dst_mode            EQU         $01C0
00002E3D  =00000E00               2944  dst_reg             EQU         $0E00
00002E3D  =00000038               2945  src_mode            EQU         $0038
00002E3D  =00000007               2946  src_reg             EQU         $0007
00002E3D  =00000100               2947  bit8                EQU         $0100
00002E3D                          2948  
00002E3D  =00000000               2949  ea_type_immediate   EQU     0       ; EA Type = immediate
00002E3D  =00000001               2950  ea_type_move        EQU     1       ; EA Type = move
00002E3D  =00000002               2951  ea_type_movea       EQU     2       ; EA Type = movea
00002E3D  =0000000C               2952  ea_type_movea6      EQU     12      ; EA Type = movea * 6
00002E3D  =00000003               2953  ea_type_lea         EQU     3       ; EA Type = lea
00002E3D  =00000004               2954  ea_type_dstonly     EQU     4       ; EA Type = clr, neg, not, jsr, jmp
00002E3D  =00000005               2955  ea_type_ext         EQU     5       ; EA Type = ext, add, adda
00002E3D  =00000006               2956  ea_type_movem       EQU     6       ; EA Type = movem
00002E3D  =00000007               2957  ea_type_shifts      EQU     7       ; EA Type = ASL/ASR/LSL/LSR/ROL/ROR
00002E3D  =00000008               2958  ea_type_quick       EQU     8       ; EA Type = addq, subq
00002E3D  =00000009               2959  ea_type_branch      EQU     9       ; EA Type = bra, bsr, bcc
00002E3D  =00000000               2960  ea_bcc_flag         EQU     0       ; EA Type = branch, flag = bcc
00002E3D  =00000001               2961  ea_dbcc_flag        EQU     1       ; EA Type = branch, flag = dbcc
00002E3D  =00000002               2962  ea_scc_flag         EQU     2       ; EA Type = branch, flag = scc
00002E3D                          2963  
00002E3D= 57 72 6F 6E 67 20 ...   2964  WRONG_SIZE_MESSAGE  DC.B    'Wrong size.',CR,LF,0
00002E4B= 45 52 52 4F 52 3A ...   2965  ABSOLUTE_WRONGREG   DC.B    'ERROR: Register does not exist for Absolute and immediate',CR,LF,0
00002E87= 45 52 52 4F 52 3A ...   2966  EA_TYPE_ERROR       DC.B    'ERROR: EA type is not supported',CR,LF,0
00002EA9= 45 52 52 4F 52 3A ...   2967  DST_INVALID_MSG     DC.B    'ERROR: Destination effective address is invalid',CR,LF,0
00002EDB= 45 52 52 4F 52 3A ...   2968  SRC_INVALID_MSG     DC.B    'ERROR: Source effective address is invalid',CR,LF,0
00002F08= 45 52 52 4F 52 3A ...   2969  EA_INVALID_MSG      DC.B    'ERROR: Invalid addressing mode',CR,LF,0
00002F29= 45 52 52 4F 52 3A ...   2970  OPCODE_INVALID      DC.B    'ERROR: Opcode is invalid',CR,LF,0
00002F44= 45 52 52 4F 52 3A ...   2971  ERROR_MESSAGE       DC.B    'ERROR: The input is invalid',CR,LF,0  
00002F62= 45 52 52 4F 52 3A ...   2972  ODD_ERROR_MESSAGE   DC.B    'ERROR: The last digit of the address is odd, which is invalid',CR,LF,0  
00002FA2                          2973               
00002FA2= 57 65 6C 63 6F 6D ...   2974  WELCOME             DC.B        'Welcome to the 68k Disassembler of Avery and Alan',CR,LF,CR,LF,0
00002FD8                          2975  
00002FD8= 50 6C 65 61 73 65 ...   2976  USER_INST           DC.B        'Please follow the proper input instructions below: ',CR,LF
0000300D= 2D 20 53 74 61 72 ...   2977                      DC.B        '- Starting address must be lower than ending address.',CR,LF
00003044= 2D 20 54 68 65 20 ...   2978                      DC.B        '- The values for the starting and ending address must be an even value.',CR,LF
0000308D= 2D 20 53 74 61 72 ...   2979                      DC.B        '- Starting and ending address must be inputted as hexadecimal value.',CR,LF
000030D3= 2D 20 44 6F 20 6E ...   2980                      DC.B        '- Do not put spaces in between input characters.',CR,LF
00003105= 2D 20 56 61 6C 69 ...   2981                      DC.B        '- Valid characters include: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F',CR,LF,0
00003152                          2982                  
00003152= 50 72 65 73 73 20 ...   2983  ENTER_PROMPT        DC.B        'Press enter to continue...',CR,LF,0
0000316F= 50 72 65 73 73 20 ...   2984  PROMPT_AGAIN        DC.B        'Press Y to continue / N to exit.',CR,LF,0
00003192= 50 72 6F 67 72 61 ...   2985  EXIT_PROMPT         DC.B        'Program has execution has stopped.',CR,LF,0
000031B7= 45 6E 74 65 72 20 ...   2986  PROMPT_V_END        DC.B        'Enter a valid ending address: ',CR,LF,0
000031D8                          2987        
000031D8= 45 6E 74 65 72 20 ...   2988  START_IN            DC.B        'Enter a starting address: ',CR,LF,0 
000031F5= 45 6E 74 65 72 20 ...   2989  END_IN              DC.B        'Enter an ending address: ',CR,LF,0 
00003211                          2990  START_ADDRESS       DS.B        32     
00003231                          2991  END_ADDRESS         DS.B        32 
00003251                          2992       
00003251                          2993      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_IMMEDIATE_ERROR  2DD4
ABSOLUTE_LONG       2D56
ABSOLUTE_WORD       2D4A
ABSOLUTE_WRONGREG   2E4B
ADDQ_EA_CALC        2B7C
ADD_PARENTHESIS     2A92
AND_OR_CHECK        22AE
AN_CHECK            2D9C
AN_FINISH           29D6
ASCII_TO_HEX_LETTER  109A
ASCII_Y_N           2E3C
ATOI                1074
BACK_PARENTHESIS    2A9C
BIT8                100
BRANCH_WORD_CHECK   2C78
BUFFER_SIZE         40
CHANGE_TO_001       20CA
CHANGE_TO_EIGHT     2BBE
CHECK1_BIT_0        267A
CHECK1_BIT_1        2652
CHECK1_BIT_10       24C0
CHECK1_BIT_11       2492
CHECK1_BIT_12       2464
CHECK1_BIT_13       2436
CHECK1_BIT_14       2408
CHECK1_BIT_2        262A
CHECK1_BIT_3        2602
CHECK1_BIT_4        25D4
CHECK1_BIT_5        25A6
CHECK1_BIT_6        2578
CHECK1_BIT_7        254A
CHECK1_BIT_8        251C
CHECK1_BIT_9        24EE
CHECK_BIT_0         2990
CHECK_BIT_1         2968
CHECK_BIT_10        27D8
CHECK_BIT_11        27AA
CHECK_BIT_12        277C
CHECK_BIT_13        274E
CHECK_BIT_14        2720
CHECK_BIT_2         2940
CHECK_BIT_3         2918
CHECK_BIT_4         28EA
CHECK_BIT_5         28BC
CHECK_BIT_6         288E
CHECK_BIT_7         2860
CHECK_BIT_8         2832
CHECK_BIT_9         2806
CHECK_IF_ZERO       2B22
CODE0000            144A
CODE0001            1464
CODE0010            1468
CODE0011            1480
CODE0100            1498
CODE0101            14B2
CODE0110            14B6
CODE0111            1542
CODE1000            1546
CODE1001            1566
CODE1010            156A
CODE1011            156E
CODE1100            1572
CODE1101            158C
CODE1110            15A6
CODE1111            1624
COMPLETE_END        10FC
COMPLETE_START      10F4
CONTINUE_OR_END     1320
CR                  D
D4_AN_SETONE_0      2566
D4_AN_SETONE_1      2594
D4_AN_SETONE_2      25C2
D4_AN_SETONE_3      25F0
D4_AN_SETONE_4      2618
D4_AN_SETONE_5      2640
D4_AN_SETONE_6      2668
D4_AN_SETONE_7      2690
D4_AN_SET_0         284E
D4_AN_SET_1         2822
D4_AN_SET_2         27F4
D4_AN_SET_3         27C6
D4_AN_SET_4         2798
D4_AN_SET_5         276A
D4_AN_SET_6         273C
D4_AN_SET_7         270E
D4_DN_SETONE_0      23F6
D4_DN_SETONE_1      2424
D4_DN_SETONE_2      2452
D4_DN_SETONE_3      2480
D4_DN_SETONE_4      24AE
D4_DN_SETONE_5      24DC
D4_DN_SETONE_6      250A
D4_DN_SETONE_7      2538
D4_DN_SET_0         29A6
D4_DN_SET_1         297E
D4_DN_SET_2         2956
D4_DN_SET_3         292E
D4_DN_SET_4         2906
D4_DN_SET_5         28D8
D4_DN_SET_6         28AA
D4_DN_SET_7         287C
DECODED_BUFFER      5000
DECODE_ERROR        2E04
DECODE_MEMORY       1398
DECODE_PAUSE        130C
DECODING_ITERATION  12E8
DISP_UI             100C
DISP_W              1000
DN_CHECK            2DA6
DN_DST              222A
DN_SRC              2268
DONE                2E38
DONT_CHANGE         2BC2
DO_ITOA_MOVE        2D90
DO_ITOA_OPMODE      2D96
DST_INVALID         2DE4
DST_INVALID_MSG     2EA9
DST_MODE            1C0
DST_REG             E00
EA_ABSOLUTE_AND_IMMEDIATE  2D2E
EA_ADDA             233E
EA_AN               2CD0
EA_AND              22C0
EA_AN_INDIRECT      2CDC
EA_AN_INDIRECT_DEC  2D08
EA_AN_INDIRECT_INC  2CF0
EA_BCC_FLAG         0
EA_BRANCH           2C2E
EA_CLEAR            2104
EA_DBCC_FLAG        1
EA_DN               2CC4
EA_DSTONLY          20E4
EA_EXT              2196
EA_EXT_TABLE        21B2
EA_FINISH           1E12
EA_GEN_SRC          2C86
EA_GEN_TABLE_SRC    2C94
EA_IMMEDIATE        1F36
EA_INVALID_MSG      2F08
EA_JSR              214E
EA_LEA              2066
EA_MEMORY_SHIFTS    2A34
EA_MOVE             1F8E
EA_MOVEA            1FFA
EA_MOVEM            2386
EA_MULS_MULU_DIV    22E8
EA_OPMODE_012456    21E2
EA_OPMODE_37        22D0
EA_OR               22C6
EA_QUICK            2B6C
EA_REGISTER_SHIFTS  2AAA
EA_SCC_FLAG         2
EA_SHIFTS           29EA
EA_SHIFTS_TABLE     2A04
EA_SIZE_ADDA        1EEC
EA_SIZE_B           1F14
EA_SIZE_DONE        1F34
EA_SIZE_GENERAL     1E58
EA_SIZE_L           1F2A
EA_SIZE_MEMORY_SHIFTS  1F00
EA_SIZE_MOVE        1E74
EA_SIZE_MOVEA       1E90
EA_SIZE_MOVEM       1EA4
EA_SIZE_OPMODE_012456  1EB8
EA_SIZE_W           1F1E
EA_SIZE_W_MEMORY    1F28
EA_START            1E00
EA_TYPE_BRANCH      9
EA_TYPE_DSTONLY     4
EA_TYPE_ERROR       2E87
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_SHIFTS      7
EA_TYPE_TABLE       1E18
EA_UNSUPPORTED      2D20
EA_WRONG_SIZE       2DC4
END_ADDRESS         3231
END_IN              31F5
ENTER_PROMPT        3152
ERROR_MESSAGE       2F44
EXIT                1388
EXIT_PROMPT         3192
FINISH_MOVEM_MEM_TO_REG  29B8
FINISH_REG_TO_MEM   26A2
FIRST_NIBBLE        F000
FOURTH_NIBBLE       F
FOURTH_NIBBLE_CHECK  2C62
FRONT_FORMAT        2A84
IMMEDIATE           2D62
IMMEDIATE_CHECK     2DB0
IMMEDIATE_EIGHT     2B2C
IMMEDIATE_SRC       2ADE
INPUT_INVALID       10BC
ITOA                1132
ITOA_BYTE           11BA
ITOA_BYTE_BRANCH    11C8
ITOA_BYTE_CONVERT   12A4
ITOA_CONVERT_A_TO_F  12D4
ITOA_DONE           12E0
ITOA_LONG           123A
ITOA_LONGADDRESS    126C
ITOA_MOVE           1154
ITOA_NIBBLE_CONVERT  12C4
ITOA_OPMODE         1176
ITOA_WORD           11DA
ITOA_WORD_BRANCH    11F6
ITOA_WORD_ERROR     1218
JSR_EA_VALID        218C
JSR_NOP_RTS         186E
LAST_DIGIT_CHECK    10DA
LAST_DIGIT_ODD      1116
LEA_SRC_VALID       20A4
LF                  A
LINES_P_SCREEN      1E
MEMORY_1110_LEFT    15DC
MEMORY_1110_RIGHT   1600
MEM_TO_REG          26C8
MEM_TO_REG_CONTINUE  26F0
MOVEA_DST_VALID     205C
MOVEQ_EA_CALC       2BEC
NOP_CHECK           189C
NOP_CHECK_THREE     18CC
NOP_CHECK_TWO       18B4
NORMAL_FINISH       29E4
N_LOWERCASE         6E
N_UPPERCASE         4E
ODD_ERROR_MESSAGE   2F62
OPCODE_INVALID      2F29
OP_0000_TABLE       1628
OP_0100_TABLE       1688
OP_1100_TABLE       16E8
OP_1101_TABLE       1748
OP_1110_TABLE_REGISTER  17A8
OP_ADD              1D1C
OP_ADDA             1D38
OP_ADDI             1950
OP_ADDQ             1A4C
OP_AND              1D00
OP_ASL              1D74
OP_ASR              1D58
OP_AS_CHECK         1808
OP_BCC              1ADC
OP_BCS              1AF8
OP_BEQ              1B30
OP_BGE              1BBC
OP_BGT              1BF4
OP_BHI              1AA4
OP_BLE              1C10
OP_BLS              1AC0
OP_BLT              1BD8
OP_BMI              1BA0
OP_BNE              1B14
OP_BPL              1B84
OP_BRA              1A6C
OP_BSR              1A88
OP_BVC              1B4C
OP_BVS              1B68
OP_CLEAR_DATA       13D4
OP_CLEAR_DATA_LOOP  13E0
OP_CLR              19B4
OP_CMP              1CA4
OP_DIVU             1C50
OP_FINISH           13CE
OP_JSR              19F0
OP_LEA              1A30
OP_LSL              1DAC
OP_LSR              1D90
OP_LS_CHECK         182A
OP_MOVE             1994
OP_MOVEA            1970
OP_MOVEM            1A0C
OP_MOVEQ            1C2C
OP_MULS             1CE0
OP_MULU             1CC0
OP_NOP              19D0
OP_OR               1C70
OP_ROL              1DE4
OP_ROR              1DC8
OP_RO_CHECK         184C
OP_RTS              19E0
OP_SUB              1C88
OP_SUBI             1930
OP_TABLE            13EA
OP_UNSUPPORTED      192C
PRINT1_A0           256E
PRINT1_A1           259C
PRINT1_A2           25CA
PRINT1_A3           25F8
PRINT1_A4           2620
PRINT1_A5           2648
PRINT1_A6           2670
PRINT1_A7           2698
PRINT1_D0           23FE
PRINT1_D1           242C
PRINT1_D2           245A
PRINT1_D3           2488
PRINT1_D4           24B6
PRINT1_D5           24E4
PRINT1_D6           2512
PRINT1_D7           2540
PRINT_A0            2856
PRINT_A1            2828
PRINT_A2            27FC
PRINT_A3            27CE
PRINT_A4            27A0
PRINT_A5            2772
PRINT_A6            2744
PRINT_A7            2716
PRINT_D0            29AE
PRINT_D1            2986
PRINT_D2            295E
PRINT_D3            2936
PRINT_D4            290E
PRINT_D5            28E0
PRINT_D6            28B2
PRINT_D7            2884
PROMPT_AGAIN        316F
PROMPT_END          1040
PROMPT_START        1018
PROMPT_VA_END       1052
PROMPT_V_END        31B7
READ_END            1060
READ_START          102C
REGISTER_CHECK      2DBA
REGISTER_SRC        2B32
REG_TO_MEM          23D8
RIGHT12             C
RIGHT16             10
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT6              6
RIGHT8              8
RIGHT9              9
RTS_CHECK           18E4
RTS_CHECK_THREE     1914
RTS_CHECK_TWO       18FC
SECOND_HALF         FF
SECOND_NIBBLE       F00
SRC_INVALID         2DF4
SRC_INVALID_MSG     2EDB
SRC_MODE            38
SRC_REG             7
STACK               A000
START               1000
START_ADDRESS       3211
START_DECODING      12E6
START_IN            31D8
TASK13              D
TASK14              E
TASK2               2
TASK5               5
TASK9               9
THIRD_NIBBLE        F0
USER_INST           2FD8
VALIDATE_END        1070
VALIDATE_START      103C
WELCOME             2FA2
WRONG_SIZE_MESSAGE  2E3D
Y_LOWERCASE         79
Y_UPPERCASE         59
