00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/9/2020 4:03:23 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Disassembler for the Motorola MC68000 Microprocessor
00000000                             3  * Written by :  Avery Mortenson & Alan Luu
00000000                             4  * Date       :  2/12/2020
00000000                             5  * Description:  An inverse assembler (disassembler) that will 
00000000                             6  * convert a memory image of instructions and data back 
00000000                             7  * to the MC68000 assembly code and that will output the 
00000000                             8  * disassembled code to the display.
00000000                             9  *-----------------------------------------------------------
00001000                            10      ORG    $1000
00001000                            11  START:            
00001000                            12  *------------------------------------------------------------*
00001000                            13  * D0: used for the tasks
00001000                            14  * D1: used to hold the size of the input obtained. 
00001000                            15  * D5: used to store the starting and ending address 
00001000                            16  * temporarily before moving them to A4 and A6 correspondingly. 
00001000                            17  * D6: used to check the last digit to see if the input 
00001000                            18  * for the starting and ending address causes a bus error. 
00001000                            19  * A1: a pointer to the message to print out. 
00001000                            20  *------------------------------------------------------------*
00001000  103C 000E                 21  DISP_W      MOVE.B  #14,D0                  ; Display Welcome Message. 
00001004  43F9 00002F4A             22              LEA     WELCOME,A1
0000100A  4E4F                      23              TRAP    #15
0000100C                            24  
0000100C                            25  * Put program code here
0000100C                            26  
0000100C  103C 000E                 27  DISP_UI         MOVE.B  #14,D0              ; Display User Instructions. 
00001010  43F9 00002F80             28                  LEA     USER_INST,A1
00001016  4E4F                      29                  TRAP    #15    
00001018                            30  
00001018  4FF9 0000A000             31  PROMPT_START    LEA     stack, SP           ; SP = stack ($A0000)
0000101E  43F9 0000315F             32                  LEA     START_IN,A1         ; Display starting address message
00001024  103C 000E                 33                  MOVE.B  #14,D0
00001028  4E4F                      34                  TRAP    #15       
0000102A                            35       
0000102A  43F9 00003198             36  READ_START      LEA     START_ADDRESS,A1    ; Store user's starting address input
00001030  103C 0002                 37                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001034  4E4F                      38                  TRAP    #15
00001036  1C3C 0000                 39                  MOVE.B  #0,D6               ; Used to indicate we are at start address
0000103A                            40  
0000103A  6000 0022                 41  VALIDATE_START  BRA     ATOI
0000103E                            42  
0000103E  43F9 0000317C             43  PROMPT_END      LEA     END_IN,A1           ; Display starting address message
00001044  103C 000E                 44                  MOVE.B  #14,D0
00001048  4E4F                      45                  TRAP    #15            
0000104A  43F9 000031B8             46  READ_END        LEA     END_ADDRESS,A1      ; Store user's starting address input
00001050  103C 0002                 47                  MOVE.B  #2,D0               ; Read user's input into A1; length is stored into D1
00001054  4E4F                      48                  TRAP    #15
00001056  1C3C 0001                 49                  MOVE.B  #1,D6               ; Used to indicate we are at end address
0000105A                            50  
0000105A  6000 0002                 51  VALIDATE_END    BRA     ATOI
0000105E                            52                 
0000105E                            53  * D0 stores the value to pushed from A1.
0000105E                            54  
0000105E  1019                      55  ATOI            MOVE.B  (A1)+,D0    ; Move to next character in A1 and store in D0          
00001060  B03C 0030                 56                  CMP.B   #$30,D0
00001064  6D00 0040                 57                  BLT     INPUT_INVALID
00001068  B03C 0039                 58                  CMP.B   #$39,D0
0000106C  6E00 0016                 59                  BGT     ASCII_TO_HEX_LETTER
00001070  0400 0030                 60                  SUB.B   #$30,D0     ; Subtract by 30 to get the numbers 0-9
00001074  DA80                      61                  ADD.L   D0,D5
00001076  5341                      62                  SUBI    #1,D1       ; Decrement input's length to move to next character          
00001078  B23C 0000                 63                  CMP.B   #0,D1       ; Compare to see if we're at the last digit
0000107C  6700 0046                 64                  BEQ     LAST_DIGIT_CHECK
00001080  E98D                      65                  LSL.L   #4,D5
00001082  60DA                      66                  BRA     ATOI
00001084                            67  
00001084                            68    
00001084  B03C 0041                 69  ASCII_TO_HEX_LETTER     CMP.B   #$41,D0
00001088  6D00 001C                 70                          BLT     INPUT_INVALID
0000108C  B03C 0046                 71                          CMP.B   #$46, D0
00001090  6E00 0014                 72                          BGT     INPUT_INVALID 
00001094  0400 0031                 73                          SUB.B   #$31,D0     ; Subtract by 31 to get the numbers A-F
00001098  5D00                      74                          SUB.B   #6,D0
0000109A  DA80                      75                          ADD.L   D0,D5
0000109C  5341                      76                          SUBI    #1,D1
0000109E  6700 0024                 77                          BEQ     LAST_DIGIT_CHECK
000010A2  E98D                      78                          LSL.L   #4,D5
000010A4  60B8                      79                          BRA     ATOI     
000010A6                            80  
000010A6                            81                      
000010A6  43F9 00002EEC             82  INPUT_INVALID   LEA     ERROR_MESSAGE, A1   ; Display error message
000010AC  103C 000E                 83                  MOVE.B  #14, D0
000010B0  4E4F                      84                  TRAP    #15
000010B2  4206                      85                  CLR.B   D6
000010B4                            86                  
000010B4  BC3C 0000                 87                  CMP.B   #0,D6           ; When D6 is 0
000010B8  6700 FF5E                 88                  BEQ     PROMPT_START    ; Go back to start prompt
000010BC  BC3C 0001                 89                  CMP.B   #1,D6           ; When D6 is 1
000010C0  6700 FF7C                 90                  BEQ     PROMPT_END      ; Go back to end prompt
000010C4                            91  
000010C4                            92                            
000010C4  2E05                      93  LAST_DIGIT_CHECK    MOVE.L  D5, D7          ; D7 used as temporary storage
000010C6  E20F                      94                      LSR.B   #1, D7          ; Check for carry bit to see if last digit is odd
000010C8  6500 002E                 95                      BCS     LAST_DIGIT_ODD  ; branch when there is a carry; this indicates odd last digit 
000010CC  4287                      96                      CLR.L   D7
000010CE  BC3C 0000                 97                      CMP.B   #0,D6
000010D2  6700 000A                 98                      BEQ     COMPLETE_START  
000010D6  BC3C 0001                 99                      CMP.B   #1,D6
000010DA  6700 000A                100                      BEQ     COMPLETE_END
000010DE                           101  
000010DE  2845                     102  COMPLETE_START      MOVEA.L D5, A4  ; A4 holds the starting address
000010E0  4285                     103                      CLR.L   D5 
000010E2  6000 FF5A                104                      BRA PROMPT_END
000010E6                           105  
000010E6  2C45                     106  COMPLETE_END        MOVEA.L D5, A6  ; A6 holds the ending address
000010E8  2A4C                     107                      MOVEA.L A4, A5  ; Store starting address into current address
000010EA                           108                      
000010EA                           109                      *Clear the data and address registers used to obtain the starting and ending address 
000010EA  4280                     110                      CLR.L   D0
000010EC  4285                     111                      CLR.L   D5
000010EE  4286                     112                      CLR.L   D6
000010F0  327C 0000                113                      MOVEA   #0, A1
000010F4  6000 01B0                114                      BRA     START_DECODING  ; All inputs are valid, go to the decode process
000010F8                           115                      
000010F8  43F9 00002F0A            116  LAST_DIGIT_ODD      LEA     ODD_ERROR_MESSAGE, A1 
000010FE  103C 000E                117                      MOVE.B  #14, D0
00001102  4E4F                     118                      TRAP    #15
00001104                           119                      
00001104  BC3C 0000                120                      CMP.B   #0,D6           ; When D6 is 0
00001108  6700 FF0E                121                      BEQ     PROMPT_START    ; Go back to start prompt
0000110C  BC3C 0001                122                      CMP.B   #1,D6           ; When D6 is 1
00001110  6700 FF2C                123                      BEQ     PROMPT_END      ; Go back to end prompt
00001114                           124  *--------------------------------------------------------------------------------------
00001114                           125  * param D2 data size to convert into ASCII
00001114                           126  * param A2 a pointer to decode_buf
00001114                           127  * param A5 the current address
00001114                           128  * itoa (D2, A2, A5) {
00001114                           129  * D0 byte data in ACII
00001114                           130  * D1 #sfhit
00001114                           131  * D7 long data to convert into ASCII
00001114                           132  * }
00001114                           133          
00001114                           134  ITOA                                ; convert integer to ASCII  
00001114  48E7 C000                135          MOVEM.L D0-D1,-(SP) 
00001118  B43C 0000                136          CMP.B   #%00, D2            ; byte
0000111C  6700 007E                137          BEQ     ITOA_BYTE
00001120  B43C 0001                138          CMP.B   #%01, D2            ; word
00001124  6700 0096                139          BEQ     ITOA_WORD
00001128  B43C 0002                140          CMP.B   #%10, D2            ; long
0000112C  6700 00CC                141          BEQ     ITOA_LONG
00001130  4EF9 0000122C            142          JMP     ITOA_LONGADDRESS    ; long address
00001136                           143          
00001136                           144  ITOA_MOVE                           ; convert integer to ASCII
00001136  48E7 C000                145          MOVEM.L D0-D1,-(SP) 
0000113A  B43C 0001                146          CMP.B   #%01, D2            ; byte
0000113E  6700 005C                147          BEQ     ITOA_BYTE
00001142  B43C 0003                148          CMP.B   #%11, D2            ; word
00001146  6700 0074                149          BEQ     ITOA_WORD
0000114A  B43C 0002                150          CMP.B   #%10,D2             ; long
0000114E  6700 00AA                151          BEQ     ITOA_LONG
00001152  4EF9 0000122C            152          JMP     ITOA_LONGADDRESS    ; long address
00001158                           153          
00001158                           154  ITOA_OPMODE                         ; convert integer to ASCII
00001158  48E7 C000                155          MOVEM.L D0-D1,-(SP) 
0000115C  B43C 0000                156          CMP.B   #%000,D2            ; When 0 then byte
00001160  6700 003A                157          BEQ     ITOA_BYTE
00001164  B43C 0004                158          CMP.B   #%100,D2            ; When 4 then byte
00001168  6700 0032                159          BEQ     ITOA_BYTE 
0000116C  B43C 0001                160          CMP.B   #%001,D2            ; When 1 then word
00001170  6700 004A                161          BEQ     ITOA_WORD
00001174  B43C 0003                162          CMP.B   #%011,D2            ; When 3 then word
00001178  6700 0042                163          BEQ     ITOA_WORD
0000117C  B43C 0005                164          CMP.B   #%101,D2            ; When 5 then word
00001180  6700 003A                165          BEQ     ITOA_WORD 
00001184  B43C 0002                166          CMP.B   #%010,D2            ; When 2 then long
00001188  6700 0070                167          BEQ     ITOA_LONG
0000118C  B43C 0006                168          CMP.B   #%110,D2            ; When 6 then long
00001190  6700 0068                169          BEQ     ITOA_LONG
00001194  B43C 0007                170          CMP.B   #%111,D2            ; When 7 then long
00001198  6700 0060                171          BEQ     ITOA_LONG
0000119C                           172          
0000119C                           173  ITOA_BYTE
0000119C  3E1D                     174          MOVE.W  (A5)+,D7
0000119E  4EB9 00001264            175          JSR     ITOA_BYTE_CONVERT
000011A4  4EF9 000012A0            176          JMP     ITOA_DONE
000011AA                           177  
000011AA                           178  ITOA_BYTE_BRANCH
000011AA  48E7 C000                179          MOVEM.L D0-D1,-(SP)
000011AE  3E05                     180          MOVE.W  D5,D7
000011B0  4EB9 00001264            181          JSR     ITOA_BYTE_CONVERT
000011B6  4EF9 000012A0            182          JMP     ITOA_DONE
000011BC                           183          
000011BC                           184  ITOA_WORD
000011BC  3E15                     185          MOVE.W  (A5),D7
000011BE  123C 0008                186          MOVE.B  #right8, D1
000011C2  E26F                     187          LSR.W   D1,D7
000011C4  4EB9 00001264            188          JSR     ITOA_BYTE_CONVERT
000011CA  3E1D                     189          MOVE.W  (A5)+, D7
000011CC  4EB9 00001264            190          JSR     ITOA_BYTE_CONVERT
000011D2  4EF9 000012A0            191          JMP     ITOA_DONE
000011D8                           192          
000011D8                           193  ITOA_WORD_BRANCH
000011D8  48E7 C000                194          MOVEM.L D0-D1,-(SP) 
000011DC  3E05                     195          MOVE.W  D5,D7
000011DE  123C 0008                196          MOVE.B  #right8, D1
000011E2  E26F                     197          LSR.W   D1,D7
000011E4  4EB9 00001264            198          JSR     ITOA_BYTE_CONVERT
000011EA  3E05                     199          MOVE.W  D5, D7
000011EC  361D                     200          MOVE.W  (A5)+, D3
000011EE  4EB9 00001264            201          JSR     ITOA_BYTE_CONVERT
000011F4  4EF9 000012A0            202          JMP     ITOA_DONE
000011FA                           203          
000011FA                           204  ITOA_LONG
000011FA  3E15                     205          MOVE.W  (A5),D7
000011FC  123C 0008                206          MOVE.B  #right8, D1
00001200  E26F                     207          LSR.W   D1, D7
00001202  4EB9 00001264            208          JSR     ITOA_BYTE_CONVERT
00001208  3E1D                     209          MOVE.W  (A5)+, D7
0000120A  4EB9 00001264            210          JSR     ITOA_BYTE_CONVERT
00001210                           211          
00001210  3E15                     212          MOVE.W  (A5),D7
00001212  123C 0008                213          MOVE.B  #right8, D1
00001216  E26F                     214          LSR.W   D1, D7
00001218  4EB9 00001264            215          JSR     ITOA_BYTE_CONVERT
0000121E  3E1D                     216          MOVE.W  (A5)+, D7
00001220  4EB9 00001264            217          JSR     ITOA_BYTE_CONVERT
00001226  4EF9 000012A0            218          JMP     ITOA_DONE
0000122C                           219  
0000122C                           220  ITOA_LONGADDRESS
0000122C  3E0D                     221          MOVE.W  A5,D7
0000122E  123C 0018                222          MOVE.B  #right24,D1
00001232  E26F                     223          LSR.W   D1,D7
00001234  4EB9 00001264            224          JSR     ITOA_BYTE_CONVERT
0000123A  3E0D                     225          MOVE.W  A5,D7
0000123C  123C 0010                226          MOVE.B  #right16,D1
00001240  E26F                     227          LSR.W   D1,D7
00001242  4EB9 00001264            228          JSR     ITOA_BYTE_CONVERT
00001248  3E0D                     229          MOVE.W  A5,D7
0000124A  123C 0008                230          MOVE.B  #right8,D1
0000124E  E26F                     231          LSR.W   D1,D7
00001250  4EB9 00001264            232          JSR     ITOA_BYTE_CONVERT
00001256  3E0D                     233          MOVE.W  A5,D7
00001258  4EB9 00001264            234          JSR     ITOA_BYTE_CONVERT   
0000125E  4EF9 000012A0            235          JMP     ITOA_DONE   
00001264                           236  
00001264                           237  ITOA_BYTE_CONVERT
00001264  3007                     238          MOVE.W  D7, D0 
00001266  0240 00F0                239          ANDI.W  #$F0, D0
0000126A  123C 0004                240          MOVE.B  #right4, D1
0000126E  E268                     241          LSR.W   D1, D0
00001270  4EB9 00001284            242          JSR     ITOA_NIBBLE_CONVERT
00001276                           243          
00001276  3007                     244          MOVE.W  D7, D0
00001278  0240 000F                245          ANDI.W  #$0F, D0
0000127C  4EB9 00001284            246          JSR     ITOA_NIBBLE_CONVERT
00001282  4E75                     247          RTS
00001284                           248          
00001284                           249  ITOA_NIBBLE_CONVERT
00001284  B03C 0009                250          CMP.B   #9, D0
00001288  6E00 000A                251          BGT     ITOA_CONVERT_A_TO_F
0000128C  0600 0030                252          ADD.B   #$30, D0
00001290  14C0                     253          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
00001292  4E75                     254          RTS
00001294                           255          
00001294                           256  ITOA_CONVERT_A_TO_F
00001294  0400 000A                257          SUBI.B  #10, D0
00001298  0600 0041                258          ADDI.B  #$41, D0
0000129C  14C0                     259          MOVE.B  D0, (A2)+   ; store D0 into decode buffer
0000129E  4E75                     260          RTS
000012A0                           261  
000012A0                           262  ITOA_DONE
000012A0  4CDF 0003                263          MOVEM.L (SP)+, D0-D1
000012A4  4E75                     264          RTS
000012A6                           265  *-------------------------------------------------------------------------------*
000012A6                           266  START_DECODING
000012A6  4282                     267          CLR.L   D2
000012A8                           268          
000012A8                           269  DECODING_ITERATION
000012A8                           270          ;decoding the current address
000012A8  4EB9 00001358            271          JSR     DECODE_MEMORY
000012AE  103C 000D                272          MOVE.B  #task13, D0
000012B2  43F9 00005000            273          LEA     decoded_buffer, A1
000012B8  4E4F                     274          TRAP    #15
000012BA                           275          
000012BA                           276          ;check if decoding has finished or if the screen is filled 
000012BA  BDCD                     277          CMP.L   A5, A6
000012BC  6F00 0022                278          BLE     CONTINUE_OR_END     ; If A6-A5 <= 0, go to CONTINUE_OR_END 
000012C0                           279          
000012C0                           280          ;have yet to reach the ending address
000012C0  5202                     281          ADDQ.B  #1, D2              ; D2 (screen_line_counter)++
000012C2  B43C 0014                282          CMP.B   #lines_p_screen, D2
000012C6  6C00 0004                283          BGE     DECODE_PAUSE
000012CA                           284          ;not yet reached the maximum lines per screen. 
000012CA  60DC                     285          BRA     DECODING_ITERATION
000012CC                           286  
000012CC                           287  DECODE_PAUSE
000012CC  103C 000E                288          MOVE.B  #task14, D0
000012D0  43F9 000030FA            289          LEA     ENTER_PROMPT, A1
000012D6  4E4F                     290          TRAP    #15
000012D8  103C 0005                291          MOVE.B  #task5, D0
000012DC  4E4F                     292          TRAP    #15
000012DE  60C6                     293          BRA     START_DECODING
000012E0                           294  
000012E0                           295  CONTINUE_OR_END
000012E0  4280                     296          CLR.L   D0
000012E2  4281                     297          CLR.L   D1
000012E4  4282                     298          CLR.L   D2
000012E6  4283                     299          CLR.L   D3
000012E8  4284                     300          CLR.L   D4
000012EA  4285                     301          CLR.L   D5
000012EC  4286                     302          CLR.L   D6
000012EE  4287                     303          CLR.L   D7
000012F0  327C 0000                304          MOVEA   #0,A1
000012F4  347C 0000                305          MOVEA   #0,A2
000012F8  367C 0000                306          MOVEA   #0,A3
000012FC  387C 0000                307          MOVEA   #0,A4
00001300  3A7C 0000                308          MOVEA   #0,A5
00001304  3C7C 0000                309          MOVEA   #0,A6
00001308                           310  
00001308  103C 000E                311          MOVE.B  #task14, D0
0000130C  43F9 00003117            312          LEA     PROMPT_AGAIN, A1
00001312  4E4F                     313          TRAP    #15
00001314                           314          
00001314  103C 0002                315          MOVE.B  #task2, D0
00001318  43F9 00002DE4            316          LEA     ascii_y_n, A1
0000131E  4E4F                     317          TRAP    #15
00001320                           318          
00001320  1639 00002DE4            319          MOVE.B  ascii_y_n, D3
00001326  0C03 0059                320          CMPI.B  #y_uppercase, D3
0000132A  6700 FCEC                321          BEQ     PROMPT_START
0000132E  0C03 0079                322          CMPI.B  #y_lowercase, D3
00001332  6700 FCE4                323          BEQ     PROMPT_START
00001336  0C03 004E                324          CMPI.B  #n_uppercase, D3
0000133A  6700 000C                325          BEQ     EXIT
0000133E  0C03 006E                326          CMPI.B  #n_lowercase, D3
00001342  6700 0004                327          BEQ     EXIT
00001346  6098                     328          BRA     CONTINUE_OR_END 
00001348                           329          
00001348                           330  EXIT
00001348  103C 000E                331          MOVE.B  #task14, D0
0000134C  43F9 0000313A            332          LEA     EXIT_PROMPT, A1
00001352  4E4F                     333          TRAP    #15  
00001354  6000 1A8A                334          BRA     DONE             
00001358                           335  *---------------------------------------------------------------------------------*
00001358                           336  * D0: the current instruction. 
00001358                           337  * D1: used as temp storage
00001358                           338  * D2: data size 
00001358                           339  * D3: loop counter for the amount of lines per screen. 
00001358                           340  * D4: 
00001358                           341  * D5: #shifts
00001358                           342  * D6: store first nibble
00001358                           343  * D7: 
00001358                           344  * A0: 
00001358                           345  * A1: A pointer to the message to print out. 
00001358                           346  * A2: A pointer to the decode_buffer. 
00001358                           347  * A3: 
00001358                           348  * A4: Store the starting address and increment to the ending address. 
00001358                           349  * A5: The current address. 
00001358                           350  * A6: Store the ending address. 
00001358                           351  * A7: Stack pointer. 
00001358                           352  *---------------------------------------------------------------------------------*                             
00001358                           353  DECODE_MEMORY       
00001358  48E7 2002                354          MOVEM.L D2/A6, -(SP)
0000135C                           355                  
0000135C                           356          ;zero clear the decode_buffer
0000135C  4EB9 00001394            357          JSR     OP_CLEAR_DATA
00001362  45F9 00005000            358          LEA     decoded_buffer, A2  Load decode buffer into A2
00001368                           359                  
00001368                           360          ;print out the current address
00001368  7403                     361          MOVE.L  #$0003, D2
0000136A  4EB8 1114                362          JSR      ITOA
0000136E                           363          
0000136E  14FC 0009                364          MOVE.B  #$9, (A2)+  ; Add space after long address
00001372                           365                  
00001372                           366          ;load the next instruction and jump to the opcode table entry
00001372  41F9 000013AA            367          LEA     OP_TABLE, A0
00001378  4280                     368          CLR.L   D0
0000137A  301D                     369          MOVE.W  (A5)+, D0       ; Store A5's value into D0, then increment A5
0000137C  2200                     370          MOVE.L  D0, D1          ; Store A5's value from D0 into D1
0000137E  1A3C 000C                371          MOVE.B  #right12, D5    ; Store 12 into D5
00001382  EA69                     372          LSR.W   D5, D1          ; Shift first nibble into LSB position
00001384  2C01                     373          MOVE.L  D1, D6          ; Store first nibble into D6
00001386  C2FC 0006                374          MULU    #6, D1          ; Multiply 6 to D1
0000138A  4EF0 1000                375          JMP     0(A0, D1)       ; Go to displacement (A0 + D1 * 6)      
0000138E                           376  OP_FINISH
0000138E  4CDF 4004                377          MOVEM.L (SP)+, D2/A6,
00001392  4E75                     378          RTS
00001394                           379  *------------------------------------------------------------------------------------*
00001394                           380  *Clear the 32 bits within the decoded_buffer       
00001394                           381  OP_CLEAR_DATA
00001394  4283                     382          CLR.L   D3
00001396  163C 0040                383          MOVE.B  #buffer_size, D3
0000139A  45F9 00005000            384          LEA     decoded_buffer, A2
000013A0                           385          
000013A0                           386  OP_CLEAR_DATA_LOOP
000013A0  14FC 0000                387          MOVE.B  #0, (A2)+
000013A4  5343                     388          SUBI    #1, D3
000013A6  6EF8                     389          BGT     OP_CLEAR_DATA_LOOP
000013A8  4E75                     390          RTS
000013AA                           391  
000013AA                           392  *------------------------------------------------------------------------------------*
000013AA                           393  OP_TABLE
000013AA  4EF9 0000140A            394          JMP     code0000    ; ADDI.bwl/ ANDI.bwl / CMPI.bwl / EORI.bwl / ORI.bwl / SUBI.bwl 
000013B0  4EF9 00001424            395          JMP     code0001    ; MOVE.b
000013B6  4EF9 00001428            396          JMP     code0010    ; MOVE.l / MOVEA.l
000013BC  4EF9 00001440            397          JMP     code0011    ; MOVE.w / MOVEA.w
000013C2  4EF9 00001458            398          JMP     code0100    ; CLR.bwl / JMP / JSR / LEA / MOVEM.wl / NOP / NOT.bwl / RTS / STOP / TRAP
000013C8  4EF9 00001472            399          JMP     code0101    ; ADDQ.bwl / SUBQ.bwl / Scc / Dbcc
000013CE  4EF9 00001476            400          JMP     code0110    ; BRA.bw / BSR.bw / Bcc.bw
000013D4  4EF9 00001502            401          JMP     code0111    ; MOVEQ
000013DA  4EF9 00001506            402          JMP     code1000    ; DIVS / DIVU / CR.bwl
000013E0  4EF9 00001526            403          JMP     code1001    ; SUB.bwl / SUBA.wl
000013E6  4EF9 0000152A            404          JMP     code1010    ;   [unassigned]
000013EC  4EF9 0000152E            405          JMP     code1011    ; CMP.bwl / CMPA.wl / EOR.bwl
000013F2  4EF9 00001532            406          JMP     code1100    ; MULS / MULU / AND.bwl
000013F8  4EF9 0000154C            407          JMP     code1101    ; ADD.bwl / ADDA.wl / ADDX.bwl
000013FE  4EF9 00001566            408          JMP     code1110    ; ASL.bwl / ASR.bwl / LSL.bwl / LSR.bwl / ROR.bwl / ROL.bwl
00001404  4EF9 000015E4            409          JMP     code1111    ;   [unassigned]
0000140A                           410          
0000140A                           411  code0000                            ; Opcodes ADDI and SUBI
0000140A  2200                     412          MOVE.L  D0,D1               ; D0 is current instruction word
0000140C  0241 0F00                413          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
00001410  1A3C 0008                414          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001414  EA69                     415          LSR.W   D5,D1               ; Shift nibble into LSB position
00001416  C2FC 0006                416          MULU    #6, D1              ; Set displacement 
0000141A  41F9 000015E8            417          LEA     OP_0000_TABLE,A0    ; Load table into A0
00001420  4EF0 1000                418          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00001424                           419  
00001424                           420  code0001                            ; Opcode MOVE.B
00001424  6000 053A                421          BRA     OP_MOVE             ; Go to opcode MOVE
00001428                           422  
00001428                           423  code0010                            ; Opcodes MOVE.L and MOVEA.L 
00001428  2200                     424          MOVE.L  D0,D1               ; D0 is current instruction word
0000142A  0241 01C0                425          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000142E  1A3C 0006                426          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001432  EA69                     427          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001434  B23C 0001                428          CMP.B   #1, D1              ; When 001 in destination mode
00001438  6700 0502                429          BEQ     OP_MOVEA            ; Go to opcode MOVEA
0000143C  6000 0522                430          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001440                           431  
00001440                           432  code0011                            ; Opcodes MOVE.W and MOVEA.W 
00001440  2200                     433          MOVE.L  D0,D1               ; D0 is current instruction word
00001442  0241 01C0                434          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001446  1A3C 0006                435          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000144A  EA69                     436          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000144C  B23C 0001                437          CMP.B   #1, D1              ; When 001 in destination mode
00001450  6700 04EA                438          BEQ     OP_MOVEA            ; Go to opcode MOVEA
00001454  6000 050A                439          BRA     OP_MOVE             ; Otherwise, go to opcode MOVE
00001458                           440  
00001458                           441  code0100                            ; Opcodes CLR, JSR, LEA, MOVEM, NOP, RTS
00001458  2200                     442          MOVE.L  D0,D1               ; D0 is current instruction word
0000145A  0241 0F00                443          ANDI.W  #second_nibble,D1   ; Extract 2nd nibble from instruction word
0000145E  1A3C 0008                444          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001462  EA69                     445          LSR.W   D5,D1               ; Shift nibble into LSB position
00001464  C2FC 0006                446          MULU    #6, D1              ; Set displacement 
00001468  41F9 00001648            447          LEA     OP_0100_TABLE,A0    ; Load table into A0
0000146E  4EF0 1000                448          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
00001472                           449  
00001472                           450  code0101                            ; Opcode ADDQ.B/W/L
00001472  6000 05A4                451          BRA     OP_ADDQ             ; Go to opcode ADDQ
00001476                           452  
00001476                           453  code0110                            ; Opcodes BRA / BSR / BHI
00001476  2200                     454          MOVE.L  D0,D1               ; D0 is current instruction word
00001478  0241 0F00                455          ANDI.W  #second_nibble,D1   ; Extract 2nd 4 bits from instruction word
0000147C  1A3C 0008                456          MOVE.B  #right8,D5          ; Used to shift 8 times to right
00001480  EA69                     457          LSR.W   D5,D1               ; Shift nibble into LSB position
00001482  B23C 0000                458          CMP.B   #0, D1              ; When 0000 in second nibble 
00001486  6700 05B0                459          BEQ     OP_BRA              ; Go to opcode BRA
0000148A  B23C 0001                460          CMP.B   #1, D1              ; When 0001 in second nibble 
0000148E  6700 05C4                461          BEQ     OP_BSR              ; Go to opcode BSR
00001492  B23C 0002                462          CMP.B   #2, D1              ; When 0010 in second nibble 
00001496  6700 05D8                463          BEQ     OP_BHI              ; Go to opcode BHI
0000149A  B23C 0003                464          CMP.B   #3, D1              ; When 0011 in second nibble
0000149E  6700 05EC                465          BEQ     OP_BLS              ; Go to opcode BLS
000014A2  B23C 0004                466          CMP.B   #4, D1              ; When 0100 in second nibble
000014A6  6700 0600                467          BEQ     OP_BCC              ; Go to opcode BCC
000014AA  B23C 0005                468          CMP.B   #5, D1              ; When 0101 in second nibble
000014AE  6700 0614                469          BEQ     OP_BCS              ; Go to opcode BCS
000014B2  B23C 0006                470          CMP.B   #6, D1              ; When 0110 in second nibble
000014B6  6700 0628                471          BEQ     OP_BNE              ; Go to opcode BNE
000014BA  B23C 0007                472          CMP.B   #7, D1              ; When 0111 in second nibble
000014BE  6700 063C                473          BEQ     OP_BEQ              ; Go to opcode BEQ
000014C2  B23C 0008                474          CMP.B   #8, D1              ; When 1000 in second nibble
000014C6  6700 0650                475          BEQ     OP_BVC              ; Go to opcode BVC
000014CA  B23C 0009                476          CMP.B   #9, D1              ; When 1001 in second nibble
000014CE  6700 0664                477          BEQ     OP_BVS              ; Go to opcode BVS
000014D2  B23C 000A                478          CMP.B   #10, D1             ; When 1010 in second nibble
000014D6  6700 0678                479          BEQ     OP_BPL              ; Go to opcode BPL
000014DA  B23C 000B                480          CMP.B   #11, D1             ; When 1011 in second nibble
000014DE  6700 068C                481          BEQ     OP_BMI              ; Go to opcode BMI
000014E2  B23C 000C                482          CMP.B   #12, D1             ; When 1100 in second nibble
000014E6  6700 06A0                483          BEQ     OP_BGE              ; Go to opcode BGE
000014EA  B23C 000D                484          CMP.B   #13, D1             ; When 1101 in second nibble
000014EE  6700 06B4                485          BEQ     OP_BLT              ; Go to opcode BLT
000014F2  B23C 000E                486          CMP.B   #14, D1             ; When 1110 in second nibble
000014F6  6700 06C8                487          BEQ     OP_BGT              ; Go to opcode BGT
000014FA  B23C 000F                488          CMP.B   #15, D1             ; When 1111 in second nibble
000014FE  6700 06DC                489          BEQ     OP_BLE              ; Go to opcode BLE
00001502                           490  
00001502                           491  code0111                            ; Opcode MOVEQ
00001502  6000 06F4                492          BRA     OP_MOVEQ            ; Go to opcode MOVEQ
00001506                           493  
00001506                           494  code1000                            ; Opcodes DIVU word and OR.B/W/L
00001506  2200                     495          MOVE.L  D0,D1               ; D0 is current instruction word
00001508  0241 01C0                496          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
0000150C  1A3C 0006                497          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001510  EA69                     498          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001512  B23C 0003                499          CMP.B   #3,D1               ; When 011 in destination mode
00001516  6700 0704                500          BEQ     OP_DIVU             ; Go to opcode DIVU word
0000151A  B23C 0007                501          CMP.B   #7,D1               ; When 111
0000151E  6700 03CC                502          BEQ     OP_UNSUPPORTED      ; Go to opcode unsupported
00001522  6000 0718                503          BRA     OP_OR               ; Otherwise, go to opcode OR
00001526                           504  
00001526                           505  code1001                            ; Opcode SUB.B/W/L
00001526  6000 072C                506          BRA     OP_SUB              ; Go to opcode SUB   
0000152A                           507  
0000152A                           508  code1010                            ; Opcode not supported 
0000152A  6000 03C0                509          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
0000152E                           510       
0000152E                           511  code1011                            ; Opcode CMP.B/W/L
0000152E  6000 0740                512          BRA     OP_CMP              ; Go to opcode CMP
00001532                           513  
00001532                           514  code1100                            ; Opcodes MULS, MULU, AND.B/W/L
00001532  2200                     515          MOVE.L  D0,D1               ; D0 is current instruction word
00001534  0241 01C0                516          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001538  1A3C 0006                517          MOVE.B  #right6,D5          ; Used to shift 6 times to right
0000153C  EA69                     518          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000153E  C2FC 0006                519          MULU    #6, D1              ; Set displacement 
00001542  41F9 000016A8            520          LEA     OP_1100_TABLE,A0    ; Load table into A0
00001548  4EF0 1000                521          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
0000154C                           522  
0000154C                           523  code1101                            ; Opcodes ADD.B/W/L, ADDA.B/W/L
0000154C  2200                     524          MOVE.L  D0,D1               ; D0 is current instruction word
0000154E  0241 01C0                525          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001552  1A3C 0006                526          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001556  EA69                     527          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001558  C2FC 0006                528          MULU    #6, D1              ; Set displacement 
0000155C  41F9 00001708            529          LEA     OP_1101_TABLE,A0    ; Load table into A0
00001562  4EF0 1000                530          JMP     0(A0,D1)            ; Go to displacement (A0 + D1 * 6)
00001566                           531  
00001566                           532  code1110                            ; Opcodes ASL.B/W/L, ASR.B/W/L, LSL.B/W/L, LSR.B/W/L, ROL.B/W/L, ROR.B/W/L   
00001566  2200                     533          MOVE.L  D0,D1               ; D0 is current instruction word
00001568  0241 01C0                534          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
0000156C  1A3C 0006                535          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001570  EA69                     536          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001572                           537     
00001572                           538          ; Check Memory Shifts
00001572  B23C 0007                539          CMP.B   #7, D1              ; When 111
00001576  6700 0024                540          BEQ     MEMORY_1110_LEFT    ; Go to Memory Shift Left Side
0000157A                           541      
0000157A  B23C 0003                542          CMP.B   #3, D1              ; When 011
0000157E  6700 0040                543          BEQ     MEMORY_1110_RIGHT   ; Go Memory Shift Right Side
00001582                           544      
00001582                           545          ; Check Register Shifts
00001582  2200                     546          MOVE.L  D0,D1                       ; D0 is current instruction word
00001584  0241 0038                547          ANDI.W  #src_mode,D1                ; Extract 5-3 bits from instruction word
00001588  1A3C 0003                548          MOVE.B  #right3,D5                  ; Used to shift 3 times to right
0000158C  EA69                     549          LSR.W   D5,D1                       ; Shift 5-3 bits into LSB position
0000158E  C2FC 0006                550          MULU    #6,D1                       ; Set displacement 
00001592  41F9 00001768            551          LEA     OP_1110_TABLE_REGISTER,A0   ; Load table into A0
00001598  4EF0 1000                552          JMP     0(A0,D1)                    ; go to displacement (A0 + D1 * 6)
0000159C                           553  
0000159C                           554  MEMORY_1110_LEFT    
0000159C  2200                     555          MOVE.L  D0,D1               ; D0 is current instruction word
0000159E  0241 0E00                556          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
000015A2  1A3C 0009                557          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000015A6  EA69                     558          LSR.W   D5,D1               ; Shift dst reg into LSB position
000015A8  B23C 0000                559          CMP.B   #0,D1               ; When D1 is 0
000015AC  6700 0792                560          BEQ     OP_ASL              ; Go to opcode ASL
000015B0  B23C 0001                561          CMP.B   #1, D1              ; when D1 is 1
000015B4  6700 07C2                562          BEQ     OP_LSL              ; Go to opcode LSL
000015B8  B23C 0003                563          CMP.B   #3, D1              ; When D1 is 3
000015BC  6700 07F2                564          BEQ     OP_ROL              ; Go to opcode ROL
000015C0                           565  
000015C0                           566  MEMORY_1110_RIGHT
000015C0  2200                     567          MOVE.L  D0,D1               ; D0 is current instruction word
000015C2  0241 0E00                568          ANDI.W  #dst_reg,D1         ; Extract 11-9 position from instruction word
000015C6  1A3C 0009                569          MOVE.B  #right9,D5          ; Used to shift 9 times to right
000015CA  EA69                     570          LSR.W   D5,D1               ; Shift dst reg into LSB position
000015CC  B23C 0000                571          CMP.B   #0,D1               ; When D1 is 0
000015D0  6700 0752                572          BEQ     OP_ASR              ; Go to opcode ASR
000015D4  B23C 0001                573          CMP.B   #1, D1              ; when D1 is 1
000015D8  6700 0782                574          BEQ     OP_LSR              ; Go to opcode LSR
000015DC  B23C 0003                575          CMP.B   #3, D1              ; When D1 is 3
000015E0  6700 07B2                576          BEQ     OP_ROR              ; Go to opcode ROR
000015E4                           577  
000015E4                           578  code1111                            ; Opcode not supported 
000015E4  6000 0306                579          BRA     OP_UNSUPPORTED      ; Go to opcode unsupported   
000015E8                           580           
000015E8                           581  OP_0000_TABLE
000015E8  4EF9 000018EC            582          JMP     OP_UNSUPPORTED  ; 0 Go to opcode unsupported  
000015EE  4EF9 000018EC            583          JMP     OP_UNSUPPORTED  ; 1 Go to opcode unsupported  
000015F4  4EF9 000018EC            584          JMP     OP_UNSUPPORTED  ; 2 Go to opcode unsupported  
000015FA  4EF9 000018EC            585          JMP     OP_UNSUPPORTED  ; 3 Go to opcode unsupported  
00001600  4EF9 000018FC            586          JMP     OP_SUBI         ; 4 Go to opcode SUBI
00001606  4EF9 000018EC            587          JMP     OP_UNSUPPORTED  ; 5 Go to opcode unsupported  
0000160C  4EF9 0000191C            588          JMP     OP_ADDI         ; 6 Go to opcode ADDI
00001612  4EF9 000018EC            589          JMP     OP_UNSUPPORTED  ; 7 Go to opcode unsupported  
00001618  4EF9 000018EC            590          JMP     OP_UNSUPPORTED  ; 8 Go to opcode unsupported  
0000161E  4EF9 000018EC            591          JMP     OP_UNSUPPORTED  ; 9 Go to opcode unsupported  
00001624  4EF9 000018EC            592          JMP     OP_UNSUPPORTED  ; A Go to opcode unsupported  
0000162A  4EF9 000018EC            593          JMP     OP_UNSUPPORTED  ; B Go to opcode unsupported  
00001630  4EF9 000018EC            594          JMP     OP_UNSUPPORTED  ; C Go to opcode unsupported  
00001636  4EF9 000018EC            595          JMP     OP_UNSUPPORTED  ; D Go to opcode unsupported  
0000163C  4EF9 000018EC            596          JMP     OP_UNSUPPORTED  ; E Go to opcode unsupported  
00001642  4EF9 000018EC            597          JMP     OP_UNSUPPORTED  ; F Go to opcode unsupported  
00001648                           598      
00001648                           599  OP_0100_TABLE
00001648  4EF9 000018EC            600          JMP     OP_UNSUPPORTED      ; 0 Go to opcode unsupported  
0000164E  4EF9 000019FC            601          JMP     OP_LEA              ; 1 Go to opcode LEA
00001654  4EF9 00001980            602          JMP     OP_CLR              ; 2 Go to opcode CLR
0000165A  4EF9 000019FC            603          JMP     OP_LEA              ; 3 Go to opcode LEA
00001660  4EF9 000018EC            604          JMP     OP_UNSUPPORTED      ; 4 Go to opcode unsupported  
00001666  4EF9 000019FC            605          JMP     OP_LEA              ; 5 Go to opcode LEA
0000166C  4EF9 0000191C            606          JMP     OP_ADDI             ; 6 Go to opcode ADDI
00001672  4EF9 000019FC            607          JMP     OP_LEA              ; 7 Go to opcode LEA
00001678  4EF9 000019D8            608          JMP     OP_MOVEM            ; 8 Go to opcode MOVEM
0000167E  4EF9 000019FC            609          JMP     OP_LEA              ; 9 Go to opcode LEA
00001684  4EF9 000018EC            610          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
0000168A  4EF9 000019FC            611          JMP     OP_LEA              ; B Go to opcode LEA
00001690  4EF9 000019D8            612          JMP     OP_MOVEM            ; C Go to opcode MOVEM
00001696  4EF9 000019FC            613          JMP     OP_LEA              ; D Go to opcode LEA
0000169C  4EF9 0000182E            614          JMP     JSR_NOP_RTS         ; E Go to opcode JSR, NOP, or RTS
000016A2  4EF9 000018EC            615          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000016A8                           616      
000016A8                           617  OP_1100_TABLE
000016A8  4EF9 00001CCC            618          JMP     OP_AND              ; 0 Go to opcode AND 
000016AE  4EF9 00001CCC            619          JMP     OP_AND              ; 1 Go to opcode AND
000016B4  4EF9 00001CCC            620          JMP     OP_AND              ; 2 Go to opcode AND
000016BA  4EF9 00001C8C            621          JMP     OP_MULU             ; 3 Go to opcode MULU
000016C0  4EF9 00001CCC            622          JMP     OP_AND              ; 4 Go to opcode AND 
000016C6  4EF9 00001CCC            623          JMP     OP_AND              ; 5 Go to opcode AND
000016CC  4EF9 00001CCC            624          JMP     OP_AND              ; 6 Go to opcode AND
000016D2  4EF9 00001CAC            625          JMP     OP_MULS             ; 7 Go to opcode MULS
000016D8  4EF9 000018EC            626          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
000016DE  4EF9 000018EC            627          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
000016E4  4EF9 000018EC            628          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000016EA  4EF9 000018EC            629          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
000016F0  4EF9 000018EC            630          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
000016F6  4EF9 000018EC            631          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
000016FC  4EF9 000018EC            632          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001702  4EF9 000018EC            633          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001708                           634      
00001708                           635  OP_1101_TABLE
00001708  4EF9 00001CE8            636          JMP     OP_ADD              ; 0 Go to opcode ADD 
0000170E  4EF9 00001CE8            637          JMP     OP_ADD              ; 1 Go to opcode ADD
00001714  4EF9 00001CE8            638          JMP     OP_ADD              ; 2 Go to opcode ADD
0000171A  4EF9 00001D04            639          JMP     OP_ADDA             ; 3 Go to opcode ADDA
00001720  4EF9 00001CE8            640          JMP     OP_ADD              ; 4 Go to opcode ADD 
00001726  4EF9 00001CE8            641          JMP     OP_ADD              ; 5 Go to opcode ADD
0000172C  4EF9 00001CE8            642          JMP     OP_ADD              ; 6 Go to opcode ADD
00001732  4EF9 00001D04            643          JMP     OP_ADDA             ; 7 Go to opcode ADDA
00001738  4EF9 000018EC            644          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000173E  4EF9 000018EC            645          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
00001744  4EF9 000018EC            646          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
0000174A  4EF9 000018EC            647          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
00001750  4EF9 000018EC            648          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
00001756  4EF9 000018EC            649          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
0000175C  4EF9 000018EC            650          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
00001762  4EF9 000018EC            651          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
00001768                           652      
00001768                           653  OP_1110_TABLE_REGISTER
00001768  4EF9 000017C8            654          JMP     OP_AS_CHECK         ; 0 Check if AS is left or right
0000176E  4EF9 000017EA            655          JMP     OP_LS_CHECK         ; 1 Check if LS is left or right
00001774  4EF9 000018EC            656          JMP     OP_UNSUPPORTED      ; 2 Go to opcode unsupported  
0000177A  4EF9 0000180C            657          JMP     OP_RO_CHECK         ; 3 Check if RO is left or right
00001780  4EF9 000017C8            658          JMP     OP_AS_CHECK         ; 4 Check if AS is left or right
00001786  4EF9 000017EA            659          JMP     OP_LS_CHECK         ; 5 Check if LS is left or right
0000178C  4EF9 000018EC            660          JMP     OP_UNSUPPORTED      ; 6 Go to opcode unsupported 
00001792  4EF9 0000180C            661          JMP     OP_RO_CHECK         ; 7 Check if RO is left or right
00001798  4EF9 000018EC            662          JMP     OP_UNSUPPORTED      ; 8 Go to opcode unsupported  
0000179E  4EF9 000018EC            663          JMP     OP_UNSUPPORTED      ; 9 Go to opcode unsupported  
000017A4  4EF9 000018EC            664          JMP     OP_UNSUPPORTED      ; A Go to opcode unsupported  
000017AA  4EF9 000018EC            665          JMP     OP_UNSUPPORTED      ; B Go to opcode unsupported  
000017B0  4EF9 000018EC            666          JMP     OP_UNSUPPORTED      ; C Go to opcode unsupported  
000017B6  4EF9 000018EC            667          JMP     OP_UNSUPPORTED      ; D Go to opcode unsupported  
000017BC  4EF9 000018EC            668          JMP     OP_UNSUPPORTED      ; E Go to opcode unsupported  
000017C2  4EF9 000018EC            669          JMP     OP_UNSUPPORTED      ; F Go to opcode unsupported  
000017C8                           670  
000017C8                           671  OP_AS_CHECK
000017C8  2200                     672          MOVE.L  D0,D1               ; D0 is current instruction word
000017CA  0241 01C0                673          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000017CE  1A3C 0006                674          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000017D2  EA69                     675          LSR.W   D5,D1               ; Shift dst mode into LSB position
000017D4  0201 0004                676          ANDI.B  #4,D1               ; Get only bit 8 (dr)
000017D8  E449                     677          LSR.W   #2,D1
000017DA                           678  
000017DA  B23C 0001                679          CMP.B   #1,D1               ; Go left
000017DE  6700 0560                680          BEQ     OP_ASL              ; 1 Go to opcode ASL
000017E2  B23C 0000                681          CMP.B   #0,D1               ; Go right
000017E6  6700 053C                682          BEQ     OP_ASR              ; 0 Go to opcode ASR
000017EA                           683          
000017EA                           684  OP_LS_CHECK
000017EA  2200                     685          MOVE.L  D0,D1               ; D0 is current instruction word
000017EC  0241 01C0                686          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000017F0  1A3C 0006                687          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000017F4  EA69                     688          LSR.W   D5,D1               ; Shift dst mode into LSB position
000017F6  0201 0004                689          ANDI.B  #4,D1               ; Get only bit 8 (dr)
000017FA  E449                     690          LSR.W   #2,D1
000017FC                           691  
000017FC  B23C 0001                692          CMP.B   #1,D1               ; Go left
00001800  6700 0576                693          BEQ     OP_LSL              ; 1 Go to opcode LSL
00001804  B23C 0000                694          CMP.B   #0,D1               ; Go right
00001808  6700 0552                695          BEQ     OP_LSR              ; 0 Go to opcode LSR
0000180C                           696          
0000180C                           697  OP_RO_CHECK
0000180C  2200                     698          MOVE.L  D0,D1               ; D0 is current instruction word
0000180E  0241 01C0                699          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
00001812  1A3C 0006                700          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001816  EA69                     701          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001818  0201 0004                702          ANDI.B  #4,D1               ; Get only bit 8 (dr)
0000181C  E449                     703          LSR.W   #2,D1
0000181E                           704  
0000181E  B23C 0001                705          CMP.B   #1,D1               ; Go left
00001822  6700 058C                706          BEQ     OP_ROL              ; 1 Go to opcode ROL
00001826  B23C 0000                707          CMP.B   #0,D1               ; Go right
0000182A  6700 0568                708          BEQ     OP_ROR              ; 0 Go to opcode ROR
0000182E                           709          
0000182E                           710  JSR_NOP_RTS
0000182E  2200                     711          MOVE.L  D0,D1               ; D0 is current instruction word
00001830  0241 01C0                712          ANDI.W  #dst_mode,D1        ; Extract dst mode position from instruction word
00001834  1A3C 0006                713          MOVE.B  #right6,D5          ; Used to shift 6 times to right
00001838  EA69                     714          LSR.W   D5,D1               ; Shift dst mode into LSB position
0000183A  B23C 0002                715          CMP.B   #2, D1              ; When 010 in destination mode
0000183E  6700 017C                716          BEQ     OP_JSR              ; Go to opcode JSR
00001842                           717          
00001842  2200                     718          MOVE.L  D0,D1               ; D0 is current instruction word
00001844  0241 000F                719          ANDI.W  #fourth_nibble,D1   ; Extract dst mode position from instruction word
00001848  B23C 0001                720          CMP.B   #1, D1  
0000184C  6700 000E                721          BEQ     NOP_CHECK
00001850  B23C 0005                722          CMP.B   #5, D1  
00001854  6700 004E                723          BEQ     RTS_CHECK
00001858  6000 0092                724          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000185C                           725          
0000185C                           726  NOP_CHECK
0000185C  2200                     727          MOVE.L  D0,D1               ; D0 is current instruction word
0000185E  0241 F000                728          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
00001862  1A3C 000C                729          MOVE.B  #right12,D5         ; Used to shift 6 times to right
00001866  EA69                     730          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001868  B23C 0004                731          CMP.B   #4, D1              
0000186C  6700 0006                732          BEQ     NOP_CHECK_TWO
00001870  6000 007A                733          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
00001874                           734          
00001874                           735  NOP_CHECK_TWO
00001874  2200                     736          MOVE.L  D0,D1               ; D0 is current instruction word
00001876  0241 0F00                737          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
0000187A  1A3C 0008                738          MOVE.B  #right8,D5          ; Used to shift 6 times to right
0000187E  EA69                     739          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001880  B23C 000E                740          CMP.B   #14, D1            
00001884  6700 0006                741          BEQ     NOP_CHECK_THREE
00001888  6000 0062                742          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
0000188C                           743  
0000188C                           744  NOP_CHECK_THREE
0000188C  2200                     745          MOVE.L  D0,D1               ; D0 is current instruction word
0000188E  0241 00F0                746          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
00001892  1A3C 0004                747          MOVE.B  #right4,D5          ; Used to shift 6 times to right
00001896  EA69                     748          LSR.W   D5,D1               ; Shift dst mode into LSB position
00001898  B23C 0007                749          CMP.B   #7, D1              
0000189C  6700 00FE                750          BEQ     OP_NOP
000018A0  6000 004A                751          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018A4                           752       
000018A4                           753  RTS_CHECK
000018A4  2200                     754          MOVE.L  D0,D1               ; D0 is current instruction word
000018A6  0241 F000                755          ANDI.W  #first_nibble,D1    ; Extract dst mode position from instruction word
000018AA  1A3C 000C                756          MOVE.B  #right12,D5         ; Used to shift 6 times to right
000018AE  EA69                     757          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018B0  B23C 0004                758          CMP.B   #4, D1              
000018B4  6700 0006                759          BEQ     RTS_CHECK_TWO
000018B8  6000 0032                760          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018BC                           761          
000018BC                           762  RTS_CHECK_TWO
000018BC  2200                     763          MOVE.L  D0,D1               ; D0 is current instruction word
000018BE  0241 0F00                764          ANDI.W  #second_nibble,D1   ; Extract dst mode position from instruction word
000018C2  1A3C 0008                765          MOVE.B  #right8,D5          ; Used to shift 6 times to right
000018C6  EA69                     766          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018C8  B23C 000E                767          CMP.B   #14, D1             
000018CC  6700 0006                768          BEQ     RTS_CHECK_THREE
000018D0  6000 001A                769          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018D4                           770  
000018D4                           771  RTS_CHECK_THREE
000018D4  2200                     772          MOVE.L  D0,D1               ; D0 is current instruction word
000018D6  0241 00F0                773          ANDI.W  #third_nibble,D1    ; Extract dst mode position from instruction word
000018DA  1A3C 0004                774          MOVE.B  #right4,D5          ; Used to shift 6 times to right
000018DE  EA69                     775          LSR.W   D5,D1               ; Shift dst mode into LSB position
000018E0  B23C 0007                776          CMP.B   #7, D1             
000018E4  6700 00C6                777          BEQ     OP_RTS
000018E8  6000 0002                778          BRA     OP_UNSUPPORTED      ; Otherwise, go to opcode unsupported
000018EC                           779  
000018EC                           780  OP_UNSUPPORTED
000018EC  43F9 00002ED1            781          LEA     OPCODE_INVALID,A1 
000018F2  103C 000E                782          MOVE.B  #14,D0
000018F6  4E4F                     783          TRAP    #15
000018F8  4EF8 138E                784          JMP     OP_FINISH
000018FC                           785          
000018FC                           786  *----------------------------------------------------------------------------------------------*
000018FC                           787  * param D0 the current instruction in word
000018FC                           788  * param D1 the EA type
000018FC                           789  * param A2 a pointer to the decode_buffer
000018FC                           790  * param A5 current address
000018FC                           791  * ea_start(D0, D1, A2, A5){
000018FC                           792  * D2: size
000018FC                           793  * D3: src mode, dst mode
000018FC                           794  * D4: src regs, dst regs
000018FC                           795  * D5: #shifts
000018FC                           796  * D7: immediate data
000018FC                           797  * A0: EA_TYPE_TABLE
000018FC                           798  *       0 = ea_immediate
000018FC                           799  * }
000018FC                           800  
000018FC                           801  *----------------------------------------------------------------------------------------------*
000018FC                           802  * First 4 bits: 0000
000018FC                           803  OP_SUBI
000018FC  14FC 0053                804          MOVE.B  #'S',(A2)+
00001900  14FC 0055                805          MOVE.B  #'U',(A2)+
00001904  14FC 0042                806          MOVE.B  #'B',(A2)+
00001908  14FC 0049                807          MOVE.B  #'I',(A2)+
0000190C  223C 00000000            808          MOVE.L  #ea_type_immediate,D1
00001912  4EB9 00001DCC            809          JSR     EA_START
00001918  4EF8 138E                810          JMP     OP_FINISH
0000191C                           811          
0000191C                           812  OP_ADDI
0000191C  14FC 0041                813          MOVE.B  #'A',(A2)+
00001920  14FC 0044                814          MOVE.B  #'D',(A2)+
00001924  14FC 0044                815          MOVE.B  #'D',(A2)+
00001928  14FC 0049                816          MOVE.B  #'I',(A2)+
0000192C  223C 00000000            817          MOVE.L  #ea_type_immediate,D1
00001932  4EB9 00001DCC            818          JSR     EA_START
00001938  4EF8 138E                819          JMP     OP_FINISH
0000193C                           820  
0000193C                           821  *-----------------------------------------------------------------------------------------------*
0000193C                           822  * First 4 bits: 0001
0000193C                           823  OP_MOVEA
0000193C  14FC 004D                824          MOVE.B  #'M',(A2)+
00001940  14FC 004F                825          MOVE.B  #'O',(A2)+
00001944  14FC 0056                826          MOVE.B  #'V',(A2)+
00001948  14FC 0045                827          MOVE.B  #'E',(A2)+
0000194C  14FC 0041                828          MOVE.B  #'A',(A2)+
00001950  223C 00000002            829          MOVE.L  #ea_type_movea,D1
00001956  4EB9 00001DCC            830          JSR     EA_START
0000195C  4EF8 138E                831          JMP     OP_FINISH
00001960                           832  
00001960                           833  *------------------------------------------------------------------------------------------------*
00001960                           834  * First 4 bits: 0011
00001960                           835  OP_MOVE
00001960  14FC 004D                836          MOVE.B  #'M',(A2)+
00001964  14FC 004F                837          MOVE.B  #'O',(A2)+
00001968  14FC 0056                838          MOVE.B  #'V',(A2)+
0000196C  14FC 0045                839          MOVE.B  #'E',(A2)+
00001970  223C 00000001            840          MOVE.L  #ea_type_move,D1
00001976  4EB9 00001DCC            841          JSR     EA_START
0000197C  4EF8 138E                842          JMP     OP_FINISH
00001980                           843  
00001980                           844  *------------------------------------------------------------------------------------------------*
00001980                           845  * First 4 bits: 0100
00001980                           846  OP_CLR
00001980  14FC 0043                847          MOVE.B  #'C',(A2)+
00001984  14FC 004C                848          MOVE.B  #'L',(A2)+
00001988  14FC 0052                849          MOVE.B  #'R',(A2)+
0000198C  223C 00000004            850          MOVE.L  #ea_type_dstonly,D1
00001992  4EB9 00001DCC            851          JSR     EA_START
00001998  4EF8 138E                852          JMP     OP_FINISH
0000199C                           853          
0000199C                           854  OP_NOP
0000199C  14FC 004E                855          MOVE.B  #'N',(A2)+
000019A0  14FC 004F                856          MOVE.B  #'O',(A2)+
000019A4  14FC 0050                857          MOVE.B  #'P',(A2)+
000019A8  4EF8 138E                858          JMP     OP_FINISH
000019AC                           859          
000019AC                           860  OP_RTS
000019AC  14FC 0052                861          MOVE.B  #'R',(A2)+
000019B0  14FC 0054                862          MOVE.B  #'T',(A2)+
000019B4  14FC 0053                863          MOVE.B  #'S',(A2)+
000019B8  4EF8 138E                864          JMP     OP_FINISH
000019BC                           865          
000019BC                           866  OP_JSR
000019BC  14FC 004A                867          MOVE.B  #'J',(A2)+
000019C0  14FC 0053                868          MOVE.B  #'S',(A2)+
000019C4  14FC 0052                869          MOVE.B  #'R',(A2)+
000019C8  223C 00000004            870          MOVE.L  #ea_type_dstonly,D1
000019CE  4EB9 00001DCC            871          JSR     EA_START
000019D4  4EF8 138E                872          JMP     OP_FINISH
000019D8                           873  
000019D8                           874  OP_MOVEM
000019D8  14FC 004D                875          MOVE.B  #'M',(A2)+
000019DC  14FC 004F                876          MOVE.B  #'O',(A2)+
000019E0  14FC 0056                877          MOVE.B  #'V',(A2)+
000019E4  14FC 0045                878          MOVE.B  #'E',(A2)+
000019E8  14FC 004D                879          MOVE.B  #'M',(A2)+
000019EC  223C 00000006            880          MOVE.L  #ea_type_movem,D1
000019F2  4EB9 00001DCC            881          JSR     EA_START
000019F8  4EF8 138E                882          JMP     OP_FINISH
000019FC                           883          
000019FC                           884  OP_LEA
000019FC  14FC 004C                885          MOVE.B  #'L',(A2)+
00001A00  14FC 0045                886          MOVE.B  #'E',(A2)+
00001A04  14FC 0041                887          MOVE.B  #'A',(A2)+
00001A08  223C 00000003            888          MOVE.L  #ea_type_lea,D1
00001A0E  4EB9 00001DCC            889          JSR     EA_START
00001A14  4EF8 138E                890          JMP     OP_FINISH
00001A18                           891  
00001A18                           892  *------------------------------------------------------------------------------------------------*
00001A18                           893  * First 4 bits: 0101
00001A18                           894  OP_ADDQ
00001A18  14FC 0041                895          MOVE.B  #'A',(A2)+
00001A1C  14FC 0044                896          MOVE.B  #'D',(A2)+
00001A20  14FC 0044                897          MOVE.B  #'D',(A2)+
00001A24  14FC 0051                898          MOVE.B  #'Q',(A2)+
00001A28  223C 00000008            899          MOVE.L  #ea_type_quick,D1
00001A2E  4EB9 00001DCC            900          JSR     EA_START
00001A34  4EF8 138E                901          JMP     OP_FINISH
00001A38                           902          
00001A38                           903  *------------------------------------------------------------------------------------------------*
00001A38                           904  * First 4 bits: 0110
00001A38                           905  OP_BRA
00001A38  14FC 0042                906          MOVE.B  #'B',(A2)+
00001A3C  14FC 0052                907          MOVE.B  #'R',(A2)+
00001A40  14FC 0041                908          MOVE.B  #'A',(A2)+
00001A44  223C 00000009            909          MOVE.L  #ea_type_branch,D1
00001A4A  4EB9 00001DCC            910          JSR     EA_START
00001A50  4EF8 138E                911          JMP     OP_FINISH
00001A54                           912  
00001A54                           913  OP_BSR
00001A54  14FC 0042                914          MOVE.B  #'B',(A2)+
00001A58  14FC 0053                915          MOVE.B  #'S',(A2)+
00001A5C  14FC 0052                916          MOVE.B  #'R',(A2)+
00001A60  223C 00000009            917          MOVE.L  #ea_type_branch,D1
00001A66  4EB9 00001DCC            918          JSR     EA_START
00001A6C  4EF8 138E                919          JMP     OP_FINISH
00001A70                           920          
00001A70                           921  OP_BHI
00001A70  14FC 0042                922          MOVE.B  #'B',(A2)+
00001A74  14FC 0048                923          MOVE.B  #'H',(A2)+
00001A78  14FC 0049                924          MOVE.B  #'I',(A2)+
00001A7C  223C 00000009            925          MOVE.L  #ea_type_branch,D1
00001A82  4EB9 00001DCC            926          JSR     EA_START
00001A88  4EF8 138E                927          JMP     OP_FINISH
00001A8C                           928  
00001A8C                           929  OP_BLS
00001A8C  14FC 0042                930          MOVE.B  #'B',(A2)+
00001A90  14FC 004C                931          MOVE.B  #'L',(A2)+
00001A94  14FC 0053                932          MOVE.B  #'S',(A2)+
00001A98  223C 00000009            933          MOVE.L  #ea_type_branch,D1
00001A9E  4EB9 00001DCC            934          JSR     EA_START
00001AA4  4EF8 138E                935          JMP     OP_FINISH
00001AA8                           936  
00001AA8                           937  OP_BCC
00001AA8  14FC 0042                938          MOVE.B  #'B',(A2)+
00001AAC  14FC 0043                939          MOVE.B  #'C',(A2)+
00001AB0  14FC 0043                940          MOVE.B  #'C',(A2)+
00001AB4  223C 00000009            941          MOVE.L  #ea_type_branch,D1
00001ABA  4EB9 00001DCC            942          JSR     EA_START
00001AC0  4EF8 138E                943          JMP     OP_FINISH
00001AC4                           944          
00001AC4                           945  OP_BCS
00001AC4  14FC 0042                946          MOVE.B  #'B',(A2)+
00001AC8  14FC 0043                947          MOVE.B  #'C',(A2)+
00001ACC  14FC 0053                948          MOVE.B  #'S',(A2)+
00001AD0  223C 00000009            949          MOVE.L  #ea_type_branch,D1
00001AD6  4EB9 00001DCC            950          JSR     EA_START
00001ADC  4EF8 138E                951          JMP     OP_FINISH
00001AE0                           952  
00001AE0                           953  OP_BNE
00001AE0  14FC 0042                954          MOVE.B  #'B',(A2)+
00001AE4  14FC 004E                955          MOVE.B  #'N',(A2)+
00001AE8  14FC 0045                956          MOVE.B  #'E',(A2)+
00001AEC  223C 00000009            957          MOVE.L  #ea_type_branch,D1
00001AF2  4EB9 00001DCC            958          JSR     EA_START
00001AF8  4EF8 138E                959          JMP     OP_FINISH
00001AFC                           960  
00001AFC                           961  OP_BEQ
00001AFC  14FC 0042                962          MOVE.B  #'B',(A2)+
00001B00  14FC 0045                963          MOVE.B  #'E',(A2)+
00001B04  14FC 0051                964          MOVE.B  #'Q',(A2)+
00001B08  223C 00000009            965          MOVE.L  #ea_type_branch,D1
00001B0E  4EB9 00001DCC            966          JSR     EA_START
00001B14  4EF8 138E                967          JMP     OP_FINISH
00001B18                           968  
00001B18                           969  OP_BVC
00001B18  14FC 0042                970          MOVE.B  #'B',(A2)+
00001B1C  14FC 0056                971          MOVE.B  #'V',(A2)+
00001B20  14FC 0043                972          MOVE.B  #'C',(A2)+
00001B24  223C 00000009            973          MOVE.L  #ea_type_branch,D1
00001B2A  4EB9 00001DCC            974          JSR     EA_START
00001B30  4EF8 138E                975          JMP     OP_FINISH
00001B34                           976  
00001B34                           977  OP_BVS
00001B34  14FC 0042                978          MOVE.B  #'B',(A2)+
00001B38  14FC 0056                979          MOVE.B  #'V',(A2)+
00001B3C  14FC 0053                980          MOVE.B  #'S',(A2)+
00001B40  223C 00000009            981          MOVE.L  #ea_type_branch,D1
00001B46  4EB9 00001DCC            982          JSR     EA_START
00001B4C  4EF8 138E                983          JMP     OP_FINISH
00001B50                           984  
00001B50                           985  OP_BPL
00001B50  14FC 0042                986          MOVE.B  #'B',(A2)+
00001B54  14FC 0050                987          MOVE.B  #'P',(A2)+
00001B58  14FC 004C                988          MOVE.B  #'L',(A2)+
00001B5C  223C 00000009            989          MOVE.L  #ea_type_branch,D1
00001B62  4EB9 00001DCC            990          JSR     EA_START
00001B68  4EF8 138E                991          JMP     OP_FINISH
00001B6C                           992  
00001B6C                           993  OP_BMI
00001B6C  14FC 0042                994          MOVE.B  #'B',(A2)+
00001B70  14FC 004D                995          MOVE.B  #'M',(A2)+
00001B74  14FC 0049                996          MOVE.B  #'I',(A2)+
00001B78  223C 00000009            997          MOVE.L  #ea_type_branch,D1
00001B7E  4EB9 00001DCC            998          JSR     EA_START
00001B84  4EF8 138E                999          JMP     OP_FINISH
00001B88                          1000  
00001B88                          1001  OP_BGE
00001B88  14FC 0042               1002          MOVE.B  #'B',(A2)+
00001B8C  14FC 0047               1003          MOVE.B  #'G',(A2)+
00001B90  14FC 0045               1004          MOVE.B  #'E',(A2)+
00001B94  223C 00000009           1005          MOVE.L  #ea_type_branch,D1
00001B9A  4EB9 00001DCC           1006          JSR     EA_START
00001BA0  4EF8 138E               1007          JMP     OP_FINISH
00001BA4                          1008  
00001BA4                          1009  OP_BLT
00001BA4  14FC 0042               1010          MOVE.B  #'B',(A2)+
00001BA8  14FC 004C               1011          MOVE.B  #'L',(A2)+
00001BAC  14FC 0054               1012          MOVE.B  #'T',(A2)+
00001BB0  223C 00000009           1013          MOVE.L  #ea_type_branch,D1
00001BB6  4EB9 00001DCC           1014          JSR     EA_START
00001BBC  4EF8 138E               1015          JMP     OP_FINISH
00001BC0                          1016  
00001BC0                          1017  OP_BGT
00001BC0  14FC 0042               1018          MOVE.B  #'B',(A2)+
00001BC4  14FC 0047               1019          MOVE.B  #'G',(A2)+
00001BC8  14FC 0054               1020          MOVE.B  #'T',(A2)+
00001BCC  223C 00000009           1021          MOVE.L  #ea_type_branch,D1
00001BD2  4EB9 00001DCC           1022          JSR     EA_START
00001BD8  4EF8 138E               1023          JMP     OP_FINISH
00001BDC                          1024  
00001BDC                          1025  OP_BLE
00001BDC  14FC 0042               1026          MOVE.B  #'B',(A2)+
00001BE0  14FC 004C               1027          MOVE.B  #'L',(A2)+
00001BE4  14FC 0045               1028          MOVE.B  #'E',(A2)+
00001BE8  223C 00000009           1029          MOVE.L  #ea_type_branch,D1
00001BEE  4EB9 00001DCC           1030          JSR     EA_START
00001BF4  4EF8 138E               1031          JMP     OP_FINISH
00001BF8                          1032  *------------------------------------------------------------------------------------------------*
00001BF8                          1033  * First 4 bits: 0111
00001BF8                          1034  OP_MOVEQ
00001BF8  14FC 004D               1035          MOVE.B  #'M',(A2)+
00001BFC  14FC 004F               1036          MOVE.B  #'O',(A2)+
00001C00  14FC 0056               1037          MOVE.B  #'V',(A2)+
00001C04  14FC 0045               1038          MOVE.B  #'E',(A2)+
00001C08  14FC 0051               1039          MOVE.B  #'Q',(A2)+
00001C0C  223C 00000008           1040          MOVE.L  #ea_type_quick,D1
00001C12  4EB9 00001DCC           1041          JSR     EA_START
00001C18  4EF8 138E               1042          JMP     OP_FINISH
00001C1C                          1043          
00001C1C                          1044  *------------------------------------------------------------------------------------------------*
00001C1C                          1045  * First 4 bits: 1000
00001C1C                          1046  OP_DIVU
00001C1C  14FC 0044               1047          MOVE.B  #'D',(A2)+
00001C20  14FC 0049               1048          MOVE.B  #'I',(A2)+
00001C24  14FC 0056               1049          MOVE.B  #'V',(A2)+
00001C28  14FC 0055               1050          MOVE.B  #'U',(A2)+
00001C2C  223C 00000005           1051          MOVE.L  #ea_type_ext,D1
00001C32  4EB9 00001DCC           1052          JSR     EA_START
00001C38  4EF8 138E               1053          JMP     OP_FINISH
00001C3C                          1054    
00001C3C                          1055  OP_OR
00001C3C  14FC 004F               1056          MOVE.B  #'O',(A2)+
00001C40  14FC 0052               1057          MOVE.B  #'R',(A2)+
00001C44  223C 00000005           1058          MOVE.L  #ea_type_ext,D1
00001C4A  4EB9 00001DCC           1059          JSR     EA_START
00001C50  4EF8 138E               1060          JMP     OP_FINISH
00001C54                          1061  
00001C54                          1062  *------------------------------------------------------------------------------------------------*
00001C54                          1063  * First 4 bits: 1001
00001C54                          1064  OP_SUB
00001C54  14FC 0053               1065          MOVE.B  #'S',(A2)+
00001C58  14FC 0055               1066          MOVE.B  #'U',(A2)+
00001C5C  14FC 0042               1067          MOVE.B  #'B',(A2)+
00001C60  223C 00000005           1068          MOVE.L  #ea_type_ext,D1
00001C66  4EB9 00001DCC           1069          JSR     EA_START
00001C6C  4EF8 138E               1070          JMP     OP_FINISH
00001C70                          1071          
00001C70                          1072  *------------------------------------------------------------------------------------------------*
00001C70                          1073  * First 4 bits: 1011
00001C70                          1074  OP_CMP
00001C70  14FC 0043               1075          MOVE.B  #'C',(A2)+
00001C74  14FC 004D               1076          MOVE.B  #'M',(A2)+
00001C78  14FC 0050               1077          MOVE.B  #'P',(A2)+
00001C7C  223C 00000005           1078          MOVE.L  #ea_type_ext,D1
00001C82  4EB9 00001DCC           1079          JSR     EA_START
00001C88  4EF8 138E               1080          JMP     OP_FINISH
00001C8C                          1081          
00001C8C                          1082  *------------------------------------------------------------------------------------------------*
00001C8C                          1083  * First 4 bits: 1100
00001C8C                          1084  OP_MULU
00001C8C  14FC 004D               1085          MOVE.B  #'M',(A2)+
00001C90  14FC 0055               1086          MOVE.B  #'U',(A2)+
00001C94  14FC 004C               1087          MOVE.B  #'L',(A2)+
00001C98  14FC 0055               1088          MOVE.B  #'U',(A2)+
00001C9C  223C 00000005           1089          MOVE.L  #ea_type_ext,D1
00001CA2  4EB9 00001DCC           1090          JSR     EA_START
00001CA8  4EF8 138E               1091          JMP     OP_FINISH
00001CAC                          1092          
00001CAC                          1093  OP_MULS
00001CAC  14FC 004D               1094          MOVE.B  #'M',(A2)+
00001CB0  14FC 0055               1095          MOVE.B  #'U',(A2)+
00001CB4  14FC 004C               1096          MOVE.B  #'L',(A2)+
00001CB8  14FC 0053               1097          MOVE.B  #'S',(A2)+
00001CBC  223C 00000005           1098          MOVE.L  #ea_type_ext,D1
00001CC2  4EB9 00001DCC           1099          JSR     EA_START
00001CC8  4EF8 138E               1100          JMP     OP_FINISH
00001CCC                          1101          
00001CCC                          1102  OP_AND
00001CCC  14FC 0041               1103          MOVE.B  #'A',(A2)+
00001CD0  14FC 004E               1104          MOVE.B  #'N',(A2)+
00001CD4  14FC 0044               1105          MOVE.B  #'D',(A2)+
00001CD8  223C 00000005           1106          MOVE.L  #ea_type_ext,D1
00001CDE  4EB9 00001DCC           1107          JSR     EA_START
00001CE4  4EF8 138E               1108          JMP     OP_FINISH
00001CE8                          1109          
00001CE8                          1110  *------------------------------------------------------------------------------------------------*
00001CE8                          1111  * First 4 bits: 1101
00001CE8                          1112  OP_ADD
00001CE8  14FC 0041               1113          MOVE.B  #'A',(A2)+
00001CEC  14FC 0044               1114          MOVE.B  #'D',(A2)+
00001CF0  14FC 0044               1115          MOVE.B  #'D',(A2)+
00001CF4  223C 00000005           1116          MOVE.L  #ea_type_ext,D1
00001CFA  4EB9 00001DCC           1117          JSR     EA_START
00001D00  4EF8 138E               1118          JMP     OP_FINISH
00001D04                          1119  
00001D04                          1120  OP_ADDA
00001D04  14FC 0041               1121          MOVE.B  #'A',(A2)+
00001D08  14FC 0044               1122          MOVE.B  #'D',(A2)+
00001D0C  14FC 0044               1123          MOVE.B  #'D',(A2)+
00001D10  14FC 0041               1124          MOVE.B  #'A',(A2)+
00001D14  223C 00000005           1125          MOVE.L  #ea_type_ext,D1
00001D1A  4EB9 00001DCC           1126          JSR     EA_START
00001D20  4EF8 138E               1127          JMP     OP_FINISH
00001D24                          1128          
00001D24                          1129  *------------------------------------------------------------------------------------------------*
00001D24                          1130  * First 4 bits: 1110
00001D24                          1131  OP_ASR
00001D24  14FC 0041               1132          MOVE.B  #'A',(A2)+
00001D28  14FC 0053               1133          MOVE.B  #'S',(A2)+
00001D2C  14FC 0052               1134          MOVE.B  #'R',(A2)+
00001D30  223C 00000007           1135          MOVE.L  #ea_type_shifts,D1
00001D36  4EB9 00001DCC           1136          JSR     EA_START
00001D3C  4EF8 138E               1137          JMP     OP_FINISH
00001D40                          1138  OP_ASL
00001D40  14FC 0041               1139          MOVE.B  #'A',(A2)+
00001D44  14FC 0053               1140          MOVE.B  #'S',(A2)+
00001D48  14FC 004C               1141          MOVE.B  #'L',(A2)+
00001D4C  223C 00000007           1142          MOVE.L  #ea_type_shifts,D1
00001D52  4EB9 00001DCC           1143          JSR     EA_START
00001D58  4EF8 138E               1144          JMP     OP_FINISH
00001D5C                          1145          
00001D5C                          1146  OP_LSR
00001D5C  14FC 004C               1147          MOVE.B  #'L',(A2)+
00001D60  14FC 0053               1148          MOVE.B  #'S',(A2)+
00001D64  14FC 0052               1149          MOVE.B  #'R',(A2)+
00001D68  223C 00000007           1150          MOVE.L  #ea_type_shifts,D1
00001D6E  4EB9 00001DCC           1151          JSR     EA_START
00001D74  4EF8 138E               1152          JMP     OP_FINISH
00001D78                          1153         
00001D78                          1154  OP_LSL
00001D78  14FC 004C               1155          MOVE.B  #'L',(A2)+
00001D7C  14FC 0053               1156          MOVE.B  #'S',(A2)+
00001D80  14FC 004C               1157          MOVE.B  #'L',(A2)+
00001D84  223C 00000007           1158          MOVE.L  #ea_type_shifts,D1
00001D8A  4EB9 00001DCC           1159          JSR     EA_START
00001D90  4EF8 138E               1160          JMP     OP_FINISH
00001D94                          1161          
00001D94                          1162  OP_ROR
00001D94  14FC 0052               1163          MOVE.B  #'R',(A2)+
00001D98  14FC 004F               1164          MOVE.B  #'O',(A2)+
00001D9C  14FC 0052               1165          MOVE.B  #'R',(A2)+
00001DA0  223C 00000007           1166          MOVE.L  #ea_type_shifts,D1
00001DA6  4EB9 00001DCC           1167          JSR     EA_START
00001DAC  4EF8 138E               1168          JMP     OP_FINISH
00001DB0                          1169          
00001DB0                          1170  OP_ROL
00001DB0  14FC 0052               1171          MOVE.B  #'R',(A2)+
00001DB4  14FC 004F               1172          MOVE.B  #'O',(A2)+
00001DB8  14FC 004C               1173          MOVE.B  #'L',(A2)+
00001DBC  223C 00000007           1174          MOVE.L  #ea_type_shifts,D1
00001DC2  4EB9 00001DCC           1175          JSR     EA_START
00001DC8  4EF8 138E               1176          JMP     OP_FINISH
00001DCC                          1177          
00001DCC                          1178  *------------------------------------------------------------------------------------------------*
00001DCC                          1179  EA_START
00001DCC  48E7 38C0               1180          MOVEM.L D2-D4/A0-A1, -(SP)
00001DD0                          1181          
00001DD0  41F9 00001DE4           1182          LEA     EA_TYPE_TABLE, A0
00001DD6  C2FC 0006               1183          MULU    #6, D1
00001DDA  4EF0 1000               1184          JMP     0(A0, D1)
00001DDE                          1185          
00001DDE                          1186  EA_FINISH
00001DDE  4CDF 031C               1187          MOVEM.L (SP)+, D2-D4/A0-A1
00001DE2  4E75                    1188          RTS
00001DE4                          1189          
00001DE4                          1190  EA_TYPE_TABLE
00001DE4  4EF9 00001F02           1191          JMP     EA_IMMEDIATE        ; 0: ea_immediate
00001DEA  4EF9 00001F5A           1192          JMP     EA_MOVE             ; 1: ea_move
00001DF0  4EF9 00001FC6           1193          JMP     EA_MOVEA            ; 2: ea_movea
00001DF6  4EF9 00002032           1194          JMP     EA_LEA              ; 3: ea_lea
00001DFC  4EF9 000020B0           1195          JMP     EA_DSTONLY          ; 4: ea_dstonly
00001E02  4EF9 00002162           1196          JMP     EA_EXT              ; 5: ea_ext
00001E08  4EF9 00002352           1197          JMP     EA_MOVEM            ; 6: ea_movem
00001E0E  4EF9 000029B6           1198          JMP     EA_SHIFTS           ; 7: ea_shifts
00001E14  4EF9 00002B38           1199          JMP     EA_QUICK            ; 8: ea_quick
00001E1A  4EF9 00002BFA           1200          JMP     EA_branch           ; 9: ea_branch
00001E20  4EF8 1DDE               1201          JMP     EA_FINISH
00001E24                          1202          
00001E24                          1203  EA_SIZE_GENERAL
00001E24  B43C 0000               1204          CMP.B   #%00,D2             ; .b
00001E28  6700 00B6               1205          BEQ     EA_SIZE_B       
00001E2C  B43C 0001               1206          CMP.B   #%01,D2             ; .w
00001E30  6700 00B8               1207          BEQ     EA_SIZE_W       
00001E34  B43C 0002               1208          CMP.B   #%10,D2             ; .l
00001E38  6700 00BC               1209          BEQ     EA_SIZE_L
00001E3C  6000 0F52               1210          BRA     EA_WRONG_SIZE       ; wrong size
00001E40                          1211  
00001E40                          1212  EA_SIZE_MOVE
00001E40  B43C 0001               1213          CMP.B   #%01,D2             ; .b
00001E44  6700 009A               1214          BEQ     EA_SIZE_B       
00001E48  B43C 0003               1215          CMP.B   #%11,D2             ; .w
00001E4C  6700 009C               1216          BEQ     EA_SIZE_W       
00001E50  B43C 0002               1217          CMP.B   #%10,D2             ; .l
00001E54  6700 00A0               1218          BEQ     EA_SIZE_L
00001E58  6000 0F36               1219          BRA     EA_WRONG_SIZE       ; wrong size
00001E5C                          1220  
00001E5C                          1221  EA_SIZE_MOVEA     
00001E5C  B43C 0003               1222          CMP.B   #%11,D2             ; .w
00001E60  6700 0088               1223          BEQ     EA_SIZE_W       
00001E64  B43C 0002               1224          CMP.B   #%10,D2             ; .l
00001E68  6700 008C               1225          BEQ     EA_SIZE_L
00001E6C  6000 0F22               1226          BRA     EA_WRONG_SIZE       ; wrong size
00001E70                          1227          
00001E70                          1228  EA_SIZE_MOVEM     
00001E70  B43C 0000               1229          CMP.B   #%0000,D2              ; .w
00001E74  6700 0074               1230          BEQ     EA_SIZE_W       
00001E78  B43C 0004               1231          CMP.B   #%0100,D2              ; .l
00001E7C  6700 0078               1232          BEQ     EA_SIZE_L
00001E80  6000 0F0E               1233          BRA     EA_WRONG_SIZE       ; wrong size
00001E84                          1234  
00001E84                          1235  EA_SIZE_OPMODE_012456               ; Check opmode field for size
00001E84  B43C 0000               1236          CMP.B   #%000,D2            ; When 0 then .b
00001E88  6700 0056               1237          BEQ     EA_SIZE_B
00001E8C  B43C 0004               1238          CMP.B   #%100,D2            ; When 4 then .b
00001E90  6700 004E               1239          BEQ     EA_SIZE_B  
00001E94  B43C 0001               1240          CMP.B   #%001,D2            ; When 1 then .w
00001E98  6700 0050               1241          BEQ     EA_SIZE_W
00001E9C  B43C 0005               1242          CMP.B   #%101,D2            ; When 5 then .w
00001EA0  6700 0048               1243          BEQ     EA_SIZE_W 
00001EA4  B43C 0002               1244          CMP.B   #%010,D2            ; When 2 then .l
00001EA8  6700 004C               1245          BEQ     EA_SIZE_L
00001EAC  B43C 0006               1246          CMP.B   #%110,D2            ; When 6 then .l
00001EB0  6700 0044               1247          BEQ     EA_SIZE_L
00001EB4  6000 0EDA               1248          BRA     EA_WRONG_SIZE       ; wrong size
00001EB8                          1249  
00001EB8                          1250  EA_SIZE_ADDA                        ; Check opmode field for size
00001EB8  B43C 0003               1251          CMP.B   #%011,D2            ; When 3 then .w
00001EBC  6700 002C               1252          BEQ     EA_SIZE_W       
00001EC0  B43C 0007               1253          CMP.B   #%111,D2            ; When 7 then .l
00001EC4  6700 0030               1254          BEQ     EA_SIZE_L
00001EC8  6000 0EC6               1255          BRA     EA_WRONG_SIZE       ; wrong size
00001ECC                          1256                  
00001ECC                          1257  EA_SIZE_MEMORY_SHIFTS
00001ECC  B43C 0000               1258          CMP.B   #%00,D2             ; .w
00001ED0  6700 0022               1259          BEQ     EA_SIZE_W_MEMORY      
00001ED4  B43C 0001               1260          CMP.B   #%01,D2             ; .l
00001ED8  6700 001C               1261          BEQ     EA_SIZE_L      
00001EDC  6000 0EB2               1262          BRA     EA_WRONG_SIZE       ; wrong size
00001EE0                          1263  
00001EE0                          1264  EA_SIZE_B
00001EE0  14FC 002E               1265          MOVE.B  #'.',(A2)+
00001EE4  14FC 0042               1266          MOVE.B  #'B',(A2)+
00001EE8  4E75                    1267          RTS
00001EEA                          1268  EA_SIZE_W
00001EEA  14FC 002E               1269          MOVE.B  #'.',(A2)+
00001EEE  14FC 0057               1270          MOVE.B  #'W',(A2)+
00001EF2  4E75                    1271          RTS     
00001EF4                          1272  EA_SIZE_W_MEMORY
00001EF4  4E75                    1273          RTS        
00001EF6                          1274  EA_SIZE_L
00001EF6  14FC 002E               1275          MOVE.B  #'.',(A2)+
00001EFA  14FC 004C               1276          MOVE.B  #'L',(A2)+
00001EFE  4E75                    1277          RTS
00001F00                          1278  EA_SIZE_DONE
00001F00  4E75                    1279          RTS
00001F02                          1280  *------------------------------------------------------------------------------------------------*     
00001F02                          1281  EA_IMMEDIATE                        ; 0 ea_immediate
00001F02  2200                    1282          MOVE.L  D0,D1
00001F04  0241 01C0               1283          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00001F08  1A3C 0006               1284          MOVE.B  #right6,D5          ; Store 6 into D5
00001F0C  EA69                    1285          LSR.W   D5,D1               ; Shift D1 six times to LSB position
00001F0E  0201 0003               1286          ANDI.B  #3,D1               ; Remove the front bit from D1
00001F12  1401                    1287          MOVE.B  D1,D2               ; Store D1 into D2 (used to check size)
00001F14  4EB8 1E24               1288          JSR     EA_SIZE_GENERAL     ; Get size 
00001F18                          1289          
00001F18  14FC 0020               1290          MOVE.B  #$20,(A2)+          ; Add space after size
00001F1C  14FC 0020               1291          MOVE.B  #$20,(A2)+          ; Add space 
00001F20  14FC 0020               1292          MOVE.B  #$20,(A2)+          ; Add space
00001F24                          1293  
00001F24                          1294          ; Get source and store into decode buffer
00001F24  7804                    1295          MOVE.L  #4,D4               ; Store 100 into D4 (jump to immed)
00001F26  7607                    1296          MOVE.L  #7,D3               ; Store 111 into D3 (Go abs and immed)
00001F28  4EB9 00002C52           1297          JSR     EA_GEN_SRC          ; Get EA src print 
00001F2E                          1298  
00001F2E  14FC 002C               1299          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001F32  14FC 0020               1300          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F36                          1301  
00001F36                          1302          ; Get desination and store into decode buffer
00001F36  2800                    1303          MOVE.L  D0,D4               ; Store the current address into D4 
00001F38  0244 0007               1304          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00001F3C                          1305          
00001F3C  2600                    1306          MOVE.L  D0,D3               ; Store the current address into D3 
00001F3E  0243 0038               1307          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00001F42  1A3C 0003               1308          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00001F46  EA6B                    1309          LSR.W   D5,D3               ; do the actual shift 
00001F48  B63C 0001               1310          CMP.B   #1,D3               ; If dest mode is 001: An
00001F4C  6700 0E62               1311          BEQ     DST_INVALID         ; Go to invalid message 
00001F50  4EB9 00002C52           1312          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00001F56                          1313  
00001F56  4EF8 1DDE               1314          JMP     EA_FINISH           ; Opcode is finish
00001F5A                          1315  *------------------------------------------------------------------------------------------------*
00001F5A                          1316  EA_MOVE                             ; 1: ea_move
00001F5A  2200                    1317          MOVE.L  D0,D1
00001F5C  0241 F000               1318          ANDI.W  #first_nibble,D1
00001F60  1A3C 000C               1319          MOVE.B  #right12,D5 
00001F64  EA69                    1320          LSR.W   D5,D1
00001F66  0201 0003               1321          ANDI.B  #3,D1
00001F6A  1401                    1322          MOVE.B  D1,D2
00001F6C  4EB8 1E40               1323          JSR     EA_SIZE_MOVE
00001F70                          1324          
00001F70  14FC 0020               1325          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001F74  14FC 0020               1326          MOVE.B  #$20,(A2)+          ; Print out a space
00001F78  14FC 0020               1327          MOVE.B  #$20,(A2)+          ; Print out a space
00001F7C                          1328          
00001F7C                          1329          ; Get source and store into decode buffer
00001F7C  2800                    1330          MOVE.L  D0,D4               ; Store the src reg in D4
00001F7E  0244 0007               1331          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001F82                          1332          
00001F82  2600                    1333          MOVE.L  D0,D3               ; Store the src mode in D3
00001F84  0243 0038               1334          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001F88  1A3C 0003               1335          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001F8C  EA6B                    1336          LSR.W   D5,D3               ; Do the actual shift 
00001F8E  4EB9 00002C52           1337          JSR     EA_GEN_SRC
00001F94                          1338          
00001F94  14FC 002C               1339          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00001F98  14FC 0020               1340          MOVE.B  #$20,(A2)+          ; Add space after comma
00001F9C                          1341          
00001F9C                          1342          ; Get desination and store into decode buffer
00001F9C  2800                    1343          MOVE.L  D0,D4               ; Store the dest reg in D4
00001F9E  0244 0E00               1344          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00001FA2  1A3C 0009               1345          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00001FA6  EA6C                    1346          LSR.W   D5,D4               ; Do the actual shift
00001FA8                          1347          
00001FA8  2600                    1348          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00001FAA  0243 01C0               1349          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00001FAE  1A3C 0006               1350          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00001FB2  EA6B                    1351          LSR.W   D5,D3               ; Do the actual shift 
00001FB4  B63C 0001               1352          CMP.B   #1,D3               ; If dest mode is 001: An
00001FB8  6700 0DF6               1353          BEQ     DST_INVALID         ; Go to invalid message 
00001FBC  4EB9 00002C52           1354          JSR     EA_GEN_SRC          ; Get EA print
00001FC2                          1355          
00001FC2  4EF8 1DDE               1356          JMP     EA_FINISH           ; Opcode is finish
00001FC6                          1357  *------------------------------------------------------------------------------------------------*          
00001FC6                          1358  EA_MOVEA                            ; 2: ea_movea
00001FC6  2200                    1359          MOVE.L  D0,D1
00001FC8  0241 F000               1360          ANDI.W  #first_nibble,D1
00001FCC  1A3C 000C               1361          MOVE.B  #right12,D5 
00001FD0  EA69                    1362          LSR.W   D5,D1
00001FD2  0201 0003               1363          ANDI.B  #3,D1
00001FD6  1401                    1364          MOVE.B  D1,D2
00001FD8  4EB8 1E5C               1365          JSR     EA_SIZE_MOVEA 
00001FDC                          1366          
00001FDC  14FC 0020               1367          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001FE0  14FC 0020               1368          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00001FE4                          1369          
00001FE4                          1370          ; Get source and store into decode buffer
00001FE4  2800                    1371          MOVE.L  D0,D4               ; Store the src reg in D4
00001FE6  0244 0007               1372          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00001FEA                          1373          
00001FEA  2600                    1374          MOVE.L  D0,D3               ; Store the src mode in D3
00001FEC  0243 0038               1375          ANDI.W  #src_mode,D3        ; Get bits 5-3
00001FF0  1A3C 0003               1376          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00001FF4  EA6B                    1377          LSR.W   D5,D3               ; Do the actual shift 
00001FF6  4EB9 00002C52           1378          JSR     EA_GEN_SRC
00001FFC                          1379          
00001FFC  14FC 002C               1380          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002000  14FC 0020               1381          MOVE.B  #$20,(A2)+          ; Add space after comma
00002004                          1382          
00002004                          1383          ; Get desination and store into decode buffer
00002004  2800                    1384          MOVE.L  D0,D4               ; Store the dest reg in D4
00002006  0244 0E00               1385          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
0000200A  1A3C 0009               1386          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
0000200E  EA6C                    1387          LSR.W   D5,D4               ; Do the actual shift
00002010                          1388          
00002010  2600                    1389          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00002012  0243 01C0               1390          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00002016  1A3C 0006               1391          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
0000201A  EA6B                    1392          LSR.W   D5,D3               ; Do the actual shift 
0000201C  B63C 0001               1393          CMP.B   #1,D3               ; If dst mode is 001: An 
00002020  6700 0006               1394          BEQ     MOVEA_DST_VALID     ; dst is valid, so branch 
00002024  6000 0D8A               1395          BRA     DST_INVALID         ; Otherwise, go to invalid message 
00002028                          1396          
00002028                          1397  MOVEA_DST_VALID
00002028  4EB9 00002C52           1398          JSR     EA_GEN_SRC          ; Get EA print
0000202E  4EF8 1DDE               1399          JMP     EA_FINISH           ; Opcode is finish
00002032                          1400  *------------------------------------------------------------------------------------------------*
00002032                          1401  EA_LEA                              ; 3: ea_lea
00002032  14FC 0020               1402          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002036  14FC 0020               1403          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000203A  14FC 0020               1404          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000203E  14FC 0020               1405          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002042  14FC 0020               1406          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
00002046  14FC 0020               1407          MOVE.B  #$20,(A2)+          ; print out a space after the LEA
0000204A                          1408  
0000204A  2800                    1409          MOVE.L  D0,D4               ; Store the src reg in D4
0000204C  0244 0007               1410          ANDI.W  #src_reg,D4         ; get the bits at 2-0
00002050                          1411          
00002050  2600                    1412          MOVE.L  D0,D3               ; Store the src mode in D3
00002052  0243 0038               1413          ANDI.W  #src_mode,D3        ; get bits 5-3
00002056  1A3C 0003               1414          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB
0000205A  EA6B                    1415          LSR.W   D5,D3               ; do the actual shift 
0000205C  B67C 0002               1416          CMP     #2,D3               ; If D3 (src mode) is 010 (An)
00002060  6700 000E               1417          BEQ     LEA_SRC_VALID
00002064  B67C 0007               1418          CMP     #7,D3               ; If D3 (src mode) is 111 (W or L)
00002068  6700 0006               1419          BEQ     LEA_SRC_VALID
0000206C  6000 0D52               1420          BRA     SRC_INVALID         ; when src mode is not 010 or 111, branch to error message
00002070                          1421          
00002070                          1422  LEA_SRC_VALID        
00002070  4EB9 00002C52           1423          JSR     EA_GEN_SRC          ; Go to function 
00002076                          1424   
00002076  14FC 002C               1425          MOVE.B  #$2C,(A2)+          ; Add comma after size print
0000207A  14FC 0020               1426          MOVE.B  #$20,(A2)+          ; Add space after comma
0000207E                          1427  
0000207E  2600                    1428          MOVE.L  D0,D3               ; D0 does not change, D3 is used to store the dst mode and src mode 
00002080  0243 01C0               1429          ANDI.W  #dst_mode,D3        ; Get bits 8-6
00002084  1A3C 0006               1430          MOVE.B  #right6,D5          ; Shift the bits 8-6 to the LSB
00002088  EA6B                    1431          LSR.W   D5,D3               ; Do the actual shift
0000208A  B63C 0007               1432          CMP.B   #7,D3               ; Check if D3 is 111
0000208E  6700 0006               1433          BEQ     CHANGE_TO_001       ; change the D3 bits to 001 
00002092  6000 0D1C               1434          BRA     DST_INVALID         ; Print out an error message if bits 8-6 (dst mode) are not 111
00002096                          1435    
00002096                          1436  CHANGE_TO_001
00002096  163C 0001               1437          MOVE.B  #%001,D3            ; set D3 to 001 to ensure the print out A 
0000209A                          1438          
0000209A  2800                    1439          MOVE.L  D0,D4               ; Store the dest reg in D4 to get the Address register number
0000209C  0244 0E00               1440          ANDI.W  #dst_reg,D4         ; get the bits at 11-9
000020A0  1A3C 0009               1441          MOVE.B  #right9,D5          ; shift the bits 11-9 to the LSB
000020A4  EA6C                    1442          LSR.W   D5,D4               ; do the actual shift
000020A6  4EB9 00002C52           1443          JSR     EA_GEN_SRC          ; Print out the address register
000020AC  4EF8 1DDE               1444          JMP     EA_FINISH           ; Opcode is finish
000020B0                          1445  *------------------------------------------------------------------------------------------------*
000020B0                          1446  EA_DSTONLY                          ; 4: ea_dstonly
000020B0  2200                    1447          MOVE.L  D0,D1
000020B2  0241 0F00               1448          ANDI.W  #second_nibble,D1   ; get second nibble from D1
000020B6  1A3C 0008               1449          MOVE.B  #right8,D5 
000020BA  EA69                    1450          LSR.W   D5,D1     
000020BC  B23C 0002               1451          CMP.B   #2, D1              ; When 0010 for second nibble
000020C0  6700 000E               1452          BEQ     EA_CLEAR            ; Then do EA_CLEAR
000020C4  B23C 000E               1453          CMP.B   #$E, D1             ; When 1110 for second nibble
000020C8  6700 0050               1454          BEQ     EA_JSR              ; Then do EA_JSR
000020CC  6000 0CE2               1455          BRA     DST_INVALID     
000020D0                          1456          
000020D0                          1457  EA_CLEAR
000020D0  2200                    1458          MOVE.L  D0,D1
000020D2  0241 01C0               1459          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
000020D6  1A3C 0006               1460          MOVE.B  #right6,D5          ; Store 6 into D5
000020DA  EA69                    1461          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
000020DC  0201 0003               1462          ANDI.B  #3,D1               ; Remove the front bit from D1
000020E0  1401                    1463          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
000020E2  4EB8 1E24               1464          JSR     EA_SIZE_GENERAL     ; Get size 
000020E6                          1465          
000020E6  14FC 0020               1466          MOVE.B  #$20,(A2)+          ; Add space after size
000020EA  14FC 0020               1467          MOVE.B  #$20,(A2)+          ; Add space 
000020EE  14FC 0020               1468          MOVE.B  #$20,(A2)+          ; Add space 
000020F2  14FC 0020               1469          MOVE.B  #$20,(A2)+          ; Add space
000020F6                          1470          
000020F6                          1471          ; Get desination and store into decode buffer
000020F6  2800                    1472          MOVE.L  D0,D4               ; Store the current address into D4 
000020F8  0244 0007               1473          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
000020FC                          1474          
000020FC  2600                    1475          MOVE.L  D0,D3               ; Store the current address into D3 
000020FE  0243 0038               1476          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
00002102  1A3C 0003               1477          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002106  EA6B                    1478          LSR.W   D5,D3               ; do the actual shift 
00002108  B63C 0001               1479          CMP.B   #1,D3               ; If dest mode is 001: An
0000210C  6700 0CA2               1480          BEQ     DST_INVALID         ; Go to invalid message 
00002110  4EB9 00002C52           1481          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
00002116  4EF8 1DDE               1482          JMP     EA_FINISH           ; Opcode is finish
0000211A                          1483          
0000211A  14FC 0020               1484  EA_JSR  MOVE.B  #$20,(A2)+          ; Add space 
0000211E  14FC 0020               1485          MOVE.B  #$20,(A2)+          ; Add space 
00002122  14FC 0020               1486          MOVE.B  #$20,(A2)+          ; Add space 
00002126  14FC 0020               1487          MOVE.B  #$20,(A2)+          ; Add space 
0000212A  14FC 0020               1488          MOVE.B  #$20,(A2)+          ; Add space 
0000212E  14FC 0020               1489          MOVE.B  #$20,(A2)+          ; Add space
00002132                          1490  
00002132                          1491          ; Get EA and store into decode buffer   
00002132  2800                    1492          MOVE.L  D0,D4               ; Store the current address into D4 
00002134  0244 0007               1493          ANDI.W  #src_reg,D4         ; get the bits at 2-0 (D4 stores EA reg)
00002138                          1494          
00002138  2600                    1495          MOVE.L  D0,D3               ; Store the current address into D3 
0000213A  0243 0038               1496          ANDI.W  #src_mode,D3        ; get bits 5-3 (D3 stores EA mode)
0000213E  1A3C 0003               1497          MOVE.B  #right3,D5          ; shift the bits 5-3 to the LSB position
00002142  EA6B                    1498          LSR.W   D5,D3               ; do the actual shift 
00002144  B67C 0002               1499          CMP     #2,D3               ; If D3 (src mode) is 010: (An)
00002148  6700 000E               1500          BEQ     JSR_EA_VALID
0000214C  B67C 0007               1501          CMP     #7,D3               ; If D3 (src mode) is 111: (W or L)
00002150  6700 0006               1502          BEQ     JSR_EA_VALID
00002154  6000 0C7A               1503          BRA     EA_INVALID          ; Otherwise, branch to invalid message
00002158                          1504          
00002158                          1505  JSR_EA_VALID
00002158  4EB9 00002C52           1506          JSR     EA_GEN_SRC          ; When a valid dst, get EA dst print
0000215E  4EF8 1DDE               1507          JMP     EA_FINISH           ; Opcode is finish
00002162                          1508  *------------------------------------------------------------------------------------------------*
00002162                          1509  EA_EXT                              ; 5: ea_ext
00002162  2200                    1510          MOVE.L  D0,D1
00002164  0241 01C0               1511          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1 (get opmode)
00002168  1A3C 0006               1512          MOVE.B  #right6,D5          ; Store 6 into D5
0000216C  EA69                    1513          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
0000216E  1401                    1514          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002170  C2FC 0006               1515          MULU    #6, D1              ; Multiply 6 to D1 
00002174  41F9 0000217E           1516          LEA     EA_EXT_TABLE,A0     ; Load table into A0
0000217A  4EF0 1000               1517          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
0000217E                          1518  
0000217E                          1519  EA_EXT_TABLE
0000217E  4EF9 000021AE           1520          JMP     EA_OPMODE_012456    ; 000: ADD/SUB/CMP/OR/AND
00002184  4EF9 000021AE           1521          JMP     EA_OPMODE_012456    ; 001: ADD/SUB/CMP/OR/AND
0000218A  4EF9 000021AE           1522          JMP     EA_OPMODE_012456    ; 010: ADD/SUB/CMP/OR/AND
00002190  4EF9 0000229C           1523          JMP     EA_OPMODE_37        ; 011: ADDA/MULS/MULU/DIVU
00002196  4EF9 000021AE           1524          JMP     EA_OPMODE_012456    ; 100: ADD/SUB/CMP/OR/AND
0000219C  4EF9 000021AE           1525          JMP     EA_OPMODE_012456    ; 101: ADD/SUB/CMP/OR/AND
000021A2  4EF9 000021AE           1526          JMP     EA_OPMODE_012456    ; 110: ADD/SUB/CMP/OR/AND
000021A8  4EF9 0000229C           1527          JMP     EA_OPMODE_37        ; 111: ADDA/MULS/MULU/DIVU
000021AE                          1528  
000021AE                          1529  EA_OPMODE_012456
000021AE  4EB8 1E84               1530          JSR     EA_SIZE_OPMODE_012456    
000021B2                          1531          
000021B2  14FC 0020               1532          MOVE.B  #$20,(A2)+          ; Print out a space after the size
000021B6  14FC 0020               1533          MOVE.B  #$20,(A2)+          ; Print out a space 
000021BA  14FC 0020               1534          MOVE.B  #$20,(A2)+          ; Print out a space
000021BE  14FC 0020               1535          MOVE.B  #$20,(A2)+          ; Add space
000021C2                          1536          
000021C2                          1537          ; Operation: <ea> + Dn -> Dn
000021C2  B43C 0000               1538          CMP.B   #%000,D2            ; When 0 then Dn is destination
000021C6  6700 002E               1539          BEQ     Dn_DST
000021CA  B43C 0001               1540          CMP.B   #%001,D2            ; When 1 then Dn is destination
000021CE  6700 0026               1541          BEQ     Dn_DST
000021D2  B43C 0002               1542          CMP.B   #%010,D2            ; When 2 then Dn is destination
000021D6  6700 001E               1543          BEQ     Dn_DST
000021DA                          1544          
000021DA                          1545          ; Operation: Dn + <ea> -> <ea>
000021DA  B43C 0004               1546          CMP.B   #%100,D2            ; When 4 then Dn is source
000021DE  6700 0054               1547          BEQ     Dn_SRC  
000021E2  B43C 0005               1548          CMP.B   #%101,D2            ; When 5 then Dn is source
000021E6  6700 004C               1549          BEQ     Dn_SRC 
000021EA  B43C 0006               1550          CMP.B   #%110,D2            ; When 6 then Dn is source
000021EE  6700 0044               1551          BEQ     Dn_SRC 
000021F2                          1552          
000021F2  6000 0BDC               1553          BRA     EA_INVALID
000021F6                          1554  
000021F6                          1555  Dn_DST
000021F6                          1556          ; Get source and store into decode buffer
000021F6  2800                    1557          MOVE.L  D0,D4               ; Store the src reg in D4
000021F8  0244 0007               1558          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000021FC                          1559          
000021FC  2600                    1560          MOVE.L  D0,D3               ; Store the src mode in D3
000021FE  0243 0038               1561          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002202  1A3C 0003               1562          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002206  EA6B                    1563          LSR.W   D5,D3               ; Do the actual shift 
00002208  4EB9 0000227A           1564          JSR     AND_OR_CHECK 
0000220E  4EB9 00002C52           1565          JSR     EA_GEN_SRC          ; Get EA print
00002214                          1566          
00002214  14FC 002C               1567          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002218  14FC 0020               1568          MOVE.B  #$20,(A2)+          ; Add space after comma
0000221C                          1569          
0000221C                          1570          ; Get desination and store into decode buffer
0000221C  2800                    1571          MOVE.L  D0,D4               ; Store the dest reg in D4
0000221E  0244 0E00               1572          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002222  1A3C 0009               1573          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002226  EA6C                    1574          LSR.W   D5,D4               ; Do the actual shift
00002228                          1575          
00002228  7600                    1576          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000222A  4EB9 00002C52           1577          JSR     EA_GEN_SRC          ; Get the Dn print
00002230  4EF8 1DDE               1578          JMP     EA_FINISH           ; Opcode is finish
00002234                          1579            
00002234                          1580  Dn_SRC  
00002234  BC3C 000B               1581          CMP.B   #11,D6              ; If first nibble is 1011 (indicates CMP opcode)
00002238  6700 0B96               1582          BEQ     EA_INVALID          ; Then branch to error message
0000223C                          1583       
0000223C                          1584          ; Get source and store into decode buffer
0000223C  2800                    1585          MOVE.L  D0,D4               ; Store the src reg in D4
0000223E  0244 0E00               1586          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002242  1A3C 0009               1587          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002246  EA6C                    1588          LSR.W   D5,D4               ; Do the actual shift
00002248                          1589          
00002248  7600                    1590          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
0000224A  4EB9 00002C52           1591          JSR     EA_GEN_SRC          ; Get the Dn print
00002250                          1592          
00002250  14FC 002C               1593          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002254  14FC 0020               1594          MOVE.B  #$20,(A2)+          ; Add space after comma
00002258                          1595  
00002258                          1596          ; Get destination and store into decode buffer
00002258  2800                    1597          MOVE.L  D0,D4               ; Store the dst reg in D4
0000225A  0244 0007               1598          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000225E                          1599          
0000225E  2600                    1600          MOVE.L  D0,D3               ; Store the dest mode in D3
00002260  0243 0038               1601          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002264  1A3C 0003               1602          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002268  EA6B                    1603          LSR.W   D5,D3               ; Do the actual shift
0000226A  4EB9 00002D68           1604          JSR     An_CHECK            ; Check if mode is An
00002270                          1605         
00002270  4EB9 00002C52           1606          JSR     EA_GEN_SRC          ; Get EA print
00002276  4EF8 1DDE               1607          JMP     EA_FINISH           ; Opcode is finish
0000227A                          1608  
0000227A                          1609  AND_OR_CHECK
0000227A  BC3C 000C               1610          CMP.B   #12,D6              ; If first nibble is 1100 (indicates AND opcode)
0000227E  6700 000C               1611          BEQ     EA_AND              
00002282  BC3C 0008               1612          CMP.B   #8,D6               ; If first nibble is 1000 (indicates OR opcode)
00002286  6700 000A               1613          BEQ     EA_OR 
0000228A  4E75                    1614          RTS
0000228C                          1615  EA_AND
0000228C  4EF9 00002D68           1616          JMP     An_CHECK            ; Go check if mode is An 
00002292                          1617      
00002292                          1618  EA_OR
00002292  14FC 0020               1619          MOVE.B  #$20,(A2)+          ; Add space
00002296  4EF9 00002D68           1620          JMP     An_CHECK            ; Check if mode is An
0000229C                          1621          
0000229C                          1622  EA_OPMODE_37
0000229C  BC3C 0008               1623          CMP.B   #8,D6               ; If first nibble 1000: DIVU
000022A0  6700 0012               1624          BEQ     EA_MULS_MULU_DIV
000022A4  BC3C 000C               1625          CMP.B   #12,D6              ; If first nibble 1100: MULS/MULU
000022A8  6700 000A               1626          BEQ     EA_MULS_MULU_DIV
000022AC  BC3C 000D               1627          CMP.B   #13,D6              ; If first nibble 1101: ADDA
000022B0  6700 0058               1628          BEQ     EA_ADDA                
000022B4                          1629  
000022B4                          1630  EA_MULS_MULU_DIV
000022B4  143C 0001               1631          MOVE.B  #1,D2               ; Set D2 to 1, since we know size is word   
000022B8                          1632  
000022B8  14FC 0020               1633          MOVE.B  #$20,(A2)+          ; Print out a space
000022BC  14FC 0020               1634          MOVE.B  #$20,(A2)+          ; Print out a space
000022C0  14FC 0020               1635          MOVE.B  #$20,(A2)+          ; Print out a space
000022C4  14FC 0020               1636          MOVE.B  #$20,(A2)+          ; Add space
000022C8  14FC 0020               1637          MOVE.B  #$20,(A2)+          ; Add space
000022CC                          1638  
000022CC                          1639          ; Get source and store into decode buffer
000022CC  2800                    1640          MOVE.L  D0,D4               ; Store the src reg in D4
000022CE  0244 0007               1641          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000022D2                          1642          
000022D2  2600                    1643          MOVE.L  D0,D3               ; Store the src mode in D3
000022D4  0243 0038               1644          ANDI.W  #src_mode,D3        ; Get bits 5-3
000022D8  1A3C 0003               1645          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000022DC  EA6B                    1646          LSR.W   D5,D3               ; Do the actual shift
000022DE  4EB9 00002D68           1647          JSR     An_CHECK            ; Check if mode is An 
000022E4  4EB9 00002C52           1648          JSR     EA_GEN_SRC          ; Go get EA print
000022EA                          1649          
000022EA  14FC 002C               1650          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000022EE  14FC 0020               1651          MOVE.B  #$20,(A2)+          ; Add space after comma
000022F2                          1652          
000022F2                          1653          ; Get desination and store into decode buffer
000022F2  2800                    1654          MOVE.L  D0,D4               ; Store the dest reg in D4
000022F4  0244 0E00               1655          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
000022F8  1A3C 0009               1656          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
000022FC  EA6C                    1657          LSR.W   D5,D4               ; Do the actual shift
000022FE                          1658          
000022FE  7600                    1659          MOVE.L  #0,D3               ; Store 000 into D3, so it can jump to Dn 
00002300  4EB9 00002C52           1660          JSR     EA_GEN_SRC          ; Go get EA print
00002306  4EF8 1DDE               1661          JMP     EA_FINISH           ; Opcode is finish
0000230A                          1662  
0000230A                          1663  EA_ADDA
0000230A  4EB8 1EB8               1664          JSR     EA_SIZE_ADDA        ; Get size    
0000230E                          1665  
0000230E  14FC 0020               1666          MOVE.B  #$20,(A2)+          ; Print out a space after the size
00002312  14FC 0020               1667          MOVE.B  #$20,(A2)+          ; Print out a space
00002316  14FC 0020               1668          MOVE.B  #$20,(A2)+          ; Add space        
0000231A                          1669          
0000231A                          1670          
0000231A                          1671          ; Get source and store into decode buffer
0000231A  2800                    1672          MOVE.L  D0,D4               ; Store the src reg in D4
0000231C  0244 0007               1673          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002320                          1674          
00002320  2600                    1675          MOVE.L  D0,D3               ; Store the src mode in D3
00002322  0243 0038               1676          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002326  1A3C 0003               1677          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000232A  EA6B                    1678          LSR.W   D5,D3               ; Do the actual shift 
0000232C  4EB9 00002C52           1679          JSR     EA_GEN_SRC
00002332                          1680          
00002332  14FC 002C               1681          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002336  14FC 0020               1682          MOVE.B  #$20,(A2)+          ; Add space after comma
0000233A                          1683          
0000233A                          1684          ; Get desination and store into decode buffer
0000233A  2800                    1685          MOVE.L  D0,D4               ; Store the dest reg in D4
0000233C  0244 0E00               1686          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002340  1A3C 0009               1687          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002344  EA6C                    1688          LSR.W   D5,D4               ; Do the actual shift
00002346                          1689          
00002346  7601                    1690          MOVE.L  #1,D3               ; Store 001 into D3, so it can jump to An 
00002348  4EB9 00002C52           1691          JSR     EA_GEN_SRC          ; Go get EA print
0000234E  4EF8 1DDE               1692          JMP     EA_FINISH           ; Opcode is finish
00002352                          1693  *------------------------------------------------------------------------------------------------*
00002352                          1694  EA_MOVEM        ; 6: ea_movem
00002352  2200                    1695          MOVE.L  D0, D1
00002354  0241 00F0               1696          ANDI.W  #third_nibble,D1
00002358  1A3C 0004               1697          MOVE.B  #right4,D5 
0000235C  EA69                    1698          LSR.W   D5,D1
0000235E  0201 0004               1699          ANDI.B  #4,D1
00002362  1401                    1700          MOVE.B  D1,D2
00002364  4EB8 1E70               1701          JSR     EA_SIZE_MOVEM       ; get the size of the MOVEM as .W or .L 
00002368                          1702  
00002368  14FC 0020               1703          MOVE.B  #$20,(A2)+          ; Print out a space after the size
0000236C  14FC 0020               1704          MOVE.B  #$20,(A2)+          ; Print out a space
00002370                          1705          
00002370                          1706  *-----------------------------------------------------------------------------------*
00002370                          1707  * HANDLE the case where src mode is 010. 
00002370  2600                    1708          MOVE.L  D0,D3               ; Store the src mode in D3
00002372  0243 0038               1709          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002376  1A3C 0003               1710          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000237A  EA6B                    1711          LSR.W   D5,D3 
0000237C                          1712  
0000237C  B63C 0002               1713          CMP.B   #2, D3
00002380  6700 0312               1714          BEQ     MEM_TO_REG        
00002384                          1715  
00002384                          1716  *-----------------------------------------------------------------------------------*
00002384                          1717  
00002384  2200                    1718          MOVE.L  D0, D1
00002386  0241 0F00               1719          ANDI.W  #second_nibble,D1
0000238A  1A3C 0008               1720          MOVE.B  #right8,D5 
0000238E  EA69                    1721          LSR.W   D5,D1
00002390  0201 0006               1722          ANDI.B  #6, D1              ; Get the Dr field
00002394                          1723          
00002394  B23C 0000               1724          CMP.B   #0, D1              ; check if Dr field is 0. 
00002398  6700 000A               1725          BEQ     REG_TO_MEM
0000239C                          1726  
0000239C  B23C 0004               1727          CMP.B   #4, D1              ; check if Dr field is 1. 
000023A0  6700 02F2               1728          BEQ     MEM_TO_REG
000023A4                          1729  
000023A4                          1730  REG_TO_MEM                          ; pre-decrement - D7-D0,A7-A0
000023A4  3C15                    1731          MOVE.W  (A5), D6            ; store the register list mask field for REG to MEM
000023A6                          1732          
000023A6                          1733  * Print out the proper data and address registers. 
000023A6                          1734  * FIRST NIBBLE CHECK D0 - D3
000023A6                          1735  *-----------------------------------------------------------------------------------*
000023A6                          1736  * Print out D0 if mask field states to. 
000023A6                          1737  
000023A6  3606                    1738          MOVE.W  D6, D3
000023A8  0243 F000               1739          ANDI.W  #first_nibble,D3
000023AC  1A3C 000C               1740          MOVE.B  #right12,D5 
000023B0  EA6B                    1741          LSR.W   D5,D3
000023B2  0203 0008               1742          ANDI.B  #8,D3
000023B6  B63C 0008               1743          CMP.B   #8,D3
000023BA  6700 0006               1744          BEQ     D4_Dn_SETONE_0      ; SETONE refers to the set for reg to mem branch. 
000023BE  6000 0014               1745          BRA     CHECK1_BIT_14
000023C2                          1746  D4_Dn_SETONE_0
000023C2  183C 0000               1747          MOVE.B  #$0, D4
000023C6                          1748          
000023C6  6000 0002               1749          BRA     PRINT1_D0
000023CA                          1750          
000023CA                          1751  PRINT1_D0
000023CA  4EB9 00002C90           1752          JSR     EA_Dn
000023D0  14FC 002F               1753          MOVE.B  #$2F,(A2)+
000023D4                          1754          
000023D4                          1755  *-----------------------------------------------------------------------------------*
000023D4                          1756  * Print out D1 if mask field states to. 
000023D4                          1757  
000023D4                          1758  CHECK1_BIT_14
000023D4  3606                    1759          MOVE.W  D6, D3
000023D6  0243 F000               1760          ANDI.W  #first_nibble,D3
000023DA  1A3C 000C               1761          MOVE.B  #right12,D5 
000023DE  EA6B                    1762          LSR.W   D5,D3
000023E0  0203 0004               1763          ANDI.B  #4,D3
000023E4  B63C 0004               1764          CMP.B   #4,D3
000023E8  6700 0006               1765          BEQ     D4_Dn_SETONE_1      ; SETONE refers to the set for reg to mem branch. 
000023EC  6000 0014               1766          BRA     CHECK1_BIT_13
000023F0                          1767  D4_Dn_SETONE_1
000023F0  183C 0001               1768          MOVE.B  #$1, D4
000023F4                          1769          
000023F4  6000 0002               1770          BRA     PRINT1_D1
000023F8                          1771          
000023F8                          1772  PRINT1_D1
000023F8  4EB9 00002C90           1773          JSR     EA_Dn
000023FE  14FC 002F               1774          MOVE.B  #$2F,(A2)+
00002402                          1775  
00002402                          1776  *-----------------------------------------------------------------------------------*
00002402                          1777  * Print out D2 if mask field states to. 
00002402                          1778  
00002402                          1779  CHECK1_BIT_13
00002402  3606                    1780          MOVE.W  D6, D3
00002404  0243 F000               1781          ANDI.W  #first_nibble,D3
00002408  1A3C 000C               1782          MOVE.B  #right12,D5 
0000240C  EA6B                    1783          LSR.W   D5,D3
0000240E  0203 0002               1784          ANDI.B  #2,D3
00002412  B63C 0002               1785          CMP.B   #2,D3
00002416  6700 0006               1786          BEQ     D4_Dn_SETONE_2      ; SETONE refers to the set for reg to mem branch. 
0000241A  6000 0014               1787          BRA     CHECK1_BIT_12
0000241E                          1788  D4_Dn_SETONE_2
0000241E  183C 0002               1789          MOVE.B  #$2, D4
00002422                          1790          
00002422  6000 0002               1791          BRA     PRINT1_D2
00002426                          1792          
00002426                          1793  PRINT1_D2
00002426  4EB9 00002C90           1794          JSR     EA_Dn
0000242C  14FC 002F               1795          MOVE.B  #$2F,(A2)+       
00002430                          1796  
00002430                          1797  *-----------------------------------------------------------------------------------*
00002430                          1798  * Print out D3 if mask field states to. 
00002430                          1799  
00002430                          1800  CHECK1_BIT_12
00002430  3606                    1801          MOVE.W  D6, D3
00002432  0243 F000               1802          ANDI.W  #first_nibble,D3
00002436  1A3C 000C               1803          MOVE.B  #right12,D5 
0000243A  EA6B                    1804          LSR.W   D5,D3
0000243C  0203 0001               1805          ANDI.B  #1,D3
00002440  B63C 0001               1806          CMP.B   #1,D3
00002444  6700 0006               1807          BEQ     D4_Dn_SETONE_3      ; SETONE refers to the set for reg to mem branch. 
00002448  6000 0014               1808          BRA     CHECK1_BIT_11
0000244C                          1809  D4_Dn_SETONE_3
0000244C  183C 0003               1810          MOVE.B  #$3, D4
00002450                          1811          
00002450  6000 0002               1812          BRA     PRINT1_D3
00002454                          1813          
00002454                          1814  PRINT1_D3
00002454  4EB9 00002C90           1815          JSR     EA_Dn
0000245A  14FC 002F               1816          MOVE.B  #$2F,(A2)+ 
0000245E                          1817          
0000245E                          1818  * SECOND NIBBLE CHECK D4 - D7
0000245E                          1819  *-----------------------------------------------------------------------------------*
0000245E                          1820  * Print out D4 if mask field states to. 
0000245E                          1821  
0000245E                          1822  
0000245E                          1823  CHECK1_BIT_11
0000245E  3606                    1824          MOVE.W  D6, D3
00002460  0243 0F00               1825          ANDI.W  #second_nibble,D3
00002464  1A3C 0008               1826          MOVE.B  #right8,D5 
00002468  EA6B                    1827          LSR.W   D5,D3
0000246A  0203 0008               1828          ANDI.B  #8,D3
0000246E  B63C 0008               1829          CMP.B   #8,D3
00002472  6700 0006               1830          BEQ     D4_Dn_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
00002476  6000 0014               1831          BRA     CHECK1_BIT_10
0000247A                          1832  D4_Dn_SETONE_4
0000247A  183C 0004               1833          MOVE.B  #$4, D4
0000247E                          1834          
0000247E  6000 0002               1835          BRA     PRINT1_D4
00002482                          1836          
00002482                          1837  PRINT1_D4
00002482  4EB9 00002C90           1838          JSR     EA_Dn
00002488  14FC 002F               1839          MOVE.B  #$2F,(A2)+ 
0000248C                          1840  
0000248C                          1841  *-----------------------------------------------------------------------------------*
0000248C                          1842  * Print out D5 if mask field states to. 
0000248C                          1843  
0000248C                          1844  CHECK1_BIT_10
0000248C  3606                    1845          MOVE.W  D6, D3
0000248E  0243 0F00               1846          ANDI.W  #second_nibble,D3
00002492  1A3C 0008               1847          MOVE.B  #right8,D5 
00002496  EA6B                    1848          LSR.W   D5,D3
00002498  0203 0004               1849          ANDI.B  #4,D3
0000249C  B63C 0004               1850          CMP.B   #4,D3
000024A0  6700 0006               1851          BEQ     D4_Dn_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
000024A4  6000 0014               1852          BRA     CHECK1_BIT_9
000024A8                          1853  D4_Dn_SETONE_5
000024A8  183C 0005               1854          MOVE.B  #$5, D4
000024AC                          1855          
000024AC  6000 0002               1856          BRA     PRINT1_D5
000024B0                          1857          
000024B0                          1858  PRINT1_D5
000024B0  4EB9 00002C90           1859          JSR     EA_Dn
000024B6  14FC 002F               1860          MOVE.B  #$2F,(A2)+ 
000024BA                          1861  
000024BA                          1862  *-----------------------------------------------------------------------------------*
000024BA                          1863  * Print out D6 if mask field states to. 
000024BA                          1864  
000024BA                          1865  CHECK1_BIT_9
000024BA  3606                    1866          MOVE.W  D6, D3
000024BC  0243 0F00               1867          ANDI.W  #second_nibble,D3
000024C0  1A3C 0008               1868          MOVE.B  #right8,D5 
000024C4  EA6B                    1869          LSR.W   D5,D3
000024C6  0203 0002               1870          ANDI.B  #2,D3
000024CA  B63C 0002               1871          CMP.B   #2,D3
000024CE  6700 0006               1872          BEQ     D4_Dn_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
000024D2  6000 0014               1873          BRA     CHECK1_BIT_8
000024D6                          1874  D4_Dn_SETONE_6
000024D6  183C 0006               1875          MOVE.B  #$6, D4
000024DA                          1876          
000024DA  6000 0002               1877          BRA     PRINT1_D6
000024DE                          1878          
000024DE                          1879  PRINT1_D6
000024DE  4EB9 00002C90           1880          JSR     EA_Dn
000024E4  14FC 002F               1881          MOVE.B  #$2F,(A2)+ 
000024E8                          1882          
000024E8                          1883  *-----------------------------------------------------------------------------------*
000024E8                          1884  * Print out D7 if mask field states to. 
000024E8                          1885  
000024E8                          1886  CHECK1_BIT_8
000024E8  3606                    1887          MOVE.W  D6, D3
000024EA  0243 0F00               1888          ANDI.W  #second_nibble,D3
000024EE  1A3C 0008               1889          MOVE.B  #right8,D5 
000024F2  EA6B                    1890          LSR.W   D5,D3
000024F4  0203 0001               1891          ANDI.B  #1,D3
000024F8  B63C 0001               1892          CMP.B   #1,D3
000024FC  6700 0006               1893          BEQ     D4_Dn_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
00002500  6000 0014               1894          BRA     CHECK1_BIT_7
00002504                          1895  D4_Dn_SETONE_7
00002504  183C 0007               1896          MOVE.B  #$7, D4
00002508                          1897          
00002508  6000 0002               1898          BRA     PRINT1_D7
0000250C                          1899          
0000250C                          1900  PRINT1_D7
0000250C  4EB9 00002C90           1901          JSR     EA_Dn
00002512  14FC 002F               1902          MOVE.B  #$2F,(A2)+ 
00002516                          1903  
00002516                          1904  * THIRD NIBBLE CHECK - A0 / A3
00002516                          1905  *-----------------------------------------------------------------------------------*
00002516                          1906  * Print out A0 if mask field states to. 
00002516                          1907  
00002516                          1908  CHECK1_BIT_7
00002516  3606                    1909          MOVE.W  D6, D3
00002518  0243 00F0               1910          ANDI.W  #third_nibble,D3
0000251C  1A3C 0004               1911          MOVE.B  #right4,D5 
00002520  EA6B                    1912          LSR.W   D5,D3
00002522  0203 0008               1913          ANDI.B  #8,D3
00002526  B63C 0008               1914          CMP.B   #8,D3
0000252A  6700 0006               1915          BEQ     D4_An_SETONE_0       ; SETONE refers to the set for reg to mem branch. 
0000252E  6000 0014               1916          BRA     CHECK1_BIT_6
00002532                          1917  D4_An_SETONE_0
00002532  183C 0000               1918          MOVE.B  #$0, D4
00002536                          1919          
00002536  6000 0002               1920          BRA     PRINT1_A0
0000253A                          1921          
0000253A                          1922  PRINT1_A0
0000253A  4EB9 00002C9C           1923          JSR     EA_An
00002540  14FC 002F               1924          MOVE.B  #$2F,(A2)+ 
00002544                          1925          
00002544                          1926  *-----------------------------------------------------------------------------------*
00002544                          1927  * Print out A1 if mask field states to. 
00002544                          1928  
00002544                          1929  CHECK1_BIT_6
00002544  3606                    1930          MOVE.W  D6, D3
00002546  0243 00F0               1931          ANDI.W  #third_nibble,D3
0000254A  1A3C 0004               1932          MOVE.B  #right4,D5 
0000254E  EA6B                    1933          LSR.W   D5,D3
00002550  0203 0004               1934          ANDI.B  #4,D3
00002554  B63C 0004               1935          CMP.B   #4,D3
00002558  6700 0006               1936          BEQ     D4_An_SETONE_1       ; SETONE refers to the set for reg to mem branch. 
0000255C  6000 0014               1937          BRA     CHECK1_BIT_5
00002560                          1938  D4_An_SETONE_1
00002560  183C 0001               1939          MOVE.B  #$1, D4
00002564                          1940          
00002564  6000 0002               1941          BRA     PRINT1_A1
00002568                          1942          
00002568                          1943  PRINT1_A1
00002568  4EB9 00002C9C           1944          JSR     EA_An
0000256E  14FC 002F               1945          MOVE.B  #$2F,(A2)+ 
00002572                          1946  
00002572                          1947  *-----------------------------------------------------------------------------------*
00002572                          1948  * Print out A2 if mask field states to. 
00002572                          1949  
00002572                          1950  CHECK1_BIT_5
00002572  3606                    1951          MOVE.W  D6, D3
00002574  0243 00F0               1952          ANDI.W  #third_nibble,D3
00002578  1A3C 0004               1953          MOVE.B  #right4,D5 
0000257C  EA6B                    1954          LSR.W   D5,D3
0000257E  0203 0002               1955          ANDI.B  #2,D3
00002582  B63C 0002               1956          CMP.B   #2,D3
00002586  6700 0006               1957          BEQ     D4_An_SETONE_2       ; SETONE refers to the set for reg to mem branch. 
0000258A  6000 0014               1958          BRA     CHECK1_BIT_4
0000258E                          1959  D4_An_SETONE_2
0000258E  183C 0002               1960          MOVE.B  #$2, D4
00002592                          1961          
00002592  6000 0002               1962          BRA     PRINT1_A2
00002596                          1963          
00002596                          1964  PRINT1_A2
00002596  4EB9 00002C9C           1965          JSR     EA_An
0000259C  14FC 002F               1966          MOVE.B  #$2F,(A2)+ 
000025A0                          1967  
000025A0                          1968  *-----------------------------------------------------------------------------------*
000025A0                          1969  * Print out A3 if mask field states to. 
000025A0                          1970  
000025A0                          1971  CHECK1_BIT_4
000025A0  3606                    1972          MOVE.W  D6, D3
000025A2  0243 00F0               1973          ANDI.W  #third_nibble,D3
000025A6  1A3C 0004               1974          MOVE.B  #right4,D5 
000025AA  EA6B                    1975          LSR.W   D5,D3
000025AC  0203 0001               1976          ANDI.B  #1,D3
000025B0  B63C 0001               1977          CMP.B   #1,D3
000025B4  6700 0006               1978          BEQ     D4_An_SETONE_3       ; SETONE refers to the set for reg to mem branch. 
000025B8  6000 0014               1979          BRA     CHECK1_BIT_3
000025BC                          1980  D4_An_SETONE_3
000025BC  183C 0003               1981          MOVE.B  #$3, D4
000025C0                          1982          
000025C0  6000 0002               1983          BRA     PRINT1_A3
000025C4                          1984          
000025C4                          1985  PRINT1_A3
000025C4  4EB9 00002C9C           1986          JSR     EA_An
000025CA  14FC 002F               1987          MOVE.B  #$2F,(A2)+ 
000025CE                          1988  
000025CE                          1989  * FOURTH NIBBLE CHECK A4 - A7 
000025CE                          1990  *-----------------------------------------------------------------------------------*
000025CE                          1991  * Print out A4 if mask field states to. 
000025CE                          1992  
000025CE                          1993  CHECK1_BIT_3
000025CE  3606                    1994          MOVE.W  D6, D3
000025D0  0243 000F               1995          ANDI.W  #fourth_nibble,D3
000025D4  0203 0008               1996          ANDI.B  #8,D3
000025D8  B63C 0008               1997          CMP.B   #8,D3
000025DC  6700 0006               1998          BEQ     D4_An_SETONE_4       ; SETONE refers to the set for reg to mem branch. 
000025E0  6000 0014               1999          BRA     CHECK1_BIT_2
000025E4                          2000  D4_An_SETONE_4
000025E4  183C 0004               2001          MOVE.B  #$4, D4
000025E8                          2002          
000025E8  6000 0002               2003          BRA     PRINT1_A4
000025EC                          2004          
000025EC                          2005  PRINT1_A4
000025EC  4EB9 00002C9C           2006          JSR     EA_An
000025F2  14FC 002F               2007          MOVE.B  #$2F,(A2)+ 
000025F6                          2008  
000025F6                          2009  *-----------------------------------------------------------------------------------*
000025F6                          2010  * Print out A5 if mask field states to. 
000025F6                          2011  
000025F6                          2012  CHECK1_BIT_2
000025F6  3606                    2013          MOVE.W  D6, D3
000025F8  0243 000F               2014          ANDI.W  #fourth_nibble,D3
000025FC  0203 0004               2015          ANDI.B  #4,D3
00002600  B63C 0004               2016          CMP.B   #4,D3
00002604  6700 0006               2017          BEQ     D4_An_SETONE_5       ; SETONE refers to the set for reg to mem branch. 
00002608  6000 0014               2018          BRA     CHECK1_BIT_1
0000260C                          2019  D4_An_SETONE_5
0000260C  183C 0005               2020          MOVE.B  #$5, D4
00002610                          2021          
00002610  6000 0002               2022          BRA     PRINT1_A5
00002614                          2023          
00002614                          2024  PRINT1_A5
00002614  4EB9 00002C9C           2025          JSR     EA_An
0000261A  14FC 002F               2026          MOVE.B  #$2F,(A2)+ 
0000261E                          2027  
0000261E                          2028  *-----------------------------------------------------------------------------------*
0000261E                          2029  * Print out A6 if mask field states to. 
0000261E                          2030  
0000261E                          2031  CHECK1_BIT_1
0000261E  3606                    2032          MOVE.W  D6, D3
00002620  0243 000F               2033          ANDI.W  #fourth_nibble,D3
00002624  0203 0002               2034          ANDI.B  #2,D3
00002628  B63C 0002               2035          CMP.B   #2,D3
0000262C  6700 0006               2036          BEQ     D4_An_SETONE_6       ; SETONE refers to the set for reg to mem branch. 
00002630  6000 0014               2037          BRA     CHECK1_BIT_0
00002634                          2038  D4_An_SETONE_6
00002634  183C 0006               2039          MOVE.B  #$6, D4
00002638                          2040          
00002638  6000 0002               2041          BRA     PRINT1_A6
0000263C                          2042          
0000263C                          2043  PRINT1_A6
0000263C  4EB9 00002C9C           2044          JSR     EA_An
00002642  14FC 002F               2045          MOVE.B  #$2F,(A2)+ 
00002646                          2046  
00002646                          2047  *-----------------------------------------------------------------------------------*
00002646                          2048  * Print out A7 if mask field states to. 
00002646                          2049  
00002646                          2050  CHECK1_BIT_0
00002646  3606                    2051          MOVE.W  D6, D3
00002648  0243 000F               2052          ANDI.W  #fourth_nibble,D3
0000264C  0203 0001               2053          ANDI.B  #1,D3
00002650  B63C 0001               2054          CMP.B   #1,D3
00002654  6700 0006               2055          BEQ     D4_An_SETONE_7       ; SETONE refers to the set for reg to mem branch. 
00002658  6000 0014               2056          BRA     FINISH_REG_TO_MEM
0000265C                          2057  D4_An_SETONE_7
0000265C  183C 0007               2058          MOVE.B  #$7, D4
00002660                          2059          
00002660  6000 0002               2060          BRA     PRINT1_A7
00002664                          2061          
00002664                          2062  PRINT1_A7
00002664  4EB9 00002C9C           2063          JSR     EA_An
0000266A  14FC 002F               2064          MOVE.B  #$2F,(A2)+ 
0000266E                          2065  
0000266E                          2066  FINISH_REG_TO_MEM
0000266E  14FC 002C               2067          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002672  14FC 0020               2068          MOVE.B  #$20,(A2)+          ; Add space after comma
00002676                          2069  
00002676  2800                    2070          MOVE.L  D0,D4               ; Store the src reg in D4
00002678  0244 0007               2071          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
0000267C                          2072          
0000267C  2600                    2073          MOVE.L  D0,D3               ; Store the src mode in D3
0000267E  0243 0038               2074          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002682  1A3C 0003               2075          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002686  EA6B                    2076          LSR.W   D5,D3               ; Do the actual shift 
00002688  4EB9 00002C52           2077          JSR     EA_GEN_SRC
0000268E                          2078          
0000268E  301D                    2079          MOVE.W  (A5)+, D0 
00002690                          2080  
00002690  4EF8 1DDE               2081          JMP     EA_FINISH
00002694                          2082  
00002694                          2083  MEM_TO_REG                          ; post-increment + A7-A0,D7-D0
00002694                          2084  
00002694  B63C 0002               2085          CMP.B   #2, D3              ; check if the destination is (An)
00002698  6700 0022               2086          BEQ     MEM_TO_REG_CONTINUE ; branch to print out the address and data registers. 
0000269C                          2087          
0000269C  2800                    2088          MOVE.L  D0,D4               ; Store the src reg in D4
0000269E  0244 0007               2089          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
000026A2                          2090          
000026A2  2600                    2091          MOVE.L  D0,D3               ; Store the src mode in D3
000026A4  0243 0038               2092          ANDI.W  #src_mode,D3        ; Get bits 5-3
000026A8  1A3C 0003               2093          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
000026AC  EA6B                    2094          LSR.W   D5,D3               ; Do the actual shift 
000026AE  4EB9 00002C52           2095          JSR     EA_GEN_SRC
000026B4                          2096          
000026B4  14FC 002C               2097          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000026B8  14FC 0020               2098          MOVE.B  #$20,(A2)+          ; Add space after comma
000026BC                          2099  
000026BC                          2100          
000026BC                          2101  * Print out the proper data and address registers. 
000026BC                          2102  * FIRST NIBBLE CHECK A7 - A4
000026BC                          2103  *-----------------------------------------------------------------------------------*
000026BC                          2104  * Print out A7 if mask field states to. 
000026BC                          2105  MEM_TO_REG_CONTINUE
000026BC  3C15                    2106          MOVE.W  (A5), D6            ; store the register list mask field for MEM to REG
000026BE                          2107          
000026BE  3606                    2108          MOVE.W  D6, D3
000026C0  0243 F000               2109          ANDI.W  #first_nibble,D3
000026C4  1A3C 000C               2110          MOVE.B  #right12,D5 
000026C8  EA6B                    2111          LSR.W   D5,D3
000026CA  0203 0008               2112          ANDI.B  #8,D3
000026CE  B63C 0008               2113          CMP.B   #8,D3
000026D2  6700 0006               2114          BEQ     D4_An_SET_7
000026D6  6000 0014               2115          BRA     CHECK_BIT_14
000026DA                          2116  D4_An_SET_7
000026DA  183C 0007               2117          MOVE.B  #$7, D4
000026DE                          2118          
000026DE  6000 0002               2119          BRA     PRINT_A7
000026E2                          2120          
000026E2                          2121  PRINT_A7
000026E2  4EB9 00002C9C           2122          JSR     EA_An
000026E8  14FC 002F               2123          MOVE.B  #$2F,(A2)+
000026EC                          2124          
000026EC                          2125  *-----------------------------------------------------------------------------------*
000026EC                          2126  * Print out A6 if mask field states to. 
000026EC                          2127  
000026EC                          2128  CHECK_BIT_14
000026EC  3606                    2129          MOVE.W  D6, D3
000026EE  0243 F000               2130          ANDI.W  #first_nibble,D3
000026F2  1A3C 000C               2131          MOVE.B  #right12,D5 
000026F6  EA6B                    2132          LSR.W   D5,D3
000026F8  0203 0004               2133          ANDI.B  #4,D3
000026FC  B63C 0004               2134          CMP.B   #4,D3
00002700  6700 0006               2135          BEQ     D4_An_SET_6
00002704  6000 0014               2136          BRA     CHECK_BIT_13
00002708                          2137  D4_An_SET_6
00002708  183C 0006               2138          MOVE.B  #$6, D4
0000270C                          2139          
0000270C  6000 0002               2140          BRA     PRINT_A6
00002710                          2141          
00002710                          2142  PRINT_A6
00002710  4EB9 00002C9C           2143          JSR     EA_An
00002716  14FC 002F               2144          MOVE.B  #$2F,(A2)+
0000271A                          2145  
0000271A                          2146  *-----------------------------------------------------------------------------------*
0000271A                          2147  * Print out A5 if mask field states to. 
0000271A                          2148  
0000271A                          2149  CHECK_BIT_13
0000271A  3606                    2150          MOVE.W  D6, D3
0000271C  0243 F000               2151          ANDI.W  #first_nibble,D3
00002720  1A3C 000C               2152          MOVE.B  #right12,D5 
00002724  EA6B                    2153          LSR.W   D5,D3
00002726  0203 0002               2154          ANDI.B  #2,D3
0000272A  B63C 0002               2155          CMP.B   #2,D3
0000272E  6700 0006               2156          BEQ     D4_An_SET_5
00002732  6000 0014               2157          BRA     CHECK_BIT_12
00002736                          2158  D4_An_SET_5
00002736  183C 0005               2159          MOVE.B  #$5, D4
0000273A                          2160          
0000273A  6000 0002               2161          BRA     PRINT_A5
0000273E                          2162          
0000273E                          2163  PRINT_A5
0000273E  4EB9 00002C9C           2164          JSR     EA_An
00002744  14FC 002F               2165          MOVE.B  #$2F,(A2)+
00002748                          2166  
00002748                          2167  *-----------------------------------------------------------------------------------*
00002748                          2168  * Print out A4 if mask field states to. 
00002748                          2169          
00002748                          2170  CHECK_BIT_12
00002748  3606                    2171          MOVE.W  D6, D3
0000274A  0243 F000               2172          ANDI.W  #first_nibble,D3
0000274E  1A3C 000C               2173          MOVE.B  #right12,D5 
00002752  EA6B                    2174          LSR.W   D5,D3
00002754  0203 0001               2175          ANDI.B  #1,D3
00002758  B63C 0001               2176          CMP.B   #1,D3
0000275C  6700 0006               2177          BEQ     D4_An_SET_4
00002760  6000 0014               2178          BRA     CHECK_BIT_11
00002764                          2179  D4_An_SET_4
00002764  183C 0004               2180          MOVE.B  #$4, D4
00002768                          2181          
00002768  6000 0002               2182          BRA     PRINT_A4
0000276C                          2183          
0000276C                          2184  PRINT_A4
0000276C  4EB9 00002C9C           2185          JSR     EA_An
00002772  14FC 002F               2186          MOVE.B  #$2F,(A2)+
00002776                          2187  
00002776                          2188  *-----------------------------------------------------------------------------------*
00002776                          2189  * Print out A3 if mask field states to. 
00002776                          2190  * SECOND NIBBLE CHECK A7 - A4
00002776                          2191    
00002776                          2192  CHECK_BIT_11
00002776  3606                    2193          MOVE.W  D6, D3
00002778  0243 0F00               2194          ANDI.W  #second_nibble,D3
0000277C  1A3C 0008               2195          MOVE.B  #right8,D5 
00002780  EA6B                    2196          LSR.W   D5,D3
00002782  0203 0008               2197          ANDI.B  #8,D3
00002786  B63C 0008               2198          CMP.B   #8,D3
0000278A  6700 0006               2199          BEQ     D4_An_SET_3
0000278E  6000 0014               2200          BRA     CHECK_BIT_10
00002792                          2201  D4_An_SET_3
00002792  183C 0003               2202          MOVE.B  #$3, D4
00002796                          2203          
00002796  6000 0002               2204          BRA     PRINT_A3
0000279A                          2205          
0000279A                          2206  PRINT_A3
0000279A  4EB9 00002C9C           2207          JSR     EA_An
000027A0  14FC 002F               2208          MOVE.B  #$2F,(A2)+     
000027A4                          2209  
000027A4                          2210  *-----------------------------------------------------------------------------------*
000027A4                          2211  * Print out A2 if mask field states to. 
000027A4                          2212    
000027A4                          2213  CHECK_BIT_10
000027A4  3606                    2214          MOVE.W  D6, D3
000027A6  0243 0F00               2215          ANDI.W  #second_nibble,D3
000027AA  1A3C 0008               2216          MOVE.B  #right8,D5 
000027AE  EA6B                    2217          LSR.W   D5,D3
000027B0  0203 0004               2218          ANDI.B  #4,D3
000027B4  B63C 0004               2219          CMP.B   #4,D3
000027B8  6700 0006               2220          BEQ     D4_An_SET_2
000027BC  6000 0014               2221          BRA     CHECK_BIT_9
000027C0                          2222  D4_An_SET_2
000027C0  183C 0002               2223          MOVE.B  #$2, D4
000027C4                          2224          
000027C4  6000 0002               2225          BRA     PRINT_A2
000027C8                          2226          
000027C8                          2227  PRINT_A2
000027C8  4EB9 00002C9C           2228          JSR     EA_An
000027CE  14FC 002F               2229          MOVE.B  #$2F,(A2)+  
000027D2                          2230  
000027D2                          2231  *-----------------------------------------------------------------------------------*
000027D2                          2232  * Print out A1 if mask field states to. 
000027D2                          2233    
000027D2                          2234  CHECK_BIT_9
000027D2  3606                    2235          MOVE.W  D6, D3
000027D4  0243 0F00               2236          ANDI.W  #second_nibble,D3
000027D8  1A3C 0008               2237          MOVE.B  #right8,D5 
000027DC  EA6B                    2238          LSR.W   D5,D3
000027DE  0203 0002               2239          ANDI.B  #2,D3
000027E2  B63C 0002               2240          CMP.B   #2,D3
000027E6  6700 0006               2241          BEQ     D4_An_SET_1
000027EA  6000 0012               2242          BRA     CHECK_BIT_8
000027EE                          2243  D4_An_SET_1
000027EE  183C 0001               2244          MOVE.B  #$1, D4
000027F2                          2245          
000027F2  60D4                    2246          BRA     PRINT_A2
000027F4                          2247          
000027F4                          2248  PRINT_A1
000027F4  4EB9 00002C9C           2249          JSR     EA_An
000027FA  14FC 002F               2250          MOVE.B  #$2F,(A2)+ 
000027FE                          2251  
000027FE                          2252  *-----------------------------------------------------------------------------------*
000027FE                          2253  * Print out A0 if mask field states to. 
000027FE                          2254    
000027FE                          2255  CHECK_BIT_8
000027FE  3606                    2256          MOVE.W  D6, D3
00002800  0243 0F00               2257          ANDI.W  #second_nibble,D3
00002804  1A3C 0008               2258          MOVE.B  #right8,D5 
00002808  EA6B                    2259          LSR.W   D5,D3
0000280A  0203 0001               2260          ANDI.B  #1,D3
0000280E  B63C 0001               2261          CMP.B   #1,D3
00002812  6700 0006               2262          BEQ     D4_An_SET_0
00002816  6000 0014               2263          BRA     CHECK_BIT_7
0000281A                          2264  D4_An_SET_0
0000281A  183C 0000               2265          MOVE.B  #$0, D4
0000281E                          2266          
0000281E  6000 0002               2267          BRA     PRINT_A0
00002822                          2268          
00002822                          2269  PRINT_A0
00002822  4EB9 00002C9C           2270          JSR     EA_An
00002828  14FC 002F               2271          MOVE.B  #$2F,(A2)+        
0000282C                          2272  
0000282C                          2273  *-----------------------------------------------------------------------------------*
0000282C                          2274  * Print out D7 if mask field states to. 
0000282C                          2275  * THIRD NIBBLE CHECK D7-D0
0000282C                          2276  
0000282C                          2277  CHECK_BIT_7
0000282C  3606                    2278          MOVE.W  D6, D3
0000282E  0243 00F0               2279          ANDI.W  #third_nibble,D3
00002832  1A3C 0004               2280          MOVE.B  #right4,D5 
00002836  EA6B                    2281          LSR.W   D5,D3
00002838  0203 0008               2282          ANDI.B  #8,D3
0000283C  B63C 0008               2283          CMP.B   #8,D3
00002840  6700 0006               2284          BEQ     D4_Dn_SET_7
00002844  6000 0014               2285          BRA     CHECK_BIT_6
00002848                          2286  D4_Dn_SET_7
00002848  183C 0007               2287          MOVE.B  #$7, D4
0000284C                          2288          
0000284C  6000 0002               2289          BRA     PRINT_D7
00002850                          2290          
00002850                          2291  PRINT_D7
00002850  4EB9 00002C90           2292          JSR     EA_Dn
00002856  14FC 002F               2293          MOVE.B  #$2F,(A2)+
0000285A                          2294  
0000285A                          2295  *-----------------------------------------------------------------------------------*
0000285A                          2296  * Print out D6 if mask field states to. 
0000285A                          2297  
0000285A                          2298  CHECK_BIT_6
0000285A  3606                    2299          MOVE.W  D6, D3
0000285C  0243 00F0               2300          ANDI.W  #third_nibble,D3
00002860  1A3C 0004               2301          MOVE.B  #right4,D5 
00002864  EA6B                    2302          LSR.W   D5,D3
00002866  0203 0004               2303          ANDI.B  #4,D3
0000286A  B63C 0004               2304          CMP.B   #4,D3
0000286E  6700 0006               2305          BEQ     D4_Dn_SET_6
00002872  6000 0014               2306          BRA     CHECK_BIT_5
00002876                          2307  D4_Dn_SET_6
00002876  183C 0006               2308          MOVE.B  #$6, D4
0000287A                          2309          
0000287A  6000 0002               2310          BRA     PRINT_D6
0000287E                          2311          
0000287E                          2312  PRINT_D6
0000287E  4EB9 00002C90           2313          JSR     EA_Dn
00002884  14FC 002F               2314          MOVE.B  #$2F,(A2)+
00002888                          2315  
00002888                          2316  *-----------------------------------------------------------------------------------*
00002888                          2317  * Print out D5 if mask field states to. 
00002888                          2318  
00002888                          2319  CHECK_BIT_5
00002888  3606                    2320          MOVE.W  D6, D3
0000288A  0243 00F0               2321          ANDI.W  #third_nibble,D3
0000288E  1A3C 0004               2322          MOVE.B  #right4,D5 
00002892  EA6B                    2323          LSR.W   D5,D3
00002894  0203 0002               2324          ANDI.B  #2,D3
00002898  B63C 0002               2325          CMP.B   #2,D3
0000289C  6700 0006               2326          BEQ     D4_Dn_SET_5
000028A0  6000 0014               2327          BRA     CHECK_BIT_4
000028A4                          2328  D4_Dn_SET_5
000028A4  183C 0005               2329          MOVE.B  #$5, D4
000028A8                          2330          
000028A8  6000 0002               2331          BRA     PRINT_D5
000028AC                          2332          
000028AC                          2333  PRINT_D5
000028AC  4EB9 00002C90           2334          JSR     EA_Dn
000028B2  14FC 002F               2335          MOVE.B  #$2F,(A2)+
000028B6                          2336  
000028B6                          2337  *-----------------------------------------------------------------------------------*
000028B6                          2338  * Print out D4 if mask field states to. 
000028B6                          2339  
000028B6                          2340  CHECK_BIT_4
000028B6  3606                    2341          MOVE.W  D6, D3
000028B8  0243 00F0               2342          ANDI.W  #third_nibble,D3
000028BC  1A3C 0004               2343          MOVE.B  #right4,D5 
000028C0  EA6B                    2344          LSR.W   D5,D3
000028C2  0203 0001               2345          ANDI.B  #1,D3
000028C6  B63C 0001               2346          CMP.B   #1,D3
000028CA  6700 0006               2347          BEQ     D4_Dn_SET_4
000028CE  6000 0014               2348          BRA     CHECK_BIT_3
000028D2                          2349  D4_Dn_SET_4
000028D2  183C 0004               2350          MOVE.B  #$4, D4
000028D6                          2351          
000028D6  6000 0002               2352          BRA     PRINT_D4
000028DA                          2353          
000028DA                          2354  PRINT_D4
000028DA  4EB9 00002C90           2355          JSR     EA_Dn
000028E0  14FC 002F               2356          MOVE.B  #$2F,(A2)+
000028E4                          2357  
000028E4                          2358  *-----------------------------------------------------------------------------------*
000028E4                          2359  * Print out D3 if mask field states to. 
000028E4                          2360  * FOURTH NIBBLE CHECK / D3 - D0
000028E4                          2361  
000028E4                          2362  CHECK_BIT_3
000028E4  3606                    2363          MOVE.W  D6, D3
000028E6  0243 000F               2364          ANDI.W  #fourth_nibble,D3
000028EA  0203 0008               2365          ANDI.B  #8,D3
000028EE  B63C 0008               2366          CMP.B   #8,D3
000028F2  6700 0006               2367          BEQ     D4_Dn_SET_3
000028F6  6000 0014               2368          BRA     CHECK_BIT_2
000028FA                          2369  D4_Dn_SET_3
000028FA  183C 0003               2370          MOVE.B  #$3, D4
000028FE                          2371          
000028FE  6000 0002               2372          BRA     PRINT_D3
00002902                          2373          
00002902                          2374  PRINT_D3
00002902  4EB9 00002C90           2375          JSR     EA_Dn
00002908  14FC 002F               2376          MOVE.B  #$2F,(A2)+
0000290C                          2377  
0000290C                          2378  *-----------------------------------------------------------------------------------*
0000290C                          2379  * Print out D2 if mask field states to. 
0000290C                          2380  
0000290C                          2381  CHECK_BIT_2
0000290C  3606                    2382          MOVE.W  D6, D3
0000290E  0243 000F               2383          ANDI.W  #fourth_nibble,D3
00002912  0203 0004               2384          ANDI.B  #4,D3
00002916  B63C 0004               2385          CMP.B   #4,D3
0000291A  6700 0006               2386          BEQ     D4_Dn_SET_2
0000291E  6000 0014               2387          BRA     CHECK_BIT_1
00002922                          2388  D4_Dn_SET_2
00002922  183C 0002               2389          MOVE.B  #$2, D4
00002926                          2390          
00002926  6000 0002               2391          BRA     PRINT_D2
0000292A                          2392          
0000292A                          2393  PRINT_D2
0000292A  4EB9 00002C90           2394          JSR     EA_Dn
00002930  14FC 002F               2395          MOVE.B  #$2F,(A2)+
00002934                          2396  
00002934                          2397  *-----------------------------------------------------------------------------------*
00002934                          2398  * Print out D1 if mask field states to. 
00002934                          2399  
00002934                          2400  CHECK_BIT_1
00002934  3606                    2401          MOVE.W  D6, D3
00002936  0243 000F               2402          ANDI.W  #fourth_nibble,D3
0000293A  0203 0002               2403          ANDI.B  #2,D3
0000293E  B63C 0002               2404          CMP.B   #2,D3
00002942  6700 0006               2405          BEQ     D4_Dn_SET_1
00002946  6000 0014               2406          BRA     CHECK_BIT_0
0000294A                          2407  D4_Dn_SET_1
0000294A  183C 0001               2408          MOVE.B  #$1, D4
0000294E                          2409          
0000294E  6000 0002               2410          BRA     PRINT_D1
00002952                          2411          
00002952                          2412  PRINT_D1
00002952  4EB9 00002C90           2413          JSR     EA_Dn
00002958  14FC 002F               2414          MOVE.B  #$2F,(A2)+
0000295C                          2415  
0000295C                          2416  *-----------------------------------------------------------------------------------*
0000295C                          2417  * Print out D0 if mask field states to. 
0000295C                          2418  
0000295C                          2419  CHECK_BIT_0
0000295C  3606                    2420          MOVE.W  D6, D3
0000295E  0243 000F               2421          ANDI.W  #fourth_nibble,D3
00002962  0203 0001               2422          ANDI.B  #1,D3
00002966  B63C 0001               2423          CMP.B   #1,D3
0000296A  6700 0006               2424          BEQ     D4_Dn_SET_0
0000296E  6000 0014               2425          BRA     FINISH_MOVEM_MEM_TO_REG
00002972                          2426  D4_Dn_SET_0
00002972  183C 0000               2427          MOVE.B  #$0, D4
00002976                          2428          
00002976  6000 0002               2429          BRA     PRINT_D0
0000297A                          2430          
0000297A                          2431  PRINT_D0
0000297A  4EB9 00002C90           2432          JSR     EA_Dn
00002980  14FC 002F               2433          MOVE.B  #$2F,(A2)+
00002984                          2434  
00002984                          2435  FINISH_MOVEM_MEM_TO_REG
00002984                          2436          
00002984  2600                    2437          MOVE.L  D0,D3               ; Store the src mode in D3
00002986  0243 0038               2438          ANDI.W  #src_mode,D3        ; Get bits 5-3
0000298A  1A3C 0003               2439          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
0000298E  EA6B                    2440          LSR.W   D5,D3               ; Do the actual shift
00002990                          2441  
00002990  2800                    2442          MOVE.L  D0,D4               ; Store the dst reg in D4
00002992  0244 0007               2443          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002996                          2444   
00002996  B63C 0002               2445          CMP.B   #2, D3
0000299A  6700 0006               2446          BEQ     An_FINISH           ; branch to print out (An) 
0000299E  6000 0010               2447          BRA     NORMAL_FINISH       ; branch to the normal finish
000029A2                          2448  
000029A2                          2449  An_FINISH
000029A2  14FC 002C               2450          MOVE.B  #$2C,(A2)+          ; Add comma after size print
000029A6  14FC 0020               2451          MOVE.B  #$20,(A2)+          ; Add space after comma
000029AA                          2452          
000029AA                          2453                      
000029AA  4EB9 00002C52           2454          JSR     EA_GEN_SRC
000029B0                          2455  
000029B0                          2456  NORMAL_FINISH
000029B0  301D                    2457          MOVE.W  (A5)+, D0
000029B2                          2458          
000029B2  4EF8 1DDE               2459          JMP     EA_FINISH
000029B6                          2460  *------------------------------------------------------------------------------------------------*
000029B6                          2461  EA_SHIFTS       ; 7: ea_shifts
000029B6  2200                    2462          MOVE.L  D0,D1               ; D0 is current instruction word
000029B8  0241 01C0               2463          ANDI.W  #dst_mode,D1        ; Extract 8-6 bits from instruction word
000029BC  1A3C 0006               2464          MOVE.B  #right6,D5          ; Used to shift 6 times to right
000029C0  EA69                    2465          LSR.W   D5,D1               ; Shift dst mode into LSB position
000029C2  C2FC 0006               2466          MULU    #6, D1              ; Set displacement 
000029C6  41F9 000029D0           2467          LEA     EA_SHIFTS_TABLE,A0  ; Load table into A0
000029CC  4EF0 1000               2468          JMP     0(A0,D1)            ; go to displacement (A0 + D1 * 6)
000029D0                          2469  
000029D0                          2470  EA_SHIFTS_TABLE
000029D0  4EF9 00002A76           2471          JMP     EA_REGISTER_SHIFTS  ; 000 Register
000029D6  4EF9 00002A76           2472          JMP     EA_REGISTER_SHIFTS  ; 001 Register
000029DC  4EF9 00002A76           2473          JMP     EA_REGISTER_SHIFTS  ; 010 Register
000029E2  4EF9 00002A00           2474          JMP     EA_MEMORY_SHIFTS    ; 011 Memory
000029E8  4EF9 00002A76           2475          JMP     EA_REGISTER_SHIFTS  ; 100 Register
000029EE  4EF9 00002A76           2476          JMP     EA_REGISTER_SHIFTS  ; 101 Register
000029F4  4EF9 00002A76           2477          JMP     EA_REGISTER_SHIFTS  ; 110 Register
000029FA  4EF9 00002A00           2478          JMP     EA_MEMORY_SHIFTS    ; 111 Memory
00002A00                          2479          
00002A00                          2480  EA_MEMORY_SHIFTS
00002A00                          2481          ; Get EA and store into decode buffer
00002A00  2800                    2482          MOVE.L  D0,D4               ; Store the EA reg in D4
00002A02  0244 0007               2483          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002A06                          2484          
00002A06  2600                    2485          MOVE.L  D0,D3               ; Store the EA mode in D3
00002A08  0243 0038               2486          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002A0C  1A3C 0003               2487          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002A10  EA6B                    2488          LSR.W   D5,D3               ; Do the actual shift
00002A12  4EB9 00002D68           2489          JSR     An_CHECK            ; Check if mode is An 
00002A18  4EB9 00002D72           2490          JSR     Dn_CHECK            ; Check if mode is Dn
00002A1E  4EB9 00002D7C           2491          JSR     IMMEDIATE_CHECK     ; Check if mode is immediate
00002A24                          2492          
00002A24  14FC 0020               2493          MOVE.B  #$20,(A2)+          ; Print out a space 
00002A28  14FC 0020               2494          MOVE.B  #$20,(A2)+          ; Print out a space
00002A2C  14FC 0020               2495          MOVE.B  #$20,(A2)+          ; Print out a space
00002A30  14FC 0020               2496          MOVE.B  #$20,(A2)+          ; Print out a space
00002A34  14FC 0020               2497          MOVE.B  #$20,(A2)+          ; Add space
00002A38                          2498          
00002A38  4EB9 00002A50           2499          JSR     FRONT_FORMAT
00002A3E  4EB9 00002C52           2500          JSR     EA_GEN_SRC          ; Go get EA print
00002A44  B63C 002A               2501          CMP.B   #$2A,D3             ; When mode is 111 * 6 (2A)
00002A48  6700 001E               2502          BEQ     BACK_PARENTHESIS  
00002A4C  4EF8 1DDE               2503          JMP     EA_FINISH           ; Opcode is finish
00002A50                          2504  
00002A50                          2505  FRONT_FORMAT
00002A50  B63C 0007               2506          CMP.B   #7,D3               ; When mode is 111
00002A54  6700 0008               2507          BEQ     ADD_PARENTHESIS
00002A58  14FC 0020               2508          MOVE.B  #$20,(A2)+          ; Print out a space
00002A5C  4E75                    2509          RTS
00002A5E                          2510          
00002A5E                          2511  ADD_PARENTHESIS
00002A5E  14FC 0020               2512          MOVE.B  #$20,(A2)+          ; Print out a space
00002A62  14FC 0028               2513          MOVE.B  #'(',(A2)+
00002A66  4E75                    2514          RTS
00002A68                          2515          
00002A68                          2516  BACK_PARENTHESIS            
00002A68  14FC 0029               2517          MOVE.B  #')',(A2)+
00002A6C  1404                    2518          MOVE.B  D4,D2
00002A6E  4EB8 1ECC               2519          JSR     EA_SIZE_MEMORY_SHIFTS
00002A72  4EF8 1DDE               2520          JMP     EA_FINISH           ; Opcode is finish
00002A76                          2521      
00002A76                          2522  EA_REGISTER_SHIFTS
00002A76  2200                    2523          MOVE.L  D0,D1
00002A78  0241 01C0               2524          ANDI.W  #dst_mode,D1
00002A7C  1A3C 0006               2525          MOVE.B  #right6,D5 
00002A80  EA69                    2526          LSR.W   D5,D1
00002A82  0201 0003               2527          ANDI.B  #3,D1               ; Remove bit 8 and get bits 7-6
00002A86  1401                    2528          MOVE.B  D1,D2
00002A88  4EB8 1E24               2529          JSR     EA_SIZE_GENERAL
00002A8C                          2530          
00002A8C  2600                    2531          MOVE.L  D0,D3               ; Store the instruction in D3
00002A8E  0243 0038               2532          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002A92  1A3C 0003               2533          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002A96  EA6B                    2534          LSR.W   D5,D3               ; Do the actual shift 
00002A98  0203 0004               2535          ANDI.B  #4,D3               ; Get bit 5(ir) from bits 5-3
00002A9C  E44B                    2536          LSR.W   #2,D3
00002A9E                          2537  
00002A9E  B63C 0000               2538          CMP.B   #0,D3               ; When D1 is 0 (immediate)
00002AA2  6700 0006               2539          BEQ     IMMEDIATE_SRC
00002AA6  6000 0056               2540          BRA     REGISTER_SRC        ; When D1 is 1 (register)
00002AAA                          2541          
00002AAA                          2542  IMMEDIATE_SRC
00002AAA  14FC 0020               2543          MOVE.B  #$20,(A2)+          ; Add space
00002AAE  14FC 0020               2544          MOVE.B  #$20,(A2)+          ; Add space
00002AB2  14FC 0020               2545          MOVE.B  #$20,(A2)+          ; Add space
00002AB6  14FC 0020               2546          MOVE.B  #$20,(A2)+          ; Add space
00002ABA                          2547          
00002ABA                          2548          ; Get source and store into decode buffer
00002ABA  2800                    2549          MOVE.L  D0,D4               ; Store the src reg in D4
00002ABC  0244 0E00               2550          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002AC0  1A3C 0009               2551          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002AC4  EA6C                    2552          LSR.W   D5,D4               ; Do the actual shift
00002AC6  4EB9 00002AEE           2553          JSR     CHECK_IF_ZERO       ; Check if register is 0
00002ACC                          2554          
00002ACC  14FC 0023               2555          MOVE.B  #$23,(A2)+          ; Add # symbol
00002AD0  0604 0030               2556          ADDI.B  #$30,D4             ; Convert hex to ASCII
00002AD4  14C4                    2557          MOVE.B  D4,(A2)+            ; Store into buffer
00002AD6                          2558          
00002AD6  14FC 002C               2559          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002ADA  14FC 0020               2560          MOVE.B  #$20,(A2)+          ; Add space after comma
00002ADE                          2561  
00002ADE                          2562          ; Get destination and store into decode buffer
00002ADE  2800                    2563          MOVE.L  D0,D4               ; Store the src reg in D4
00002AE0  0244 0007               2564          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002AE4  4EB9 00002C90           2565          JSR     EA_Dn               ; store Dn into decode buffer
00002AEA  4EF8 1DDE               2566          JMP     EA_FINISH           ; Opcode is finish
00002AEE                          2567                
00002AEE                          2568  CHECK_IF_ZERO
00002AEE  B83C 0000               2569          CMP.B   #0,D4               ; When D4 is 0 
00002AF2  6700 0004               2570          BEQ     IMMEDIATE_EIGHT     ; Branch
00002AF6  4E75                    2571          RTS
00002AF8                          2572  
00002AF8                          2573  IMMEDIATE_EIGHT
00002AF8  183C 0008               2574          MOVE.B  #8,D4               ; Store 8 into D4 
00002AFC  4E75                    2575          RTS
00002AFE                          2576  
00002AFE                          2577  REGISTER_SRC        
00002AFE  14FC 0020               2578          MOVE.B  #$20,(A2)+          ; Add space
00002B02  14FC 0020               2579          MOVE.B  #$20,(A2)+          ; Add space
00002B06  14FC 0020               2580          MOVE.B  #$20,(A2)+          ; Add space
00002B0A  14FC 0020               2581          MOVE.B  #$20,(A2)+          ; Add space
00002B0E                          2582  
00002B0E                          2583          ; Get source and store into decode buffer
00002B0E  2800                    2584          MOVE.L  D0,D4               ; Store the src reg in D4
00002B10  0244 0E00               2585          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B14  1A3C 0009               2586          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B18  EA6C                    2587          LSR.W   D5,D4               ; Do the actual shift
00002B1A  4EB9 00002C90           2588          JSR     EA_Dn               ; store Dn into decode buffer
00002B20                          2589          
00002B20  14FC 002C               2590          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B24  14FC 0020               2591          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B28                          2592  
00002B28                          2593          ; Get destination and store into decode buffer
00002B28  2800                    2594          MOVE.L  D0,D4               ; Store the src reg in D4
00002B2A  0244 0007               2595          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002B2E  4EB9 00002C90           2596          JSR     EA_Dn               ; store Dn into decode buffer
00002B34  4EF8 1DDE               2597          JMP     EA_FINISH           ; Opcode is finish
00002B38                          2598  *------------------------------------------------------------------------------------------------*
00002B38                          2599  EA_QUICK        ; 8: ea_quick
00002B38  BC3C 0005               2600          CMP.B   #5, D6              ; check if the first nibble is 5 for ADDQ
00002B3C  6700 000A               2601          BEQ     ADDQ_EA_CALC
00002B40                          2602          
00002B40  BC3C 0007               2603          CMP.B   #7, D6              ; check if the first nibble is 7 for MOVEQ
00002B44  6700 0072               2604          BEQ     MOVEQ_EA_CALC
00002B48                          2605          
00002B48                          2606  ADDQ_EA_CALC
00002B48  2200                    2607          MOVE.L  D0,D1
00002B4A  0241 01C0               2608          ANDI.W  #dst_mode,D1        ; Get bits 8-6 from D1
00002B4E  1A3C 0006               2609          MOVE.B  #right6,D5          ; Store 6 into D5
00002B52  EA69                    2610          LSR.W   D5,D1               ; Shift D1 six times to the LSB position
00002B54  0201 0003               2611          ANDI.B  #3,D1               ; Remove the front bit from D1
00002B58  1401                    2612          MOVE.B  D1,D2               ; Store D1 into D2 (D2 is used to check size)
00002B5A  4EB8 1E24               2613          JSR     EA_SIZE_GENERAL     ; Get size and print size.
00002B5E                          2614          
00002B5E  14FC 0020               2615          MOVE.B  #$20,(A2)+          ; Add space after size
00002B62  14FC 0020               2616          MOVE.B  #$20,(A2)+          ; Add space
00002B66  14FC 0020               2617          MOVE.B  #$20,(A2)+          ; Add space
00002B6A                          2618          
00002B6A  14FC 0023               2619          MOVE.B  #$23,(A2)+          ; Add # symbol
00002B6E  14FC 0024               2620          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002B72                          2621          
00002B72  2800                    2622          MOVE.L  D0,D4               ; Store the data in D4
00002B74  0244 0E00               2623          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002B78  1A3C 0009               2624          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002B7C  EA6C                    2625          LSR.W   D5,D4               ; Do the actual shift
00002B7E                          2626          
00002B7E  B83C 0000               2627          CMP.B   #0, D4
00002B82  6700 0006               2628          BEQ     CHANGE_TO_EIGHT
00002B86                          2629          
00002B86  6000 0006               2630          BRA     DONT_CHANGE
00002B8A                          2631  
00002B8A                          2632  CHANGE_TO_EIGHT
00002B8A  183C 0008               2633          MOVE.B  #8, D4
00002B8E                          2634  
00002B8E                          2635  DONT_CHANGE        
00002B8E  0604 0030               2636          ADDI.B  #$30, D4
00002B92  14C4                    2637          MOVE.B  D4, (A2)+      
00002B94                          2638          
00002B94  14FC 002C               2639          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002B98  14FC 0020               2640          MOVE.B  #$20,(A2)+          ; Add space after comma
00002B9C                          2641          
00002B9C  2800                    2642          MOVE.L  D0,D4               ; Store the src reg in D4
00002B9E  0244 0007               2643          ANDI.W  #src_reg,D4         ; Get the bits at 2-0
00002BA2                          2644          
00002BA2  2600                    2645          MOVE.L  D0,D3               ; Store the src mode in D3
00002BA4  0243 0038               2646          ANDI.W  #src_mode,D3        ; Get bits 5-3
00002BA8  1A3C 0003               2647          MOVE.B  #right3,D5          ; Shift the bits 5-3 to the LSB
00002BAC  EA6B                    2648          LSR.W   D5,D3               ; Do the actual shift 
00002BAE  4EB9 00002C52           2649          JSR     EA_GEN_SRC
00002BB4                          2650          
00002BB4  4EF8 1DDE               2651          JMP     EA_FINISH
00002BB8                          2652  
00002BB8                          2653  MOVEQ_EA_CALC
00002BB8  14FC 0020               2654          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002BBC  14FC 0020               2655          MOVE.B  #$20,(A2)+          ; print out a space after the MOVEQ
00002BC0  14FC 0020               2656          MOVE.B  #$20,(A2)+          ; Add space
00002BC4  14FC 0020               2657          MOVE.B  #$20,(A2)+          ; Add space
00002BC8                          2658  
00002BC8  14FC 0023               2659          MOVE.B  #$23,(A2)+          ; Add # symbol
00002BCC  14FC 0024               2660          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002BD0                          2661          
00002BD0  2200                    2662          MOVE.L  D0, D1              ; move D0 to D1
00002BD2  0241 00FF               2663          ANDI.W  #second_half, D1    ; get the second 8 bits of D1
00002BD6  1A01                    2664          MOVE.B  D1, D5              ; move D1 to D5 to convert it to ASCII
00002BD8                          2665          
00002BD8  4EB8 11AA               2666          JSR     ITOA_BYTE_BRANCH    ; print out the bit of data
00002BDC                          2667          
00002BDC  14FC 002C               2668          MOVE.B  #$2C,(A2)+          ; Add comma after size print
00002BE0  14FC 0020               2669          MOVE.B  #$20,(A2)+          ; Add space after comma
00002BE4                          2670          
00002BE4  2800                    2671          MOVE.L  D0,D4               ; Store the data in D4
00002BE6  0244 0E00               2672          ANDI.W  #dst_reg,D4         ; Get the bits at 11-9
00002BEA  1A3C 0009               2673          MOVE.B  #right9,D5          ; Shift the bits 11-9 to the LSB
00002BEE  EA6C                    2674          LSR.W   D5,D4               ; Do the actual shift
00002BF0  4EB9 00002C52           2675          JSR     EA_GEN_SRC
00002BF6                          2676          
00002BF6  4EF8 1DDE               2677          JMP     EA_FINISH
00002BFA                          2678  *------------------------------------------------------------------------------------------------*
00002BFA                          2679  EA_BRANCH       ; 9: ea_branch
00002BFA  14FC 0020               2680          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002BFE  14FC 0020               2681          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C02  14FC 0020               2682          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C06  14FC 0020               2683          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C0A  14FC 0020               2684          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C0E  14FC 0020               2685          MOVE.B  #$20,(A2)+          ; print out a space after the Branch
00002C12                          2686  
00002C12  2600                    2687          MOVE.L  D0,D3               ; D0 is current instruction word
00002C14  0243 00F0               2688          ANDI.W  #third_nibble,D3   ; Extract 3rd nibble from instruction word
00002C18  1A3C 0004               2689          MOVE.B  #right4,D5
00002C1C                          2690          
00002C1C  2800                    2691          MOVE.L  D0,D4               ; D0 is current instruction word
00002C1E  0244 000F               2692          ANDI.W  #fourth_nibble,D4   ; Extract 4th nibble from instruction word
00002C22                          2693           
00002C22  B63C 0000               2694          CMP.B   #0,D3               ; check if 3rd nibble is 0. 
00002C26  6700 0006               2695          BEQ     FOURTH_NIBBLE_CHECK
00002C2A                          2696          
00002C2A  6000 0018               2697          BRA     BRANCH_WORD_CHECK
00002C2E                          2698          
00002C2E                          2699  FOURTH_NIBBLE_CHECK                 
00002C2E  B83C 0000               2700          CMP.B   #0,D4               ; check if the 4th nibble is 0. 
00002C32                          2701          
00002C32  3A15                    2702          MOVE.W  (A5), D5            ; store the 16-bit displacement into D5
00002C34                          2703          
00002C34  260D                    2704          MOVE.L  A5, D3              ; Store A5 address into D3
00002C36                          2705          
00002C36  DA43                    2706          ADD.W   D3, D5              ; Add the address to D5 to get the displacement. 
00002C38                          2707          
00002C38  14FC 0024               2708          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002C3C                          2709          
00002C3C  4EB8 11D8               2710          JSR     ITOA_WORD_BRANCH    ; Print. 
00002C40                          2711  
00002C40  4EF8 1DDE               2712          JMP     EA_FINISH
00002C44                          2713  
00002C44                          2714  BRANCH_WORD_CHECK
00002C44  4245                    2715          CLR     D5                  ; handles 8-bit displacement. 
00002C46  DA03                    2716          ADD.B   D3,D5               ; add d3 and d4 to d5
00002C48  DA04                    2717          ADD.B   D4,D5
00002C4A                          2718          
00002C4A  4EB8 11AA               2719          JSR     ITOA_BYTE_BRANCH    ; Print. 
00002C4E                          2720  
00002C4E  4EF8 1DDE               2721          JMP     EA_FINISH
00002C52                          2722  
00002C52                          2723  EA_GEN_SRC
00002C52  41F9 00002C60           2724          LEA     EA_GEN_TABLE_SRC, A0
00002C58  C6FC 0006               2725          MULU    #6, D3              ; use D3 to jump to the proper src mode and dst mode. 
00002C5C  4EF0 3000               2726          JMP     0(A0,D3)            ; jump to each ea src generation table entry 
00002C60                          2727  
00002C60                          2728  EA_GEN_TABLE_SRC
00002C60  4EF9 00002C90           2729          JMP     EA_Dn                       ; 000: Dn
00002C66  4EF9 00002C9C           2730          JMP     EA_An                       ; 001: An
00002C6C  4EF9 00002CA8           2731          JMP     EA_An_Indirect              ; 010: (An)
00002C72  4EF9 00002CBC           2732          JMP     EA_An_Indirect_Inc          ; 011: (An)+
00002C78  4EF9 00002CD4           2733          JMP     EA_An_Indirect_Dec          ; 100: -(An)
00002C7E  4EF9 00002CEC           2734          JMP     EA_UNSUPPORTED              ; 101: Unsupported EA
00002C84  4EF9 00002CEC           2735          JMP     EA_UNSUPPORTED              ; 110: Unsupported EA
00002C8A  4EF9 00002CFA           2736          JMP     EA_Absolute_And_Immediate   ; 111: (xxx).W,(xxx).L, or #<data>
00002C90                          2737  
00002C90                          2738  EA_Dn               ; 000: Dn
00002C90  14FC 0044               2739          MOVE.B  #'D',(A2)+
00002C94  0604 0030               2740          ADDI.B  #$30,D4
00002C98  14C4                    2741          MOVE.B  D4,(A2)+
00002C9A  4E75                    2742          RTS
00002C9C                          2743  
00002C9C                          2744  EA_An               ; 001: An
00002C9C  14FC 0041               2745          MOVE.B  #'A',(A2)+
00002CA0  0604 0030               2746          ADDI.B  #$30,D4
00002CA4  14C4                    2747          MOVE.B  D4,(A2)+
00002CA6  4E75                    2748          RTS
00002CA8                          2749  
00002CA8                          2750  EA_An_Indirect      ; 010: (An)
00002CA8  14FC 0028               2751          MOVE.B  #'(',(A2)+
00002CAC  14FC 0041               2752          MOVE.B  #'A',(A2)+
00002CB0  0604 0030               2753          ADDI.B  #$30,D4
00002CB4  14C4                    2754          MOVE.B  D4,(A2)+
00002CB6  14FC 0029               2755          MOVE.B  #')',(A2)+
00002CBA  4E75                    2756          RTS
00002CBC                          2757          
00002CBC                          2758  EA_An_Indirect_Inc  ; 011: (An)+
00002CBC  14FC 0028               2759          MOVE.B  #'(',(A2)+
00002CC0  14FC 0041               2760          MOVE.B  #'A',(A2)+
00002CC4  0604 0030               2761          ADDI.B  #$30, D4
00002CC8  14C4                    2762          MOVE.B  D4,(A2)+
00002CCA  14FC 0029               2763          MOVE.B  #')',(A2)+
00002CCE  14FC 002B               2764          MOVE.B  #'+',(A2)+
00002CD2  4E75                    2765          RTS
00002CD4                          2766          
00002CD4                          2767  EA_An_Indirect_Dec  ; 100: -(An)
00002CD4  14FC 002D               2768          MOVE.B  #'-',(A2)+
00002CD8  14FC 0028               2769          MOVE.B  #'(',(A2)+
00002CDC  14FC 0041               2770          MOVE.B  #'A',(A2)+
00002CE0  0604 0030               2771          ADDI.B  #$30,D4
00002CE4  14C4                    2772          MOVE.B  D4,(A2)+
00002CE6  14FC 0029               2773          MOVE.B  #')',(A2)+
00002CEA  4E75                    2774          RTS
00002CEC                          2775  
00002CEC                          2776  EA_UNSUPPORTED
00002CEC  43F9 00002E2F           2777          LEA     EA_TYPE_ERROR,A1
00002CF2  103C 000E               2778          MOVE.B  #14,D0
00002CF6  4E4F                    2779          TRAP    #15  
00002CF8  4E75                    2780          RTS 
00002CFA                          2781          
00002CFA                          2782  EA_Absolute_And_Immediate           ; 111: (xxx).W,(xxx).L, or #<data>
00002CFA  B83C 0000               2783          CMP.B   #0,D4               ; If D4 is (xxx).W
00002CFE  6700 0016               2784          BEQ     ABSOLUTE_WORD
00002D02                          2785          
00002D02  B83C 0001               2786          CMP.B   #1,D4               ; If D4 is (xxx).L
00002D06  6700 001A               2787          BEQ     ABSOLUTE_LONG
00002D0A                          2788          
00002D0A  B83C 0004               2789          CMP.B   #4,D4               ; If D4 is #<data>  
00002D0E  6700 001E               2790          BEQ     IMMEDIATE
00002D12                          2791          
00002D12  6000 008C               2792          BRA     ABSOLUTE_IMMEDIATE_ERROR    
00002D16                          2793  
00002D16                          2794  ABSOLUTE_WORD
00002D16  14FC 0024               2795          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D1A  7401                    2796          MOVE.L  #1,D2               ; Insert 1 to D2 
00002D1C  4EB8 1114               2797          JSR     ITOA                ; Convert word hex values to ITOA
00002D20  4E75                    2798          RTS
00002D22                          2799          
00002D22                          2800  ABSOLUTE_LONG
00002D22  14FC 0024               2801          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D26  7402                    2802          MOVE.L  #2,D2               ; Insert 2 to D2
00002D28  4EB8 1114               2803          JSR     ITOA                ; Convert long hex values to ITOA
00002D2C  4E75                    2804          RTS
00002D2E                          2805     
00002D2E                          2806  IMMEDIATE
00002D2E  14FC 0023               2807          MOVE.B  #$23,(A2)+          ; Add # symbol
00002D32  14FC 0024               2808          MOVE.B  #$24,(A2)+          ; Add $ symbol
00002D36                          2809  
00002D36  BC3C 0001               2810          CMP.B   #1,D6               ; If MOVE.b (code0001)
00002D3A  6700 0020               2811          BEQ     DO_ITOA_MOVE
00002D3E  BC3C 0002               2812          CMP.B   #2, D6              ; If MOVE.l / MOVEA.l (code0010)
00002D42  6700 0018               2813          BEQ     DO_ITOA_MOVE
00002D46  BC3C 0003               2814          CMP.B   #3, D6              ; If MOVE.w / MOVEA.w (code0011)
00002D4A  6700 0010               2815          BEQ     DO_ITOA_MOVE        
00002D4E  BC3C 000D               2816          CMP.B   #13, D6             ; If ADD / ADDA (code1101)
00002D52  6700 000E               2817          BEQ     DO_ITOA_OPMODE
00002D56                          2818          
00002D56  4EB8 1114               2819          JSR     ITOA                ; Go to ITOA when not a move instruction
00002D5A  4E75                    2820          RTS
00002D5C                          2821          
00002D5C                          2822  DO_ITOA_MOVE
00002D5C  4EB8 1136               2823          JSR ITOA_MOVE
00002D60  4E75                    2824          RTS
00002D62                          2825                
00002D62                          2826  DO_ITOA_OPMODE
00002D62  4EB8 1158               2827          JSR ITOA_OPMODE
00002D66  4E75                    2828          RTS
00002D68                          2829  
00002D68                          2830  An_CHECK 
00002D68  B63C 0001               2831          CMP.B   #1,D3               ; If mode is An     
00002D6C  6700 0062               2832          BEQ     EA_INVALID          ; Then branch to error message
00002D70  4E75                    2833          RTS   
00002D72                          2834        
00002D72                          2835  Dn_CHECK 
00002D72  B63C 0000               2836          CMP.B   #0,D3               ; If mode is An     
00002D76  6700 0058               2837          BEQ     EA_INVALID          ; Then branch to error message
00002D7A  4E75                    2838          RTS    
00002D7C                          2839       
00002D7C                          2840  IMMEDIATE_CHECK
00002D7C  B63C 0007               2841          CMP.B   #7,D3
00002D80  6700 0004               2842          BEQ     REGISTER_CHECK
00002D84  4E75                    2843          RTS
00002D86                          2844          
00002D86                          2845  REGISTER_CHECK
00002D86  B63C 0004               2846          CMP.B   #4,D3               ; If 100 in register
00002D8A  6700 0044               2847          BEQ     EA_INVALID          ; Branch to invalid
00002D8E  4E75                    2848          RTS   
00002D90                          2849                
00002D90                          2850  EA_WRONG_SIZE 
00002D90  43F9 00002DE5           2851          LEA     WRONG_SIZE_MESSAGE, A1 
00002D96  103C 000E               2852          MOVE.B  #14, D0
00002D9A  4E4F                    2853          TRAP    #15
00002D9C  4EF8 138E               2854          JMP     OP_FINISH
00002DA0                          2855          
00002DA0                          2856  ABSOLUTE_IMMEDIATE_ERROR  
00002DA0  43F9 00002DF3           2857          LEA     ABSOLUTE_WRONGREG, A1 
00002DA6  103C 000E               2858          MOVE.B  #14, D0
00002DAA  4E4F                    2859          TRAP    #15
00002DAC  4EF8 138E               2860          JMP     OP_FINISH
00002DB0                          2861          
00002DB0                          2862  DST_INVALID
00002DB0  43F9 00002E51           2863          LEA     DST_INVALID_MSG, A1 
00002DB6  103C 000E               2864          MOVE.B  #14, D0
00002DBA  4E4F                    2865          TRAP    #15
00002DBC  4EF8 138E               2866          JMP     OP_FINISH
00002DC0                          2867          
00002DC0                          2868  SRC_INVALID 
00002DC0  43F9 00002E83           2869          LEA     SRC_INVALID_MSG, A1 
00002DC6  103C 000E               2870          MOVE.B  #14, D0
00002DCA  4E4F                    2871          TRAP    #15
00002DCC  4EF8 138E               2872          JMP     OP_FINISH
00002DD0                          2873          
00002DD0                          2874  EA_INVALID  
00002DD0  43F9 00002EB0           2875          LEA     EA_INVALID_MSG, A1 
00002DD6  103C 000E               2876          MOVE.B  #14, D0
00002DDA  4E4F                    2877          TRAP    #15
00002DDC  4EF8 138E               2878          JMP     OP_FINISH
00002DE0                          2879           
00002DE0  FFFF FFFF               2880  DONE    SIMHALT             ; halt simulator
00002DE4                          2881  
00002DE4                          2882  * Put variables and constants here
00002DE4                          2883      
00002DE4  =00000040               2884  buffer_size         EQU         64 
00002DE4  =00005000               2885  decoded_buffer      EQU         $5000  
00002DE4  =0000000D               2886  CR                  EQU         $0D
00002DE4  =0000000A               2887  LF                  EQU         $0A
00002DE4  =0000A000               2888  stack               EQU         $0000A000
00002DE4  =00000014               2889  lines_p_screen      EQU         20
00002DE4  =00000003               2890  right3              EQU         3
00002DE4  =00000004               2891  right4              EQU         4
00002DE4  =00000006               2892  right6              EQU         6
00002DE4  =00000008               2893  right8              EQU         8
00002DE4  =00000009               2894  right9              EQU         9
00002DE4  =0000000C               2895  right12             EQU         12
00002DE4  =00000010               2896  right16             EQU         16
00002DE4  =00000018               2897  right24             EQU         24
00002DE4= 20                      2898  ascii_y_n           DC.B        32
00002DE5  =00000059               2899  y_uppercase         EQU         $59         
00002DE5  =00000079               2900  y_lowercase         EQU         $79
00002DE5  =0000004E               2901  n_uppercase         EQU         $4E
00002DE5  =0000006E               2902  n_lowercase         EQU         $6E
00002DE5  =00000002               2903  task2               EQU         $02
00002DE5  =00000005               2904  task5               EQU         $05
00002DE5  =00000009               2905  task9               EQU         $09
00002DE5  =0000000D               2906  task13              EQU         $0D
00002DE5  =0000000E               2907  task14              EQU         $0E
00002DE5  =0000F000               2908  first_nibble        EQU         $F000
00002DE5  =00000F00               2909  second_nibble       EQU         $0F00   
00002DE5  =000000F0               2910  third_nibble        EQU         $00F0
00002DE5  =0000000F               2911  fourth_nibble       EQU         $000F
00002DE5  =000000FF               2912  second_half         EQU         $00FF
00002DE5  =000001C0               2913  dst_mode            EQU         $01C0
00002DE5  =00000E00               2914  dst_reg             EQU         $0E00
00002DE5  =00000038               2915  src_mode            EQU         $0038
00002DE5  =00000007               2916  src_reg             EQU         $0007
00002DE5  =00000100               2917  bit8                EQU         $0100
00002DE5                          2918  
00002DE5  =00000000               2919  ea_type_immediate   EQU     0       ; EA Type = immediate
00002DE5  =00000001               2920  ea_type_move        EQU     1       ; EA Type = move
00002DE5  =00000002               2921  ea_type_movea       EQU     2       ; EA Type = movea
00002DE5  =0000000C               2922  ea_type_movea6      EQU     12      ; EA Type = movea * 6
00002DE5  =00000003               2923  ea_type_lea         EQU     3       ; EA Type = lea
00002DE5  =00000004               2924  ea_type_dstonly     EQU     4       ; EA Type = clr, neg, not, jsr, jmp
00002DE5  =00000005               2925  ea_type_ext         EQU     5       ; EA Type = ext, add, adda
00002DE5  =00000006               2926  ea_type_movem       EQU     6       ; EA Type = movem
00002DE5  =00000007               2927  ea_type_shifts      EQU     7       ; EA Type = ASL/ASR/LSL/LSR/ROL/ROR
00002DE5  =00000008               2928  ea_type_quick       EQU     8       ; EA Type = addq, subq
00002DE5  =00000009               2929  ea_type_branch      EQU     9       ; EA Type = bra, bsr, bcc
00002DE5  =00000000               2930  ea_bcc_flag         EQU     0       ; EA Type = branch, flag = bcc
00002DE5  =00000001               2931  ea_dbcc_flag        EQU     1       ; EA Type = branch, flag = dbcc
00002DE5  =00000002               2932  ea_scc_flag         EQU     2       ; EA Type = branch, flag = scc
00002DE5                          2933  
00002DE5= 57 72 6F 6E 67 20 ...   2934  WRONG_SIZE_MESSAGE  DC.B    'Wrong size.',CR,LF,0
00002DF3= 45 52 52 4F 52 3A ...   2935  ABSOLUTE_WRONGREG   DC.B    'ERROR: Register does not exist for Absolute and immediate',CR,LF,0
00002E2F= 45 52 52 4F 52 3A ...   2936  EA_TYPE_ERROR       DC.B    'ERROR: EA type is not supported',CR,LF,0
00002E51= 45 52 52 4F 52 3A ...   2937  DST_INVALID_MSG     DC.B    'ERROR: Destination effective address is invalid',CR,LF,0
00002E83= 45 52 52 4F 52 3A ...   2938  SRC_INVALID_MSG     DC.B    'ERROR: Source effective address is invalid',CR,LF,0
00002EB0= 45 52 52 4F 52 3A ...   2939  EA_INVALID_MSG      DC.B    'ERROR: Invalid addressing mode',CR,LF,0
00002ED1= 45 52 52 4F 52 3A ...   2940  OPCODE_INVALID      DC.B    'ERROR: Opcode is invalid',CR,LF,0
00002EEC= 45 52 52 4F 52 3A ...   2941  ERROR_MESSAGE       DC.B    'ERROR: The input is invalid',CR,LF,0  
00002F0A= 45 52 52 4F 52 3A ...   2942  ODD_ERROR_MESSAGE   DC.B    'ERROR: The last digit of the address is odd, which is invalid',CR,LF,0  
00002F4A                          2943               
00002F4A= 57 65 6C 63 6F 6D ...   2944  WELCOME             DC.B        'Welcome to the 68k Disassembler of Avery and Alan',CR,LF,CR,LF,0
00002F80                          2945  
00002F80= 50 6C 65 61 73 65 ...   2946  USER_INST           DC.B        'Please follow the proper input instructions below: ',CR,LF
00002FB5= 2D 20 53 74 61 72 ...   2947                      DC.B        '- Starting address must be lower than ending address.',CR,LF
00002FEC= 2D 20 54 68 65 20 ...   2948                      DC.B        '- The values for the starting and ending address must be an even value.',CR,LF
00003035= 2D 20 53 74 61 72 ...   2949                      DC.B        '- Starting and ending address must be inputted as hexadecimal value.',CR,LF
0000307B= 2D 20 44 6F 20 6E ...   2950                      DC.B        '- Do not put spaces in between input characters.',CR,LF
000030AD= 2D 20 56 61 6C 69 ...   2951                      DC.B        '- Valid characters include: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F',CR,LF,0
000030FA                          2952                  
000030FA= 50 72 65 73 73 20 ...   2953  ENTER_PROMPT        DC.B        'Press enter to continue...',CR,LF,0
00003117= 50 72 65 73 73 20 ...   2954  PROMPT_AGAIN        DC.B        'Press Y to continue / N to exit.',CR,LF,0
0000313A= 50 72 6F 67 72 61 ...   2955  EXIT_PROMPT         DC.B        'Program has execution has stopped.',CR,LF,0
0000315F                          2956        
0000315F= 45 6E 74 65 72 20 ...   2957  START_IN            DC.B        'Enter a starting address: ',CR,LF,0 
0000317C= 45 6E 74 65 72 20 ...   2958  END_IN              DC.B        'Enter an ending address: ',CR,LF,0 
00003198                          2959  START_ADDRESS       DS.B        32     
000031B8                          2960  END_ADDRESS         DS.B        32 
000031D8                          2961       
000031D8                          2962      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ABSOLUTE_IMMEDIATE_ERROR  2DA0
ABSOLUTE_LONG       2D22
ABSOLUTE_WORD       2D16
ABSOLUTE_WRONGREG   2DF3
ADDQ_EA_CALC        2B48
ADD_PARENTHESIS     2A5E
AND_OR_CHECK        227A
AN_CHECK            2D68
AN_FINISH           29A2
ASCII_TO_HEX_LETTER  1084
ASCII_Y_N           2DE4
ATOI                105E
BACK_PARENTHESIS    2A68
BIT8                100
BRANCH_WORD_CHECK   2C44
BUFFER_SIZE         40
CHANGE_TO_001       2096
CHANGE_TO_EIGHT     2B8A
CHECK1_BIT_0        2646
CHECK1_BIT_1        261E
CHECK1_BIT_10       248C
CHECK1_BIT_11       245E
CHECK1_BIT_12       2430
CHECK1_BIT_13       2402
CHECK1_BIT_14       23D4
CHECK1_BIT_2        25F6
CHECK1_BIT_3        25CE
CHECK1_BIT_4        25A0
CHECK1_BIT_5        2572
CHECK1_BIT_6        2544
CHECK1_BIT_7        2516
CHECK1_BIT_8        24E8
CHECK1_BIT_9        24BA
CHECK_BIT_0         295C
CHECK_BIT_1         2934
CHECK_BIT_10        27A4
CHECK_BIT_11        2776
CHECK_BIT_12        2748
CHECK_BIT_13        271A
CHECK_BIT_14        26EC
CHECK_BIT_2         290C
CHECK_BIT_3         28E4
CHECK_BIT_4         28B6
CHECK_BIT_5         2888
CHECK_BIT_6         285A
CHECK_BIT_7         282C
CHECK_BIT_8         27FE
CHECK_BIT_9         27D2
CHECK_IF_ZERO       2AEE
CODE0000            140A
CODE0001            1424
CODE0010            1428
CODE0011            1440
CODE0100            1458
CODE0101            1472
CODE0110            1476
CODE0111            1502
CODE1000            1506
CODE1001            1526
CODE1010            152A
CODE1011            152E
CODE1100            1532
CODE1101            154C
CODE1110            1566
CODE1111            15E4
COMPLETE_END        10E6
COMPLETE_START      10DE
CONTINUE_OR_END     12E0
CR                  D
D4_AN_SETONE_0      2532
D4_AN_SETONE_1      2560
D4_AN_SETONE_2      258E
D4_AN_SETONE_3      25BC
D4_AN_SETONE_4      25E4
D4_AN_SETONE_5      260C
D4_AN_SETONE_6      2634
D4_AN_SETONE_7      265C
D4_AN_SET_0         281A
D4_AN_SET_1         27EE
D4_AN_SET_2         27C0
D4_AN_SET_3         2792
D4_AN_SET_4         2764
D4_AN_SET_5         2736
D4_AN_SET_6         2708
D4_AN_SET_7         26DA
D4_DN_SETONE_0      23C2
D4_DN_SETONE_1      23F0
D4_DN_SETONE_2      241E
D4_DN_SETONE_3      244C
D4_DN_SETONE_4      247A
D4_DN_SETONE_5      24A8
D4_DN_SETONE_6      24D6
D4_DN_SETONE_7      2504
D4_DN_SET_0         2972
D4_DN_SET_1         294A
D4_DN_SET_2         2922
D4_DN_SET_3         28FA
D4_DN_SET_4         28D2
D4_DN_SET_5         28A4
D4_DN_SET_6         2876
D4_DN_SET_7         2848
DECODED_BUFFER      5000
DECODE_MEMORY       1358
DECODE_PAUSE        12CC
DECODING_ITERATION  12A8
DISP_UI             100C
DISP_W              1000
DN_CHECK            2D72
DN_DST              21F6
DN_SRC              2234
DONE                2DE0
DONT_CHANGE         2B8E
DO_ITOA_MOVE        2D5C
DO_ITOA_OPMODE      2D62
DST_INVALID         2DB0
DST_INVALID_MSG     2E51
DST_MODE            1C0
DST_REG             E00
EA_ABSOLUTE_AND_IMMEDIATE  2CFA
EA_ADDA             230A
EA_AN               2C9C
EA_AND              228C
EA_AN_INDIRECT      2CA8
EA_AN_INDIRECT_DEC  2CD4
EA_AN_INDIRECT_INC  2CBC
EA_BCC_FLAG         0
EA_BRANCH           2BFA
EA_CLEAR            20D0
EA_DBCC_FLAG        1
EA_DN               2C90
EA_DSTONLY          20B0
EA_EXT              2162
EA_EXT_TABLE        217E
EA_FINISH           1DDE
EA_GEN_SRC          2C52
EA_GEN_TABLE_SRC    2C60
EA_IMMEDIATE        1F02
EA_INVALID          2DD0
EA_INVALID_MSG      2EB0
EA_JSR              211A
EA_LEA              2032
EA_MEMORY_SHIFTS    2A00
EA_MOVE             1F5A
EA_MOVEA            1FC6
EA_MOVEM            2352
EA_MULS_MULU_DIV    22B4
EA_OPMODE_012456    21AE
EA_OPMODE_37        229C
EA_OR               2292
EA_QUICK            2B38
EA_REGISTER_SHIFTS  2A76
EA_SCC_FLAG         2
EA_SHIFTS           29B6
EA_SHIFTS_TABLE     29D0
EA_SIZE_ADDA        1EB8
EA_SIZE_B           1EE0
EA_SIZE_DONE        1F00
EA_SIZE_GENERAL     1E24
EA_SIZE_L           1EF6
EA_SIZE_MEMORY_SHIFTS  1ECC
EA_SIZE_MOVE        1E40
EA_SIZE_MOVEA       1E5C
EA_SIZE_MOVEM       1E70
EA_SIZE_OPMODE_012456  1E84
EA_SIZE_W           1EEA
EA_SIZE_W_MEMORY    1EF4
EA_START            1DCC
EA_TYPE_BRANCH      9
EA_TYPE_DSTONLY     4
EA_TYPE_ERROR       2E2F
EA_TYPE_EXT         5
EA_TYPE_IMMEDIATE   0
EA_TYPE_LEA         3
EA_TYPE_MOVE        1
EA_TYPE_MOVEA       2
EA_TYPE_MOVEA6      C
EA_TYPE_MOVEM       6
EA_TYPE_QUICK       8
EA_TYPE_SHIFTS      7
EA_TYPE_TABLE       1DE4
EA_UNSUPPORTED      2CEC
EA_WRONG_SIZE       2D90
END_ADDRESS         31B8
END_IN              317C
ENTER_PROMPT        30FA
ERROR_MESSAGE       2EEC
EXIT                1348
EXIT_PROMPT         313A
FINISH_MOVEM_MEM_TO_REG  2984
FINISH_REG_TO_MEM   266E
FIRST_NIBBLE        F000
FOURTH_NIBBLE       F
FOURTH_NIBBLE_CHECK  2C2E
FRONT_FORMAT        2A50
IMMEDIATE           2D2E
IMMEDIATE_CHECK     2D7C
IMMEDIATE_EIGHT     2AF8
IMMEDIATE_SRC       2AAA
INPUT_INVALID       10A6
ITOA                1114
ITOA_BYTE           119C
ITOA_BYTE_BRANCH    11AA
ITOA_BYTE_CONVERT   1264
ITOA_CONVERT_A_TO_F  1294
ITOA_DONE           12A0
ITOA_LONG           11FA
ITOA_LONGADDRESS    122C
ITOA_MOVE           1136
ITOA_NIBBLE_CONVERT  1284
ITOA_OPMODE         1158
ITOA_WORD           11BC
ITOA_WORD_BRANCH    11D8
JSR_EA_VALID        2158
JSR_NOP_RTS         182E
LAST_DIGIT_CHECK    10C4
LAST_DIGIT_ODD      10F8
LEA_SRC_VALID       2070
LF                  A
LINES_P_SCREEN      14
MEMORY_1110_LEFT    159C
MEMORY_1110_RIGHT   15C0
MEM_TO_REG          2694
MEM_TO_REG_CONTINUE  26BC
MOVEA_DST_VALID     2028
MOVEQ_EA_CALC       2BB8
NOP_CHECK           185C
NOP_CHECK_THREE     188C
NOP_CHECK_TWO       1874
NORMAL_FINISH       29B0
N_LOWERCASE         6E
N_UPPERCASE         4E
ODD_ERROR_MESSAGE   2F0A
OPCODE_INVALID      2ED1
OP_0000_TABLE       15E8
OP_0100_TABLE       1648
OP_1100_TABLE       16A8
OP_1101_TABLE       1708
OP_1110_TABLE_REGISTER  1768
OP_ADD              1CE8
OP_ADDA             1D04
OP_ADDI             191C
OP_ADDQ             1A18
OP_AND              1CCC
OP_ASL              1D40
OP_ASR              1D24
OP_AS_CHECK         17C8
OP_BCC              1AA8
OP_BCS              1AC4
OP_BEQ              1AFC
OP_BGE              1B88
OP_BGT              1BC0
OP_BHI              1A70
OP_BLE              1BDC
OP_BLS              1A8C
OP_BLT              1BA4
OP_BMI              1B6C
OP_BNE              1AE0
OP_BPL              1B50
OP_BRA              1A38
OP_BSR              1A54
OP_BVC              1B18
OP_BVS              1B34
OP_CLEAR_DATA       1394
OP_CLEAR_DATA_LOOP  13A0
OP_CLR              1980
OP_CMP              1C70
OP_DIVU             1C1C
OP_FINISH           138E
OP_JSR              19BC
OP_LEA              19FC
OP_LSL              1D78
OP_LSR              1D5C
OP_LS_CHECK         17EA
OP_MOVE             1960
OP_MOVEA            193C
OP_MOVEM            19D8
OP_MOVEQ            1BF8
OP_MULS             1CAC
OP_MULU             1C8C
OP_NOP              199C
OP_OR               1C3C
OP_ROL              1DB0
OP_ROR              1D94
OP_RO_CHECK         180C
OP_RTS              19AC
OP_SUB              1C54
OP_SUBI             18FC
OP_TABLE            13AA
OP_UNSUPPORTED      18EC
PRINT1_A0           253A
PRINT1_A1           2568
PRINT1_A2           2596
PRINT1_A3           25C4
PRINT1_A4           25EC
PRINT1_A5           2614
PRINT1_A6           263C
PRINT1_A7           2664
PRINT1_D0           23CA
PRINT1_D1           23F8
PRINT1_D2           2426
PRINT1_D3           2454
PRINT1_D4           2482
PRINT1_D5           24B0
PRINT1_D6           24DE
PRINT1_D7           250C
PRINT_A0            2822
PRINT_A1            27F4
PRINT_A2            27C8
PRINT_A3            279A
PRINT_A4            276C
PRINT_A5            273E
PRINT_A6            2710
PRINT_A7            26E2
PRINT_D0            297A
PRINT_D1            2952
PRINT_D2            292A
PRINT_D3            2902
PRINT_D4            28DA
PRINT_D5            28AC
PRINT_D6            287E
PRINT_D7            2850
PROMPT_AGAIN        3117
PROMPT_END          103E
PROMPT_START        1018
READ_END            104A
READ_START          102A
REGISTER_CHECK      2D86
REGISTER_SRC        2AFE
REG_TO_MEM          23A4
RIGHT12             C
RIGHT16             10
RIGHT24             18
RIGHT3              3
RIGHT4              4
RIGHT6              6
RIGHT8              8
RIGHT9              9
RTS_CHECK           18A4
RTS_CHECK_THREE     18D4
RTS_CHECK_TWO       18BC
SECOND_HALF         FF
SECOND_NIBBLE       F00
SRC_INVALID         2DC0
SRC_INVALID_MSG     2E83
SRC_MODE            38
SRC_REG             7
STACK               A000
START               1000
START_ADDRESS       3198
START_DECODING      12A6
START_IN            315F
TASK13              D
TASK14              E
TASK2               2
TASK5               5
TASK9               9
THIRD_NIBBLE        F0
USER_INST           2F80
VALIDATE_END        105A
VALIDATE_START      103A
WELCOME             2F4A
WRONG_SIZE_MESSAGE  2DE5
Y_LOWERCASE         79
Y_UPPERCASE         59
